/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "node_modules/picocolors/picocolors.browser.js"(exports2, module2) {
    var x6 = String;
    var create2 = function() {
      return { isColorSupported: false, reset: x6, bold: x6, dim: x6, italic: x6, underline: x6, inverse: x6, hidden: x6, strikethrough: x6, black: x6, red: x6, green: x6, yellow: x6, blue: x6, magenta: x6, cyan: x6, white: x6, gray: x6, bgBlack: x6, bgRed: x6, bgGreen: x6, bgYellow: x6, bgBlue: x6, bgMagenta: x6, bgCyan: x6, bgWhite: x6, blackBright: x6, redBright: x6, greenBright: x6, yellowBright: x6, blueBright: x6, magentaBright: x6, cyanBright: x6, whiteBright: x6, bgBlackBright: x6, bgRedBright: x6, bgGreenBright: x6, bgYellowBright: x6, bgBlueBright: x6, bgMagentaBright: x6, bgCyanBright: x6, bgWhiteBright: x6 };
    };
    module2.exports = create2();
    module2.exports.createColors = create2;
  }
});

// (disabled):node_modules/postcss/lib/terminal-highlight
var require_terminal_highlight = __commonJS({
  "(disabled):node_modules/postcss/lib/terminal-highlight"() {
  }
});

// node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS({
  "node_modules/postcss/lib/css-syntax-error.js"(exports2, module2) {
    "use strict";
    var pico = require_picocolors_browser();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError2 = class extends Error {
      constructor(message, line2, column, source, file, plugin2) {
        super(message);
        this.name = "CssSyntaxError";
        this.reason = message;
        if (file) {
          this.file = file;
        }
        if (source) {
          this.source = source;
        }
        if (plugin2) {
          this.plugin = plugin2;
        }
        if (typeof line2 !== "undefined" && typeof column !== "undefined") {
          if (typeof line2 === "number") {
            this.line = line2;
            this.column = column;
          } else {
            this.line = line2.line;
            this.column = line2.column;
            this.endLine = column.line;
            this.endColumn = column.column;
          }
        }
        this.setMessage();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, CssSyntaxError2);
        }
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "";
        this.message += this.file ? this.file : "<css input>";
        if (typeof this.line !== "undefined") {
          this.message += ":" + this.line + ":" + this.column;
        }
        this.message += ": " + this.reason;
      }
      showSourceCode(color3) {
        if (!this.source)
          return "";
        let css = this.source;
        if (color3 == null)
          color3 = pico.isColorSupported;
        let aside = (text) => text;
        let mark = (text) => text;
        let highlight = (text) => text;
        if (color3) {
          let { bold, gray, red } = pico.createColors(true);
          mark = (text) => bold(red(text));
          aside = (text) => gray(text);
          if (terminalHighlight) {
            highlight = (text) => terminalHighlight(text);
          }
        }
        let lines = css.split(/\r?\n/);
        let start2 = Math.max(this.line - 3, 0);
        let end = Math.min(this.line + 2, lines.length);
        let maxWidth = String(end).length;
        return lines.slice(start2, end).map((line2, index2) => {
          let number5 = start2 + 1 + index2;
          let gutter = " " + (" " + number5).slice(-maxWidth) + " | ";
          if (number5 === this.line) {
            if (line2.length > 160) {
              let padding = 20;
              let subLineStart = Math.max(0, this.column - padding);
              let subLineEnd = Math.max(
                this.column + padding,
                this.endColumn + padding
              );
              let subLine = line2.slice(subLineStart, subLineEnd);
              let spacing2 = aside(gutter.replace(/\d/g, " ")) + line2.slice(0, Math.min(this.column - 1, padding - 1)).replace(/[^\t]/g, " ");
              return mark(">") + aside(gutter) + highlight(subLine) + "\n " + spacing2 + mark("^");
            }
            let spacing = aside(gutter.replace(/\d/g, " ")) + line2.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return mark(">") + aside(gutter) + highlight(line2) + "\n " + spacing + mark("^");
          }
          return " " + aside(gutter) + highlight(line2);
        }).join("\n");
      }
      toString() {
        let code = this.showSourceCode();
        if (code) {
          code = "\n\n" + code + "\n";
        }
        return this.name + ": " + this.message + code;
      }
    };
    module2.exports = CssSyntaxError2;
    CssSyntaxError2.default = CssSyntaxError2;
  }
});

// node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS({
  "node_modules/postcss/lib/stringifier.js"(exports2, module2) {
    "use strict";
    var DEFAULT_RAW = {
      after: "\n",
      beforeClose: "\n",
      beforeComment: "\n",
      beforeDecl: "\n",
      beforeOpen: " ",
      beforeRule: "\n",
      colon: ": ",
      commentLeft: " ",
      commentRight: " ",
      emptyBody: "",
      indent: "    ",
      semicolon: false
    };
    function capitalize2(str) {
      return str[0].toUpperCase() + str.slice(1);
    }
    var Stringifier = class {
      constructor(builder) {
        this.builder = builder;
      }
      atrule(node, semicolon) {
        let name = "@" + node.name;
        let params = node.params ? this.rawValue(node, "params") : "";
        if (typeof node.raws.afterName !== "undefined") {
          name += node.raws.afterName;
        } else if (params) {
          name += " ";
        }
        if (node.nodes) {
          this.block(node, name + params);
        } else {
          let end = (node.raws.between || "") + (semicolon ? ";" : "");
          this.builder(name + params + end, node);
        }
      }
      beforeAfter(node, detect) {
        let value;
        if (node.type === "decl") {
          value = this.raw(node, null, "beforeDecl");
        } else if (node.type === "comment") {
          value = this.raw(node, null, "beforeComment");
        } else if (detect === "before") {
          value = this.raw(node, null, "beforeRule");
        } else {
          value = this.raw(node, null, "beforeClose");
        }
        let buf = node.parent;
        let depth = 0;
        while (buf && buf.type !== "root") {
          depth += 1;
          buf = buf.parent;
        }
        if (value.includes("\n")) {
          let indent = this.raw(node, null, "indent");
          if (indent.length) {
            for (let step = 0; step < depth; step++)
              value += indent;
          }
        }
        return value;
      }
      block(node, start2) {
        let between = this.raw(node, "between", "beforeOpen");
        this.builder(start2 + between + "{", node, "start");
        let after;
        if (node.nodes && node.nodes.length) {
          this.body(node);
          after = this.raw(node, "after");
        } else {
          after = this.raw(node, "after", "emptyBody");
        }
        if (after)
          this.builder(after);
        this.builder("}", node, "end");
      }
      body(node) {
        let last = node.nodes.length - 1;
        while (last > 0) {
          if (node.nodes[last].type !== "comment")
            break;
          last -= 1;
        }
        let semicolon = this.raw(node, "semicolon");
        for (let i4 = 0; i4 < node.nodes.length; i4++) {
          let child = node.nodes[i4];
          let before = this.raw(child, "before");
          if (before)
            this.builder(before);
          this.stringify(child, last !== i4 || semicolon);
        }
      }
      comment(node) {
        let left = this.raw(node, "left", "commentLeft");
        let right = this.raw(node, "right", "commentRight");
        this.builder("/*" + left + node.text + right + "*/", node);
      }
      decl(node, semicolon) {
        let between = this.raw(node, "between", "colon");
        let string2 = node.prop + between + this.rawValue(node, "value");
        if (node.important) {
          string2 += node.raws.important || " !important";
        }
        if (semicolon)
          string2 += ";";
        this.builder(string2, node);
      }
      document(node) {
        this.body(node);
      }
      raw(node, own, detect) {
        let value;
        if (!detect)
          detect = own;
        if (own) {
          value = node.raws[own];
          if (typeof value !== "undefined")
            return value;
        }
        let parent = node.parent;
        if (detect === "before") {
          if (!parent || parent.type === "root" && parent.first === node) {
            return "";
          }
          if (parent && parent.type === "document") {
            return "";
          }
        }
        if (!parent)
          return DEFAULT_RAW[detect];
        let root4 = node.root();
        if (!root4.rawCache)
          root4.rawCache = {};
        if (typeof root4.rawCache[detect] !== "undefined") {
          return root4.rawCache[detect];
        }
        if (detect === "before" || detect === "after") {
          return this.beforeAfter(node, detect);
        } else {
          let method = "raw" + capitalize2(detect);
          if (this[method]) {
            value = this[method](root4, node);
          } else {
            root4.walk((i4) => {
              value = i4.raws[own];
              if (typeof value !== "undefined")
                return false;
            });
          }
        }
        if (typeof value === "undefined")
          value = DEFAULT_RAW[detect];
        root4.rawCache[detect] = value;
        return value;
      }
      rawBeforeClose(root4) {
        let value;
        root4.walk((i4) => {
          if (i4.nodes && i4.nodes.length > 0) {
            if (typeof i4.raws.after !== "undefined") {
              value = i4.raws.after;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawBeforeComment(root4, node) {
        let value;
        root4.walkComments((i4) => {
          if (typeof i4.raws.before !== "undefined") {
            value = i4.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeDecl");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeDecl(root4, node) {
        let value;
        root4.walkDecls((i4) => {
          if (typeof i4.raws.before !== "undefined") {
            value = i4.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeRule");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeOpen(root4) {
        let value;
        root4.walk((i4) => {
          if (i4.type !== "decl") {
            value = i4.raws.between;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawBeforeRule(root4) {
        let value;
        root4.walk((i4) => {
          if (i4.nodes && (i4.parent !== root4 || root4.first !== i4)) {
            if (typeof i4.raws.before !== "undefined") {
              value = i4.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawColon(root4) {
        let value;
        root4.walkDecls((i4) => {
          if (typeof i4.raws.between !== "undefined") {
            value = i4.raws.between.replace(/[^\s:]/g, "");
            return false;
          }
        });
        return value;
      }
      rawEmptyBody(root4) {
        let value;
        root4.walk((i4) => {
          if (i4.nodes && i4.nodes.length === 0) {
            value = i4.raws.after;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawIndent(root4) {
        if (root4.raws.indent)
          return root4.raws.indent;
        let value;
        root4.walk((i4) => {
          let p7 = i4.parent;
          if (p7 && p7 !== root4 && p7.parent && p7.parent === root4) {
            if (typeof i4.raws.before !== "undefined") {
              let parts = i4.raws.before.split("\n");
              value = parts[parts.length - 1];
              value = value.replace(/\S/g, "");
              return false;
            }
          }
        });
        return value;
      }
      rawSemicolon(root4) {
        let value;
        root4.walk((i4) => {
          if (i4.nodes && i4.nodes.length && i4.last.type === "decl") {
            value = i4.raws.semicolon;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawValue(node, prop) {
        let value = node[prop];
        let raw = node.raws[prop];
        if (raw && raw.value === value) {
          return raw.raw;
        }
        return value;
      }
      root(node) {
        this.body(node);
        if (node.raws.after)
          this.builder(node.raws.after);
      }
      rule(node) {
        this.block(node, this.rawValue(node, "selector"));
        if (node.raws.ownSemicolon) {
          this.builder(node.raws.ownSemicolon, node, "end");
        }
      }
      stringify(node, semicolon) {
        if (!this[node.type]) {
          throw new Error(
            "Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier."
          );
        }
        this[node.type](node, semicolon);
      }
    };
    module2.exports = Stringifier;
    Stringifier.default = Stringifier;
  }
});

// node_modules/postcss/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/postcss/lib/stringify.js"(exports2, module2) {
    "use strict";
    var Stringifier = require_stringifier();
    function stringify2(node, builder) {
      let str = new Stringifier(builder);
      str.stringify(node);
    }
    module2.exports = stringify2;
    stringify2.default = stringify2;
  }
});

// node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/postcss/lib/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports.isClean = Symbol("isClean");
    module2.exports.my = Symbol("my");
  }
});

// node_modules/postcss/lib/node.js
var require_node = __commonJS({
  "node_modules/postcss/lib/node.js"(exports2, module2) {
    "use strict";
    var CssSyntaxError2 = require_css_syntax_error();
    var Stringifier = require_stringifier();
    var stringify2 = require_stringify();
    var { isClean, my } = require_symbols();
    function cloneNode(obj, parent) {
      let cloned = new obj.constructor();
      for (let i4 in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, i4)) {
          continue;
        }
        if (i4 === "proxyCache")
          continue;
        let value = obj[i4];
        let type2 = typeof value;
        if (i4 === "parent" && type2 === "object") {
          if (parent)
            cloned[i4] = parent;
        } else if (i4 === "source") {
          cloned[i4] = value;
        } else if (Array.isArray(value)) {
          cloned[i4] = value.map((j2) => cloneNode(j2, cloned));
        } else {
          if (type2 === "object" && value !== null)
            value = cloneNode(value);
          cloned[i4] = value;
        }
      }
      return cloned;
    }
    function sourceOffset(inputCSS, position) {
      if (position && typeof position.offset !== "undefined") {
        return position.offset;
      }
      let column = 1;
      let line2 = 1;
      let offset = 0;
      for (let i4 = 0; i4 < inputCSS.length; i4++) {
        if (line2 === position.line && column === position.column) {
          offset = i4;
          break;
        }
        if (inputCSS[i4] === "\n") {
          column = 1;
          line2 += 1;
        } else {
          column += 1;
        }
      }
      return offset;
    }
    var Node4 = class {
      get proxyOf() {
        return this;
      }
      constructor(defaults = {}) {
        this.raws = {};
        this[isClean] = false;
        this[my] = true;
        for (let name in defaults) {
          if (name === "nodes") {
            this.nodes = [];
            for (let node of defaults[name]) {
              if (typeof node.clone === "function") {
                this.append(node.clone());
              } else {
                this.append(node);
              }
            }
          } else {
            this[name] = defaults[name];
          }
        }
      }
      addToError(error) {
        error.postcssNode = this;
        if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
          let s3 = this.source;
          error.stack = error.stack.replace(
            /\n\s{4}at /,
            `$&${s3.input.from}:${s3.start.line}:${s3.start.column}$&`
          );
        }
        return error;
      }
      after(add2) {
        this.parent.insertAfter(this, add2);
        return this;
      }
      assign(overrides = {}) {
        for (let name in overrides) {
          this[name] = overrides[name];
        }
        return this;
      }
      before(add2) {
        this.parent.insertBefore(this, add2);
        return this;
      }
      cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween)
          delete this.raws.between;
      }
      clone(overrides = {}) {
        let cloned = cloneNode(this);
        for (let name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      }
      cloneAfter(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      }
      cloneBefore(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      }
      error(message, opts = {}) {
        if (this.source) {
          let { end, start: start2 } = this.rangeBy(opts);
          return this.source.input.error(
            message,
            { column: start2.column, line: start2.line },
            { column: end.column, line: end.line },
            opts
          );
        }
        return new CssSyntaxError2(message);
      }
      getProxyProcessor() {
        return {
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else {
              return node[prop];
            }
          },
          set(node, prop, value) {
            if (node[prop] === value)
              return true;
            node[prop] = value;
            if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
            prop === "text") {
              node.markDirty();
            }
            return true;
          }
        };
      }
      /* c8 ignore next 3 */
      markClean() {
        this[isClean] = true;
      }
      markDirty() {
        if (this[isClean]) {
          this[isClean] = false;
          let next = this;
          while (next = next.parent) {
            next[isClean] = false;
          }
        }
      }
      next() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 + 1];
      }
      positionBy(opts = {}) {
        let pos = this.source.start;
        if (opts.index) {
          pos = this.positionInside(opts.index);
        } else if (opts.word) {
          let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
          let stringRepresentation = inputString.slice(
            sourceOffset(inputString, this.source.start),
            sourceOffset(inputString, this.source.end)
          );
          let index2 = stringRepresentation.indexOf(opts.word);
          if (index2 !== -1)
            pos = this.positionInside(index2);
        }
        return pos;
      }
      positionInside(index2) {
        let column = this.source.start.column;
        let line2 = this.source.start.line;
        let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
        let offset = sourceOffset(inputString, this.source.start);
        let end = offset + index2;
        for (let i4 = offset; i4 < end; i4++) {
          if (inputString[i4] === "\n") {
            column = 1;
            line2 += 1;
          } else {
            column += 1;
          }
        }
        return { column, line: line2, offset: end };
      }
      prev() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 - 1];
      }
      rangeBy(opts = {}) {
        let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
        let start2 = {
          column: this.source.start.column,
          line: this.source.start.line,
          offset: sourceOffset(inputString, this.source.start)
        };
        let end = this.source.end ? {
          column: this.source.end.column + 1,
          line: this.source.end.line,
          offset: typeof this.source.end.offset === "number" ? (
            // `source.end.offset` is exclusive, so we don't need to add 1
            this.source.end.offset
          ) : (
            // Since line/column in this.source.end is inclusive,
            // the `sourceOffset(... , this.source.end)` returns an inclusive offset.
            // So, we add 1 to convert it to exclusive.
            sourceOffset(inputString, this.source.end) + 1
          )
        } : {
          column: start2.column + 1,
          line: start2.line,
          offset: start2.offset + 1
        };
        if (opts.word) {
          let stringRepresentation = inputString.slice(
            sourceOffset(inputString, this.source.start),
            sourceOffset(inputString, this.source.end)
          );
          let index2 = stringRepresentation.indexOf(opts.word);
          if (index2 !== -1) {
            start2 = this.positionInside(index2);
            end = this.positionInside(index2 + opts.word.length);
          }
        } else {
          if (opts.start) {
            start2 = {
              column: opts.start.column,
              line: opts.start.line,
              offset: sourceOffset(inputString, opts.start)
            };
          } else if (opts.index) {
            start2 = this.positionInside(opts.index);
          }
          if (opts.end) {
            end = {
              column: opts.end.column,
              line: opts.end.line,
              offset: sourceOffset(inputString, opts.end)
            };
          } else if (typeof opts.endIndex === "number") {
            end = this.positionInside(opts.endIndex);
          } else if (opts.index) {
            end = this.positionInside(opts.index + 1);
          }
        }
        if (end.line < start2.line || end.line === start2.line && end.column <= start2.column) {
          end = {
            column: start2.column + 1,
            line: start2.line,
            offset: start2.offset + 1
          };
        }
        return { end, start: start2 };
      }
      raw(prop, defaultType) {
        let str = new Stringifier();
        return str.raw(this, prop, defaultType);
      }
      remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      }
      replaceWith(...nodes) {
        if (this.parent) {
          let bookmark = this;
          let foundSelf = false;
          for (let node of nodes) {
            if (node === this) {
              foundSelf = true;
            } else if (foundSelf) {
              this.parent.insertAfter(bookmark, node);
              bookmark = node;
            } else {
              this.parent.insertBefore(bookmark, node);
            }
          }
          if (!foundSelf) {
            this.remove();
          }
        }
        return this;
      }
      root() {
        let result = this;
        while (result.parent && result.parent.type !== "document") {
          result = result.parent;
        }
        return result;
      }
      toJSON(_2, inputs) {
        let fixed = {};
        let emitInputs = inputs == null;
        inputs = inputs || /* @__PURE__ */ new Map();
        let inputsNextIndex = 0;
        for (let name in this) {
          if (!Object.prototype.hasOwnProperty.call(this, name)) {
            continue;
          }
          if (name === "parent" || name === "proxyCache")
            continue;
          let value = this[name];
          if (Array.isArray(value)) {
            fixed[name] = value.map((i4) => {
              if (typeof i4 === "object" && i4.toJSON) {
                return i4.toJSON(null, inputs);
              } else {
                return i4;
              }
            });
          } else if (typeof value === "object" && value.toJSON) {
            fixed[name] = value.toJSON(null, inputs);
          } else if (name === "source") {
            if (value == null)
              continue;
            let inputId = inputs.get(value.input);
            if (inputId == null) {
              inputId = inputsNextIndex;
              inputs.set(value.input, inputsNextIndex);
              inputsNextIndex++;
            }
            fixed[name] = {
              end: value.end,
              inputId,
              start: value.start
            };
          } else {
            fixed[name] = value;
          }
        }
        if (emitInputs) {
          fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
        }
        return fixed;
      }
      toProxy() {
        if (!this.proxyCache) {
          this.proxyCache = new Proxy(this, this.getProxyProcessor());
        }
        return this.proxyCache;
      }
      toString(stringifier = stringify2) {
        if (stringifier.stringify)
          stringifier = stringifier.stringify;
        let result = "";
        stringifier(this, (i4) => {
          result += i4;
        });
        return result;
      }
      warn(result, text, opts = {}) {
        let data = { node: this };
        for (let i4 in opts)
          data[i4] = opts[i4];
        return result.warn(text, data);
      }
    };
    module2.exports = Node4;
    Node4.default = Node4;
  }
});

// node_modules/postcss/lib/comment.js
var require_comment = __commonJS({
  "node_modules/postcss/lib/comment.js"(exports2, module2) {
    "use strict";
    var Node4 = require_node();
    var Comment2 = class extends Node4 {
      constructor(defaults) {
        super(defaults);
        this.type = "comment";
      }
    };
    module2.exports = Comment2;
    Comment2.default = Comment2;
  }
});

// node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS({
  "node_modules/postcss/lib/declaration.js"(exports2, module2) {
    "use strict";
    var Node4 = require_node();
    var Declaration2 = class extends Node4 {
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
      constructor(defaults) {
        if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
          defaults = { ...defaults, value: String(defaults.value) };
        }
        super(defaults);
        this.type = "decl";
      }
    };
    module2.exports = Declaration2;
    Declaration2.default = Declaration2;
  }
});

// node_modules/postcss/lib/container.js
var require_container = __commonJS({
  "node_modules/postcss/lib/container.js"(exports2, module2) {
    "use strict";
    var Comment2 = require_comment();
    var Declaration2 = require_declaration();
    var Node4 = require_node();
    var { isClean, my } = require_symbols();
    var AtRule2;
    var parse3;
    var Root2;
    var Rule2;
    function cleanSource(nodes) {
      return nodes.map((i4) => {
        if (i4.nodes)
          i4.nodes = cleanSource(i4.nodes);
        delete i4.source;
        return i4;
      });
    }
    function markTreeDirty(node) {
      node[isClean] = false;
      if (node.proxyOf.nodes) {
        for (let i4 of node.proxyOf.nodes) {
          markTreeDirty(i4);
        }
      }
    }
    var Container2 = class extends Node4 {
      get first() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[0];
      }
      get last() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
      append(...children2) {
        for (let child of children2) {
          let nodes = this.normalize(child, this.last);
          for (let node of nodes)
            this.proxyOf.nodes.push(node);
        }
        this.markDirty();
        return this;
      }
      cleanRaws(keepBetween) {
        super.cleanRaws(keepBetween);
        if (this.nodes) {
          for (let node of this.nodes)
            node.cleanRaws(keepBetween);
        }
      }
      each(callback) {
        if (!this.proxyOf.nodes)
          return void 0;
        let iterator = this.getIterator();
        let index2, result;
        while (this.indexes[iterator] < this.proxyOf.nodes.length) {
          index2 = this.indexes[iterator];
          result = callback(this.proxyOf.nodes[index2], index2);
          if (result === false)
            break;
          this.indexes[iterator] += 1;
        }
        delete this.indexes[iterator];
        return result;
      }
      every(condition) {
        return this.nodes.every(condition);
      }
      getIterator() {
        if (!this.lastEach)
          this.lastEach = 0;
        if (!this.indexes)
          this.indexes = {};
        this.lastEach += 1;
        let iterator = this.lastEach;
        this.indexes[iterator] = 0;
        return iterator;
      }
      getProxyProcessor() {
        return {
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (!node[prop]) {
              return node[prop];
            } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
              return (...args) => {
                return node[prop](
                  ...args.map((i4) => {
                    if (typeof i4 === "function") {
                      return (child, index2) => i4(child.toProxy(), index2);
                    } else {
                      return i4;
                    }
                  })
                );
              };
            } else if (prop === "every" || prop === "some") {
              return (cb) => {
                return node[prop](
                  (child, ...other) => cb(child.toProxy(), ...other)
                );
              };
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else if (prop === "nodes") {
              return node.nodes.map((i4) => i4.toProxy());
            } else if (prop === "first" || prop === "last") {
              return node[prop].toProxy();
            } else {
              return node[prop];
            }
          },
          set(node, prop, value) {
            if (node[prop] === value)
              return true;
            node[prop] = value;
            if (prop === "name" || prop === "params" || prop === "selector") {
              node.markDirty();
            }
            return true;
          }
        };
      }
      index(child) {
        if (typeof child === "number")
          return child;
        if (child.proxyOf)
          child = child.proxyOf;
        return this.proxyOf.nodes.indexOf(child);
      }
      insertAfter(exist, add2) {
        let existIndex = this.index(exist);
        let nodes = this.normalize(add2, this.proxyOf.nodes[existIndex]).reverse();
        existIndex = this.index(exist);
        for (let node of nodes)
          this.proxyOf.nodes.splice(existIndex + 1, 0, node);
        let index2;
        for (let id2 in this.indexes) {
          index2 = this.indexes[id2];
          if (existIndex < index2) {
            this.indexes[id2] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      insertBefore(exist, add2) {
        let existIndex = this.index(exist);
        let type2 = existIndex === 0 ? "prepend" : false;
        let nodes = this.normalize(
          add2,
          this.proxyOf.nodes[existIndex],
          type2
        ).reverse();
        existIndex = this.index(exist);
        for (let node of nodes)
          this.proxyOf.nodes.splice(existIndex, 0, node);
        let index2;
        for (let id2 in this.indexes) {
          index2 = this.indexes[id2];
          if (existIndex <= index2) {
            this.indexes[id2] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      normalize(nodes, sample) {
        if (typeof nodes === "string") {
          nodes = cleanSource(parse3(nodes).nodes);
        } else if (typeof nodes === "undefined") {
          nodes = [];
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (let i4 of nodes) {
            if (i4.parent)
              i4.parent.removeChild(i4, "ignore");
          }
        } else if (nodes.type === "root" && this.type !== "document") {
          nodes = nodes.nodes.slice(0);
          for (let i4 of nodes) {
            if (i4.parent)
              i4.parent.removeChild(i4, "ignore");
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === "undefined") {
            throw new Error("Value field is missed in node creation");
          } else if (typeof nodes.value !== "string") {
            nodes.value = String(nodes.value);
          }
          nodes = [new Declaration2(nodes)];
        } else if (nodes.selector || nodes.selectors) {
          nodes = [new Rule2(nodes)];
        } else if (nodes.name) {
          nodes = [new AtRule2(nodes)];
        } else if (nodes.text) {
          nodes = [new Comment2(nodes)];
        } else {
          throw new Error("Unknown node type in node creation");
        }
        let processed = nodes.map((i4) => {
          if (!i4[my])
            Container2.rebuild(i4);
          i4 = i4.proxyOf;
          if (i4.parent)
            i4.parent.removeChild(i4);
          if (i4[isClean])
            markTreeDirty(i4);
          if (!i4.raws)
            i4.raws = {};
          if (typeof i4.raws.before === "undefined") {
            if (sample && typeof sample.raws.before !== "undefined") {
              i4.raws.before = sample.raws.before.replace(/\S/g, "");
            }
          }
          i4.parent = this.proxyOf;
          return i4;
        });
        return processed;
      }
      prepend(...children2) {
        children2 = children2.reverse();
        for (let child of children2) {
          let nodes = this.normalize(child, this.first, "prepend").reverse();
          for (let node of nodes)
            this.proxyOf.nodes.unshift(node);
          for (let id2 in this.indexes) {
            this.indexes[id2] = this.indexes[id2] + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      push(child) {
        child.parent = this;
        this.proxyOf.nodes.push(child);
        return this;
      }
      removeAll() {
        for (let node of this.proxyOf.nodes)
          node.parent = void 0;
        this.proxyOf.nodes = [];
        this.markDirty();
        return this;
      }
      removeChild(child) {
        child = this.index(child);
        this.proxyOf.nodes[child].parent = void 0;
        this.proxyOf.nodes.splice(child, 1);
        let index2;
        for (let id2 in this.indexes) {
          index2 = this.indexes[id2];
          if (index2 >= child) {
            this.indexes[id2] = index2 - 1;
          }
        }
        this.markDirty();
        return this;
      }
      replaceValues(pattern, opts, callback) {
        if (!callback) {
          callback = opts;
          opts = {};
        }
        this.walkDecls((decl2) => {
          if (opts.props && !opts.props.includes(decl2.prop))
            return;
          if (opts.fast && !decl2.value.includes(opts.fast))
            return;
          decl2.value = decl2.value.replace(pattern, callback);
        });
        this.markDirty();
        return this;
      }
      some(condition) {
        return this.nodes.some(condition);
      }
      walk(callback) {
        return this.each((child, i4) => {
          let result;
          try {
            result = callback(child, i4);
          } catch (e8) {
            throw child.addToError(e8);
          }
          if (result !== false && child.walk) {
            result = child.walk(callback);
          }
          return result;
        });
      }
      walkAtRules(name, callback) {
        if (!callback) {
          callback = name;
          return this.walk((child, i4) => {
            if (child.type === "atrule") {
              return callback(child, i4);
            }
          });
        }
        if (name instanceof RegExp) {
          return this.walk((child, i4) => {
            if (child.type === "atrule" && name.test(child.name)) {
              return callback(child, i4);
            }
          });
        }
        return this.walk((child, i4) => {
          if (child.type === "atrule" && child.name === name) {
            return callback(child, i4);
          }
        });
      }
      walkComments(callback) {
        return this.walk((child, i4) => {
          if (child.type === "comment") {
            return callback(child, i4);
          }
        });
      }
      walkDecls(prop, callback) {
        if (!callback) {
          callback = prop;
          return this.walk((child, i4) => {
            if (child.type === "decl") {
              return callback(child, i4);
            }
          });
        }
        if (prop instanceof RegExp) {
          return this.walk((child, i4) => {
            if (child.type === "decl" && prop.test(child.prop)) {
              return callback(child, i4);
            }
          });
        }
        return this.walk((child, i4) => {
          if (child.type === "decl" && child.prop === prop) {
            return callback(child, i4);
          }
        });
      }
      walkRules(selector, callback) {
        if (!callback) {
          callback = selector;
          return this.walk((child, i4) => {
            if (child.type === "rule") {
              return callback(child, i4);
            }
          });
        }
        if (selector instanceof RegExp) {
          return this.walk((child, i4) => {
            if (child.type === "rule" && selector.test(child.selector)) {
              return callback(child, i4);
            }
          });
        }
        return this.walk((child, i4) => {
          if (child.type === "rule" && child.selector === selector) {
            return callback(child, i4);
          }
        });
      }
    };
    Container2.registerParse = (dependant) => {
      parse3 = dependant;
    };
    Container2.registerRule = (dependant) => {
      Rule2 = dependant;
    };
    Container2.registerAtRule = (dependant) => {
      AtRule2 = dependant;
    };
    Container2.registerRoot = (dependant) => {
      Root2 = dependant;
    };
    module2.exports = Container2;
    Container2.default = Container2;
    Container2.rebuild = (node) => {
      if (node.type === "atrule") {
        Object.setPrototypeOf(node, AtRule2.prototype);
      } else if (node.type === "rule") {
        Object.setPrototypeOf(node, Rule2.prototype);
      } else if (node.type === "decl") {
        Object.setPrototypeOf(node, Declaration2.prototype);
      } else if (node.type === "comment") {
        Object.setPrototypeOf(node, Comment2.prototype);
      } else if (node.type === "root") {
        Object.setPrototypeOf(node, Root2.prototype);
      }
      node[my] = true;
      if (node.nodes) {
        node.nodes.forEach((child) => {
          Container2.rebuild(child);
        });
      }
    };
  }
});

// node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS({
  "node_modules/postcss/lib/at-rule.js"(exports2, module2) {
    "use strict";
    var Container2 = require_container();
    var AtRule2 = class extends Container2 {
      constructor(defaults) {
        super(defaults);
        this.type = "atrule";
      }
      append(...children2) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.append(...children2);
      }
      prepend(...children2) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.prepend(...children2);
      }
    };
    module2.exports = AtRule2;
    AtRule2.default = AtRule2;
    Container2.registerAtRule(AtRule2);
  }
});

// node_modules/postcss/lib/document.js
var require_document = __commonJS({
  "node_modules/postcss/lib/document.js"(exports2, module2) {
    "use strict";
    var Container2 = require_container();
    var LazyResult;
    var Processor2;
    var Document2 = class extends Container2 {
      constructor(defaults) {
        super({ type: "document", ...defaults });
        if (!this.nodes) {
          this.nodes = [];
        }
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor2(), this, opts);
        return lazy.stringify();
      }
    };
    Document2.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Document2.registerProcessor = (dependant) => {
      Processor2 = dependant;
    };
    module2.exports = Document2;
    Document2.default = Document2;
  }
});

// node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS({
  "node_modules/nanoid/non-secure/index.cjs"(exports2, module2) {
    var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id2 = "";
        let i4 = size | 0;
        while (i4--) {
          id2 += alphabet[Math.random() * alphabet.length | 0];
        }
        return id2;
      };
    };
    var nanoid = (size = 21) => {
      let id2 = "";
      let i4 = size | 0;
      while (i4--) {
        id2 += urlAlphabet[Math.random() * 64 | 0];
      }
      return id2;
    };
    module2.exports = { nanoid, customAlphabet };
  }
});

// (disabled):node_modules/source-map-js/source-map.js
var require_source_map = __commonJS({
  "(disabled):node_modules/source-map-js/source-map.js"() {
  }
});

// node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS({
  "node_modules/postcss/lib/previous-map.js"(exports2, module2) {
    "use strict";
    var { existsSync, readFileSync } = require("fs");
    var { dirname, join: join2 } = require("path");
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    function fromBase64(str) {
      if (Buffer) {
        return Buffer.from(str, "base64").toString();
      } else {
        return window.atob(str);
      }
    }
    var PreviousMap = class {
      constructor(css, opts) {
        if (opts.map === false)
          return;
        this.loadAnnotation(css);
        this.inline = this.startWith(this.annotation, "data:");
        let prev = opts.map ? opts.map.prev : void 0;
        let text = this.loadMap(opts.from, prev);
        if (!this.mapFile && opts.from) {
          this.mapFile = opts.from;
        }
        if (this.mapFile)
          this.root = dirname(this.mapFile);
        if (text)
          this.text = text;
      }
      consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new SourceMapConsumer(this.text);
        }
        return this.consumerCache;
      }
      decodeInline(text) {
        let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        let baseUri = /^data:application\/json;base64,/;
        let charsetUri = /^data:application\/json;charset=utf-?8,/;
        let uri = /^data:application\/json,/;
        let uriMatch = text.match(charsetUri) || text.match(uri);
        if (uriMatch) {
          return decodeURIComponent(text.substr(uriMatch[0].length));
        }
        let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri);
        if (baseUriMatch) {
          return fromBase64(text.substr(baseUriMatch[0].length));
        }
        let encoding = text.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + encoding);
      }
      getAnnotationURL(sourceMapString) {
        return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
      }
      isMap(map2) {
        if (typeof map2 !== "object")
          return false;
        return typeof map2.mappings === "string" || typeof map2._mappings === "string" || Array.isArray(map2.sections);
      }
      loadAnnotation(css) {
        let comments = css.match(/\/\*\s*# sourceMappingURL=/g);
        if (!comments)
          return;
        let start2 = css.lastIndexOf(comments.pop());
        let end = css.indexOf("*/", start2);
        if (start2 > -1 && end > -1) {
          this.annotation = this.getAnnotationURL(css.substring(start2, end));
        }
      }
      loadFile(path2) {
        this.root = dirname(path2);
        if (existsSync(path2)) {
          this.mapFile = path2;
          return readFileSync(path2, "utf-8").toString().trim();
        }
      }
      loadMap(file, prev) {
        if (prev === false)
          return false;
        if (prev) {
          if (typeof prev === "string") {
            return prev;
          } else if (typeof prev === "function") {
            let prevPath = prev(file);
            if (prevPath) {
              let map2 = this.loadFile(prevPath);
              if (!map2) {
                throw new Error(
                  "Unable to load previous source map: " + prevPath.toString()
                );
              }
              return map2;
            }
          } else if (prev instanceof SourceMapConsumer) {
            return SourceMapGenerator.fromSourceMap(prev).toString();
          } else if (prev instanceof SourceMapGenerator) {
            return prev.toString();
          } else if (this.isMap(prev)) {
            return JSON.stringify(prev);
          } else {
            throw new Error(
              "Unsupported previous source map format: " + prev.toString()
            );
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation);
        } else if (this.annotation) {
          let map2 = this.annotation;
          if (file)
            map2 = join2(dirname(file), map2);
          return this.loadFile(map2);
        }
      }
      startWith(string2, start2) {
        if (!string2)
          return false;
        return string2.substr(0, start2.length) === start2;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
    };
    module2.exports = PreviousMap;
    PreviousMap.default = PreviousMap;
  }
});

// node_modules/postcss/lib/input.js
var require_input = __commonJS({
  "node_modules/postcss/lib/input.js"(exports2, module2) {
    "use strict";
    var { nanoid } = require_non_secure();
    var { isAbsolute, resolve } = require("path");
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { fileURLToPath, pathToFileURL } = require("url");
    var CssSyntaxError2 = require_css_syntax_error();
    var PreviousMap = require_previous_map();
    var terminalHighlight = require_terminal_highlight();
    var lineToIndexCache = Symbol("lineToIndexCache");
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(resolve && isAbsolute);
    function getLineToIndex(input) {
      if (input[lineToIndexCache])
        return input[lineToIndexCache];
      let lines = input.css.split("\n");
      let lineToIndex = new Array(lines.length);
      let prevIndex = 0;
      for (let i4 = 0, l3 = lines.length; i4 < l3; i4++) {
        lineToIndex[i4] = prevIndex;
        prevIndex += lines[i4].length + 1;
      }
      input[lineToIndexCache] = lineToIndex;
      return lineToIndex;
    }
    var Input2 = class {
      get from() {
        return this.file || this.id;
      }
      constructor(css, opts = {}) {
        if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
          throw new Error(`PostCSS received ${css} instead of CSS string`);
        }
        this.css = css.toString();
        if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }
        this.document = this.css;
        if (opts.document)
          this.document = opts.document.toString();
        if (opts.from) {
          if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
            this.file = opts.from;
          } else {
            this.file = resolve(opts.from);
          }
        }
        if (pathAvailable && sourceMapAvailable) {
          let map2 = new PreviousMap(this.css, opts);
          if (map2.text) {
            this.map = map2;
            let file = map2.consumer().file;
            if (!this.file && file)
              this.file = this.mapResolve(file);
          }
        }
        if (!this.file) {
          this.id = "<input css " + nanoid(6) + ">";
        }
        if (this.map)
          this.map.file = this.from;
      }
      error(message, line2, column, opts = {}) {
        let endColumn, endLine, endOffset, offset, result;
        if (line2 && typeof line2 === "object") {
          let start2 = line2;
          let end = column;
          if (typeof start2.offset === "number") {
            offset = start2.offset;
            let pos = this.fromOffset(offset);
            line2 = pos.line;
            column = pos.col;
          } else {
            line2 = start2.line;
            column = start2.column;
            offset = this.fromLineAndColumn(line2, column);
          }
          if (typeof end.offset === "number") {
            endOffset = end.offset;
            let pos = this.fromOffset(endOffset);
            endLine = pos.line;
            endColumn = pos.col;
          } else {
            endLine = end.line;
            endColumn = end.column;
            endOffset = this.fromLineAndColumn(end.line, end.column);
          }
        } else if (!column) {
          offset = line2;
          let pos = this.fromOffset(offset);
          line2 = pos.line;
          column = pos.col;
        } else {
          offset = this.fromLineAndColumn(line2, column);
        }
        let origin = this.origin(line2, column, endLine, endColumn);
        if (origin) {
          result = new CssSyntaxError2(
            message,
            origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
            origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
            origin.source,
            origin.file,
            opts.plugin
          );
        } else {
          result = new CssSyntaxError2(
            message,
            endLine === void 0 ? line2 : { column, line: line2 },
            endLine === void 0 ? column : { column: endColumn, line: endLine },
            this.css,
            this.file,
            opts.plugin
          );
        }
        result.input = { column, endColumn, endLine, endOffset, line: line2, offset, source: this.css };
        if (this.file) {
          if (pathToFileURL) {
            result.input.url = pathToFileURL(this.file).toString();
          }
          result.input.file = this.file;
        }
        return result;
      }
      fromLineAndColumn(line2, column) {
        let lineToIndex = getLineToIndex(this);
        let index2 = lineToIndex[line2 - 1];
        return index2 + column - 1;
      }
      fromOffset(offset) {
        let lineToIndex = getLineToIndex(this);
        let lastLine = lineToIndex[lineToIndex.length - 1];
        let min3 = 0;
        if (offset >= lastLine) {
          min3 = lineToIndex.length - 1;
        } else {
          let max3 = lineToIndex.length - 2;
          let mid;
          while (min3 < max3) {
            mid = min3 + (max3 - min3 >> 1);
            if (offset < lineToIndex[mid]) {
              max3 = mid - 1;
            } else if (offset >= lineToIndex[mid + 1]) {
              min3 = mid + 1;
            } else {
              min3 = mid;
              break;
            }
          }
        }
        return {
          col: offset - lineToIndex[min3] + 1,
          line: min3 + 1
        };
      }
      mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file;
        }
        return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
      }
      origin(line2, column, endLine, endColumn) {
        if (!this.map)
          return false;
        let consumer = this.map.consumer();
        let from = consumer.originalPositionFor({ column, line: line2 });
        if (!from.source)
          return false;
        let to;
        if (typeof endLine === "number") {
          to = consumer.originalPositionFor({ column: endColumn, line: endLine });
        }
        let fromUrl;
        if (isAbsolute(from.source)) {
          fromUrl = pathToFileURL(from.source);
        } else {
          fromUrl = new URL(
            from.source,
            this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
          );
        }
        let result = {
          column: from.column,
          endColumn: to && to.column,
          endLine: to && to.line,
          line: from.line,
          url: fromUrl.toString()
        };
        if (fromUrl.protocol === "file:") {
          if (fileURLToPath) {
            result.file = fileURLToPath(fromUrl);
          } else {
            throw new Error(`file: protocol is not available in this PostCSS build`);
          }
        }
        let source = consumer.sourceContentFor(from.source);
        if (source)
          result.source = source;
        return result;
      }
      toJSON() {
        let json2 = {};
        for (let name of ["hasBOM", "css", "file", "id"]) {
          if (this[name] != null) {
            json2[name] = this[name];
          }
        }
        if (this.map) {
          json2.map = { ...this.map };
          if (json2.map.consumerCache) {
            json2.map.consumerCache = void 0;
          }
        }
        return json2;
      }
    };
    module2.exports = Input2;
    Input2.default = Input2;
    if (terminalHighlight && terminalHighlight.registerInput) {
      terminalHighlight.registerInput(Input2);
    }
  }
});

// node_modules/postcss/lib/root.js
var require_root2 = __commonJS({
  "node_modules/postcss/lib/root.js"(exports2, module2) {
    "use strict";
    var Container2 = require_container();
    var LazyResult;
    var Processor2;
    var Root2 = class extends Container2 {
      constructor(defaults) {
        super(defaults);
        this.type = "root";
        if (!this.nodes)
          this.nodes = [];
      }
      normalize(child, sample, type2) {
        let nodes = super.normalize(child);
        if (sample) {
          if (type2 === "prepend") {
            if (this.nodes.length > 1) {
              sample.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample.raws.before;
            }
          } else if (this.first !== sample) {
            for (let node of nodes) {
              node.raws.before = sample.raws.before;
            }
          }
        }
        return nodes;
      }
      removeChild(child, ignore) {
        let index2 = this.index(child);
        if (!ignore && index2 === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index2].raws.before;
        }
        return super.removeChild(child);
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor2(), this, opts);
        return lazy.stringify();
      }
    };
    Root2.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Root2.registerProcessor = (dependant) => {
      Processor2 = dependant;
    };
    module2.exports = Root2;
    Root2.default = Root2;
    Container2.registerRoot(Root2);
  }
});

// node_modules/postcss/lib/list.js
var require_list = __commonJS({
  "node_modules/postcss/lib/list.js"(exports2, module2) {
    "use strict";
    var list3 = {
      comma(string2) {
        return list3.split(string2, [","], true);
      },
      space(string2) {
        let spaces = [" ", "\n", "	"];
        return list3.split(string2, spaces);
      },
      split(string2, separators, last) {
        let array3 = [];
        let current = "";
        let split = false;
        let func = 0;
        let inQuote = false;
        let prevQuote = "";
        let escape = false;
        for (let letter of string2) {
          if (escape) {
            escape = false;
          } else if (letter === "\\") {
            escape = true;
          } else if (inQuote) {
            if (letter === prevQuote) {
              inQuote = false;
            }
          } else if (letter === '"' || letter === "'") {
            inQuote = true;
            prevQuote = letter;
          } else if (letter === "(") {
            func += 1;
          } else if (letter === ")") {
            if (func > 0)
              func -= 1;
          } else if (func === 0) {
            if (separators.includes(letter))
              split = true;
          }
          if (split) {
            if (current !== "")
              array3.push(current.trim());
            current = "";
            split = false;
          } else {
            current += letter;
          }
        }
        if (last || current !== "")
          array3.push(current.trim());
        return array3;
      }
    };
    module2.exports = list3;
    list3.default = list3;
  }
});

// node_modules/postcss/lib/rule.js
var require_rule = __commonJS({
  "node_modules/postcss/lib/rule.js"(exports2, module2) {
    "use strict";
    var Container2 = require_container();
    var list3 = require_list();
    var Rule2 = class extends Container2 {
      get selectors() {
        return list3.comma(this.selector);
      }
      set selectors(values) {
        let match = this.selector ? this.selector.match(/,\s*/) : null;
        let sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
        this.selector = values.join(sep);
      }
      constructor(defaults) {
        super(defaults);
        this.type = "rule";
        if (!this.nodes)
          this.nodes = [];
      }
    };
    module2.exports = Rule2;
    Rule2.default = Rule2;
    Container2.registerRule(Rule2);
  }
});

// node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS({
  "node_modules/postcss/lib/fromJSON.js"(exports2, module2) {
    "use strict";
    var AtRule2 = require_at_rule();
    var Comment2 = require_comment();
    var Declaration2 = require_declaration();
    var Input2 = require_input();
    var PreviousMap = require_previous_map();
    var Root2 = require_root2();
    var Rule2 = require_rule();
    function fromJSON2(json2, inputs) {
      if (Array.isArray(json2))
        return json2.map((n4) => fromJSON2(n4));
      let { inputs: ownInputs, ...defaults } = json2;
      if (ownInputs) {
        inputs = [];
        for (let input of ownInputs) {
          let inputHydrated = { ...input, __proto__: Input2.prototype };
          if (inputHydrated.map) {
            inputHydrated.map = {
              ...inputHydrated.map,
              __proto__: PreviousMap.prototype
            };
          }
          inputs.push(inputHydrated);
        }
      }
      if (defaults.nodes) {
        defaults.nodes = json2.nodes.map((n4) => fromJSON2(n4, inputs));
      }
      if (defaults.source) {
        let { inputId, ...source } = defaults.source;
        defaults.source = source;
        if (inputId != null) {
          defaults.source.input = inputs[inputId];
        }
      }
      if (defaults.type === "root") {
        return new Root2(defaults);
      } else if (defaults.type === "decl") {
        return new Declaration2(defaults);
      } else if (defaults.type === "rule") {
        return new Rule2(defaults);
      } else if (defaults.type === "comment") {
        return new Comment2(defaults);
      } else if (defaults.type === "atrule") {
        return new AtRule2(defaults);
      } else {
        throw new Error("Unknown node type: " + json2.type);
      }
    }
    module2.exports = fromJSON2;
    fromJSON2.default = fromJSON2;
  }
});

// node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS({
  "node_modules/postcss/lib/map-generator.js"(exports2, module2) {
    "use strict";
    var { dirname, relative, resolve, sep } = require("path");
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { pathToFileURL } = require("url");
    var Input2 = require_input();
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(dirname && resolve && relative && sep);
    var MapGenerator = class {
      constructor(stringify2, root4, opts, cssString) {
        this.stringify = stringify2;
        this.mapOpts = opts.map || {};
        this.root = root4;
        this.opts = opts;
        this.css = cssString;
        this.originalCSS = cssString;
        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
        this.memoizedFileURLs = /* @__PURE__ */ new Map();
        this.memoizedPaths = /* @__PURE__ */ new Map();
        this.memoizedURLs = /* @__PURE__ */ new Map();
      }
      addAnnotation() {
        let content;
        if (this.isInline()) {
          content = "data:application/json;base64," + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === "string") {
          content = this.mapOpts.annotation;
        } else if (typeof this.mapOpts.annotation === "function") {
          content = this.mapOpts.annotation(this.opts.to, this.root);
        } else {
          content = this.outputFile() + ".map";
        }
        let eol = "\n";
        if (this.css.includes("\r\n"))
          eol = "\r\n";
        this.css += eol + "/*# sourceMappingURL=" + content + " */";
      }
      applyPrevMaps() {
        for (let prev of this.previous()) {
          let from = this.toUrl(this.path(prev.file));
          let root4 = prev.root || dirname(prev.file);
          let map2;
          if (this.mapOpts.sourcesContent === false) {
            map2 = new SourceMapConsumer(prev.text);
            if (map2.sourcesContent) {
              map2.sourcesContent = null;
            }
          } else {
            map2 = prev.consumer();
          }
          this.map.applySourceMap(map2, from, this.toUrl(this.path(root4)));
        }
      }
      clearAnnotation() {
        if (this.mapOpts.annotation === false)
          return;
        if (this.root) {
          let node;
          for (let i4 = this.root.nodes.length - 1; i4 >= 0; i4--) {
            node = this.root.nodes[i4];
            if (node.type !== "comment")
              continue;
            if (node.text.startsWith("# sourceMappingURL=")) {
              this.root.removeChild(i4);
            }
          }
        } else if (this.css) {
          this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, "");
        }
      }
      generate() {
        this.clearAnnotation();
        if (pathAvailable && sourceMapAvailable && this.isMap()) {
          return this.generateMap();
        } else {
          let result = "";
          this.stringify(this.root, (i4) => {
            result += i4;
          });
          return [result];
        }
      }
      generateMap() {
        if (this.root) {
          this.generateString();
        } else if (this.previous().length === 1) {
          let prev = this.previous()[0].consumer();
          prev.file = this.outputFile();
          this.map = SourceMapGenerator.fromSourceMap(prev, {
            ignoreInvalidMapping: true
          });
        } else {
          this.map = new SourceMapGenerator({
            file: this.outputFile(),
            ignoreInvalidMapping: true
          });
          this.map.addMapping({
            generated: { column: 0, line: 1 },
            original: { column: 0, line: 1 },
            source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
          });
        }
        if (this.isSourcesContent())
          this.setSourcesContent();
        if (this.root && this.previous().length > 0)
          this.applyPrevMaps();
        if (this.isAnnotation())
          this.addAnnotation();
        if (this.isInline()) {
          return [this.css];
        } else {
          return [this.css, this.map];
        }
      }
      generateString() {
        this.css = "";
        this.map = new SourceMapGenerator({
          file: this.outputFile(),
          ignoreInvalidMapping: true
        });
        let line2 = 1;
        let column = 1;
        let noSource = "<no source>";
        let mapping = {
          generated: { column: 0, line: 0 },
          original: { column: 0, line: 0 },
          source: ""
        };
        let last, lines;
        this.stringify(this.root, (str, node, type2) => {
          this.css += str;
          if (node && type2 !== "end") {
            mapping.generated.line = line2;
            mapping.generated.column = column - 1;
            if (node.source && node.source.start) {
              mapping.source = this.sourcePath(node);
              mapping.original.line = node.source.start.line;
              mapping.original.column = node.source.start.column - 1;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              this.map.addMapping(mapping);
            }
          }
          lines = str.match(/\n/g);
          if (lines) {
            line2 += lines.length;
            last = str.lastIndexOf("\n");
            column = str.length - last;
          } else {
            column += str.length;
          }
          if (node && type2 !== "start") {
            let p7 = node.parent || { raws: {} };
            let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
            if (!childless || node !== p7.last || p7.raws.semicolon) {
              if (node.source && node.source.end) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.end.line;
                mapping.original.column = node.source.end.column - 1;
                mapping.generated.line = line2;
                mapping.generated.column = column - 2;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                mapping.generated.line = line2;
                mapping.generated.column = column - 1;
                this.map.addMapping(mapping);
              }
            }
          }
        });
      }
      isAnnotation() {
        if (this.isInline()) {
          return true;
        }
        if (typeof this.mapOpts.annotation !== "undefined") {
          return this.mapOpts.annotation;
        }
        if (this.previous().length) {
          return this.previous().some((i4) => i4.annotation);
        }
        return true;
      }
      isInline() {
        if (typeof this.mapOpts.inline !== "undefined") {
          return this.mapOpts.inline;
        }
        let annotation = this.mapOpts.annotation;
        if (typeof annotation !== "undefined" && annotation !== true) {
          return false;
        }
        if (this.previous().length) {
          return this.previous().some((i4) => i4.inline);
        }
        return true;
      }
      isMap() {
        if (typeof this.opts.map !== "undefined") {
          return !!this.opts.map;
        }
        return this.previous().length > 0;
      }
      isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== "undefined") {
          return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
          return this.previous().some((i4) => i4.withContent());
        }
        return true;
      }
      outputFile() {
        if (this.opts.to) {
          return this.path(this.opts.to);
        } else if (this.opts.from) {
          return this.path(this.opts.from);
        } else {
          return "to.css";
        }
      }
      path(file) {
        if (this.mapOpts.absolute)
          return file;
        if (file.charCodeAt(0) === 60)
          return file;
        if (/^\w+:\/\//.test(file))
          return file;
        let cached = this.memoizedPaths.get(file);
        if (cached)
          return cached;
        let from = this.opts.to ? dirname(this.opts.to) : ".";
        if (typeof this.mapOpts.annotation === "string") {
          from = dirname(resolve(from, this.mapOpts.annotation));
        }
        let path2 = relative(from, file);
        this.memoizedPaths.set(file, path2);
        return path2;
      }
      previous() {
        if (!this.previousMaps) {
          this.previousMaps = [];
          if (this.root) {
            this.root.walk((node) => {
              if (node.source && node.source.input.map) {
                let map2 = node.source.input.map;
                if (!this.previousMaps.includes(map2)) {
                  this.previousMaps.push(map2);
                }
              }
            });
          } else {
            let input = new Input2(this.originalCSS, this.opts);
            if (input.map)
              this.previousMaps.push(input.map);
          }
        }
        return this.previousMaps;
      }
      setSourcesContent() {
        let already = {};
        if (this.root) {
          this.root.walk((node) => {
            if (node.source) {
              let from = node.source.input.from;
              if (from && !already[from]) {
                already[from] = true;
                let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
                this.map.setSourceContent(fromUrl, node.source.input.css);
              }
            }
          });
        } else if (this.css) {
          let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
          this.map.setSourceContent(from, this.css);
        }
      }
      sourcePath(node) {
        if (this.mapOpts.from) {
          return this.toUrl(this.mapOpts.from);
        } else if (this.usesFileUrls) {
          return this.toFileUrl(node.source.input.from);
        } else {
          return this.toUrl(this.path(node.source.input.from));
        }
      }
      toBase64(str) {
        if (Buffer) {
          return Buffer.from(str).toString("base64");
        } else {
          return window.btoa(unescape(encodeURIComponent(str)));
        }
      }
      toFileUrl(path2) {
        let cached = this.memoizedFileURLs.get(path2);
        if (cached)
          return cached;
        if (pathToFileURL) {
          let fileURL = pathToFileURL(path2).toString();
          this.memoizedFileURLs.set(path2, fileURL);
          return fileURL;
        } else {
          throw new Error(
            "`map.absolute` option is not available in this PostCSS build"
          );
        }
      }
      toUrl(path2) {
        let cached = this.memoizedURLs.get(path2);
        if (cached)
          return cached;
        if (sep === "\\") {
          path2 = path2.replace(/\\/g, "/");
        }
        let url = encodeURI(path2).replace(/[#?]/g, encodeURIComponent);
        this.memoizedURLs.set(path2, url);
        return url;
      }
    };
    module2.exports = MapGenerator;
  }
});

// node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/postcss/lib/tokenize.js"(exports2, module2) {
    "use strict";
    var SINGLE_QUOTE = "'".charCodeAt(0);
    var DOUBLE_QUOTE = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var SLASH = "/".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var SPACE = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var OPEN_SQUARE = "[".charCodeAt(0);
    var CLOSE_SQUARE = "]".charCodeAt(0);
    var OPEN_PARENTHESES = "(".charCodeAt(0);
    var CLOSE_PARENTHESES = ")".charCodeAt(0);
    var OPEN_CURLY = "{".charCodeAt(0);
    var CLOSE_CURLY = "}".charCodeAt(0);
    var SEMICOLON = ";".charCodeAt(0);
    var ASTERISK = "*".charCodeAt(0);
    var COLON = ":".charCodeAt(0);
    var AT = "@".charCodeAt(0);
    var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
    var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
    var RE_HEX_ESCAPE = /[\da-f]/i;
    module2.exports = function tokenizer(input, options = {}) {
      let css = input.css.valueOf();
      let ignore = options.ignoreErrors;
      let code, content, escape, next, quote;
      let currentToken, escaped, escapePos, n4, prev;
      let length = css.length;
      let pos = 0;
      let buffer = [];
      let returned = [];
      function position() {
        return pos;
      }
      function unclosed(what) {
        throw input.error("Unclosed " + what, pos);
      }
      function endOfFile() {
        return returned.length === 0 && pos >= length;
      }
      function nextToken(opts) {
        if (returned.length)
          return returned.pop();
        if (pos >= length)
          return;
        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
        code = css.charCodeAt(pos);
        switch (code) {
          case NEWLINE:
          case SPACE:
          case TAB:
          case CR:
          case FEED: {
            next = pos;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
            currentToken = ["space", css.slice(pos, next)];
            pos = next - 1;
            break;
          }
          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON:
          case SEMICOLON:
          case CLOSE_PARENTHESES: {
            let controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, pos];
            break;
          }
          case OPEN_PARENTHESES: {
            prev = buffer.length ? buffer.pop()[1] : "";
            n4 = css.charCodeAt(pos + 1);
            if (prev === "url" && n4 !== SINGLE_QUOTE && n4 !== DOUBLE_QUOTE && n4 !== SPACE && n4 !== NEWLINE && n4 !== TAB && n4 !== FEED && n4 !== CR) {
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(")", next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos;
                    break;
                  } else {
                    unclosed("bracket");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              next = css.indexOf(")", pos + 1);
              content = css.slice(pos, next + 1);
              if (next === -1 || RE_BAD_BRACKET.test(content)) {
                currentToken = ["(", "(", pos];
              } else {
                currentToken = ["brackets", content, pos, next];
                pos = next;
              }
            }
            break;
          }
          case SINGLE_QUOTE:
          case DOUBLE_QUOTE: {
            quote = code === SINGLE_QUOTE ? "'" : '"';
            next = pos;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos + 1;
                  break;
                } else {
                  unclosed("string");
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            currentToken = ["string", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case AT: {
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css);
            if (RE_AT_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }
            currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case BACKSLASH: {
            next = pos;
            escape = true;
            while (css.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape = !escape;
            }
            code = css.charCodeAt(next + 1);
            if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
              next += 1;
              if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                  next += 1;
                }
                if (css.charCodeAt(next + 1) === SPACE) {
                  next += 1;
                }
              }
            }
            currentToken = ["word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          default: {
            if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
              next = css.indexOf("*/", pos + 2) + 1;
              if (next === 0) {
                if (ignore || ignoreUnclosed) {
                  next = css.length;
                } else {
                  unclosed("comment");
                }
              }
              currentToken = ["comment", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css);
              if (RE_WORD_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }
              currentToken = ["word", css.slice(pos, next + 1), pos, next];
              buffer.push(currentToken);
              pos = next;
            }
            break;
          }
        }
        pos++;
        return currentToken;
      }
      function back(token) {
        returned.push(token);
      }
      return {
        back,
        endOfFile,
        nextToken,
        position
      };
    };
  }
});

// node_modules/postcss/lib/parser.js
var require_parser = __commonJS({
  "node_modules/postcss/lib/parser.js"(exports2, module2) {
    "use strict";
    var AtRule2 = require_at_rule();
    var Comment2 = require_comment();
    var Declaration2 = require_declaration();
    var Root2 = require_root2();
    var Rule2 = require_rule();
    var tokenizer = require_tokenize();
    var SAFE_COMMENT_NEIGHBOR = {
      empty: true,
      space: true
    };
    function findLastWithPosition(tokens) {
      for (let i4 = tokens.length - 1; i4 >= 0; i4--) {
        let token = tokens[i4];
        let pos = token[3] || token[2];
        if (pos)
          return pos;
      }
    }
    var Parser = class {
      constructor(input) {
        this.input = input;
        this.root = new Root2();
        this.current = this.root;
        this.spaces = "";
        this.semicolon = false;
        this.createTokenizer();
        this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
      }
      atrule(token) {
        let node = new AtRule2();
        node.name = token[1].slice(1);
        if (node.name === "") {
          this.unnamedAtrule(node, token);
        }
        this.init(node, token[2]);
        let type2;
        let prev;
        let shift;
        let last = false;
        let open = false;
        let params = [];
        let brackets = [];
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          type2 = token[0];
          if (type2 === "(" || type2 === "[") {
            brackets.push(type2 === "(" ? ")" : "]");
          } else if (type2 === "{" && brackets.length > 0) {
            brackets.push("}");
          } else if (type2 === brackets[brackets.length - 1]) {
            brackets.pop();
          }
          if (brackets.length === 0) {
            if (type2 === ";") {
              node.source.end = this.getPosition(token[2]);
              node.source.end.offset++;
              this.semicolon = true;
              break;
            } else if (type2 === "{") {
              open = true;
              break;
            } else if (type2 === "}") {
              if (params.length > 0) {
                shift = params.length - 1;
                prev = params[shift];
                while (prev && prev[0] === "space") {
                  prev = params[--shift];
                }
                if (prev) {
                  node.source.end = this.getPosition(prev[3] || prev[2]);
                  node.source.end.offset++;
                }
              }
              this.end(token);
              break;
            } else {
              params.push(token);
            }
          } else {
            params.push(token);
          }
          if (this.tokenizer.endOfFile()) {
            last = true;
            break;
          }
        }
        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node, "params", params);
          if (last) {
            token = params[params.length - 1];
            node.source.end = this.getPosition(token[3] || token[2]);
            node.source.end.offset++;
            this.spaces = node.raws.between;
            node.raws.between = "";
          }
        } else {
          node.raws.afterName = "";
          node.params = "";
        }
        if (open) {
          node.nodes = [];
          this.current = node;
        }
      }
      checkMissedSemicolon(tokens) {
        let colon = this.colon(tokens);
        if (colon === false)
          return;
        let founded = 0;
        let token;
        for (let j2 = colon - 1; j2 >= 0; j2--) {
          token = tokens[j2];
          if (token[0] !== "space") {
            founded += 1;
            if (founded === 2)
              break;
          }
        }
        throw this.input.error(
          "Missed semicolon",
          token[0] === "word" ? token[3] + 1 : token[2]
        );
      }
      colon(tokens) {
        let brackets = 0;
        let prev, token, type2;
        for (let [i4, element] of tokens.entries()) {
          token = element;
          type2 = token[0];
          if (type2 === "(") {
            brackets += 1;
          }
          if (type2 === ")") {
            brackets -= 1;
          }
          if (brackets === 0 && type2 === ":") {
            if (!prev) {
              this.doubleColon(token);
            } else if (prev[0] === "word" && prev[1] === "progid") {
              continue;
            } else {
              return i4;
            }
          }
          prev = token;
        }
        return false;
      }
      comment(token) {
        let node = new Comment2();
        this.init(node, token[2]);
        node.source.end = this.getPosition(token[3] || token[2]);
        node.source.end.offset++;
        let text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
          node.text = "";
          node.raws.left = text;
          node.raws.right = "";
        } else {
          let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
          node.text = match[2];
          node.raws.left = match[1];
          node.raws.right = match[3];
        }
      }
      createTokenizer() {
        this.tokenizer = tokenizer(this.input);
      }
      decl(tokens, customProperty) {
        let node = new Declaration2();
        this.init(node, tokens[0][2]);
        let last = tokens[tokens.length - 1];
        if (last[0] === ";") {
          this.semicolon = true;
          tokens.pop();
        }
        node.source.end = this.getPosition(
          last[3] || last[2] || findLastWithPosition(tokens)
        );
        node.source.end.offset++;
        while (tokens[0][0] !== "word") {
          if (tokens.length === 1)
            this.unknownWord(tokens);
          node.raws.before += tokens.shift()[1];
        }
        node.source.start = this.getPosition(tokens[0][2]);
        node.prop = "";
        while (tokens.length) {
          let type2 = tokens[0][0];
          if (type2 === ":" || type2 === "space" || type2 === "comment") {
            break;
          }
          node.prop += tokens.shift()[1];
        }
        node.raws.between = "";
        let token;
        while (tokens.length) {
          token = tokens.shift();
          if (token[0] === ":") {
            node.raws.between += token[1];
            break;
          } else {
            if (token[0] === "word" && /\w/.test(token[1])) {
              this.unknownWord([token]);
            }
            node.raws.between += token[1];
          }
        }
        if (node.prop[0] === "_" || node.prop[0] === "*") {
          node.raws.before += node.prop[0];
          node.prop = node.prop.slice(1);
        }
        let firstSpaces = [];
        let next;
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          firstSpaces.push(tokens.shift());
        }
        this.precheckMissedSemicolon(tokens);
        for (let i4 = tokens.length - 1; i4 >= 0; i4--) {
          token = tokens[i4];
          if (token[1].toLowerCase() === "!important") {
            node.important = true;
            let string2 = this.stringFrom(tokens, i4);
            string2 = this.spacesFromEnd(tokens) + string2;
            if (string2 !== " !important")
              node.raws.important = string2;
            break;
          } else if (token[1].toLowerCase() === "important") {
            let cache = tokens.slice(0);
            let str = "";
            for (let j2 = i4; j2 > 0; j2--) {
              let type2 = cache[j2][0];
              if (str.trim().startsWith("!") && type2 !== "space") {
                break;
              }
              str = cache.pop()[1] + str;
            }
            if (str.trim().startsWith("!")) {
              node.important = true;
              node.raws.important = str;
              tokens = cache;
            }
          }
          if (token[0] !== "space" && token[0] !== "comment") {
            break;
          }
        }
        let hasWord = tokens.some((i4) => i4[0] !== "space" && i4[0] !== "comment");
        if (hasWord) {
          node.raws.between += firstSpaces.map((i4) => i4[1]).join("");
          firstSpaces = [];
        }
        this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
        if (node.value.includes(":") && !customProperty) {
          this.checkMissedSemicolon(tokens);
        }
      }
      doubleColon(token) {
        throw this.input.error(
          "Double colon",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
      emptyRule(token) {
        let node = new Rule2();
        this.init(node, token[2]);
        node.selector = "";
        node.raws.between = "";
        this.current = node;
      }
      end(token) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.spaces = "";
        if (this.current.parent) {
          this.current.source.end = this.getPosition(token[2]);
          this.current.source.end.offset++;
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token);
        }
      }
      endFile() {
        if (this.current.parent)
          this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.root.source.end = this.getPosition(this.tokenizer.position());
      }
      freeSemicolon(token) {
        this.spaces += token[1];
        if (this.current.nodes) {
          let prev = this.current.nodes[this.current.nodes.length - 1];
          if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
            prev.raws.ownSemicolon = this.spaces;
            this.spaces = "";
            prev.source.end = this.getPosition(token[2]);
            prev.source.end.offset += prev.raws.ownSemicolon.length;
          }
        }
      }
      // Helpers
      getPosition(offset) {
        let pos = this.input.fromOffset(offset);
        return {
          column: pos.col,
          line: pos.line,
          offset
        };
      }
      init(node, offset) {
        this.current.push(node);
        node.source = {
          input: this.input,
          start: this.getPosition(offset)
        };
        node.raws.before = this.spaces;
        this.spaces = "";
        if (node.type !== "comment")
          this.semicolon = false;
      }
      other(start2) {
        let end = false;
        let type2 = null;
        let colon = false;
        let bracket = null;
        let brackets = [];
        let customProperty = start2[1].startsWith("--");
        let tokens = [];
        let token = start2;
        while (token) {
          type2 = token[0];
          tokens.push(token);
          if (type2 === "(" || type2 === "[") {
            if (!bracket)
              bracket = token;
            brackets.push(type2 === "(" ? ")" : "]");
          } else if (customProperty && colon && type2 === "{") {
            if (!bracket)
              bracket = token;
            brackets.push("}");
          } else if (brackets.length === 0) {
            if (type2 === ";") {
              if (colon) {
                this.decl(tokens, customProperty);
                return;
              } else {
                break;
              }
            } else if (type2 === "{") {
              this.rule(tokens);
              return;
            } else if (type2 === "}") {
              this.tokenizer.back(tokens.pop());
              end = true;
              break;
            } else if (type2 === ":") {
              colon = true;
            }
          } else if (type2 === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0)
              bracket = null;
          }
          token = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile())
          end = true;
        if (brackets.length > 0)
          this.unclosedBracket(bracket);
        if (end && colon) {
          if (!customProperty) {
            while (tokens.length) {
              token = tokens[tokens.length - 1][0];
              if (token !== "space" && token !== "comment")
                break;
              this.tokenizer.back(tokens.pop());
            }
          }
          this.decl(tokens, customProperty);
        } else {
          this.unknownWord(tokens);
        }
      }
      parse() {
        let token;
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          switch (token[0]) {
            case "space":
              this.spaces += token[1];
              break;
            case ";":
              this.freeSemicolon(token);
              break;
            case "}":
              this.end(token);
              break;
            case "comment":
              this.comment(token);
              break;
            case "at-word":
              this.atrule(token);
              break;
            case "{":
              this.emptyRule(token);
              break;
            default:
              this.other(token);
              break;
          }
        }
        this.endFile();
      }
      precheckMissedSemicolon() {
      }
      raw(node, prop, tokens, customProperty) {
        let token, type2;
        let length = tokens.length;
        let value = "";
        let clean = true;
        let next, prev;
        for (let i4 = 0; i4 < length; i4 += 1) {
          token = tokens[i4];
          type2 = token[0];
          if (type2 === "space" && i4 === length - 1 && !customProperty) {
            clean = false;
          } else if (type2 === "comment") {
            prev = tokens[i4 - 1] ? tokens[i4 - 1][0] : "empty";
            next = tokens[i4 + 1] ? tokens[i4 + 1][0] : "empty";
            if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
              if (value.slice(-1) === ",") {
                clean = false;
              } else {
                value += token[1];
              }
            } else {
              clean = false;
            }
          } else {
            value += token[1];
          }
        }
        if (!clean) {
          let raw = tokens.reduce((all, i4) => all + i4[1], "");
          node.raws[prop] = { raw, value };
        }
        node[prop] = value;
      }
      rule(tokens) {
        tokens.pop();
        let node = new Rule2();
        this.init(node, tokens[0][2]);
        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, "selector", tokens);
        this.current = node;
      }
      spacesAndCommentsFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space" && lastTokenType !== "comment")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      // Errors
      spacesAndCommentsFromStart(tokens) {
        let next;
        let spaces = "";
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          spaces += tokens.shift()[1];
        }
        return spaces;
      }
      spacesFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      stringFrom(tokens, from) {
        let result = "";
        for (let i4 = from; i4 < tokens.length; i4++) {
          result += tokens[i4][1];
        }
        tokens.splice(from, tokens.length - from);
        return result;
      }
      unclosedBlock() {
        let pos = this.current.source.start;
        throw this.input.error("Unclosed block", pos.line, pos.column);
      }
      unclosedBracket(bracket) {
        throw this.input.error(
          "Unclosed bracket",
          { offset: bracket[2] },
          { offset: bracket[2] + 1 }
        );
      }
      unexpectedClose(token) {
        throw this.input.error(
          "Unexpected }",
          { offset: token[2] },
          { offset: token[2] + 1 }
        );
      }
      unknownWord(tokens) {
        throw this.input.error(
          "Unknown word " + tokens[0][1],
          { offset: tokens[0][2] },
          { offset: tokens[0][2] + tokens[0][1].length }
        );
      }
      unnamedAtrule(node, token) {
        throw this.input.error(
          "At-rule without name",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
    };
    module2.exports = Parser;
  }
});

// node_modules/postcss/lib/parse.js
var require_parse = __commonJS({
  "node_modules/postcss/lib/parse.js"(exports2, module2) {
    "use strict";
    var Container2 = require_container();
    var Input2 = require_input();
    var Parser = require_parser();
    function parse3(css, opts) {
      let input = new Input2(css, opts);
      let parser = new Parser(input);
      try {
        parser.parse();
      } catch (e8) {
        if (true) {
          if (e8.name === "CssSyntaxError" && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e8.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
            } else if (/\.sass/i.test(opts.from)) {
              e8.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
            } else if (/\.less$/i.test(opts.from)) {
              e8.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
            }
          }
        }
        throw e8;
      }
      return parser.root;
    }
    module2.exports = parse3;
    parse3.default = parse3;
    Container2.registerParse(parse3);
  }
});

// node_modules/postcss/lib/warning.js
var require_warning = __commonJS({
  "node_modules/postcss/lib/warning.js"(exports2, module2) {
    "use strict";
    var Warning2 = class {
      constructor(text, opts = {}) {
        this.type = "warning";
        this.text = text;
        if (opts.node && opts.node.source) {
          let range = opts.node.rangeBy(opts);
          this.line = range.start.line;
          this.column = range.start.column;
          this.endLine = range.end.line;
          this.endColumn = range.end.column;
        }
        for (let opt in opts)
          this[opt] = opts[opt];
      }
      toString() {
        if (this.node) {
          return this.node.error(this.text, {
            index: this.index,
            plugin: this.plugin,
            word: this.word
          }).message;
        }
        if (this.plugin) {
          return this.plugin + ": " + this.text;
        }
        return this.text;
      }
    };
    module2.exports = Warning2;
    Warning2.default = Warning2;
  }
});

// node_modules/postcss/lib/result.js
var require_result = __commonJS({
  "node_modules/postcss/lib/result.js"(exports2, module2) {
    "use strict";
    var Warning2 = require_warning();
    var Result2 = class {
      get content() {
        return this.css;
      }
      constructor(processor, root4, opts) {
        this.processor = processor;
        this.messages = [];
        this.root = root4;
        this.opts = opts;
        this.css = "";
        this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(text, opts = {}) {
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }
        let warning = new Warning2(text, opts);
        this.messages.push(warning);
        return warning;
      }
      warnings() {
        return this.messages.filter((i4) => i4.type === "warning");
      }
    };
    module2.exports = Result2;
    Result2.default = Result2;
  }
});

// node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS({
  "node_modules/postcss/lib/warn-once.js"(exports2, module2) {
    "use strict";
    var printed = {};
    module2.exports = function warnOnce(message) {
      if (printed[message])
        return;
      printed[message] = true;
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
    };
  }
});

// node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS({
  "node_modules/postcss/lib/lazy-result.js"(exports2, module2) {
    "use strict";
    var Container2 = require_container();
    var Document2 = require_document();
    var MapGenerator = require_map_generator();
    var parse3 = require_parse();
    var Result2 = require_result();
    var Root2 = require_root2();
    var stringify2 = require_stringify();
    var { isClean, my } = require_symbols();
    var warnOnce = require_warn_once();
    var TYPE_TO_CLASS_NAME = {
      atrule: "AtRule",
      comment: "Comment",
      decl: "Declaration",
      document: "Document",
      root: "Root",
      rule: "Rule"
    };
    var PLUGIN_PROPS = {
      AtRule: true,
      AtRuleExit: true,
      Comment: true,
      CommentExit: true,
      Declaration: true,
      DeclarationExit: true,
      Document: true,
      DocumentExit: true,
      Once: true,
      OnceExit: true,
      postcssPlugin: true,
      prepare: true,
      Root: true,
      RootExit: true,
      Rule: true,
      RuleExit: true
    };
    var NOT_VISITORS = {
      Once: true,
      postcssPlugin: true,
      prepare: true
    };
    var CHILDREN = 0;
    function isPromise(obj) {
      return typeof obj === "object" && typeof obj.then === "function";
    }
    function getEvents(node) {
      let key = false;
      let type2 = TYPE_TO_CLASS_NAME[node.type];
      if (node.type === "decl") {
        key = node.prop.toLowerCase();
      } else if (node.type === "atrule") {
        key = node.name.toLowerCase();
      }
      if (key && node.append) {
        return [
          type2,
          type2 + "-" + key,
          CHILDREN,
          type2 + "Exit",
          type2 + "Exit-" + key
        ];
      } else if (key) {
        return [type2, type2 + "-" + key, type2 + "Exit", type2 + "Exit-" + key];
      } else if (node.append) {
        return [type2, CHILDREN, type2 + "Exit"];
      } else {
        return [type2, type2 + "Exit"];
      }
    }
    function toStack(node) {
      let events;
      if (node.type === "document") {
        events = ["Document", CHILDREN, "DocumentExit"];
      } else if (node.type === "root") {
        events = ["Root", CHILDREN, "RootExit"];
      } else {
        events = getEvents(node);
      }
      return {
        eventIndex: 0,
        events,
        iterator: 0,
        node,
        visitorIndex: 0,
        visitors: []
      };
    }
    function cleanMarks(node) {
      node[isClean] = false;
      if (node.nodes)
        node.nodes.forEach((i4) => cleanMarks(i4));
      return node;
    }
    var postcss2 = {};
    var LazyResult = class {
      get content() {
        return this.stringify().content;
      }
      get css() {
        return this.stringify().css;
      }
      get map() {
        return this.stringify().map;
      }
      get messages() {
        return this.sync().messages;
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        return this.sync().root;
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
      constructor(processor, css, opts) {
        this.stringified = false;
        this.processed = false;
        let root4;
        if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
          root4 = cleanMarks(css);
        } else if (css instanceof LazyResult || css instanceof Result2) {
          root4 = cleanMarks(css.root);
          if (css.map) {
            if (typeof opts.map === "undefined")
              opts.map = {};
            if (!opts.map.inline)
              opts.map.inline = false;
            opts.map.prev = css.map;
          }
        } else {
          let parser = parse3;
          if (opts.syntax)
            parser = opts.syntax.parse;
          if (opts.parser)
            parser = opts.parser;
          if (parser.parse)
            parser = parser.parse;
          try {
            root4 = parser(css, opts);
          } catch (error) {
            this.processed = true;
            this.error = error;
          }
          if (root4 && !root4[my]) {
            Container2.rebuild(root4);
          }
        }
        this.result = new Result2(processor, root4, opts);
        this.helpers = { ...postcss2, postcss: postcss2, result: this.result };
        this.plugins = this.processor.plugins.map((plugin2) => {
          if (typeof plugin2 === "object" && plugin2.prepare) {
            return { ...plugin2, ...plugin2.prepare(this.result) };
          } else {
            return plugin2;
          }
        });
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        if (this.processed)
          return Promise.resolve(this.result);
        if (!this.processing) {
          this.processing = this.runAsync();
        }
        return this.processing;
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(error, node) {
        let plugin2 = this.result.lastPlugin;
        try {
          if (node)
            node.addToError(error);
          this.error = error;
          if (error.name === "CssSyntaxError" && !error.plugin) {
            error.plugin = plugin2.postcssPlugin;
            error.setMessage();
          } else if (plugin2.postcssVersion) {
            if (true) {
              let pluginName = plugin2.postcssPlugin;
              let pluginVer = plugin2.postcssVersion;
              let runtimeVer = this.result.processor.version;
              let a3 = pluginVer.split(".");
              let b2 = runtimeVer.split(".");
              if (a3[0] !== b2[0] || parseInt(a3[1]) > parseInt(b2[1])) {
                console.error(
                  "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                );
              }
            }
          }
        } catch (err) {
          if (console && console.error)
            console.error(err);
        }
        return error;
      }
      prepareVisitors() {
        this.listeners = {};
        let add2 = (plugin2, type2, cb) => {
          if (!this.listeners[type2])
            this.listeners[type2] = [];
          this.listeners[type2].push([plugin2, cb]);
        };
        for (let plugin2 of this.plugins) {
          if (typeof plugin2 === "object") {
            for (let event in plugin2) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error(
                  `Unknown event ${event} in ${plugin2.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                );
              }
              if (!NOT_VISITORS[event]) {
                if (typeof plugin2[event] === "object") {
                  for (let filter2 in plugin2[event]) {
                    if (filter2 === "*") {
                      add2(plugin2, event, plugin2[event][filter2]);
                    } else {
                      add2(
                        plugin2,
                        event + "-" + filter2.toLowerCase(),
                        plugin2[event][filter2]
                      );
                    }
                  }
                } else if (typeof plugin2[event] === "function") {
                  add2(plugin2, event, plugin2[event]);
                }
              }
            }
          }
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      async runAsync() {
        this.plugin = 0;
        for (let i4 = 0; i4 < this.plugins.length; i4++) {
          let plugin2 = this.plugins[i4];
          let promise = this.runOnRoot(plugin2);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (error) {
              throw this.handleError(error);
            }
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root4 = this.result.root;
          while (!root4[isClean]) {
            root4[isClean] = true;
            let stack = [toStack(root4)];
            while (stack.length > 0) {
              let promise = this.visitTick(stack);
              if (isPromise(promise)) {
                try {
                  await promise;
                } catch (e8) {
                  let node = stack[stack.length - 1].node;
                  throw this.handleError(e8, node);
                }
              }
            }
          }
          if (this.listeners.OnceExit) {
            for (let [plugin2, visitor] of this.listeners.OnceExit) {
              this.result.lastPlugin = plugin2;
              try {
                if (root4.type === "document") {
                  let roots = root4.nodes.map(
                    (subRoot) => visitor(subRoot, this.helpers)
                  );
                  await Promise.all(roots);
                } else {
                  await visitor(root4, this.helpers);
                }
              } catch (e8) {
                throw this.handleError(e8);
              }
            }
          }
        }
        this.processed = true;
        return this.stringify();
      }
      runOnRoot(plugin2) {
        this.result.lastPlugin = plugin2;
        try {
          if (typeof plugin2 === "object" && plugin2.Once) {
            if (this.result.root.type === "document") {
              let roots = this.result.root.nodes.map(
                (root4) => plugin2.Once(root4, this.helpers)
              );
              if (isPromise(roots[0])) {
                return Promise.all(roots);
              }
              return roots;
            }
            return plugin2.Once(this.result.root, this.helpers);
          } else if (typeof plugin2 === "function") {
            return plugin2(this.result.root, this.result);
          }
        } catch (error) {
          throw this.handleError(error);
        }
      }
      stringify() {
        if (this.error)
          throw this.error;
        if (this.stringified)
          return this.result;
        this.stringified = true;
        this.sync();
        let opts = this.result.opts;
        let str = stringify2;
        if (opts.syntax)
          str = opts.syntax.stringify;
        if (opts.stringifier)
          str = opts.stringifier;
        if (str.stringify)
          str = str.stringify;
        let map2 = new MapGenerator(str, this.result.root, this.result.opts);
        let data = map2.generate();
        this.result.css = data[0];
        this.result.map = data[1];
        return this.result;
      }
      sync() {
        if (this.error)
          throw this.error;
        if (this.processed)
          return this.result;
        this.processed = true;
        if (this.processing) {
          throw this.getAsyncError();
        }
        for (let plugin2 of this.plugins) {
          let promise = this.runOnRoot(plugin2);
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root4 = this.result.root;
          while (!root4[isClean]) {
            root4[isClean] = true;
            this.walkSync(root4);
          }
          if (this.listeners.OnceExit) {
            if (root4.type === "document") {
              for (let subRoot of root4.nodes) {
                this.visitSync(this.listeners.OnceExit, subRoot);
              }
            } else {
              this.visitSync(this.listeners.OnceExit, root4);
            }
          }
        }
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this.opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this.css;
      }
      visitSync(visitors, node) {
        for (let [plugin2, visitor] of visitors) {
          this.result.lastPlugin = plugin2;
          let promise;
          try {
            promise = visitor(node, this.helpers);
          } catch (e8) {
            throw this.handleError(e8, node.proxyOf);
          }
          if (node.type !== "root" && node.type !== "document" && !node.parent) {
            return true;
          }
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
      }
      visitTick(stack) {
        let visit = stack[stack.length - 1];
        let { node, visitors } = visit;
        if (node.type !== "root" && node.type !== "document" && !node.parent) {
          stack.pop();
          return;
        }
        if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
          let [plugin2, visitor] = visitors[visit.visitorIndex];
          visit.visitorIndex += 1;
          if (visit.visitorIndex === visitors.length) {
            visit.visitors = [];
            visit.visitorIndex = 0;
          }
          this.result.lastPlugin = plugin2;
          try {
            return visitor(node.toProxy(), this.helpers);
          } catch (e8) {
            throw this.handleError(e8, node);
          }
        }
        if (visit.iterator !== 0) {
          let iterator = visit.iterator;
          let child;
          while (child = node.nodes[node.indexes[iterator]]) {
            node.indexes[iterator] += 1;
            if (!child[isClean]) {
              child[isClean] = true;
              stack.push(toStack(child));
              return;
            }
          }
          visit.iterator = 0;
          delete node.indexes[iterator];
        }
        let events = visit.events;
        while (visit.eventIndex < events.length) {
          let event = events[visit.eventIndex];
          visit.eventIndex += 1;
          if (event === CHILDREN) {
            if (node.nodes && node.nodes.length) {
              node[isClean] = true;
              visit.iterator = node.getIterator();
            }
            return;
          } else if (this.listeners[event]) {
            visit.visitors = this.listeners[event];
            return;
          }
        }
        stack.pop();
      }
      walkSync(node) {
        node[isClean] = true;
        let events = getEvents(node);
        for (let event of events) {
          if (event === CHILDREN) {
            if (node.nodes) {
              node.each((child) => {
                if (!child[isClean])
                  this.walkSync(child);
              });
            }
          } else {
            let visitors = this.listeners[event];
            if (visitors) {
              if (this.visitSync(visitors, node.toProxy()))
                return;
            }
          }
        }
      }
      warnings() {
        return this.sync().warnings();
      }
    };
    LazyResult.registerPostcss = (dependant) => {
      postcss2 = dependant;
    };
    module2.exports = LazyResult;
    LazyResult.default = LazyResult;
    Root2.registerLazyResult(LazyResult);
    Document2.registerLazyResult(LazyResult);
  }
});

// node_modules/postcss/lib/no-work-result.js
var require_no_work_result = __commonJS({
  "node_modules/postcss/lib/no-work-result.js"(exports2, module2) {
    "use strict";
    var MapGenerator = require_map_generator();
    var parse3 = require_parse();
    var Result2 = require_result();
    var stringify2 = require_stringify();
    var warnOnce = require_warn_once();
    var NoWorkResult = class {
      get content() {
        return this.result.css;
      }
      get css() {
        return this.result.css;
      }
      get map() {
        return this.result.map;
      }
      get messages() {
        return [];
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        if (this._root) {
          return this._root;
        }
        let root4;
        let parser = parse3;
        try {
          root4 = parser(this._css, this._opts);
        } catch (error) {
          this.error = error;
        }
        if (this.error) {
          throw this.error;
        } else {
          this._root = root4;
          return root4;
        }
      }
      get [Symbol.toStringTag]() {
        return "NoWorkResult";
      }
      constructor(processor, css, opts) {
        css = css.toString();
        this.stringified = false;
        this._processor = processor;
        this._css = css;
        this._opts = opts;
        this._map = void 0;
        let root4;
        let str = stringify2;
        this.result = new Result2(this._processor, root4, this._opts);
        this.result.css = css;
        let self2 = this;
        Object.defineProperty(this.result, "root", {
          get() {
            return self2.root;
          }
        });
        let map2 = new MapGenerator(str, root4, this._opts, css);
        if (map2.isMap()) {
          let [generatedCSS, generatedMap] = map2.generate();
          if (generatedCSS) {
            this.result.css = generatedCSS;
          }
          if (generatedMap) {
            this.result.map = generatedMap;
          }
        } else {
          map2.clearAnnotation();
          this.result.css = map2.css;
        }
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        return Promise.resolve(this.result);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      sync() {
        if (this.error)
          throw this.error;
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this._opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this._css;
      }
      warnings() {
        return [];
      }
    };
    module2.exports = NoWorkResult;
    NoWorkResult.default = NoWorkResult;
  }
});

// node_modules/postcss/lib/processor.js
var require_processor = __commonJS({
  "node_modules/postcss/lib/processor.js"(exports2, module2) {
    "use strict";
    var Document2 = require_document();
    var LazyResult = require_lazy_result();
    var NoWorkResult = require_no_work_result();
    var Root2 = require_root2();
    var Processor2 = class {
      constructor(plugins = []) {
        this.version = "8.5.6";
        this.plugins = this.normalize(plugins);
      }
      normalize(plugins) {
        let normalized = [];
        for (let i4 of plugins) {
          if (i4.postcss === true) {
            i4 = i4();
          } else if (i4.postcss) {
            i4 = i4.postcss;
          }
          if (typeof i4 === "object" && Array.isArray(i4.plugins)) {
            normalized = normalized.concat(i4.plugins);
          } else if (typeof i4 === "object" && i4.postcssPlugin) {
            normalized.push(i4);
          } else if (typeof i4 === "function") {
            normalized.push(i4);
          } else if (typeof i4 === "object" && (i4.parse || i4.stringify)) {
            if (true) {
              throw new Error(
                "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
              );
            }
          } else {
            throw new Error(i4 + " is not a PostCSS plugin");
          }
        }
        return normalized;
      }
      process(css, opts = {}) {
        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
          return new NoWorkResult(this, css, opts);
        } else {
          return new LazyResult(this, css, opts);
        }
      }
      use(plugin2) {
        this.plugins = this.plugins.concat(this.normalize([plugin2]));
        return this;
      }
    };
    module2.exports = Processor2;
    Processor2.default = Processor2;
    Root2.registerProcessor(Processor2);
    Document2.registerProcessor(Processor2);
  }
});

// node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS({
  "node_modules/postcss/lib/postcss.js"(exports2, module2) {
    "use strict";
    var AtRule2 = require_at_rule();
    var Comment2 = require_comment();
    var Container2 = require_container();
    var CssSyntaxError2 = require_css_syntax_error();
    var Declaration2 = require_declaration();
    var Document2 = require_document();
    var fromJSON2 = require_fromJSON();
    var Input2 = require_input();
    var LazyResult = require_lazy_result();
    var list3 = require_list();
    var Node4 = require_node();
    var parse3 = require_parse();
    var Processor2 = require_processor();
    var Result2 = require_result();
    var Root2 = require_root2();
    var Rule2 = require_rule();
    var stringify2 = require_stringify();
    var Warning2 = require_warning();
    function postcss2(...plugins) {
      if (plugins.length === 1 && Array.isArray(plugins[0])) {
        plugins = plugins[0];
      }
      return new Processor2(plugins);
    }
    postcss2.plugin = function plugin2(name, initializer) {
      let warningPrinted = false;
      function creator(...args) {
        if (console && console.warn && !warningPrinted) {
          warningPrinted = true;
          console.warn(
            name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
          );
          if (process.env.LANG && process.env.LANG.startsWith("cn")) {
            console.warn(
              name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
            );
          }
        }
        let transformer2 = initializer(...args);
        transformer2.postcssPlugin = name;
        transformer2.postcssVersion = new Processor2().version;
        return transformer2;
      }
      let cache;
      Object.defineProperty(creator, "postcss", {
        get() {
          if (!cache)
            cache = creator();
          return cache;
        }
      });
      creator.process = function(css, processOpts, pluginOpts) {
        return postcss2([creator(pluginOpts)]).process(css, processOpts);
      };
      return creator;
    };
    postcss2.stringify = stringify2;
    postcss2.parse = parse3;
    postcss2.fromJSON = fromJSON2;
    postcss2.list = list3;
    postcss2.comment = (defaults) => new Comment2(defaults);
    postcss2.atRule = (defaults) => new AtRule2(defaults);
    postcss2.decl = (defaults) => new Declaration2(defaults);
    postcss2.rule = (defaults) => new Rule2(defaults);
    postcss2.root = (defaults) => new Root2(defaults);
    postcss2.document = (defaults) => new Document2(defaults);
    postcss2.CssSyntaxError = CssSyntaxError2;
    postcss2.Declaration = Declaration2;
    postcss2.Container = Container2;
    postcss2.Processor = Processor2;
    postcss2.Document = Document2;
    postcss2.Comment = Comment2;
    postcss2.Warning = Warning2;
    postcss2.AtRule = AtRule2;
    postcss2.Result = Result2;
    postcss2.Input = Input2;
    postcss2.Rule = Rule2;
    postcss2.Root = Root2;
    postcss2.Node = Node4;
    LazyResult.registerPostcss(postcss2);
    module2.exports = postcss2;
    postcss2.default = postcss2;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn5, context, once) {
      this.fn = fn5;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn5, context, once) {
      if (typeof fn5 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn5, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names2 = [], events, name;
      if (this._eventsCount === 0)
        return names2;
      for (name in events = this._events) {
        if (has.call(events, name))
          names2.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names2.concat(Object.getOwnPropertySymbols(events));
      }
      return names2;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i4 = 0, l3 = handlers.length, ee = new Array(l3); i4 < l3; i4++) {
        ee[i4] = handlers[i4].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i4;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i4 = 0; i4 < length; i4++) {
          if (listeners[i4].once)
            this.removeListener(event, listeners[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i4].fn.call(listeners[i4].context);
              break;
            case 2:
              listeners[i4].fn.call(listeners[i4].context, a1);
              break;
            case 3:
              listeners[i4].fn.call(listeners[i4].context, a1, a22);
              break;
            case 4:
              listeners[i4].fn.call(listeners[i4].context, a1, a22, a3);
              break;
            default:
              if (!args)
                for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                  args[j2 - 1] = arguments[j2];
                }
              listeners[i4].fn.apply(listeners[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn5, context) {
      return addListener(this, event, fn5, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn5, context) {
      return addListener(this, event, fn5, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn5, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn5) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn5 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events = [], length = listeners.length; i4 < length; i4++) {
          if (listeners[i4].fn !== fn5 || once && !listeners[i4].once || context && listeners[i4].context !== context) {
            events.push(listeners[i4]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => InfographicPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// node_modules/@antv/infographic/esm/templates/registry.js
var TEMPLATE_REGISTRY = /* @__PURE__ */ new Map();
function registerTemplate(type2, template) {
  TEMPLATE_REGISTRY.set(type2, template);
}
function getTemplate(type2) {
  return TEMPLATE_REGISTRY.get(type2);
}

// node_modules/@antv/infographic/esm/templates/chart-pie.js
var chartPieTemplates = {
  "chart-pie-plain-text": {
    design: {
      title: "default",
      structure: {
        type: "chart-pie"
      },
      items: [
        {
          type: "plain-text"
        }
      ]
    }
  },
  "chart-pie-compact-card": {
    design: {
      title: "default",
      structure: {
        type: "chart-pie",
        avoidLabelOverlap: true
      },
      items: [
        {
          type: "compact-card"
        }
      ]
    }
  },
  "chart-pie-pill-badge": {
    design: {
      title: "default",
      structure: {
        type: "chart-pie",
        avoidLabelOverlap: true
      },
      items: [
        {
          type: "pill-badge"
        }
      ]
    }
  },
  "chart-pie-donut-plain-text": {
    design: {
      title: "default",
      structure: {
        type: "chart-pie",
        innerRadius: 90
      },
      items: [
        {
          type: "plain-text"
        }
      ]
    }
  },
  "chart-pie-donut-compact-card": {
    design: {
      title: "default",
      structure: {
        type: "chart-pie",
        innerRadius: 90,
        avoidLabelOverlap: true
      },
      items: [
        {
          type: "compact-card"
        }
      ]
    }
  },
  "chart-pie-donut-pill-badge": {
    design: {
      title: "default",
      structure: {
        type: "chart-pie",
        innerRadius: 90,
        avoidLabelOverlap: true
      },
      items: [
        {
          type: "pill-badge"
        }
      ]
    }
  }
};

// node_modules/@antv/infographic/esm/templates/compare-quadrant.js
var baseTemplates = {
  "compare-quadrant-quarter-simple-card": {
    design: {
      title: "default",
      structure: { type: "quadrant" },
      items: [{ type: "quarter-simple-card" }]
    }
  },
  "compare-quadrant-quarter-circular": {
    design: {
      title: "default",
      structure: { type: "quadrant" },
      items: [{ type: "quarter-circular" }]
    }
  },
  "compare-quadrant-simple-illus": {
    design: {
      title: "default",
      structure: { type: "quadrant" },
      items: [{ type: "simple-illus" }]
    }
  }
};
var warnedKeys = /* @__PURE__ */ new Set();
var wrappedTemplates = {};
Object.entries(baseTemplates).forEach(([key, template]) => {
  wrappedTemplates[key] = template;
  const oldKey = key.replace("compare-quadrant", "quadrant");
  wrappedTemplates[oldKey] = new Proxy(template, {
    get(target, prop, receiver) {
      if (!warnedKeys.has(oldKey)) {
        console.warn(`[Deprecated] "${oldKey}" \u5DF2\u88AB\u5E9F\u5F03\uFF0C\u5C06\u5728\u4E0B\u4E2A\u7248\u672C\u79FB\u9664\uFF0C\u8BF7\u4F7F\u7528 "${key}"`);
        warnedKeys.add(oldKey);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
});
var compareQuadrantTemplates = wrappedTemplates;

// node_modules/@antv/infographic/esm/templates/hierarchy-mindmap.js
var BRANCH_GRADIENT = {
  edgeType: "curved",
  edgeColorMode: "gradient",
  edgeWidth: 2,
  colorMode: "branch",
  levelGap: 80,
  nodeGap: 18
};
var LEVEL_GRADIENT = {
  edgeType: "curved",
  edgeWidth: 2,
  edgeColorMode: "gradient",
  colorMode: "level",
  levelGap: 80,
  nodeGap: 18
};
var LINED_PALETTE = {
  type: "lined-text",
  usePaletteColor: true,
  showUnderline: true,
  underlineThickness: 2
};
var CAPSULE = {
  type: "capsule-item"
};
var CIRCULAR_PROGRESS = {
  type: "circular-progress"
};
var ROUNDED_RECT_NODE = {
  type: "rounded-rect-node",
  positionH: "center"
};
var COMPACT_CARD = {
  type: "compact-card"
};
var createStructure = (gradient, edgeAlign) => Object.assign(Object.assign({ type: "hierarchy-mindmap" }, edgeAlign !== void 0 ? { edgeAlign } : {}), gradient);
var createTemplate = (key, gradient, item, edgeAlign) => [
  key,
  {
    design: {
      structure: createStructure(gradient, edgeAlign),
      item
    }
  }
];
var hierarchyMindmapTemplates = Object.fromEntries([
  createTemplate("hierarchy-mindmap-branch-gradient-lined-palette", BRANCH_GRADIENT, LINED_PALETTE, "bottom"),
  createTemplate("hierarchy-mindmap-level-gradient-lined-palette", LEVEL_GRADIENT, LINED_PALETTE, "bottom"),
  createTemplate("hierarchy-mindmap-branch-gradient-capsule-item", BRANCH_GRADIENT, CAPSULE),
  createTemplate("hierarchy-mindmap-level-gradient-capsule-item", LEVEL_GRADIENT, CAPSULE),
  createTemplate("hierarchy-mindmap-branch-gradient-circle-progress", BRANCH_GRADIENT, CIRCULAR_PROGRESS, 0.4),
  createTemplate("hierarchy-mindmap-level-gradient-circle-progress", LEVEL_GRADIENT, CIRCULAR_PROGRESS, 0.4),
  createTemplate("hierarchy-mindmap-branch-gradient-rounded-rect", BRANCH_GRADIENT, ROUNDED_RECT_NODE),
  createTemplate("hierarchy-mindmap-level-gradient-rounded-rect", LEVEL_GRADIENT, ROUNDED_RECT_NODE),
  createTemplate("hierarchy-mindmap-branch-gradient-compact-card", BRANCH_GRADIENT, COMPACT_CARD),
  createTemplate("hierarchy-mindmap-level-gradient-compact-card", LEVEL_GRADIENT, COMPACT_CARD)
]);

// node_modules/@antv/infographic/esm/templates/hierarchy-structure.js
var hierarchyStructureTemplates = {
  "hierarchy-structure": {
    design: {
      title: "default",
      structure: {
        type: "hierarchy-structure"
      },
      item: "simple"
    }
  },
  "hierarchy-structure-mirror": {
    design: {
      title: "default",
      structure: {
        type: "hierarchy-structure",
        layerLabelPosition: "right"
      },
      item: "simple"
    }
  }
};

// node_modules/@antv/infographic/esm/templates/hierarchy-tree.js
var structures = {
  "tech-style": {
    edgeType: "straight",
    edgeStyle: "solid",
    edgeColorMode: "gradient",
    edgeMarker: "arrow",
    markerSize: 12,
    edgeCornerRadius: 5
  },
  "dashed-line": {
    edgeStyle: "dashed",
    edgeCornerRadius: 10,
    edgeDashPattern: "10,5",
    edgeColorMode: "gradient",
    edgeMarker: "dot",
    markerSize: 6,
    edgeOffset: 6
  },
  "distributed-origin": {
    edgeOrigin: "distributed",
    edgeOriginPadding: 30,
    edgeMarker: "arrow",
    edgeCornerRadius: 10,
    markerSize: 12,
    edgeColorMode: "gradient"
  },
  "curved-line": {
    edgeType: "curved",
    edgeColorMode: "gradient",
    edgeMarker: "none"
  },
  "dashed-arrow": {
    edgeType: "straight",
    edgeStyle: "dashed",
    edgeDashPattern: "8,4",
    edgeMarker: "arrow",
    markerSize: 10,
    edgeCornerRadius: 0
  }
};
var items = [
  "capsule-item",
  "rounded-rect-node",
  "compact-card",
  "badge-card",
  "ribbon-card"
];
var hierarchyTreeTemplates = {};
var structureName = "hierarchy-tree";
var orientationConfigs = [
  { key: "" },
  { key: "bt", orientation: "bottom-top" },
  { key: "lr", orientation: "left-right" },
  { key: "rl", orientation: "right-left" }
];
var createTemplateName = (oriKey, name, item) => {
  return oriKey ? `${structureName}-${oriKey}-${name}-${item}` : `${structureName}-${name}-${item}`;
};
for (const item of items) {
  for (const [name, structureProps] of Object.entries(structures)) {
    for (const { key, orientation } of orientationConfigs) {
      const templateName = createTemplateName(key, name, item);
      hierarchyTreeTemplates[templateName] = {
        design: {
          structure: Object.assign(Object.assign({ type: "hierarchy-tree" }, orientation ? { orientation } : {}), structureProps),
          item: {
            type: item
          }
        }
      };
    }
  }
}

// node_modules/@antv/infographic/esm/templates/list-zigzag.js
var listZigzagTemplates = {
  "list-zigzag-up-compact-card": {
    design: {
      title: "default",
      structure: {
        type: "list-zigzag-up"
      },
      items: [
        {
          type: "compact-card"
        }
      ]
    },
    themeConfig: {
      colorPrimary: "#17CA2C"
    }
  },
  "list-zigzag-up-simple": {
    design: {
      title: "default",
      structure: {
        type: "list-zigzag-up"
      },
      items: [
        {
          type: "simple",
          usePaletteColor: true
        }
      ]
    },
    themeConfig: {
      colorPrimary: "#17CA2C"
    }
  },
  "list-zigzag-down-compact-card": {
    design: {
      title: "default",
      structure: {
        type: "list-zigzag-down"
      },
      items: [
        {
          type: "compact-card"
        }
      ]
    },
    themeConfig: {
      colorPrimary: "#17CA2C"
    }
  },
  "list-zigzag-down-simple": {
    design: {
      title: "default",
      structure: {
        type: "list-zigzag-down"
      },
      items: [
        {
          type: "simple",
          usePaletteColor: true
        }
      ]
    },
    themeConfig: {
      colorPrimary: "#17CA2C"
    }
  }
};

// node_modules/@antv/infographic/esm/templates/relation-dagre-flow.js
var items2 = {
  "simple-circle-node": {
    type: "simple-circle-node"
  },
  "badge-card": {
    type: "badge-card"
  },
  capsule: {
    type: "capsule-item"
  },
  "compact-card": {
    type: "compact-card"
  }
};
var baseStructureAttrs = {
  type: "relation-dagre-flow",
  edgeColorMode: "gradient",
  showArrow: true,
  arrowType: "triangle",
  colorMode: "node"
};
var structures2 = {
  tb: Object.assign(Object.assign({}, baseStructureAttrs), { rankdir: "TB", edgeRouting: "orth" }),
  lr: Object.assign(Object.assign({}, baseStructureAttrs), { rankdir: "LR", edgeRouting: "orth" }),
  "tb-animated": Object.assign(Object.assign({}, baseStructureAttrs), { rankdir: "TB", edgeCornerRadius: 12, edgeRouting: "orth", edgeAnimation: "ant-line", edgeDashPattern: "8,4", edgeAnimationSpeed: 1 }),
  "lr-animated": Object.assign(Object.assign({}, baseStructureAttrs), { rankdir: "LR", edgeCornerRadius: 12, edgeRouting: "orth", edgeAnimation: "ant-line", edgeDashPattern: "8,4", edgeAnimationSpeed: 1 })
};
var relationDagreFlowTemplates = {};
var omit = ["lr-capsule", "tb-capsule"];
Object.entries(structures2).forEach(([strKey, strAttrs]) => {
  Object.entries(items2).forEach(([itemKey, itemAttrs]) => {
    const appendix = `${strKey}-${itemKey}`;
    if (omit.includes(appendix))
      return;
    const templateKey = `relation-dagre-flow-${appendix}`;
    relationDagreFlowTemplates[templateKey] = {
      design: {
        title: "default",
        structure: strAttrs,
        item: itemAttrs
      }
    };
  });
});

// node_modules/@antv/infographic/esm/templates/sequence-stairs.js
var sequenceStairsTemplates = {
  "sequence-stairs-front-pill-badge": {
    design: {
      title: "default",
      structure: {
        type: "sequence-stairs-front"
      },
      items: [
        {
          type: "pill-badge"
        }
      ]
    }
  },
  "sequence-stairs-front-compact-card": {
    design: {
      title: "default",
      structure: {
        type: "sequence-stairs-front"
      },
      items: [
        {
          type: "compact-card"
        }
      ]
    }
  },
  "sequence-stairs-front-simple": {
    design: {
      title: "default",
      structure: {
        type: "sequence-stairs-front"
      },
      items: [
        {
          type: "simple",
          usePaletteColor: true
        }
      ]
    }
  }
};

// node_modules/@antv/infographic/esm/templates/word-cloud.js
var wordCloudTemplate = {
  "chart-wordcloud-rotate": {
    design: {
      structure: {
        type: "chart-wordcloud"
      },
      item: "simple"
    }
  },
  "chart-wordcloud": {
    design: {
      structure: {
        type: "chart-wordcloud",
        enableRotate: false
      },
      item: "simple"
    }
  }
};

// node_modules/@antv/infographic/esm/templates/built-in.js
var BUILT_IN_TEMPLATES = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ "compare-hierarchy-left-right-circle-node-pill-badge": {
  design: {
    structure: {
      type: "compare-hierarchy-left-right",
      decoration: "split-line",
      surround: false,
      groupGap: -20
    },
    title: "default",
    items: [{ type: "circle-node", width: 240 }, "pill-badge"]
  },
  themeConfig: {}
}, "compare-hierarchy-left-right-circle-node-plain-text": {
  design: {
    title: "default",
    structure: {
      type: "compare-hierarchy-left-right",
      decoration: "dot-line",
      flipLeaf: true,
      groupGap: -10
    },
    items: [{ type: "circle-node", width: 180 }, { type: "plain-text" }]
  }
}, "list-pyramid-rounded-rect-node": {
  design: {
    title: "default",
    structure: {
      type: "list-pyramid"
    },
    items: [{ type: "rounded-rect-node" }]
  }
}, "list-pyramid-badge-card": {
  design: {
    title: "default",
    structure: { type: "list-pyramid" },
    items: [{ type: "badge-card" }]
  }
}, "list-pyramid-compact-card": {
  design: {
    title: "default",
    structure: { type: "list-pyramid" },
    items: [{ type: "compact-card" }]
  }
}, "list-column-done-list": {
  design: {
    title: "default",
    structure: { type: "list-column" },
    items: [{ type: "done-list" }]
  }
}, "list-column-vertical-icon-arrow": {
  design: {
    title: "default",
    structure: { type: "list-column", gap: -5, zigzag: true },
    items: [{ type: "vertical-icon-arrow" }]
  }
}, "list-grid-badge-card": {
  design: {
    title: "default",
    structure: { type: "list-grid" },
    items: [{ type: "badge-card" }]
  }
}, "list-grid-candy-card-lite": {
  design: {
    title: "default",
    structure: { type: "list-grid" },
    items: [{ type: "candy-card-lite" }]
  }
}, "chart-column-simple": {
  design: {
    title: "default",
    structure: { type: "chart-column" },
    items: [{ type: "simple", showIcon: false, usePaletteColor: true }]
  }
}, "list-grid-circular-progress": {
  design: {
    title: "default",
    structure: { type: "list-grid" },
    items: [{ type: "circular-progress" }]
  }
}, "list-grid-compact-card": {
  design: {
    title: "default",
    structure: { type: "list-grid" },
    items: [{ type: "compact-card" }]
  }
}, "list-grid-done-list": {
  design: {
    title: "default",
    structure: { type: "list-grid" },
    items: [{ type: "done-list" }]
  }
}, "list-grid-horizontal-icon-arrow": {
  design: {
    title: "default",
    structure: { type: "list-grid", gap: 0, zigzag: true },
    items: [{ type: "horizontal-icon-arrow" }]
  }
}, "list-grid-progress-card": {
  design: {
    title: "default",
    structure: { type: "list-grid" },
    items: [{ type: "progress-card" }]
  }
}, "list-grid-ribbon-card": {
  design: {
    title: "default",
    structure: { type: "list-grid" },
    items: [{ type: "ribbon-card" }]
  }
}, "list-grid-simple": {
  design: {
    title: "default",
    structure: { type: "list-grid" },
    items: [{ type: "simple" }]
  }
}, "list-row-circular-progress": {
  design: {
    title: "default",
    structure: { type: "list-row" },
    items: [{ type: "circular-progress" }]
  }
}, "list-row-horizontal-icon-arrow": {
  design: {
    title: "default",
    structure: { type: "list-row", gap: 0, zigzag: true },
    items: [{ type: "horizontal-icon-arrow" }]
  }
}, "relation-circle-circular-progress": {
  design: {
    title: "default",
    structure: { type: "relation-circle" },
    items: [{ type: "circular-progress" }]
  }
}, "relation-circle-icon-badge": {
  design: {
    title: "default",
    structure: { type: "relation-circle" },
    items: [{ type: "icon-badge" }]
  }
}, "sequence-steps-badge-card": {
  design: {
    title: "default",
    structure: { type: "sequence-steps" },
    items: [{ type: "badge-card" }]
  }
}, "sequence-steps-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-steps", gap: 10 },
    items: [{ type: "simple" }]
  }
}, "sequence-timeline-done-list": {
  design: {
    title: "default",
    structure: { type: "sequence-timeline" },
    items: [{ type: "done-list" }]
  }
}, "sequence-timeline-plain-text": {
  design: {
    title: "default",
    structure: { type: "sequence-timeline" },
    items: [{ type: "plain-text" }]
  }
}, "sequence-timeline-rounded-rect-node": {
  design: {
    title: "default",
    structure: { type: "sequence-timeline" },
    items: [{ type: "rounded-rect-node" }]
  }
}, "sequence-ascending-steps": {
  design: {
    title: "default",
    structure: { type: "sequence-ascending-steps", vGap: -46, hGap: -20 },
    items: [{ type: "l-corner-card" }]
  }
}, "sequence-timeline-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-timeline", gap: 20 },
    items: [{ type: "simple", positionV: "middle" }]
  }
}, "sequence-cylinders-3d-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-cylinders-3d", gapY: 20 },
    items: [{ type: "simple", showIcon: false, usePaletteColor: true }]
  }
}, "list-column-simple-vertical-arrow": {
  design: {
    title: "default",
    structure: { type: "list-column", gap: 0, zigzag: true },
    items: [{ type: "simple-vertical-arrow" }]
  }
}, "list-row-simple-horizontal-arrow": {
  design: {
    title: "default",
    structure: { type: "list-row", gap: 0, zigzag: true },
    items: [{ type: "simple-horizontal-arrow" }]
  }
}, "compare-swot": {
  design: {
    title: "default",
    structure: {
      type: "compare-hierarchy-row",
      itemGap: 32,
      itemPadding: 40,
      showColumnBackground: true,
      columnBackgroundAlpha: 0.08
    },
    items: [
      { type: "letter-card", showBottomShade: false },
      {
        type: "plain-text",
        formatter: (text) => `\u25CF ${text}`,
        usePaletteColor: true
      }
    ]
  }
}, "compare-hierarchy-row-letter-card-compact-card": {
  design: {
    title: "default",
    structure: { type: "compare-hierarchy-row" },
    items: [{ type: "letter-card" }, { type: "compact-card" }]
  }
}, "compare-hierarchy-row-letter-card-rounded-rect-node": {
  design: {
    title: "default",
    structure: { type: "compare-hierarchy-row" },
    items: [{ type: "letter-card" }, { type: "rounded-rect-node" }]
  }
}, "sequence-snake-steps-compact-card": {
  design: {
    title: "default",
    structure: { type: "sequence-snake-steps" },
    items: [{ type: "compact-card" }]
  }
}, "sequence-snake-steps-pill-badge": {
  design: {
    title: "default",
    structure: { type: "sequence-snake-steps" },
    items: [{ type: "pill-badge" }]
  }
}, "sequence-snake-steps-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-snake-steps" },
    items: [{ type: "simple" }]
  }
}, "sequence-color-snake-steps-horizontal-icon-line": {
  design: {
    title: "default",
    structure: { type: "sequence-color-snake-steps" },
    items: [{ type: "horizontal-icon-line" }]
  }
}, "sequence-pyramid-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-pyramid" },
    items: [{ type: "simple", showIcon: false, usePaletteColor: true }]
  },
  themeConfig: {
    colorPrimary: "#1677ff"
  }
}, "sequence-funnel-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-funnel" },
    items: [{ type: "simple", showIcon: false, usePaletteColor: true }]
  },
  themeConfig: {
    palette: "#1677ff"
  }
}, "list-row-horizontal-icon-line": {
  design: {
    title: "default",
    structure: { type: "list-row", gap: 0, zigzag: true },
    items: [{ type: "horizontal-icon-line" }]
  }
}, "list-sector-simple": {
  design: {
    title: "default",
    structure: { type: "list-sector" },
    items: [{ type: "simple" }]
  }
}, "list-sector-plain-text": {
  design: {
    title: "default",
    structure: { type: "list-sector" },
    items: [{ type: "plain-text" }]
  }
}, "list-sector-half-plain-text": {
  design: {
    title: "default",
    structure: { type: "list-sector", startAngle: -180, endAngle: 0 },
    items: [{ type: "plain-text" }]
  }
}, "sequence-roadmap-vertical-plain-text": {
  design: {
    title: "default",
    structure: { type: "sequence-roadmap-vertical" },
    items: [{ type: "plain-text" }]
  }
}, "sequence-roadmap-vertical-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-roadmap-vertical" },
    items: [{ type: "simple", showIcon: false }]
  }
}, "sequence-roadmap-vertical-badge-card": {
  design: {
    title: "default",
    structure: { type: "sequence-roadmap-vertical" },
    items: [{ type: "badge-card" }]
  }
}, "sequence-roadmap-vertical-pill-badge": {
  design: {
    title: "default",
    structure: { type: "sequence-roadmap-vertical" },
    items: [{ type: "pill-badge" }]
  }
}, "sequence-roadmap-vertical-quarter-circular": {
  design: {
    title: "default",
    structure: { type: "sequence-roadmap-vertical" },
    items: [{ type: "quarter-circular" }]
  }
}, "sequence-roadmap-vertical-quarter-simple-card": {
  design: {
    title: "default",
    structure: { type: "sequence-roadmap-vertical", flipped: true },
    items: [{ type: "quarter-simple-card" }]
  }
}, "sequence-horizontal-zigzag-simple-illus": {
  design: {
    title: "default",
    structure: { type: "sequence-horizontal-zigzag" },
    items: [{ type: "simple-illus" }]
  }
}, "sequence-horizontal-zigzag-horizontal-icon-line": {
  design: {
    title: "default",
    structure: { type: "sequence-horizontal-zigzag" },
    items: [{ type: "horizontal-icon-line" }]
  }
}, "sequence-horizontal-zigzag-plain-text": {
  design: {
    title: "default",
    structure: { type: "sequence-horizontal-zigzag" },
    items: [{ type: "plain-text" }]
  }
}, "sequence-horizontal-zigzag-simple-horizontal-arrow": {
  design: {
    title: "default",
    structure: { type: "sequence-horizontal-zigzag" },
    items: [{ type: "simple-horizontal-arrow" }]
  }
}, "sequence-horizontal-zigzag-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-horizontal-zigzag" },
    items: [{ type: "simple" }]
  }
}, "list-row-simple-illus": {
  design: {
    title: "default",
    structure: { type: "list-row" },
    items: [{ type: "simple-illus" }]
  }
}, "sequence-color-snake-steps-simple-illus": {
  design: {
    title: "default",
    structure: { type: "sequence-color-snake-steps" },
    items: [{ type: "simple-illus" }]
  }
}, "sequence-snake-steps-simple-illus": {
  design: {
    title: "default",
    structure: { type: "sequence-snake-steps" },
    items: [{ type: "simple-illus" }]
  }
}, "sequence-steps-simple-illus": {
  design: {
    title: "default",
    structure: { type: "sequence-steps" },
    items: [{ type: "simple-illus" }]
  }
}, "sequence-timeline-simple-illus": {
  design: {
    title: "default",
    structure: { type: "sequence-timeline" },
    items: [{ type: "simple-illus", usePaletteColor: true }]
  }
}, "sequence-zigzag-steps-underline-text": {
  design: {
    title: "default",
    structure: { type: "sequence-zigzag-steps" },
    items: [{ type: "underline-text" }]
  }
}, "sequence-horizontal-zigzag-underline-text": {
  design: {
    title: "default",
    structure: { type: "sequence-horizontal-zigzag" },
    items: [{ type: "underline-text" }]
  }
}, "sequence-roadmap-vertical-underline-text": {
  design: {
    title: "default",
    structure: { type: "sequence-roadmap-vertical" },
    items: [{ type: "underline-text" }]
  }
}, "sequence-snake-steps-underline-text": {
  design: {
    title: "default",
    structure: { type: "sequence-snake-steps" },
    items: [{ type: "underline-text" }]
  }
}, "sequence-circle-arrows-indexed-card": {
  design: {
    title: "default",
    structure: { type: "sequence-circle-arrows" },
    items: [{ type: "indexed-card" }]
  }
}, "sequence-zigzag-pucks-3d-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-zigzag-pucks-3d" },
    items: [{ type: "simple", showIcon: false, usePaletteColor: true }]
  }
}, "sequence-zigzag-pucks-3d-underline-text": {
  design: {
    title: "default",
    structure: { type: "sequence-zigzag-pucks-3d" },
    items: [{ type: "underline-text" }]
  }
}, "sequence-zigzag-pucks-3d-indexed-card": {
  design: {
    title: "default",
    structure: { type: "sequence-zigzag-pucks-3d" },
    items: [{ type: "indexed-card" }]
  }
}, "sequence-ascending-stairs-3d-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-ascending-stairs-3d" },
    items: [{ type: "simple", showIcon: false, usePaletteColor: true }]
  }
}, "sequence-ascending-stairs-3d-underline-text": {
  design: {
    title: "default",
    structure: { type: "sequence-ascending-stairs-3d" },
    items: [{ type: "underline-text" }]
  }
}, "sequence-circular-underline-text": {
  design: {
    title: "default",
    structure: { type: "sequence-circular" },
    items: [{ type: "underline-text" }]
  }
}, "sequence-circular-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-circular" },
    items: [{ type: "simple", showIcon: false, usePaletteColor: true }]
  }
}, "sequence-filter-mesh-underline-text": {
  design: {
    title: "default",
    structure: { type: "sequence-filter-mesh" },
    items: [{ type: "underline-text" }]
  }
}, "sequence-filter-mesh-simple": {
  design: {
    title: "default",
    structure: { type: "sequence-filter-mesh" },
    items: [{ type: "simple", showIcon: false, usePaletteColor: true }]
  }
}, "sequence-mountain-underline-text": {
  design: {
    title: "default",
    structure: { type: "sequence-mountain" },
    items: [{ type: "underline-text" }]
  }
}, "compare-binary-horizontal-simple-fold": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "pros-cons-fold"
    },
    items: [{ type: "simple", iconType: "circle", iconSize: 40 }]
  }
}, "compare-binary-horizontal-underline-text-fold": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "pros-cons-fold"
    },
    items: [{ type: "underline-text" }]
  }
}, "compare-binary-horizontal-badge-card-fold": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "pros-cons-fold"
    },
    items: [{ type: "badge-card" }]
  }
}, "compare-binary-horizontal-compact-card-fold": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "pros-cons-fold"
    },
    items: [{ type: "compact-card" }]
  }
}, "compare-binary-horizontal-simple-arrow": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "pros-cons-arrow"
    },
    items: [{ type: "simple", iconType: "circle", iconSize: 40 }]
  }
}, "compare-binary-horizontal-underline-text-arrow": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "pros-cons-arrow"
    },
    items: [{ type: "underline-text" }]
  }
}, "compare-binary-horizontal-badge-card-arrow": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "pros-cons-arrow"
    },
    items: [{ type: "badge-card" }]
  }
}, "compare-binary-horizontal-compact-card-arrow": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "pros-cons-arrow"
    },
    items: [{ type: "compact-card" }]
  }
}, "compare-binary-horizontal-simple-vs": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "vs"
    },
    items: [{ type: "simple", iconType: "circle", iconSize: 40 }]
  }
}, "compare-binary-horizontal-underline-text-vs": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "vs"
    },
    items: [{ type: "underline-text" }]
  }
}, "compare-binary-horizontal-badge-card-vs": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "vs"
    },
    items: [{ type: "badge-card" }]
  }
}, "compare-binary-horizontal-compact-card-vs": {
  design: {
    title: "default",
    structure: {
      type: "compare-binary-horizontal",
      dividerType: "vs"
    },
    items: [{ type: "compact-card" }]
  }
}, "chart-bar-plain-text": {
  design: {
    title: "default",
    structure: {
      type: "chart-bar"
    },
    items: [
      {
        type: "plain-text",
        positionH: "flipped"
      }
    ]
  }
}, "chart-line-plain-text": {
  design: {
    title: "default",
    structure: {
      type: "chart-line"
    },
    items: [
      {
        type: "plain-text",
        lineNumber: 2
      }
    ]
  }
} }, chartPieTemplates), compareQuadrantTemplates), hierarchyTreeTemplates), hierarchyMindmapTemplates), sequenceStairsTemplates), wordCloudTemplate), listZigzagTemplates), relationDagreFlowTemplates), hierarchyStructureTemplates);
Object.entries(BUILT_IN_TEMPLATES).forEach(([name, options]) => {
  registerTemplate(name, options);
});

// node_modules/@antv/infographic/esm/jsx/jsx-runtime.js
var Fragment = Symbol.for("@antv/infographic/Fragment");
function jsx(type2, props = {}) {
  return { type: type2, props };
}
var jsxs = jsx;

// node_modules/@antv/infographic/esm/jsx/components/Defs.js
var DefsSymbol = Symbol.for("@antv/infographic/Defs");
function Defs(props) {
  const node = {
    type: DefsSymbol,
    props
  };
  return node;
}

// node_modules/@antv/infographic/esm/jsx/components/Ellipse.js
function Ellipse(props) {
  var _a, _b, _c, _d;
  const { x: x6 = 0, y: y6 = 0, width = 0, height = 0 } = props;
  (_a = props.cx) !== null && _a !== void 0 ? _a : props.cx = x6 + width / 2;
  (_b = props.cy) !== null && _b !== void 0 ? _b : props.cy = y6 + height / 2;
  (_c = props.rx) !== null && _c !== void 0 ? _c : props.rx = width / 2;
  (_d = props.ry) !== null && _d !== void 0 ? _d : props.ry = height / 2;
  const node = {
    type: "ellipse",
    props
  };
  return node;
}

// node_modules/@antv/infographic/esm/jsx/components/Group.js
function Group(props) {
  const { x: x6 = 0, y: y6 = 0 } = props;
  if (x6 || y6) {
    props.transform || (props.transform = `translate(${x6}, ${y6})`);
  }
  const node = {
    type: "g",
    props
  };
  return node;
}

// node_modules/@antv/infographic/esm/jsx/components/Path.js
function Path(props) {
  const { x: x6, y: y6 } = props;
  const finalProps = Object.assign({}, props);
  if (x6 !== void 0 || y6 !== void 0) {
    finalProps.transform = `translate(${x6 !== null && x6 !== void 0 ? x6 : 0}, ${y6 !== null && y6 !== void 0 ? y6 : 0})`;
  }
  const node = {
    type: "path",
    props: finalProps
  };
  return node;
}

// node_modules/@antv/infographic/esm/jsx/components/Polygon.js
var __rest = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
function Polygon(_a) {
  var { points = [] } = _a, props = __rest(_a, ["points"]);
  const { x: x6, y: y6 } = props;
  const pointsStr = points.map(({ x: x7, y: y7 }) => `${x7},${y7}`).join(" ");
  const finalProps = Object.assign(Object.assign({}, props), { points: pointsStr });
  if (x6 !== void 0 || y6 !== void 0) {
    finalProps.transform = `translate(${x6 !== null && x6 !== void 0 ? x6 : 0}, ${y6 !== null && y6 !== void 0 ? y6 : 0})` + (finalProps.transform || "");
  }
  const node = {
    type: "polygon",
    props: finalProps
  };
  return node;
}

// node_modules/@antv/infographic/esm/jsx/components/Rect.js
function Rect(props) {
  const node = {
    type: "rect",
    props
  };
  return node;
}

// node_modules/@antv/infographic/esm/utils/attrs.js
function getCommonAttrs(attrs) {
  return Object.keys(attrs[0]).reduce((acc, key) => {
    const k5 = key;
    if (attrs.every((attr) => attr[k5] === attrs[0][k5])) {
      acc[k5] = attrs[0][k5];
    }
    return acc;
  }, {});
}

// node_modules/culori/src/rgb/parseNumber.js
var parseNumber = (color3, len) => {
  if (typeof color3 !== "number")
    return;
  if (len === 3) {
    return {
      mode: "rgb",
      r: (color3 >> 8 & 15 | color3 >> 4 & 240) / 255,
      g: (color3 >> 4 & 15 | color3 & 240) / 255,
      b: (color3 & 15 | color3 << 4 & 240) / 255
    };
  }
  if (len === 4) {
    return {
      mode: "rgb",
      r: (color3 >> 12 & 15 | color3 >> 8 & 240) / 255,
      g: (color3 >> 8 & 15 | color3 >> 4 & 240) / 255,
      b: (color3 >> 4 & 15 | color3 & 240) / 255,
      alpha: (color3 & 15 | color3 << 4 & 240) / 255
    };
  }
  if (len === 6) {
    return {
      mode: "rgb",
      r: (color3 >> 16 & 255) / 255,
      g: (color3 >> 8 & 255) / 255,
      b: (color3 & 255) / 255
    };
  }
  if (len === 8) {
    return {
      mode: "rgb",
      r: (color3 >> 24 & 255) / 255,
      g: (color3 >> 16 & 255) / 255,
      b: (color3 >> 8 & 255) / 255,
      alpha: (color3 & 255) / 255
    };
  }
};
var parseNumber_default = parseNumber;

// node_modules/culori/src/colors/named.js
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  // Added in CSS Colors Level 4:
  // https://drafts.csswg.org/css-color/#changes-from-3
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
var named_default = named;

// node_modules/culori/src/rgb/parseNamed.js
var parseNamed = (color3) => {
  return parseNumber_default(named_default[color3.toLowerCase()], 6);
};
var parseNamed_default = parseNamed;

// node_modules/culori/src/rgb/parseHex.js
var hex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
var parseHex = (color3) => {
  let match;
  return (match = color3.match(hex)) ? parseNumber_default(parseInt(match[1], 16), match[1].length) : void 0;
};
var parseHex_default = parseHex;

// node_modules/culori/src/util/regex.js
var num = "([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)";
var num_none = `(?:${num}|none)`;
var per = `${num}%`;
var per_none = `(?:${num}%|none)`;
var num_per = `(?:${num}%|${num})`;
var num_per_none = `(?:${num}%|${num}|none)`;
var hue = `(?:${num}(deg|grad|rad|turn)|${num})`;
var hue_none = `(?:${num}(deg|grad|rad|turn)|${num}|none)`;
var c = `\\s*,\\s*`;
var rx_num_per_none = new RegExp("^" + num_per_none + "$");

// node_modules/culori/src/rgb/parseRgbLegacy.js
var rgb_num_old = new RegExp(
  `^rgba?\\(\\s*${num}${c}${num}${c}${num}\\s*(?:,\\s*${num_per}\\s*)?\\)$`
);
var rgb_per_old = new RegExp(
  `^rgba?\\(\\s*${per}${c}${per}${c}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`
);
var parseRgbLegacy = (color3) => {
  let res = { mode: "rgb" };
  let match;
  if (match = color3.match(rgb_num_old)) {
    if (match[1] !== void 0) {
      res.r = match[1] / 255;
    }
    if (match[2] !== void 0) {
      res.g = match[2] / 255;
    }
    if (match[3] !== void 0) {
      res.b = match[3] / 255;
    }
  } else if (match = color3.match(rgb_per_old)) {
    if (match[1] !== void 0) {
      res.r = match[1] / 100;
    }
    if (match[2] !== void 0) {
      res.g = match[2] / 100;
    }
    if (match[3] !== void 0) {
      res.b = match[3] / 100;
    }
  } else {
    return void 0;
  }
  if (match[4] !== void 0) {
    res.alpha = Math.max(0, Math.min(1, match[4] / 100));
  } else if (match[5] !== void 0) {
    res.alpha = Math.max(0, Math.min(1, +match[5]));
  }
  return res;
};
var parseRgbLegacy_default = parseRgbLegacy;

// node_modules/culori/src/_prepare.js
var prepare = (color3, mode) => color3 === void 0 ? void 0 : typeof color3 !== "object" ? parse_default(color3) : color3.mode !== void 0 ? color3 : mode ? { ...color3, mode } : void 0;
var prepare_default = prepare;

// node_modules/culori/src/converter.js
var converter = (target_mode = "rgb") => (color3) => (color3 = prepare_default(color3, target_mode)) !== void 0 ? (
  // if the color's mode corresponds to our target mode
  color3.mode === target_mode ? (
    // then just return the color
    color3
  ) : (
    // otherwise check to see if we have a dedicated
    // converter for the target mode
    converters[color3.mode][target_mode] ? (
      // and return its result...
      converters[color3.mode][target_mode](color3)
    ) : (
      // ...otherwise pass through RGB as an intermediary step.
      // if the target mode is RGB...
      target_mode === "rgb" ? (
        // just return the RGB
        converters[color3.mode].rgb(color3)
      ) : (
        // otherwise convert color.mode -> RGB -> target_mode
        converters.rgb[target_mode](converters[color3.mode].rgb(color3))
      )
    )
  )
) : void 0;
var converter_default = converter;

// node_modules/culori/src/modes.js
var converters = {};
var modes = {};
var parsers = [];
var colorProfiles = {};
var identity = (v2) => v2;
var useMode = (definition29) => {
  converters[definition29.mode] = {
    ...converters[definition29.mode],
    ...definition29.toMode
  };
  Object.keys(definition29.fromMode || {}).forEach((k5) => {
    if (!converters[k5]) {
      converters[k5] = {};
    }
    converters[k5][definition29.mode] = definition29.fromMode[k5];
  });
  if (!definition29.ranges) {
    definition29.ranges = {};
  }
  if (!definition29.difference) {
    definition29.difference = {};
  }
  definition29.channels.forEach((channel) => {
    if (definition29.ranges[channel] === void 0) {
      definition29.ranges[channel] = [0, 1];
    }
    if (!definition29.interpolate[channel]) {
      throw new Error(`Missing interpolator for: ${channel}`);
    }
    if (typeof definition29.interpolate[channel] === "function") {
      definition29.interpolate[channel] = {
        use: definition29.interpolate[channel]
      };
    }
    if (!definition29.interpolate[channel].fixup) {
      definition29.interpolate[channel].fixup = identity;
    }
  });
  modes[definition29.mode] = definition29;
  (definition29.parse || []).forEach((parser) => {
    useParser(parser, definition29.mode);
  });
  return converter_default(definition29.mode);
};
var getMode = (mode) => modes[mode];
var useParser = (parser, mode) => {
  if (typeof parser === "string") {
    if (!mode) {
      throw new Error(`'mode' required when 'parser' is a string`);
    }
    colorProfiles[parser] = mode;
  } else if (typeof parser === "function") {
    if (parsers.indexOf(parser) < 0) {
      parsers.push(parser);
    }
  }
};

// node_modules/culori/src/parse.js
var IdentStartCodePoint = /[^\x00-\x7F]|[a-zA-Z_]/;
var IdentCodePoint = /[^\x00-\x7F]|[-\w]/;
var Tok = {
  Function: "function",
  Ident: "ident",
  Number: "number",
  Percentage: "percentage",
  ParenClose: ")",
  None: "none",
  Hue: "hue",
  Alpha: "alpha"
};
var _i = 0;
function is_num(chars) {
  let ch = chars[_i];
  let ch1 = chars[_i + 1];
  if (ch === "-" || ch === "+") {
    return /\d/.test(ch1) || ch1 === "." && /\d/.test(chars[_i + 2]);
  }
  if (ch === ".") {
    return /\d/.test(ch1);
  }
  return /\d/.test(ch);
}
function is_ident(chars) {
  if (_i >= chars.length) {
    return false;
  }
  let ch = chars[_i];
  if (IdentStartCodePoint.test(ch)) {
    return true;
  }
  if (ch === "-") {
    if (chars.length - _i < 2) {
      return false;
    }
    let ch1 = chars[_i + 1];
    if (ch1 === "-" || IdentStartCodePoint.test(ch1)) {
      return true;
    }
    return false;
  }
  return false;
}
var huenits = {
  deg: 1,
  rad: 180 / Math.PI,
  grad: 9 / 10,
  turn: 360
};
function num2(chars) {
  let value = "";
  if (chars[_i] === "-" || chars[_i] === "+") {
    value += chars[_i++];
  }
  value += digits(chars);
  if (chars[_i] === "." && /\d/.test(chars[_i + 1])) {
    value += chars[_i++] + digits(chars);
  }
  if (chars[_i] === "e" || chars[_i] === "E") {
    if ((chars[_i + 1] === "-" || chars[_i + 1] === "+") && /\d/.test(chars[_i + 2])) {
      value += chars[_i++] + chars[_i++] + digits(chars);
    } else if (/\d/.test(chars[_i + 1])) {
      value += chars[_i++] + digits(chars);
    }
  }
  if (is_ident(chars)) {
    let id2 = ident(chars);
    if (id2 === "deg" || id2 === "rad" || id2 === "turn" || id2 === "grad") {
      return { type: Tok.Hue, value: value * huenits[id2] };
    }
    return void 0;
  }
  if (chars[_i] === "%") {
    _i++;
    return { type: Tok.Percentage, value: +value };
  }
  return { type: Tok.Number, value: +value };
}
function digits(chars) {
  let v2 = "";
  while (/\d/.test(chars[_i])) {
    v2 += chars[_i++];
  }
  return v2;
}
function ident(chars) {
  let v2 = "";
  while (_i < chars.length && IdentCodePoint.test(chars[_i])) {
    v2 += chars[_i++];
  }
  return v2;
}
function identlike(chars) {
  let v2 = ident(chars);
  if (chars[_i] === "(") {
    _i++;
    return { type: Tok.Function, value: v2 };
  }
  if (v2 === "none") {
    return { type: Tok.None, value: void 0 };
  }
  return { type: Tok.Ident, value: v2 };
}
function tokenize(str = "") {
  let chars = str.trim();
  let tokens = [];
  let ch;
  _i = 0;
  while (_i < chars.length) {
    ch = chars[_i++];
    if (ch === "\n" || ch === "	" || ch === " ") {
      while (_i < chars.length && (chars[_i] === "\n" || chars[_i] === "	" || chars[_i] === " ")) {
        _i++;
      }
      continue;
    }
    if (ch === ",") {
      return void 0;
    }
    if (ch === ")") {
      tokens.push({ type: Tok.ParenClose });
      continue;
    }
    if (ch === "+") {
      _i--;
      if (is_num(chars)) {
        tokens.push(num2(chars));
        continue;
      }
      return void 0;
    }
    if (ch === "-") {
      _i--;
      if (is_num(chars)) {
        tokens.push(num2(chars));
        continue;
      }
      if (is_ident(chars)) {
        tokens.push({ type: Tok.Ident, value: ident(chars) });
        continue;
      }
      return void 0;
    }
    if (ch === ".") {
      _i--;
      if (is_num(chars)) {
        tokens.push(num2(chars));
        continue;
      }
      return void 0;
    }
    if (ch === "/") {
      while (_i < chars.length && (chars[_i] === "\n" || chars[_i] === "	" || chars[_i] === " ")) {
        _i++;
      }
      let alpha;
      if (is_num(chars)) {
        alpha = num2(chars);
        if (alpha.type !== Tok.Hue) {
          tokens.push({ type: Tok.Alpha, value: alpha });
          continue;
        }
      }
      if (is_ident(chars)) {
        if (ident(chars) === "none") {
          tokens.push({
            type: Tok.Alpha,
            value: { type: Tok.None, value: void 0 }
          });
          continue;
        }
      }
      return void 0;
    }
    if (/\d/.test(ch)) {
      _i--;
      tokens.push(num2(chars));
      continue;
    }
    if (IdentStartCodePoint.test(ch)) {
      _i--;
      tokens.push(identlike(chars));
      continue;
    }
    return void 0;
  }
  return tokens;
}
function parseColorSyntax(tokens) {
  tokens._i = 0;
  let token = tokens[tokens._i++];
  if (!token || token.type !== Tok.Function || token.value !== "color") {
    return void 0;
  }
  token = tokens[tokens._i++];
  if (token.type !== Tok.Ident) {
    return void 0;
  }
  const mode = colorProfiles[token.value];
  if (!mode) {
    return void 0;
  }
  const res = { mode };
  const coords = consumeCoords(tokens, false);
  if (!coords) {
    return void 0;
  }
  const channels = getMode(mode).channels;
  for (let ii = 0, c4, ch; ii < channels.length; ii++) {
    c4 = coords[ii];
    ch = channels[ii];
    if (c4.type !== Tok.None) {
      res[ch] = c4.type === Tok.Number ? c4.value : c4.value / 100;
      if (ch === "alpha") {
        res[ch] = Math.max(0, Math.min(1, res[ch]));
      }
    }
  }
  return res;
}
function consumeCoords(tokens, includeHue) {
  const coords = [];
  let token;
  while (tokens._i < tokens.length) {
    token = tokens[tokens._i++];
    if (token.type === Tok.None || token.type === Tok.Number || token.type === Tok.Alpha || token.type === Tok.Percentage || includeHue && token.type === Tok.Hue) {
      coords.push(token);
      continue;
    }
    if (token.type === Tok.ParenClose) {
      if (tokens._i < tokens.length) {
        return void 0;
      }
      continue;
    }
    return void 0;
  }
  if (coords.length < 3 || coords.length > 4) {
    return void 0;
  }
  if (coords.length === 4) {
    if (coords[3].type !== Tok.Alpha) {
      return void 0;
    }
    coords[3] = coords[3].value;
  }
  if (coords.length === 3) {
    coords.push({ type: Tok.None, value: void 0 });
  }
  return coords.every((c4) => c4.type !== Tok.Alpha) ? coords : void 0;
}
function parseModernSyntax(tokens, includeHue) {
  tokens._i = 0;
  let token = tokens[tokens._i++];
  if (!token || token.type !== Tok.Function) {
    return void 0;
  }
  let coords = consumeCoords(tokens, includeHue);
  if (!coords) {
    return void 0;
  }
  coords.unshift(token.value);
  return coords;
}
var parse = (color3) => {
  if (typeof color3 !== "string") {
    return void 0;
  }
  const tokens = tokenize(color3);
  const parsed = tokens ? parseModernSyntax(tokens, true) : void 0;
  let result = void 0;
  let i4 = 0;
  let len = parsers.length;
  while (i4 < len) {
    if ((result = parsers[i4++](color3, parsed)) !== void 0) {
      return result;
    }
  }
  return tokens ? parseColorSyntax(tokens) : void 0;
};
var parse_default = parse;

// node_modules/culori/src/rgb/parseRgb.js
function parseRgb(color3, parsed) {
  if (!parsed || parsed[0] !== "rgb" && parsed[0] !== "rgba") {
    return void 0;
  }
  const res = { mode: "rgb" };
  const [, r5, g3, b2, alpha] = parsed;
  if (r5.type === Tok.Hue || g3.type === Tok.Hue || b2.type === Tok.Hue) {
    return void 0;
  }
  if (r5.type !== Tok.None) {
    res.r = r5.type === Tok.Number ? r5.value / 255 : r5.value / 100;
  }
  if (g3.type !== Tok.None) {
    res.g = g3.type === Tok.Number ? g3.value / 255 : g3.value / 100;
  }
  if (b2.type !== Tok.None) {
    res.b = b2.type === Tok.Number ? b2.value / 255 : b2.value / 100;
  }
  if (alpha.type !== Tok.None) {
    res.alpha = Math.min(
      1,
      Math.max(
        0,
        alpha.type === Tok.Number ? alpha.value : alpha.value / 100
      )
    );
  }
  return res;
}
var parseRgb_default = parseRgb;

// node_modules/culori/src/rgb/parseTransparent.js
var parseTransparent = (c4) => c4 === "transparent" ? { mode: "rgb", r: 0, g: 0, b: 0, alpha: 0 } : void 0;
var parseTransparent_default = parseTransparent;

// node_modules/culori/src/interpolate/lerp.js
var lerp = (a3, b2, t2) => a3 + t2 * (b2 - a3);

// node_modules/culori/src/interpolate/piecewise.js
var get_classes = (arr) => {
  let classes = [];
  for (let i4 = 0; i4 < arr.length - 1; i4++) {
    let a3 = arr[i4];
    let b2 = arr[i4 + 1];
    if (a3 === void 0 && b2 === void 0) {
      classes.push(void 0);
    } else if (a3 !== void 0 && b2 !== void 0) {
      classes.push([a3, b2]);
    } else {
      classes.push(a3 !== void 0 ? [a3, a3] : [b2, b2]);
    }
  }
  return classes;
};
var interpolatorPiecewise = (interpolator) => (arr) => {
  let classes = get_classes(arr);
  return (t2) => {
    let cls = t2 * classes.length;
    let idx = t2 >= 1 ? classes.length - 1 : Math.max(Math.floor(cls), 0);
    let pair = classes[idx];
    return pair === void 0 ? void 0 : interpolator(pair[0], pair[1], cls - idx);
  };
};

// node_modules/culori/src/interpolate/linear.js
var interpolatorLinear = interpolatorPiecewise(lerp);

// node_modules/culori/src/fixup/alpha.js
var fixupAlpha = (arr) => {
  let some_defined = false;
  let res = arr.map((v2) => {
    if (v2 !== void 0) {
      some_defined = true;
      return v2;
    }
    return 1;
  });
  return some_defined ? res : arr;
};

// node_modules/culori/src/rgb/definition.js
var definition = {
  mode: "rgb",
  channels: ["r", "g", "b", "alpha"],
  parse: [
    parseRgb_default,
    parseHex_default,
    parseRgbLegacy_default,
    parseNamed_default,
    parseTransparent_default,
    "srgb"
  ],
  serialize: "srgb",
  interpolate: {
    r: interpolatorLinear,
    g: interpolatorLinear,
    b: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  gamut: true,
  white: { r: 1, g: 1, b: 1 },
  black: { r: 0, g: 0, b: 0 }
};
var definition_default = definition;

// node_modules/culori/src/a98/convertA98ToXyz65.js
var linearize = (v2 = 0) => Math.pow(Math.abs(v2), 563 / 256) * Math.sign(v2);
var convertA98ToXyz65 = (a982) => {
  let r5 = linearize(a982.r);
  let g3 = linearize(a982.g);
  let b2 = linearize(a982.b);
  let res = {
    mode: "xyz65",
    x: 0.5766690429101305 * r5 + 0.1855582379065463 * g3 + 0.1882286462349947 * b2,
    y: 0.297344975250536 * r5 + 0.6273635662554661 * g3 + 0.0752914584939979 * b2,
    z: 0.0270313613864123 * r5 + 0.0706888525358272 * g3 + 0.9913375368376386 * b2
  };
  if (a982.alpha !== void 0) {
    res.alpha = a982.alpha;
  }
  return res;
};
var convertA98ToXyz65_default = convertA98ToXyz65;

// node_modules/culori/src/a98/convertXyz65ToA98.js
var gamma = (v2) => Math.pow(Math.abs(v2), 256 / 563) * Math.sign(v2);
var convertXyz65ToA98 = ({ x: x6, y: y6, z: z2, alpha }) => {
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (z2 === void 0)
    z2 = 0;
  let res = {
    mode: "a98",
    r: gamma(
      x6 * 2.0415879038107465 - y6 * 0.5650069742788597 - 0.3447313507783297 * z2
    ),
    g: gamma(
      x6 * -0.9692436362808798 + y6 * 1.8759675015077206 + 0.0415550574071756 * z2
    ),
    b: gamma(
      x6 * 0.0134442806320312 - y6 * 0.1183623922310184 + 1.0151749943912058 * z2
    )
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz65ToA98_default = convertXyz65ToA98;

// node_modules/culori/src/lrgb/convertRgbToLrgb.js
var fn = (c4 = 0) => {
  const abs4 = Math.abs(c4);
  if (abs4 <= 0.04045) {
    return c4 / 12.92;
  }
  return (Math.sign(c4) || 1) * Math.pow((abs4 + 0.055) / 1.055, 2.4);
};
var convertRgbToLrgb = ({ r: r5, g: g3, b: b2, alpha }) => {
  let res = {
    mode: "lrgb",
    r: fn(r5),
    g: fn(g3),
    b: fn(b2)
  };
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertRgbToLrgb_default = convertRgbToLrgb;

// node_modules/culori/src/xyz65/convertRgbToXyz65.js
var convertRgbToXyz65 = (rgb4) => {
  let { r: r5, g: g3, b: b2, alpha } = convertRgbToLrgb_default(rgb4);
  let res = {
    mode: "xyz65",
    x: 0.4123907992659593 * r5 + 0.357584339383878 * g3 + 0.1804807884018343 * b2,
    y: 0.2126390058715102 * r5 + 0.715168678767756 * g3 + 0.0721923153607337 * b2,
    z: 0.0193308187155918 * r5 + 0.119194779794626 * g3 + 0.9505321522496607 * b2
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertRgbToXyz65_default = convertRgbToXyz65;

// node_modules/culori/src/lrgb/convertLrgbToRgb.js
var fn2 = (c4 = 0) => {
  const abs4 = Math.abs(c4);
  if (abs4 > 31308e-7) {
    return (Math.sign(c4) || 1) * (1.055 * Math.pow(abs4, 1 / 2.4) - 0.055);
  }
  return c4 * 12.92;
};
var convertLrgbToRgb = ({ r: r5, g: g3, b: b2, alpha }, mode = "rgb") => {
  let res = {
    mode,
    r: fn2(r5),
    g: fn2(g3),
    b: fn2(b2)
  };
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertLrgbToRgb_default = convertLrgbToRgb;

// node_modules/culori/src/xyz65/convertXyz65ToRgb.js
var convertXyz65ToRgb = ({ x: x6, y: y6, z: z2, alpha }) => {
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (z2 === void 0)
    z2 = 0;
  let res = convertLrgbToRgb_default({
    r: x6 * 3.2409699419045226 - y6 * 1.537383177570094 - 0.4986107602930034 * z2,
    g: x6 * -0.9692436362808796 + y6 * 1.8759675015077204 + 0.0415550574071756 * z2,
    b: x6 * 0.0556300796969936 - y6 * 0.2039769588889765 + 1.0569715142428784 * z2
  });
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz65ToRgb_default = convertXyz65ToRgb;

// node_modules/culori/src/a98/definition.js
var definition2 = {
  ...definition_default,
  mode: "a98",
  parse: ["a98-rgb"],
  serialize: "a98-rgb",
  fromMode: {
    rgb: (color3) => convertXyz65ToA98_default(convertRgbToXyz65_default(color3)),
    xyz65: convertXyz65ToA98_default
  },
  toMode: {
    rgb: (color3) => convertXyz65ToRgb_default(convertA98ToXyz65_default(color3)),
    xyz65: convertA98ToXyz65_default
  }
};
var definition_default2 = definition2;

// node_modules/culori/src/util/normalizeHue.js
var normalizeHue = (hue3) => (hue3 = hue3 % 360) < 0 ? hue3 + 360 : hue3;
var normalizeHue_default = normalizeHue;

// node_modules/culori/src/fixup/hue.js
var hue2 = (hues, fn5) => {
  return hues.map((hue3, idx, arr) => {
    if (hue3 === void 0) {
      return hue3;
    }
    let normalized = normalizeHue_default(hue3);
    if (idx === 0 || hues[idx - 1] === void 0) {
      return normalized;
    }
    return fn5(normalized - normalizeHue_default(arr[idx - 1]));
  }).reduce((acc, curr) => {
    if (!acc.length || curr === void 0 || acc[acc.length - 1] === void 0) {
      acc.push(curr);
      return acc;
    }
    acc.push(curr + acc[acc.length - 1]);
    return acc;
  }, []);
};
var fixupHueShorter = (arr) => hue2(arr, (d3) => Math.abs(d3) <= 180 ? d3 : d3 - 360 * Math.sign(d3));

// node_modules/culori/src/cubehelix/constants.js
var M = [-0.14861, 1.78277, -0.29227, -0.90649, 1.97294, 0];
var degToRad = Math.PI / 180;
var radToDeg = 180 / Math.PI;

// node_modules/culori/src/cubehelix/convertRgbToCubehelix.js
var DE = M[3] * M[4];
var BE = M[1] * M[4];
var BCAD = M[1] * M[2] - M[0] * M[3];
var convertRgbToCubehelix = ({ r: r5, g: g3, b: b2, alpha }) => {
  if (r5 === void 0)
    r5 = 0;
  if (g3 === void 0)
    g3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let l3 = (BCAD * b2 + r5 * DE - g3 * BE) / (BCAD + DE - BE);
  let x6 = b2 - l3;
  let y6 = (M[4] * (g3 - l3) - M[2] * x6) / M[3];
  let res = {
    mode: "cubehelix",
    l: l3,
    s: l3 === 0 || l3 === 1 ? void 0 : Math.sqrt(x6 * x6 + y6 * y6) / (M[4] * l3 * (1 - l3))
  };
  if (res.s)
    res.h = Math.atan2(y6, x6) * radToDeg - 120;
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertRgbToCubehelix_default = convertRgbToCubehelix;

// node_modules/culori/src/cubehelix/convertCubehelixToRgb.js
var convertCubehelixToRgb = ({ h: h4, s: s3, l: l3, alpha }) => {
  let res = { mode: "rgb" };
  h4 = (h4 === void 0 ? 0 : h4 + 120) * degToRad;
  if (l3 === void 0)
    l3 = 0;
  let amp = s3 === void 0 ? 0 : s3 * l3 * (1 - l3);
  let cosh = Math.cos(h4);
  let sinh = Math.sin(h4);
  res.r = l3 + amp * (M[0] * cosh + M[1] * sinh);
  res.g = l3 + amp * (M[2] * cosh + M[3] * sinh);
  res.b = l3 + amp * (M[4] * cosh + M[5] * sinh);
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertCubehelixToRgb_default = convertCubehelixToRgb;

// node_modules/culori/src/difference.js
var differenceHueSaturation = (std, smp) => {
  if (std.h === void 0 || smp.h === void 0 || !std.s || !smp.s) {
    return 0;
  }
  let std_h = normalizeHue_default(std.h);
  let smp_h = normalizeHue_default(smp.h);
  let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
  return 2 * Math.sqrt(std.s * smp.s) * dH;
};
var differenceHueNaive = (std, smp) => {
  if (std.h === void 0 || smp.h === void 0) {
    return 0;
  }
  let std_h = normalizeHue_default(std.h);
  let smp_h = normalizeHue_default(smp.h);
  if (Math.abs(smp_h - std_h) > 180) {
    return std_h - (smp_h - 360 * Math.sign(smp_h - std_h));
  }
  return smp_h - std_h;
};
var differenceHueChroma = (std, smp) => {
  if (std.h === void 0 || smp.h === void 0 || !std.c || !smp.c) {
    return 0;
  }
  let std_h = normalizeHue_default(std.h);
  let smp_h = normalizeHue_default(smp.h);
  let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
  return 2 * Math.sqrt(std.c * smp.c) * dH;
};

// node_modules/culori/src/average.js
var averageAngle = (val) => {
  let sum = val.reduce(
    (sum2, val2) => {
      if (val2 !== void 0) {
        let rad = val2 * Math.PI / 180;
        sum2.sin += Math.sin(rad);
        sum2.cos += Math.cos(rad);
      }
      return sum2;
    },
    { sin: 0, cos: 0 }
  );
  let angle = Math.atan2(sum.sin, sum.cos) * 180 / Math.PI;
  return angle < 0 ? 360 + angle : angle;
};

// node_modules/culori/src/cubehelix/definition.js
var definition3 = {
  mode: "cubehelix",
  channels: ["h", "s", "l", "alpha"],
  parse: ["--cubehelix"],
  serialize: "--cubehelix",
  ranges: {
    h: [0, 360],
    s: [0, 4.614],
    l: [0, 1]
  },
  fromMode: {
    rgb: convertRgbToCubehelix_default
  },
  toMode: {
    rgb: convertCubehelixToRgb_default
  },
  interpolate: {
    h: {
      use: interpolatorLinear,
      fixup: fixupHueShorter
    },
    s: interpolatorLinear,
    l: interpolatorLinear,
    alpha: {
      use: interpolatorLinear,
      fixup: fixupAlpha
    }
  },
  difference: {
    h: differenceHueSaturation
  },
  average: {
    h: averageAngle
  }
};
var definition_default3 = definition3;

// node_modules/culori/src/lch/convertLabToLch.js
var convertLabToLch = ({ l: l3, a: a3, b: b2, alpha }, mode = "lch") => {
  if (a3 === void 0)
    a3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let c4 = Math.sqrt(a3 * a3 + b2 * b2);
  let res = { mode, l: l3, c: c4 };
  if (c4)
    res.h = normalizeHue_default(Math.atan2(b2, a3) * 180 / Math.PI);
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertLabToLch_default = convertLabToLch;

// node_modules/culori/src/lch/convertLchToLab.js
var convertLchToLab = ({ l: l3, c: c4, h: h4, alpha }, mode = "lab") => {
  if (h4 === void 0)
    h4 = 0;
  let res = {
    mode,
    l: l3,
    a: c4 ? c4 * Math.cos(h4 / 180 * Math.PI) : 0,
    b: c4 ? c4 * Math.sin(h4 / 180 * Math.PI) : 0
  };
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertLchToLab_default = convertLchToLab;

// node_modules/culori/src/xyz65/constants.js
var k = Math.pow(29, 3) / Math.pow(3, 3);
var e = Math.pow(6, 3) / Math.pow(29, 3);

// node_modules/culori/src/constants.js
var D50 = {
  X: 0.3457 / 0.3585,
  Y: 1,
  Z: (1 - 0.3457 - 0.3585) / 0.3585
};
var D65 = {
  X: 0.3127 / 0.329,
  Y: 1,
  Z: (1 - 0.3127 - 0.329) / 0.329
};
var k2 = Math.pow(29, 3) / Math.pow(3, 3);
var e2 = Math.pow(6, 3) / Math.pow(29, 3);

// node_modules/culori/src/lab65/convertLab65ToXyz65.js
var fn3 = (v2) => Math.pow(v2, 3) > e ? Math.pow(v2, 3) : (116 * v2 - 16) / k;
var convertLab65ToXyz65 = ({ l: l3, a: a3, b: b2, alpha }) => {
  if (l3 === void 0)
    l3 = 0;
  if (a3 === void 0)
    a3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let fy = (l3 + 16) / 116;
  let fx = a3 / 500 + fy;
  let fz = fy - b2 / 200;
  let res = {
    mode: "xyz65",
    x: fn3(fx) * D65.X,
    y: fn3(fy) * D65.Y,
    z: fn3(fz) * D65.Z
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertLab65ToXyz65_default = convertLab65ToXyz65;

// node_modules/culori/src/lab65/convertLab65ToRgb.js
var convertLab65ToRgb = (lab2) => convertXyz65ToRgb_default(convertLab65ToXyz65_default(lab2));
var convertLab65ToRgb_default = convertLab65ToRgb;

// node_modules/culori/src/lab65/convertXyz65ToLab65.js
var f = (value) => value > e ? Math.cbrt(value) : (k * value + 16) / 116;
var convertXyz65ToLab65 = ({ x: x6, y: y6, z: z2, alpha }) => {
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (z2 === void 0)
    z2 = 0;
  let f0 = f(x6 / D65.X);
  let f1 = f(y6 / D65.Y);
  let f22 = f(z2 / D65.Z);
  let res = {
    mode: "lab65",
    l: 116 * f1 - 16,
    a: 500 * (f0 - f1),
    b: 200 * (f1 - f22)
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz65ToLab65_default = convertXyz65ToLab65;

// node_modules/culori/src/lab65/convertRgbToLab65.js
var convertRgbToLab65 = (rgb4) => {
  let res = convertXyz65ToLab65_default(convertRgbToXyz65_default(rgb4));
  if (rgb4.r === rgb4.b && rgb4.b === rgb4.g) {
    res.a = res.b = 0;
  }
  return res;
};
var convertRgbToLab65_default = convertRgbToLab65;

// node_modules/culori/src/dlch/constants.js
var kE = 1;
var kCH = 1;
var \u03B8 = 26 / 180 * Math.PI;
var cos\u03B8 = Math.cos(\u03B8);
var sin\u03B8 = Math.sin(\u03B8);
var factor = 100 / Math.log(139 / 100);

// node_modules/culori/src/dlch/convertDlchToLab65.js
var convertDlchToLab65 = ({ l: l3, c: c4, h: h4, alpha }) => {
  if (l3 === void 0)
    l3 = 0;
  if (c4 === void 0)
    c4 = 0;
  if (h4 === void 0)
    h4 = 0;
  let res = {
    mode: "lab65",
    l: (Math.exp(l3 * kE / factor) - 1) / 39e-4
  };
  let G3 = (Math.exp(0.0435 * c4 * kCH * kE) - 1) / 0.075;
  let e8 = G3 * Math.cos(h4 / 180 * Math.PI - \u03B8);
  let f5 = G3 * Math.sin(h4 / 180 * Math.PI - \u03B8);
  res.a = e8 * cos\u03B8 - f5 / 0.83 * sin\u03B8;
  res.b = e8 * sin\u03B8 + f5 / 0.83 * cos\u03B8;
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertDlchToLab65_default = convertDlchToLab65;

// node_modules/culori/src/dlch/convertLab65ToDlch.js
var convertLab65ToDlch = ({ l: l3, a: a3, b: b2, alpha }) => {
  if (l3 === void 0)
    l3 = 0;
  if (a3 === void 0)
    a3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let e8 = a3 * cos\u03B8 + b2 * sin\u03B8;
  let f5 = 0.83 * (b2 * cos\u03B8 - a3 * sin\u03B8);
  let G3 = Math.sqrt(e8 * e8 + f5 * f5);
  let res = {
    mode: "dlch",
    l: factor / kE * Math.log(1 + 39e-4 * l3),
    c: Math.log(1 + 0.075 * G3) / (0.0435 * kCH * kE)
  };
  if (res.c) {
    res.h = normalizeHue_default((Math.atan2(f5, e8) + \u03B8) / Math.PI * 180);
  }
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertLab65ToDlch_default = convertLab65ToDlch;

// node_modules/culori/src/dlab/definition.js
var convertDlabToLab65 = (c4) => convertDlchToLab65_default(convertLabToLch_default(c4, "dlch"));
var convertLab65ToDlab = (c4) => convertLchToLab_default(convertLab65ToDlch_default(c4), "dlab");
var definition4 = {
  mode: "dlab",
  parse: ["--din99o-lab"],
  serialize: "--din99o-lab",
  toMode: {
    lab65: convertDlabToLab65,
    rgb: (c4) => convertLab65ToRgb_default(convertDlabToLab65(c4))
  },
  fromMode: {
    lab65: convertLab65ToDlab,
    rgb: (c4) => convertLab65ToDlab(convertRgbToLab65_default(c4))
  },
  channels: ["l", "a", "b", "alpha"],
  ranges: {
    l: [0, 100],
    a: [-40.09, 45.501],
    b: [-40.469, 44.344]
  },
  interpolate: {
    l: interpolatorLinear,
    a: interpolatorLinear,
    b: interpolatorLinear,
    alpha: {
      use: interpolatorLinear,
      fixup: fixupAlpha
    }
  }
};
var definition_default4 = definition4;

// node_modules/culori/src/dlch/definition.js
var definition5 = {
  mode: "dlch",
  parse: ["--din99o-lch"],
  serialize: "--din99o-lch",
  toMode: {
    lab65: convertDlchToLab65_default,
    dlab: (c4) => convertLchToLab_default(c4, "dlab"),
    rgb: (c4) => convertLab65ToRgb_default(convertDlchToLab65_default(c4))
  },
  fromMode: {
    lab65: convertLab65ToDlch_default,
    dlab: (c4) => convertLabToLch_default(c4, "dlch"),
    rgb: (c4) => convertLab65ToDlch_default(convertRgbToLab65_default(c4))
  },
  channels: ["l", "c", "h", "alpha"],
  ranges: {
    l: [0, 100],
    c: [0, 51.484],
    h: [0, 360]
  },
  interpolate: {
    l: interpolatorLinear,
    c: interpolatorLinear,
    h: {
      use: interpolatorLinear,
      fixup: fixupHueShorter
    },
    alpha: {
      use: interpolatorLinear,
      fixup: fixupAlpha
    }
  },
  difference: {
    h: differenceHueChroma
  },
  average: {
    h: averageAngle
  }
};
var definition_default5 = definition5;

// node_modules/culori/src/hsi/convertHsiToRgb.js
function convertHsiToRgb({ h: h4, s: s3, i: i4, alpha }) {
  h4 = normalizeHue_default(h4 !== void 0 ? h4 : 0);
  if (s3 === void 0)
    s3 = 0;
  if (i4 === void 0)
    i4 = 0;
  let f5 = Math.abs(h4 / 60 % 2 - 1);
  let res;
  switch (Math.floor(h4 / 60)) {
    case 0:
      res = {
        r: i4 * (1 + s3 * (3 / (2 - f5) - 1)),
        g: i4 * (1 + s3 * (3 * (1 - f5) / (2 - f5) - 1)),
        b: i4 * (1 - s3)
      };
      break;
    case 1:
      res = {
        r: i4 * (1 + s3 * (3 * (1 - f5) / (2 - f5) - 1)),
        g: i4 * (1 + s3 * (3 / (2 - f5) - 1)),
        b: i4 * (1 - s3)
      };
      break;
    case 2:
      res = {
        r: i4 * (1 - s3),
        g: i4 * (1 + s3 * (3 / (2 - f5) - 1)),
        b: i4 * (1 + s3 * (3 * (1 - f5) / (2 - f5) - 1))
      };
      break;
    case 3:
      res = {
        r: i4 * (1 - s3),
        g: i4 * (1 + s3 * (3 * (1 - f5) / (2 - f5) - 1)),
        b: i4 * (1 + s3 * (3 / (2 - f5) - 1))
      };
      break;
    case 4:
      res = {
        r: i4 * (1 + s3 * (3 * (1 - f5) / (2 - f5) - 1)),
        g: i4 * (1 - s3),
        b: i4 * (1 + s3 * (3 / (2 - f5) - 1))
      };
      break;
    case 5:
      res = {
        r: i4 * (1 + s3 * (3 / (2 - f5) - 1)),
        g: i4 * (1 - s3),
        b: i4 * (1 + s3 * (3 * (1 - f5) / (2 - f5) - 1))
      };
      break;
    default:
      res = { r: i4 * (1 - s3), g: i4 * (1 - s3), b: i4 * (1 - s3) };
  }
  res.mode = "rgb";
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
}

// node_modules/culori/src/hsi/convertRgbToHsi.js
function convertRgbToHsi({ r: r5, g: g3, b: b2, alpha }) {
  if (r5 === void 0)
    r5 = 0;
  if (g3 === void 0)
    g3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let M4 = Math.max(r5, g3, b2), m3 = Math.min(r5, g3, b2);
  let res = {
    mode: "hsi",
    s: r5 + g3 + b2 === 0 ? 0 : 1 - 3 * m3 / (r5 + g3 + b2),
    i: (r5 + g3 + b2) / 3
  };
  if (M4 - m3 !== 0)
    res.h = (M4 === r5 ? (g3 - b2) / (M4 - m3) + (g3 < b2) * 6 : M4 === g3 ? (b2 - r5) / (M4 - m3) + 2 : (r5 - g3) / (M4 - m3) + 4) * 60;
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
}

// node_modules/culori/src/hsi/definition.js
var definition6 = {
  mode: "hsi",
  toMode: {
    rgb: convertHsiToRgb
  },
  parse: ["--hsi"],
  serialize: "--hsi",
  fromMode: {
    rgb: convertRgbToHsi
  },
  channels: ["h", "s", "i", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    s: interpolatorLinear,
    i: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueSaturation
  },
  average: {
    h: averageAngle
  }
};
var definition_default6 = definition6;

// node_modules/culori/src/hsl/convertHslToRgb.js
function convertHslToRgb({ h: h4, s: s3, l: l3, alpha }) {
  h4 = normalizeHue_default(h4 !== void 0 ? h4 : 0);
  if (s3 === void 0)
    s3 = 0;
  if (l3 === void 0)
    l3 = 0;
  let m1 = l3 + s3 * (l3 < 0.5 ? l3 : 1 - l3);
  let m22 = m1 - (m1 - l3) * 2 * Math.abs(h4 / 60 % 2 - 1);
  let res;
  switch (Math.floor(h4 / 60)) {
    case 0:
      res = { r: m1, g: m22, b: 2 * l3 - m1 };
      break;
    case 1:
      res = { r: m22, g: m1, b: 2 * l3 - m1 };
      break;
    case 2:
      res = { r: 2 * l3 - m1, g: m1, b: m22 };
      break;
    case 3:
      res = { r: 2 * l3 - m1, g: m22, b: m1 };
      break;
    case 4:
      res = { r: m22, g: 2 * l3 - m1, b: m1 };
      break;
    case 5:
      res = { r: m1, g: 2 * l3 - m1, b: m22 };
      break;
    default:
      res = { r: 2 * l3 - m1, g: 2 * l3 - m1, b: 2 * l3 - m1 };
  }
  res.mode = "rgb";
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
}

// node_modules/culori/src/hsl/convertRgbToHsl.js
function convertRgbToHsl({ r: r5, g: g3, b: b2, alpha }) {
  if (r5 === void 0)
    r5 = 0;
  if (g3 === void 0)
    g3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let M4 = Math.max(r5, g3, b2), m3 = Math.min(r5, g3, b2);
  let res = {
    mode: "hsl",
    s: M4 === m3 ? 0 : (M4 - m3) / (1 - Math.abs(M4 + m3 - 1)),
    l: 0.5 * (M4 + m3)
  };
  if (M4 - m3 !== 0)
    res.h = (M4 === r5 ? (g3 - b2) / (M4 - m3) + (g3 < b2) * 6 : M4 === g3 ? (b2 - r5) / (M4 - m3) + 2 : (r5 - g3) / (M4 - m3) + 4) * 60;
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
}

// node_modules/culori/src/util/hue.js
var hueToDeg = (val, unit2) => {
  switch (unit2) {
    case "deg":
      return +val;
    case "rad":
      return val / Math.PI * 180;
    case "grad":
      return val / 10 * 9;
    case "turn":
      return val * 360;
  }
};
var hue_default = hueToDeg;

// node_modules/culori/src/hsl/parseHslLegacy.js
var hsl_old = new RegExp(
  `^hsla?\\(\\s*${hue}${c}${per}${c}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`
);
var parseHslLegacy = (color3) => {
  let match = color3.match(hsl_old);
  if (!match)
    return;
  let res = { mode: "hsl" };
  if (match[3] !== void 0) {
    res.h = +match[3];
  } else if (match[1] !== void 0 && match[2] !== void 0) {
    res.h = hue_default(match[1], match[2]);
  }
  if (match[4] !== void 0) {
    res.s = Math.min(Math.max(0, match[4] / 100), 1);
  }
  if (match[5] !== void 0) {
    res.l = Math.min(Math.max(0, match[5] / 100), 1);
  }
  if (match[6] !== void 0) {
    res.alpha = Math.max(0, Math.min(1, match[6] / 100));
  } else if (match[7] !== void 0) {
    res.alpha = Math.max(0, Math.min(1, +match[7]));
  }
  return res;
};
var parseHslLegacy_default = parseHslLegacy;

// node_modules/culori/src/hsl/parseHsl.js
function parseHsl(color3, parsed) {
  if (!parsed || parsed[0] !== "hsl" && parsed[0] !== "hsla") {
    return void 0;
  }
  const res = { mode: "hsl" };
  const [, h4, s3, l3, alpha] = parsed;
  if (h4.type !== Tok.None) {
    if (h4.type === Tok.Percentage) {
      return void 0;
    }
    res.h = h4.value;
  }
  if (s3.type !== Tok.None) {
    if (s3.type === Tok.Hue) {
      return void 0;
    }
    res.s = s3.value / 100;
  }
  if (l3.type !== Tok.None) {
    if (l3.type === Tok.Hue) {
      return void 0;
    }
    res.l = l3.value / 100;
  }
  if (alpha.type !== Tok.None) {
    res.alpha = Math.min(
      1,
      Math.max(
        0,
        alpha.type === Tok.Number ? alpha.value : alpha.value / 100
      )
    );
  }
  return res;
}
var parseHsl_default = parseHsl;

// node_modules/culori/src/hsl/definition.js
var definition7 = {
  mode: "hsl",
  toMode: {
    rgb: convertHslToRgb
  },
  fromMode: {
    rgb: convertRgbToHsl
  },
  channels: ["h", "s", "l", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  parse: [parseHsl_default, parseHslLegacy_default],
  serialize: (c4) => `hsl(${c4.h !== void 0 ? c4.h : "none"} ${c4.s !== void 0 ? c4.s * 100 + "%" : "none"} ${c4.l !== void 0 ? c4.l * 100 + "%" : "none"}${c4.alpha < 1 ? ` / ${c4.alpha}` : ""})`,
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    s: interpolatorLinear,
    l: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueSaturation
  },
  average: {
    h: averageAngle
  }
};
var definition_default7 = definition7;

// node_modules/culori/src/hsv/convertHsvToRgb.js
function convertHsvToRgb({ h: h4, s: s3, v: v2, alpha }) {
  h4 = normalizeHue_default(h4 !== void 0 ? h4 : 0);
  if (s3 === void 0)
    s3 = 0;
  if (v2 === void 0)
    v2 = 0;
  let f5 = Math.abs(h4 / 60 % 2 - 1);
  let res;
  switch (Math.floor(h4 / 60)) {
    case 0:
      res = { r: v2, g: v2 * (1 - s3 * f5), b: v2 * (1 - s3) };
      break;
    case 1:
      res = { r: v2 * (1 - s3 * f5), g: v2, b: v2 * (1 - s3) };
      break;
    case 2:
      res = { r: v2 * (1 - s3), g: v2, b: v2 * (1 - s3 * f5) };
      break;
    case 3:
      res = { r: v2 * (1 - s3), g: v2 * (1 - s3 * f5), b: v2 };
      break;
    case 4:
      res = { r: v2 * (1 - s3 * f5), g: v2 * (1 - s3), b: v2 };
      break;
    case 5:
      res = { r: v2, g: v2 * (1 - s3), b: v2 * (1 - s3 * f5) };
      break;
    default:
      res = { r: v2 * (1 - s3), g: v2 * (1 - s3), b: v2 * (1 - s3) };
  }
  res.mode = "rgb";
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
}

// node_modules/culori/src/hsv/convertRgbToHsv.js
function convertRgbToHsv({ r: r5, g: g3, b: b2, alpha }) {
  if (r5 === void 0)
    r5 = 0;
  if (g3 === void 0)
    g3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let M4 = Math.max(r5, g3, b2), m3 = Math.min(r5, g3, b2);
  let res = {
    mode: "hsv",
    s: M4 === 0 ? 0 : 1 - m3 / M4,
    v: M4
  };
  if (M4 - m3 !== 0)
    res.h = (M4 === r5 ? (g3 - b2) / (M4 - m3) + (g3 < b2) * 6 : M4 === g3 ? (b2 - r5) / (M4 - m3) + 2 : (r5 - g3) / (M4 - m3) + 4) * 60;
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
}

// node_modules/culori/src/hsv/definition.js
var definition8 = {
  mode: "hsv",
  toMode: {
    rgb: convertHsvToRgb
  },
  parse: ["--hsv"],
  serialize: "--hsv",
  fromMode: {
    rgb: convertRgbToHsv
  },
  channels: ["h", "s", "v", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    s: interpolatorLinear,
    v: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueSaturation
  },
  average: {
    h: averageAngle
  }
};
var definition_default8 = definition8;

// node_modules/culori/src/hwb/convertHwbToRgb.js
function convertHwbToRgb({ h: h4, w: w3, b: b2, alpha }) {
  if (w3 === void 0)
    w3 = 0;
  if (b2 === void 0)
    b2 = 0;
  if (w3 + b2 > 1) {
    let s3 = w3 + b2;
    w3 /= s3;
    b2 /= s3;
  }
  return convertHsvToRgb({
    h: h4,
    s: b2 === 1 ? 1 : 1 - w3 / (1 - b2),
    v: 1 - b2,
    alpha
  });
}

// node_modules/culori/src/hwb/convertRgbToHwb.js
function convertRgbToHwb(rgba2) {
  let hsv2 = convertRgbToHsv(rgba2);
  if (hsv2 === void 0)
    return void 0;
  let s3 = hsv2.s !== void 0 ? hsv2.s : 0;
  let v2 = hsv2.v !== void 0 ? hsv2.v : 0;
  let res = {
    mode: "hwb",
    w: (1 - s3) * v2,
    b: 1 - v2
  };
  if (hsv2.h !== void 0)
    res.h = hsv2.h;
  if (hsv2.alpha !== void 0)
    res.alpha = hsv2.alpha;
  return res;
}

// node_modules/culori/src/hwb/parseHwb.js
function ParseHwb(color3, parsed) {
  if (!parsed || parsed[0] !== "hwb") {
    return void 0;
  }
  const res = { mode: "hwb" };
  const [, h4, w3, b2, alpha] = parsed;
  if (h4.type !== Tok.None) {
    if (h4.type === Tok.Percentage) {
      return void 0;
    }
    res.h = h4.value;
  }
  if (w3.type !== Tok.None) {
    if (w3.type === Tok.Hue) {
      return void 0;
    }
    res.w = w3.value / 100;
  }
  if (b2.type !== Tok.None) {
    if (b2.type === Tok.Hue) {
      return void 0;
    }
    res.b = b2.value / 100;
  }
  if (alpha.type !== Tok.None) {
    res.alpha = Math.min(
      1,
      Math.max(
        0,
        alpha.type === Tok.Number ? alpha.value : alpha.value / 100
      )
    );
  }
  return res;
}
var parseHwb_default = ParseHwb;

// node_modules/culori/src/hwb/definition.js
var definition9 = {
  mode: "hwb",
  toMode: {
    rgb: convertHwbToRgb
  },
  fromMode: {
    rgb: convertRgbToHwb
  },
  channels: ["h", "w", "b", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  parse: [parseHwb_default],
  serialize: (c4) => `hwb(${c4.h !== void 0 ? c4.h : "none"} ${c4.w !== void 0 ? c4.w * 100 + "%" : "none"} ${c4.b !== void 0 ? c4.b * 100 + "%" : "none"}${c4.alpha < 1 ? ` / ${c4.alpha}` : ""})`,
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    w: interpolatorLinear,
    b: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueNaive
  },
  average: {
    h: averageAngle
  }
};
var definition_default9 = definition9;

// node_modules/culori/src/hdr/constants.js
var YW = 203;

// node_modules/culori/src/hdr/transfer.js
var M1 = 0.1593017578125;
var M2 = 78.84375;
var C1 = 0.8359375;
var C2 = 18.8515625;
var C3 = 18.6875;
function transferPqDecode(v2) {
  if (v2 < 0)
    return 0;
  const c4 = Math.pow(v2, 1 / M2);
  return 1e4 * Math.pow(Math.max(0, c4 - C1) / (C2 - C3 * c4), 1 / M1);
}
function transferPqEncode(v2) {
  if (v2 < 0)
    return 0;
  const c4 = Math.pow(v2 / 1e4, M1);
  return Math.pow((C1 + C2 * c4) / (1 + C3 * c4), M2);
}

// node_modules/culori/src/itp/convertItpToXyz65.js
var toRel = (c4) => Math.max(c4 / YW, 0);
var convertItpToXyz65 = ({ i: i4, t: t2, p: p7, alpha }) => {
  if (i4 === void 0)
    i4 = 0;
  if (t2 === void 0)
    t2 = 0;
  if (p7 === void 0)
    p7 = 0;
  const l3 = transferPqDecode(
    i4 + 0.008609037037932761 * t2 + 0.11102962500302593 * p7
  );
  const m3 = transferPqDecode(
    i4 - 0.00860903703793275 * t2 - 0.11102962500302599 * p7
  );
  const s3 = transferPqDecode(
    i4 + 0.5600313357106791 * t2 - 0.32062717498731885 * p7
  );
  const res = {
    mode: "xyz65",
    x: toRel(
      2.070152218389422 * l3 - 1.3263473389671556 * m3 + 0.2066510476294051 * s3
    ),
    y: toRel(
      0.3647385209748074 * l3 + 0.680566024947227 * m3 - 0.0453045459220346 * s3
    ),
    z: toRel(
      -0.049747207535812 * l3 - 0.0492609666966138 * m3 + 1.1880659249923042 * s3
    )
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertItpToXyz65_default = convertItpToXyz65;

// node_modules/culori/src/itp/convertXyz65ToItp.js
var toAbs = (c4 = 0) => Math.max(c4 * YW, 0);
var convertXyz65ToItp = ({ x: x6, y: y6, z: z2, alpha }) => {
  const absX = toAbs(x6);
  const absY = toAbs(y6);
  const absZ = toAbs(z2);
  const l3 = transferPqEncode(
    0.3592832590121217 * absX + 0.6976051147779502 * absY - 0.0358915932320289 * absZ
  );
  const m3 = transferPqEncode(
    -0.1920808463704995 * absX + 1.1004767970374323 * absY + 0.0753748658519118 * absZ
  );
  const s3 = transferPqEncode(
    0.0070797844607477 * absX + 0.0748396662186366 * absY + 0.8433265453898765 * absZ
  );
  const i4 = 0.5 * l3 + 0.5 * m3;
  const t2 = 1.61376953125 * l3 - 3.323486328125 * m3 + 1.709716796875 * s3;
  const p7 = 4.378173828125 * l3 - 4.24560546875 * m3 - 0.132568359375 * s3;
  const res = { mode: "itp", i: i4, t: t2, p: p7 };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz65ToItp_default = convertXyz65ToItp;

// node_modules/culori/src/itp/definition.js
var definition10 = {
  mode: "itp",
  channels: ["i", "t", "p", "alpha"],
  parse: ["--ictcp"],
  serialize: "--ictcp",
  toMode: {
    xyz65: convertItpToXyz65_default,
    rgb: (color3) => convertXyz65ToRgb_default(convertItpToXyz65_default(color3))
  },
  fromMode: {
    xyz65: convertXyz65ToItp_default,
    rgb: (color3) => convertXyz65ToItp_default(convertRgbToXyz65_default(color3))
  },
  ranges: {
    i: [0, 0.581],
    t: [-0.369, 0.272],
    p: [-0.164, 0.331]
  },
  interpolate: {
    i: interpolatorLinear,
    t: interpolatorLinear,
    p: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
};
var definition_default10 = definition10;

// node_modules/culori/src/jab/convertXyz65ToJab.js
var p = 134.03437499999998;
var d0 = 16295499532821565e-27;
var jabPqEncode = (v2) => {
  if (v2 < 0)
    return 0;
  let vn3 = Math.pow(v2 / 1e4, M1);
  return Math.pow((C1 + C2 * vn3) / (1 + C3 * vn3), p);
};
var abs = (v2 = 0) => Math.max(v2 * 203, 0);
var convertXyz65ToJab = ({ x: x6, y: y6, z: z2, alpha }) => {
  x6 = abs(x6);
  y6 = abs(y6);
  z2 = abs(z2);
  let xp = 1.15 * x6 - 0.15 * z2;
  let yp = 0.66 * y6 + 0.34 * x6;
  let l3 = jabPqEncode(0.41478972 * xp + 0.579999 * yp + 0.014648 * z2);
  let m3 = jabPqEncode(-0.20151 * xp + 1.120649 * yp + 0.0531008 * z2);
  let s3 = jabPqEncode(-0.0166008 * xp + 0.2648 * yp + 0.6684799 * z2);
  let i4 = (l3 + m3) / 2;
  let res = {
    mode: "jab",
    j: 0.44 * i4 / (1 - 0.56 * i4) - d0,
    a: 3.524 * l3 - 4.066708 * m3 + 0.542708 * s3,
    b: 0.199076 * l3 + 1.096799 * m3 - 1.295875 * s3
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz65ToJab_default = convertXyz65ToJab;

// node_modules/culori/src/jab/convertJabToXyz65.js
var p2 = 134.03437499999998;
var d02 = 16295499532821565e-27;
var jabPqDecode = (v2) => {
  if (v2 < 0)
    return 0;
  let vp = Math.pow(v2, 1 / p2);
  return 1e4 * Math.pow((C1 - vp) / (C3 * vp - C2), 1 / M1);
};
var rel = (v2) => v2 / 203;
var convertJabToXyz65 = ({ j: j2, a: a3, b: b2, alpha }) => {
  if (j2 === void 0)
    j2 = 0;
  if (a3 === void 0)
    a3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let i4 = (j2 + d02) / (0.44 + 0.56 * (j2 + d02));
  let l3 = jabPqDecode(i4 + 0.13860504 * a3 + 0.058047316 * b2);
  let m3 = jabPqDecode(i4 - 0.13860504 * a3 - 0.058047316 * b2);
  let s3 = jabPqDecode(i4 - 0.096019242 * a3 - 0.8118919 * b2);
  let res = {
    mode: "xyz65",
    x: rel(
      1.661373024652174 * l3 - 0.914523081304348 * m3 + 0.23136208173913045 * s3
    ),
    y: rel(
      -0.3250758611844533 * l3 + 1.571847026732543 * m3 - 0.21825383453227928 * s3
    ),
    z: rel(-0.090982811 * l3 - 0.31272829 * m3 + 1.5227666 * s3)
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertJabToXyz65_default = convertJabToXyz65;

// node_modules/culori/src/jab/convertRgbToJab.js
var convertRgbToJab = (rgb4) => {
  let res = convertXyz65ToJab_default(convertRgbToXyz65_default(rgb4));
  if (rgb4.r === rgb4.b && rgb4.b === rgb4.g) {
    res.a = res.b = 0;
  }
  return res;
};
var convertRgbToJab_default = convertRgbToJab;

// node_modules/culori/src/jab/convertJabToRgb.js
var convertJabToRgb = (color3) => convertXyz65ToRgb_default(convertJabToXyz65_default(color3));
var convertJabToRgb_default = convertJabToRgb;

// node_modules/culori/src/jab/definition.js
var definition11 = {
  mode: "jab",
  channels: ["j", "a", "b", "alpha"],
  parse: ["--jzazbz"],
  serialize: "--jzazbz",
  fromMode: {
    rgb: convertRgbToJab_default,
    xyz65: convertXyz65ToJab_default
  },
  toMode: {
    rgb: convertJabToRgb_default,
    xyz65: convertJabToXyz65_default
  },
  ranges: {
    j: [0, 0.222],
    a: [-0.109, 0.129],
    b: [-0.185, 0.134]
  },
  interpolate: {
    j: interpolatorLinear,
    a: interpolatorLinear,
    b: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
};
var definition_default11 = definition11;

// node_modules/culori/src/jch/convertJabToJch.js
var convertJabToJch = ({ j: j2, a: a3, b: b2, alpha }) => {
  if (a3 === void 0)
    a3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let c4 = Math.sqrt(a3 * a3 + b2 * b2);
  let res = {
    mode: "jch",
    j: j2,
    c: c4
  };
  if (c4) {
    res.h = normalizeHue_default(Math.atan2(b2, a3) * 180 / Math.PI);
  }
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertJabToJch_default = convertJabToJch;

// node_modules/culori/src/jch/convertJchToJab.js
var convertJchToJab = ({ j: j2, c: c4, h: h4, alpha }) => {
  if (h4 === void 0)
    h4 = 0;
  let res = {
    mode: "jab",
    j: j2,
    a: c4 ? c4 * Math.cos(h4 / 180 * Math.PI) : 0,
    b: c4 ? c4 * Math.sin(h4 / 180 * Math.PI) : 0
  };
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertJchToJab_default = convertJchToJab;

// node_modules/culori/src/jch/definition.js
var definition12 = {
  mode: "jch",
  parse: ["--jzczhz"],
  serialize: "--jzczhz",
  toMode: {
    jab: convertJchToJab_default,
    rgb: (c4) => convertJabToRgb_default(convertJchToJab_default(c4))
  },
  fromMode: {
    rgb: (c4) => convertJabToJch_default(convertRgbToJab_default(c4)),
    jab: convertJabToJch_default
  },
  channels: ["j", "c", "h", "alpha"],
  ranges: {
    j: [0, 0.221],
    c: [0, 0.19],
    h: [0, 360]
  },
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    c: interpolatorLinear,
    j: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueChroma
  },
  average: {
    h: averageAngle
  }
};
var definition_default12 = definition12;

// node_modules/culori/src/xyz50/constants.js
var k3 = Math.pow(29, 3) / Math.pow(3, 3);
var e3 = Math.pow(6, 3) / Math.pow(29, 3);

// node_modules/culori/src/lab/convertLabToXyz50.js
var fn4 = (v2) => Math.pow(v2, 3) > e3 ? Math.pow(v2, 3) : (116 * v2 - 16) / k3;
var convertLabToXyz50 = ({ l: l3, a: a3, b: b2, alpha }) => {
  if (l3 === void 0)
    l3 = 0;
  if (a3 === void 0)
    a3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let fy = (l3 + 16) / 116;
  let fx = a3 / 500 + fy;
  let fz = fy - b2 / 200;
  let res = {
    mode: "xyz50",
    x: fn4(fx) * D50.X,
    y: fn4(fy) * D50.Y,
    z: fn4(fz) * D50.Z
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertLabToXyz50_default = convertLabToXyz50;

// node_modules/culori/src/xyz50/convertXyz50ToRgb.js
var convertXyz50ToRgb = ({ x: x6, y: y6, z: z2, alpha }) => {
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (z2 === void 0)
    z2 = 0;
  let res = convertLrgbToRgb_default({
    r: x6 * 3.1341359569958707 - y6 * 1.6173863321612538 - 0.4906619460083532 * z2,
    g: x6 * -0.978795502912089 + y6 * 1.916254567259524 + 0.03344273116131949 * z2,
    b: x6 * 0.07195537988411677 - y6 * 0.2289768264158322 + 1.405386058324125 * z2
  });
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz50ToRgb_default = convertXyz50ToRgb;

// node_modules/culori/src/lab/convertLabToRgb.js
var convertLabToRgb = (lab2) => convertXyz50ToRgb_default(convertLabToXyz50_default(lab2));
var convertLabToRgb_default = convertLabToRgb;

// node_modules/culori/src/xyz50/convertRgbToXyz50.js
var convertRgbToXyz50 = (rgb4) => {
  let { r: r5, g: g3, b: b2, alpha } = convertRgbToLrgb_default(rgb4);
  let res = {
    mode: "xyz50",
    x: 0.436065742824811 * r5 + 0.3851514688337912 * g3 + 0.14307845442264197 * b2,
    y: 0.22249319175623702 * r5 + 0.7168870538238823 * g3 + 0.06061979053616537 * b2,
    z: 0.013923904500943465 * r5 + 0.09708128566574634 * g3 + 0.7140993584005155 * b2
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertRgbToXyz50_default = convertRgbToXyz50;

// node_modules/culori/src/lab/convertXyz50ToLab.js
var f2 = (value) => value > e3 ? Math.cbrt(value) : (k3 * value + 16) / 116;
var convertXyz50ToLab = ({ x: x6, y: y6, z: z2, alpha }) => {
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (z2 === void 0)
    z2 = 0;
  let f0 = f2(x6 / D50.X);
  let f1 = f2(y6 / D50.Y);
  let f22 = f2(z2 / D50.Z);
  let res = {
    mode: "lab",
    l: 116 * f1 - 16,
    a: 500 * (f0 - f1),
    b: 200 * (f1 - f22)
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz50ToLab_default = convertXyz50ToLab;

// node_modules/culori/src/lab/convertRgbToLab.js
var convertRgbToLab = (rgb4) => {
  let res = convertXyz50ToLab_default(convertRgbToXyz50_default(rgb4));
  if (rgb4.r === rgb4.b && rgb4.b === rgb4.g) {
    res.a = res.b = 0;
  }
  return res;
};
var convertRgbToLab_default = convertRgbToLab;

// node_modules/culori/src/lab/parseLab.js
function parseLab(color3, parsed) {
  if (!parsed || parsed[0] !== "lab") {
    return void 0;
  }
  const res = { mode: "lab" };
  const [, l3, a3, b2, alpha] = parsed;
  if (l3.type === Tok.Hue || a3.type === Tok.Hue || b2.type === Tok.Hue) {
    return void 0;
  }
  if (l3.type !== Tok.None) {
    res.l = Math.min(Math.max(0, l3.value), 100);
  }
  if (a3.type !== Tok.None) {
    res.a = a3.type === Tok.Number ? a3.value : a3.value * 125 / 100;
  }
  if (b2.type !== Tok.None) {
    res.b = b2.type === Tok.Number ? b2.value : b2.value * 125 / 100;
  }
  if (alpha.type !== Tok.None) {
    res.alpha = Math.min(
      1,
      Math.max(
        0,
        alpha.type === Tok.Number ? alpha.value : alpha.value / 100
      )
    );
  }
  return res;
}
var parseLab_default = parseLab;

// node_modules/culori/src/lab/definition.js
var definition13 = {
  mode: "lab",
  toMode: {
    xyz50: convertLabToXyz50_default,
    rgb: convertLabToRgb_default
  },
  fromMode: {
    xyz50: convertXyz50ToLab_default,
    rgb: convertRgbToLab_default
  },
  channels: ["l", "a", "b", "alpha"],
  ranges: {
    l: [0, 100],
    a: [-125, 125],
    b: [-125, 125]
  },
  parse: [parseLab_default],
  serialize: (c4) => `lab(${c4.l !== void 0 ? c4.l : "none"} ${c4.a !== void 0 ? c4.a : "none"} ${c4.b !== void 0 ? c4.b : "none"}${c4.alpha < 1 ? ` / ${c4.alpha}` : ""})`,
  interpolate: {
    l: interpolatorLinear,
    a: interpolatorLinear,
    b: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
};
var definition_default13 = definition13;

// node_modules/culori/src/lab65/definition.js
var definition14 = {
  ...definition_default13,
  mode: "lab65",
  parse: ["--lab-d65"],
  serialize: "--lab-d65",
  toMode: {
    xyz65: convertLab65ToXyz65_default,
    rgb: convertLab65ToRgb_default
  },
  fromMode: {
    xyz65: convertXyz65ToLab65_default,
    rgb: convertRgbToLab65_default
  },
  ranges: {
    l: [0, 100],
    a: [-125, 125],
    b: [-125, 125]
  }
};
var definition_default14 = definition14;

// node_modules/culori/src/lch/parseLch.js
function parseLch(color3, parsed) {
  if (!parsed || parsed[0] !== "lch") {
    return void 0;
  }
  const res = { mode: "lch" };
  const [, l3, c4, h4, alpha] = parsed;
  if (l3.type !== Tok.None) {
    if (l3.type === Tok.Hue) {
      return void 0;
    }
    res.l = Math.min(Math.max(0, l3.value), 100);
  }
  if (c4.type !== Tok.None) {
    res.c = Math.max(
      0,
      c4.type === Tok.Number ? c4.value : c4.value * 150 / 100
    );
  }
  if (h4.type !== Tok.None) {
    if (h4.type === Tok.Percentage) {
      return void 0;
    }
    res.h = h4.value;
  }
  if (alpha.type !== Tok.None) {
    res.alpha = Math.min(
      1,
      Math.max(
        0,
        alpha.type === Tok.Number ? alpha.value : alpha.value / 100
      )
    );
  }
  return res;
}
var parseLch_default = parseLch;

// node_modules/culori/src/lch/definition.js
var definition15 = {
  mode: "lch",
  toMode: {
    lab: convertLchToLab_default,
    rgb: (c4) => convertLabToRgb_default(convertLchToLab_default(c4))
  },
  fromMode: {
    rgb: (c4) => convertLabToLch_default(convertRgbToLab_default(c4)),
    lab: convertLabToLch_default
  },
  channels: ["l", "c", "h", "alpha"],
  ranges: {
    l: [0, 100],
    c: [0, 150],
    h: [0, 360]
  },
  parse: [parseLch_default],
  serialize: (c4) => `lch(${c4.l !== void 0 ? c4.l : "none"} ${c4.c !== void 0 ? c4.c : "none"} ${c4.h !== void 0 ? c4.h : "none"}${c4.alpha < 1 ? ` / ${c4.alpha}` : ""})`,
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    c: interpolatorLinear,
    l: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueChroma
  },
  average: {
    h: averageAngle
  }
};
var definition_default15 = definition15;

// node_modules/culori/src/lch65/definition.js
var definition16 = {
  ...definition_default15,
  mode: "lch65",
  parse: ["--lch-d65"],
  serialize: "--lch-d65",
  toMode: {
    lab65: (c4) => convertLchToLab_default(c4, "lab65"),
    rgb: (c4) => convertLab65ToRgb_default(convertLchToLab_default(c4, "lab65"))
  },
  fromMode: {
    rgb: (c4) => convertLabToLch_default(convertRgbToLab65_default(c4), "lch65"),
    lab65: (c4) => convertLabToLch_default(c4, "lch65")
  },
  ranges: {
    l: [0, 100],
    c: [0, 150],
    h: [0, 360]
  }
};
var definition_default16 = definition16;

// node_modules/culori/src/lchuv/convertLuvToLchuv.js
var convertLuvToLchuv = ({ l: l3, u: u4, v: v2, alpha }) => {
  if (u4 === void 0)
    u4 = 0;
  if (v2 === void 0)
    v2 = 0;
  let c4 = Math.sqrt(u4 * u4 + v2 * v2);
  let res = {
    mode: "lchuv",
    l: l3,
    c: c4
  };
  if (c4) {
    res.h = normalizeHue_default(Math.atan2(v2, u4) * 180 / Math.PI);
  }
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertLuvToLchuv_default = convertLuvToLchuv;

// node_modules/culori/src/lchuv/convertLchuvToLuv.js
var convertLchuvToLuv = ({ l: l3, c: c4, h: h4, alpha }) => {
  if (h4 === void 0)
    h4 = 0;
  let res = {
    mode: "luv",
    l: l3,
    u: c4 ? c4 * Math.cos(h4 / 180 * Math.PI) : 0,
    v: c4 ? c4 * Math.sin(h4 / 180 * Math.PI) : 0
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertLchuvToLuv_default = convertLchuvToLuv;

// node_modules/culori/src/luv/convertXyz50ToLuv.js
var u_fn = (x6, y6, z2) => 4 * x6 / (x6 + 15 * y6 + 3 * z2);
var v_fn = (x6, y6, z2) => 9 * y6 / (x6 + 15 * y6 + 3 * z2);
var un = u_fn(D50.X, D50.Y, D50.Z);
var vn = v_fn(D50.X, D50.Y, D50.Z);
var l_fn = (value) => value <= e3 ? k3 * value : 116 * Math.cbrt(value) - 16;
var convertXyz50ToLuv = ({ x: x6, y: y6, z: z2, alpha }) => {
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (z2 === void 0)
    z2 = 0;
  let l3 = l_fn(y6 / D50.Y);
  let u4 = u_fn(x6, y6, z2);
  let v2 = v_fn(x6, y6, z2);
  if (!isFinite(u4) || !isFinite(v2)) {
    l3 = u4 = v2 = 0;
  } else {
    u4 = 13 * l3 * (u4 - un);
    v2 = 13 * l3 * (v2 - vn);
  }
  let res = {
    mode: "luv",
    l: l3,
    u: u4,
    v: v2
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz50ToLuv_default = convertXyz50ToLuv;

// node_modules/culori/src/luv/convertLuvToXyz50.js
var u_fn2 = (x6, y6, z2) => 4 * x6 / (x6 + 15 * y6 + 3 * z2);
var v_fn2 = (x6, y6, z2) => 9 * y6 / (x6 + 15 * y6 + 3 * z2);
var un2 = u_fn2(D50.X, D50.Y, D50.Z);
var vn2 = v_fn2(D50.X, D50.Y, D50.Z);
var convertLuvToXyz50 = ({ l: l3, u: u4, v: v2, alpha }) => {
  if (l3 === void 0)
    l3 = 0;
  if (l3 === 0) {
    return { mode: "xyz50", x: 0, y: 0, z: 0 };
  }
  if (u4 === void 0)
    u4 = 0;
  if (v2 === void 0)
    v2 = 0;
  let up = u4 / (13 * l3) + un2;
  let vp = v2 / (13 * l3) + vn2;
  let y6 = D50.Y * (l3 <= 8 ? l3 / k3 : Math.pow((l3 + 16) / 116, 3));
  let x6 = y6 * (9 * up) / (4 * vp);
  let z2 = y6 * (12 - 3 * up - 20 * vp) / (4 * vp);
  let res = { mode: "xyz50", x: x6, y: y6, z: z2 };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertLuvToXyz50_default = convertLuvToXyz50;

// node_modules/culori/src/lchuv/definition.js
var convertRgbToLchuv = (rgb4) => convertLuvToLchuv_default(convertXyz50ToLuv_default(convertRgbToXyz50_default(rgb4)));
var convertLchuvToRgb = (lchuv2) => convertXyz50ToRgb_default(convertLuvToXyz50_default(convertLchuvToLuv_default(lchuv2)));
var definition17 = {
  mode: "lchuv",
  toMode: {
    luv: convertLchuvToLuv_default,
    rgb: convertLchuvToRgb
  },
  fromMode: {
    rgb: convertRgbToLchuv,
    luv: convertLuvToLchuv_default
  },
  channels: ["l", "c", "h", "alpha"],
  parse: ["--lchuv"],
  serialize: "--lchuv",
  ranges: {
    l: [0, 100],
    c: [0, 176.956],
    h: [0, 360]
  },
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    c: interpolatorLinear,
    l: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueChroma
  },
  average: {
    h: averageAngle
  }
};
var definition_default17 = definition17;

// node_modules/culori/src/lrgb/definition.js
var definition18 = {
  ...definition_default,
  mode: "lrgb",
  toMode: {
    rgb: convertLrgbToRgb_default
  },
  fromMode: {
    rgb: convertRgbToLrgb_default
  },
  parse: ["srgb-linear"],
  serialize: "srgb-linear"
};
var definition_default18 = definition18;

// node_modules/culori/src/luv/definition.js
var definition19 = {
  mode: "luv",
  toMode: {
    xyz50: convertLuvToXyz50_default,
    rgb: (luv2) => convertXyz50ToRgb_default(convertLuvToXyz50_default(luv2))
  },
  fromMode: {
    xyz50: convertXyz50ToLuv_default,
    rgb: (rgb4) => convertXyz50ToLuv_default(convertRgbToXyz50_default(rgb4))
  },
  channels: ["l", "u", "v", "alpha"],
  parse: ["--luv"],
  serialize: "--luv",
  ranges: {
    l: [0, 100],
    u: [-84.936, 175.042],
    v: [-125.882, 87.243]
  },
  interpolate: {
    l: interpolatorLinear,
    u: interpolatorLinear,
    v: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
};
var definition_default19 = definition19;

// node_modules/culori/src/oklab/convertLrgbToOklab.js
var convertLrgbToOklab = ({ r: r5, g: g3, b: b2, alpha }) => {
  if (r5 === void 0)
    r5 = 0;
  if (g3 === void 0)
    g3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let L3 = Math.cbrt(
    0.412221469470763 * r5 + 0.5363325372617348 * g3 + 0.0514459932675022 * b2
  );
  let M4 = Math.cbrt(
    0.2119034958178252 * r5 + 0.6806995506452344 * g3 + 0.1073969535369406 * b2
  );
  let S2 = Math.cbrt(
    0.0883024591900564 * r5 + 0.2817188391361215 * g3 + 0.6299787016738222 * b2
  );
  let res = {
    mode: "oklab",
    l: 0.210454268309314 * L3 + 0.7936177747023054 * M4 - 0.0040720430116193 * S2,
    a: 1.9779985324311684 * L3 - 2.42859224204858 * M4 + 0.450593709617411 * S2,
    b: 0.0259040424655478 * L3 + 0.7827717124575296 * M4 - 0.8086757549230774 * S2
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertLrgbToOklab_default = convertLrgbToOklab;

// node_modules/culori/src/oklab/convertRgbToOklab.js
var convertRgbToOklab = (rgb4) => {
  let res = convertLrgbToOklab_default(convertRgbToLrgb_default(rgb4));
  if (rgb4.r === rgb4.b && rgb4.b === rgb4.g) {
    res.a = res.b = 0;
  }
  return res;
};
var convertRgbToOklab_default = convertRgbToOklab;

// node_modules/culori/src/oklab/convertOklabToLrgb.js
var convertOklabToLrgb = ({ l: l3, a: a3, b: b2, alpha }) => {
  if (l3 === void 0)
    l3 = 0;
  if (a3 === void 0)
    a3 = 0;
  if (b2 === void 0)
    b2 = 0;
  let L3 = Math.pow(l3 + 0.3963377773761749 * a3 + 0.2158037573099136 * b2, 3);
  let M4 = Math.pow(l3 - 0.1055613458156586 * a3 - 0.0638541728258133 * b2, 3);
  let S2 = Math.pow(l3 - 0.0894841775298119 * a3 - 1.2914855480194092 * b2, 3);
  let res = {
    mode: "lrgb",
    r: 4.076741636075957 * L3 - 3.3077115392580616 * M4 + 0.2309699031821044 * S2,
    g: -1.2684379732850317 * L3 + 2.6097573492876887 * M4 - 0.3413193760026573 * S2,
    b: -0.0041960761386756 * L3 - 0.7034186179359362 * M4 + 1.7076146940746117 * S2
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertOklabToLrgb_default = convertOklabToLrgb;

// node_modules/culori/src/oklab/convertOklabToRgb.js
var convertOklabToRgb = (c4) => convertLrgbToRgb_default(convertOklabToLrgb_default(c4));
var convertOklabToRgb_default = convertOklabToRgb;

// node_modules/culori/src/okhsl/helpers.js
function toe(x6) {
  const k_1 = 0.206;
  const k_2 = 0.03;
  const k_3 = (1 + k_1) / (1 + k_2);
  return 0.5 * (k_3 * x6 - k_1 + Math.sqrt((k_3 * x6 - k_1) * (k_3 * x6 - k_1) + 4 * k_2 * k_3 * x6));
}
function toe_inv(x6) {
  const k_1 = 0.206;
  const k_2 = 0.03;
  const k_3 = (1 + k_1) / (1 + k_2);
  return (x6 * x6 + k_1 * x6) / (k_3 * (x6 + k_2));
}
function compute_max_saturation(a3, b2) {
  let k0, k1, k22, k32, k42, wl, wm, ws;
  if (-1.88170328 * a3 - 0.80936493 * b2 > 1) {
    k0 = 1.19086277;
    k1 = 1.76576728;
    k22 = 0.59662641;
    k32 = 0.75515197;
    k42 = 0.56771245;
    wl = 4.0767416621;
    wm = -3.3077115913;
    ws = 0.2309699292;
  } else if (1.81444104 * a3 - 1.19445276 * b2 > 1) {
    k0 = 0.73956515;
    k1 = -0.45954404;
    k22 = 0.08285427;
    k32 = 0.1254107;
    k42 = 0.14503204;
    wl = -1.2684380046;
    wm = 2.6097574011;
    ws = -0.3413193965;
  } else {
    k0 = 1.35733652;
    k1 = -915799e-8;
    k22 = -1.1513021;
    k32 = -0.50559606;
    k42 = 692167e-8;
    wl = -0.0041960863;
    wm = -0.7034186147;
    ws = 1.707614701;
  }
  let S2 = k0 + k1 * a3 + k22 * b2 + k32 * a3 * a3 + k42 * a3 * b2;
  let k_l = 0.3963377774 * a3 + 0.2158037573 * b2;
  let k_m = -0.1055613458 * a3 - 0.0638541728 * b2;
  let k_s = -0.0894841775 * a3 - 1.291485548 * b2;
  {
    let l_ = 1 + S2 * k_l;
    let m_ = 1 + S2 * k_m;
    let s_ = 1 + S2 * k_s;
    let l3 = l_ * l_ * l_;
    let m3 = m_ * m_ * m_;
    let s3 = s_ * s_ * s_;
    let l_dS = 3 * k_l * l_ * l_;
    let m_dS = 3 * k_m * m_ * m_;
    let s_dS = 3 * k_s * s_ * s_;
    let l_dS2 = 6 * k_l * k_l * l_;
    let m_dS2 = 6 * k_m * k_m * m_;
    let s_dS2 = 6 * k_s * k_s * s_;
    let f5 = wl * l3 + wm * m3 + ws * s3;
    let f1 = wl * l_dS + wm * m_dS + ws * s_dS;
    let f22 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;
    S2 = S2 - f5 * f1 / (f1 * f1 - 0.5 * f5 * f22);
  }
  return S2;
}
function find_cusp(a3, b2) {
  let S_cusp = compute_max_saturation(a3, b2);
  let rgb4 = convertOklabToLrgb_default({ l: 1, a: S_cusp * a3, b: S_cusp * b2 });
  let L_cusp = Math.cbrt(1 / Math.max(rgb4.r, rgb4.g, rgb4.b));
  let C_cusp = L_cusp * S_cusp;
  return [L_cusp, C_cusp];
}
function find_gamut_intersection(a3, b2, L1, C12, L0, cusp = null) {
  if (!cusp) {
    cusp = find_cusp(a3, b2);
  }
  let t2;
  if ((L1 - L0) * cusp[1] - (cusp[0] - L0) * C12 <= 0) {
    t2 = cusp[1] * L0 / (C12 * cusp[0] + cusp[1] * (L0 - L1));
  } else {
    t2 = cusp[1] * (L0 - 1) / (C12 * (cusp[0] - 1) + cusp[1] * (L0 - L1));
    {
      let dL = L1 - L0;
      let dC = C12;
      let k_l = 0.3963377774 * a3 + 0.2158037573 * b2;
      let k_m = -0.1055613458 * a3 - 0.0638541728 * b2;
      let k_s = -0.0894841775 * a3 - 1.291485548 * b2;
      let l_dt = dL + dC * k_l;
      let m_dt = dL + dC * k_m;
      let s_dt = dL + dC * k_s;
      {
        let L3 = L0 * (1 - t2) + t2 * L1;
        let C4 = t2 * C12;
        let l_ = L3 + C4 * k_l;
        let m_ = L3 + C4 * k_m;
        let s_ = L3 + C4 * k_s;
        let l3 = l_ * l_ * l_;
        let m3 = m_ * m_ * m_;
        let s3 = s_ * s_ * s_;
        let ldt = 3 * l_dt * l_ * l_;
        let mdt = 3 * m_dt * m_ * m_;
        let sdt = 3 * s_dt * s_ * s_;
        let ldt2 = 6 * l_dt * l_dt * l_;
        let mdt2 = 6 * m_dt * m_dt * m_;
        let sdt2 = 6 * s_dt * s_dt * s_;
        let r5 = 4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3 - 1;
        let r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt;
        let r22 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2;
        let u_r = r1 / (r1 * r1 - 0.5 * r5 * r22);
        let t_r = -r5 * u_r;
        let g3 = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3 - 1;
        let g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt;
        let g22 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2;
        let u_g = g1 / (g1 * g1 - 0.5 * g3 * g22);
        let t_g = -g3 * u_g;
        let b3 = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3 - 1;
        let b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt;
        let b22 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2;
        let u_b = b1 / (b1 * b1 - 0.5 * b3 * b22);
        let t_b = -b3 * u_b;
        t_r = u_r >= 0 ? t_r : 1e6;
        t_g = u_g >= 0 ? t_g : 1e6;
        t_b = u_b >= 0 ? t_b : 1e6;
        t2 += Math.min(t_r, Math.min(t_g, t_b));
      }
    }
  }
  return t2;
}
function get_ST_max(a_, b_, cusp = null) {
  if (!cusp) {
    cusp = find_cusp(a_, b_);
  }
  let L3 = cusp[0];
  let C4 = cusp[1];
  return [C4 / L3, C4 / (1 - L3)];
}
function get_Cs(L3, a_, b_) {
  let cusp = find_cusp(a_, b_);
  let C_max = find_gamut_intersection(a_, b_, L3, 1, L3, cusp);
  let ST_max = get_ST_max(a_, b_, cusp);
  let S_mid = 0.11516993 + 1 / (7.4477897 + 4.1590124 * b_ + a_ * (-2.19557347 + 1.75198401 * b_ + a_ * (-2.13704948 - 10.02301043 * b_ + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_))));
  let T_mid = 0.11239642 + 1 / (1.6132032 - 0.68124379 * b_ + a_ * (0.40370612 + 0.90148123 * b_ + a_ * (-0.27087943 + 0.6122399 * b_ + a_ * (299215e-8 - 0.45399568 * b_ - 0.14661872 * a_))));
  let k5 = C_max / Math.min(L3 * ST_max[0], (1 - L3) * ST_max[1]);
  let C_a = L3 * S_mid;
  let C_b = (1 - L3) * T_mid;
  let C_mid = 0.9 * k5 * Math.sqrt(
    Math.sqrt(
      1 / (1 / (C_a * C_a * C_a * C_a) + 1 / (C_b * C_b * C_b * C_b))
    )
  );
  C_a = L3 * 0.4;
  C_b = (1 - L3) * 0.8;
  let C_0 = Math.sqrt(1 / (1 / (C_a * C_a) + 1 / (C_b * C_b)));
  return [C_0, C_mid, C_max];
}

// node_modules/culori/src/okhsl/convertOklabToOkhsl.js
function convertOklabToOkhsl(lab2) {
  const l3 = lab2.l !== void 0 ? lab2.l : 0;
  const a3 = lab2.a !== void 0 ? lab2.a : 0;
  const b2 = lab2.b !== void 0 ? lab2.b : 0;
  const ret = { mode: "okhsl", l: toe(l3) };
  if (lab2.alpha !== void 0) {
    ret.alpha = lab2.alpha;
  }
  let c4 = Math.sqrt(a3 * a3 + b2 * b2);
  if (!c4) {
    ret.s = 0;
    return ret;
  }
  let [C_0, C_mid, C_max] = get_Cs(l3, a3 / c4, b2 / c4);
  let s3;
  if (c4 < C_mid) {
    let k_0 = 0;
    let k_1 = 0.8 * C_0;
    let k_2 = 1 - k_1 / C_mid;
    let t2 = (c4 - k_0) / (k_1 + k_2 * (c4 - k_0));
    s3 = t2 * 0.8;
  } else {
    let k_0 = C_mid;
    let k_1 = 0.2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
    let k_2 = 1 - k_1 / (C_max - C_mid);
    let t2 = (c4 - k_0) / (k_1 + k_2 * (c4 - k_0));
    s3 = 0.8 + 0.2 * t2;
  }
  if (s3) {
    ret.s = s3;
    ret.h = normalizeHue_default(Math.atan2(b2, a3) * 180 / Math.PI);
  }
  return ret;
}

// node_modules/culori/src/okhsl/convertOkhslToOklab.js
function convertOkhslToOklab(hsl4) {
  let h4 = hsl4.h !== void 0 ? hsl4.h : 0;
  let s3 = hsl4.s !== void 0 ? hsl4.s : 0;
  let l3 = hsl4.l !== void 0 ? hsl4.l : 0;
  const ret = { mode: "oklab", l: toe_inv(l3) };
  if (hsl4.alpha !== void 0) {
    ret.alpha = hsl4.alpha;
  }
  if (!s3 || l3 === 1) {
    ret.a = ret.b = 0;
    return ret;
  }
  let a_ = Math.cos(h4 / 180 * Math.PI);
  let b_ = Math.sin(h4 / 180 * Math.PI);
  let [C_0, C_mid, C_max] = get_Cs(ret.l, a_, b_);
  let t2, k_0, k_1, k_2;
  if (s3 < 0.8) {
    t2 = 1.25 * s3;
    k_0 = 0;
    k_1 = 0.8 * C_0;
    k_2 = 1 - k_1 / C_mid;
  } else {
    t2 = 5 * (s3 - 0.8);
    k_0 = C_mid;
    k_1 = 0.2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
    k_2 = 1 - k_1 / (C_max - C_mid);
  }
  let C4 = k_0 + t2 * k_1 / (1 - k_2 * t2);
  ret.a = C4 * a_;
  ret.b = C4 * b_;
  return ret;
}

// node_modules/culori/src/okhsl/modeOkhsl.js
var modeOkhsl = {
  ...definition_default7,
  mode: "okhsl",
  channels: ["h", "s", "l", "alpha"],
  parse: ["--okhsl"],
  serialize: "--okhsl",
  fromMode: {
    oklab: convertOklabToOkhsl,
    rgb: (c4) => convertOklabToOkhsl(convertRgbToOklab_default(c4))
  },
  toMode: {
    oklab: convertOkhslToOklab,
    rgb: (c4) => convertOklabToRgb_default(convertOkhslToOklab(c4))
  }
};
var modeOkhsl_default = modeOkhsl;

// node_modules/culori/src/okhsv/convertOklabToOkhsv.js
function convertOklabToOkhsv(lab2) {
  let l3 = lab2.l !== void 0 ? lab2.l : 0;
  let a3 = lab2.a !== void 0 ? lab2.a : 0;
  let b2 = lab2.b !== void 0 ? lab2.b : 0;
  let c4 = Math.sqrt(a3 * a3 + b2 * b2);
  let a_ = c4 ? a3 / c4 : 1;
  let b_ = c4 ? b2 / c4 : 1;
  let [S_max, T3] = get_ST_max(a_, b_);
  let S_0 = 0.5;
  let k5 = 1 - S_0 / S_max;
  let t2 = T3 / (c4 + l3 * T3);
  let L_v = t2 * l3;
  let C_v = t2 * c4;
  let L_vt = toe_inv(L_v);
  let C_vt = C_v * L_vt / L_v;
  let rgb_scale = convertOklabToLrgb_default({ l: L_vt, a: a_ * C_vt, b: b_ * C_vt });
  let scale_L = Math.cbrt(
    1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0)
  );
  l3 = l3 / scale_L;
  c4 = c4 / scale_L * toe(l3) / l3;
  l3 = toe(l3);
  const ret = {
    mode: "okhsv",
    s: c4 ? (S_0 + T3) * C_v / (T3 * S_0 + T3 * k5 * C_v) : 0,
    v: l3 ? l3 / L_v : 0
  };
  if (ret.s) {
    ret.h = normalizeHue_default(Math.atan2(b2, a3) * 180 / Math.PI);
  }
  if (lab2.alpha !== void 0) {
    ret.alpha = lab2.alpha;
  }
  return ret;
}

// node_modules/culori/src/okhsv/convertOkhsvToOklab.js
function convertOkhsvToOklab(hsv2) {
  const ret = { mode: "oklab" };
  if (hsv2.alpha !== void 0) {
    ret.alpha = hsv2.alpha;
  }
  const h4 = hsv2.h !== void 0 ? hsv2.h : 0;
  const s3 = hsv2.s !== void 0 ? hsv2.s : 0;
  const v2 = hsv2.v !== void 0 ? hsv2.v : 0;
  const a_ = Math.cos(h4 / 180 * Math.PI);
  const b_ = Math.sin(h4 / 180 * Math.PI);
  const [S_max, T3] = get_ST_max(a_, b_);
  const S_0 = 0.5;
  const k5 = 1 - S_0 / S_max;
  const L_v = 1 - s3 * S_0 / (S_0 + T3 - T3 * k5 * s3);
  const C_v = s3 * T3 * S_0 / (S_0 + T3 - T3 * k5 * s3);
  const L_vt = toe_inv(L_v);
  const C_vt = C_v * L_vt / L_v;
  const rgb_scale = convertOklabToLrgb_default({
    l: L_vt,
    a: a_ * C_vt,
    b: b_ * C_vt
  });
  const scale_L = Math.cbrt(
    1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0)
  );
  const L_new = toe_inv(v2 * L_v);
  const C4 = C_v * L_new / L_v;
  ret.l = L_new * scale_L;
  ret.a = C4 * a_ * scale_L;
  ret.b = C4 * b_ * scale_L;
  return ret;
}

// node_modules/culori/src/okhsv/modeOkhsv.js
var modeOkhsv = {
  ...definition_default8,
  mode: "okhsv",
  channels: ["h", "s", "v", "alpha"],
  parse: ["--okhsv"],
  serialize: "--okhsv",
  fromMode: {
    oklab: convertOklabToOkhsv,
    rgb: (c4) => convertOklabToOkhsv(convertRgbToOklab_default(c4))
  },
  toMode: {
    oklab: convertOkhsvToOklab,
    rgb: (c4) => convertOklabToRgb_default(convertOkhsvToOklab(c4))
  }
};
var modeOkhsv_default = modeOkhsv;

// node_modules/culori/src/oklab/parseOklab.js
function parseOklab(color3, parsed) {
  if (!parsed || parsed[0] !== "oklab") {
    return void 0;
  }
  const res = { mode: "oklab" };
  const [, l3, a3, b2, alpha] = parsed;
  if (l3.type === Tok.Hue || a3.type === Tok.Hue || b2.type === Tok.Hue) {
    return void 0;
  }
  if (l3.type !== Tok.None) {
    res.l = Math.min(
      Math.max(0, l3.type === Tok.Number ? l3.value : l3.value / 100),
      1
    );
  }
  if (a3.type !== Tok.None) {
    res.a = a3.type === Tok.Number ? a3.value : a3.value * 0.4 / 100;
  }
  if (b2.type !== Tok.None) {
    res.b = b2.type === Tok.Number ? b2.value : b2.value * 0.4 / 100;
  }
  if (alpha.type !== Tok.None) {
    res.alpha = Math.min(
      1,
      Math.max(
        0,
        alpha.type === Tok.Number ? alpha.value : alpha.value / 100
      )
    );
  }
  return res;
}
var parseOklab_default = parseOklab;

// node_modules/culori/src/oklab/definition.js
var definition20 = {
  ...definition_default13,
  mode: "oklab",
  toMode: {
    lrgb: convertOklabToLrgb_default,
    rgb: convertOklabToRgb_default
  },
  fromMode: {
    lrgb: convertLrgbToOklab_default,
    rgb: convertRgbToOklab_default
  },
  ranges: {
    l: [0, 1],
    a: [-0.4, 0.4],
    b: [-0.4, 0.4]
  },
  parse: [parseOklab_default],
  serialize: (c4) => `oklab(${c4.l !== void 0 ? c4.l : "none"} ${c4.a !== void 0 ? c4.a : "none"} ${c4.b !== void 0 ? c4.b : "none"}${c4.alpha < 1 ? ` / ${c4.alpha}` : ""})`
};
var definition_default20 = definition20;

// node_modules/culori/src/oklch/parseOklch.js
function parseOklch(color3, parsed) {
  if (!parsed || parsed[0] !== "oklch") {
    return void 0;
  }
  const res = { mode: "oklch" };
  const [, l3, c4, h4, alpha] = parsed;
  if (l3.type !== Tok.None) {
    if (l3.type === Tok.Hue) {
      return void 0;
    }
    res.l = Math.min(
      Math.max(0, l3.type === Tok.Number ? l3.value : l3.value / 100),
      1
    );
  }
  if (c4.type !== Tok.None) {
    res.c = Math.max(
      0,
      c4.type === Tok.Number ? c4.value : c4.value * 0.4 / 100
    );
  }
  if (h4.type !== Tok.None) {
    if (h4.type === Tok.Percentage) {
      return void 0;
    }
    res.h = h4.value;
  }
  if (alpha.type !== Tok.None) {
    res.alpha = Math.min(
      1,
      Math.max(
        0,
        alpha.type === Tok.Number ? alpha.value : alpha.value / 100
      )
    );
  }
  return res;
}
var parseOklch_default = parseOklch;

// node_modules/culori/src/oklch/definition.js
var definition21 = {
  ...definition_default15,
  mode: "oklch",
  toMode: {
    oklab: (c4) => convertLchToLab_default(c4, "oklab"),
    rgb: (c4) => convertOklabToRgb_default(convertLchToLab_default(c4, "oklab"))
  },
  fromMode: {
    rgb: (c4) => convertLabToLch_default(convertRgbToOklab_default(c4), "oklch"),
    oklab: (c4) => convertLabToLch_default(c4, "oklch")
  },
  parse: [parseOklch_default],
  serialize: (c4) => `oklch(${c4.l !== void 0 ? c4.l : "none"} ${c4.c !== void 0 ? c4.c : "none"} ${c4.h !== void 0 ? c4.h : "none"}${c4.alpha < 1 ? ` / ${c4.alpha}` : ""})`,
  ranges: {
    l: [0, 1],
    c: [0, 0.4],
    h: [0, 360]
  }
};
var definition_default21 = definition21;

// node_modules/culori/src/p3/convertP3ToXyz65.js
var convertP3ToXyz65 = (rgb4) => {
  let { r: r5, g: g3, b: b2, alpha } = convertRgbToLrgb_default(rgb4);
  let res = {
    mode: "xyz65",
    x: 0.486570948648216 * r5 + 0.265667693169093 * g3 + 0.1982172852343625 * b2,
    y: 0.2289745640697487 * r5 + 0.6917385218365062 * g3 + 0.079286914093745 * b2,
    z: 0 * r5 + 0.0451133818589026 * g3 + 1.043944368900976 * b2
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertP3ToXyz65_default = convertP3ToXyz65;

// node_modules/culori/src/p3/convertXyz65ToP3.js
var convertXyz65ToP3 = ({ x: x6, y: y6, z: z2, alpha }) => {
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (z2 === void 0)
    z2 = 0;
  let res = convertLrgbToRgb_default(
    {
      r: x6 * 2.4934969119414263 - y6 * 0.9313836179191242 - 0.402710784450717 * z2,
      g: x6 * -0.8294889695615749 + y6 * 1.7626640603183465 + 0.0236246858419436 * z2,
      b: x6 * 0.0358458302437845 - y6 * 0.0761723892680418 + 0.9568845240076871 * z2
    },
    "p3"
  );
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz65ToP3_default = convertXyz65ToP3;

// node_modules/culori/src/p3/definition.js
var definition22 = {
  ...definition_default,
  mode: "p3",
  parse: ["display-p3"],
  serialize: "display-p3",
  fromMode: {
    rgb: (color3) => convertXyz65ToP3_default(convertRgbToXyz65_default(color3)),
    xyz65: convertXyz65ToP3_default
  },
  toMode: {
    rgb: (color3) => convertXyz65ToRgb_default(convertP3ToXyz65_default(color3)),
    xyz65: convertP3ToXyz65_default
  }
};
var definition_default22 = definition22;

// node_modules/culori/src/prophoto/convertXyz50ToProphoto.js
var gamma2 = (v2) => {
  let abs4 = Math.abs(v2);
  if (abs4 >= 1 / 512) {
    return Math.sign(v2) * Math.pow(abs4, 1 / 1.8);
  }
  return 16 * v2;
};
var convertXyz50ToProphoto = ({ x: x6, y: y6, z: z2, alpha }) => {
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (z2 === void 0)
    z2 = 0;
  let res = {
    mode: "prophoto",
    r: gamma2(
      x6 * 1.3457868816471585 - y6 * 0.2555720873797946 - 0.0511018649755453 * z2
    ),
    g: gamma2(
      x6 * -0.5446307051249019 + y6 * 1.5082477428451466 + 0.0205274474364214 * z2
    ),
    b: gamma2(x6 * 0 + y6 * 0 + 1.2119675456389452 * z2)
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz50ToProphoto_default = convertXyz50ToProphoto;

// node_modules/culori/src/prophoto/convertProphotoToXyz50.js
var linearize2 = (v2 = 0) => {
  let abs4 = Math.abs(v2);
  if (abs4 >= 16 / 512) {
    return Math.sign(v2) * Math.pow(abs4, 1.8);
  }
  return v2 / 16;
};
var convertProphotoToXyz50 = (prophoto2) => {
  let r5 = linearize2(prophoto2.r);
  let g3 = linearize2(prophoto2.g);
  let b2 = linearize2(prophoto2.b);
  let res = {
    mode: "xyz50",
    x: 0.7977666449006423 * r5 + 0.1351812974005331 * g3 + 0.0313477341283922 * b2,
    y: 0.2880748288194013 * r5 + 0.7118352342418731 * g3 + 899369387256e-16 * b2,
    z: 0 * r5 + 0 * g3 + 0.8251046025104602 * b2
  };
  if (prophoto2.alpha !== void 0) {
    res.alpha = prophoto2.alpha;
  }
  return res;
};
var convertProphotoToXyz50_default = convertProphotoToXyz50;

// node_modules/culori/src/prophoto/definition.js
var definition23 = {
  ...definition_default,
  mode: "prophoto",
  parse: ["prophoto-rgb"],
  serialize: "prophoto-rgb",
  fromMode: {
    xyz50: convertXyz50ToProphoto_default,
    rgb: (color3) => convertXyz50ToProphoto_default(convertRgbToXyz50_default(color3))
  },
  toMode: {
    xyz50: convertProphotoToXyz50_default,
    rgb: (color3) => convertXyz50ToRgb_default(convertProphotoToXyz50_default(color3))
  }
};
var definition_default23 = definition23;

// node_modules/culori/src/rec2020/convertXyz65ToRec2020.js
var \u03B1 = 1.09929682680944;
var \u03B2 = 0.018053968510807;
var gamma3 = (v2) => {
  const abs4 = Math.abs(v2);
  if (abs4 > \u03B2) {
    return (Math.sign(v2) || 1) * (\u03B1 * Math.pow(abs4, 0.45) - (\u03B1 - 1));
  }
  return 4.5 * v2;
};
var convertXyz65ToRec2020 = ({ x: x6, y: y6, z: z2, alpha }) => {
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (z2 === void 0)
    z2 = 0;
  let res = {
    mode: "rec2020",
    r: gamma3(
      x6 * 1.7166511879712683 - y6 * 0.3556707837763925 - 0.2533662813736599 * z2
    ),
    g: gamma3(
      x6 * -0.6666843518324893 + y6 * 1.6164812366349395 + 0.0157685458139111 * z2
    ),
    b: gamma3(
      x6 * 0.0176398574453108 - y6 * 0.0427706132578085 + 0.9421031212354739 * z2
    )
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz65ToRec2020_default = convertXyz65ToRec2020;

// node_modules/culori/src/rec2020/convertRec2020ToXyz65.js
var \u03B12 = 1.09929682680944;
var \u03B22 = 0.018053968510807;
var linearize3 = (v2 = 0) => {
  let abs4 = Math.abs(v2);
  if (abs4 < \u03B22 * 4.5) {
    return v2 / 4.5;
  }
  return (Math.sign(v2) || 1) * Math.pow((abs4 + \u03B12 - 1) / \u03B12, 1 / 0.45);
};
var convertRec2020ToXyz65 = (rec20202) => {
  let r5 = linearize3(rec20202.r);
  let g3 = linearize3(rec20202.g);
  let b2 = linearize3(rec20202.b);
  let res = {
    mode: "xyz65",
    x: 0.6369580483012911 * r5 + 0.1446169035862083 * g3 + 0.1688809751641721 * b2,
    y: 0.262700212011267 * r5 + 0.6779980715188708 * g3 + 0.059301716469862 * b2,
    z: 0 * r5 + 0.0280726930490874 * g3 + 1.0609850577107909 * b2
  };
  if (rec20202.alpha !== void 0) {
    res.alpha = rec20202.alpha;
  }
  return res;
};
var convertRec2020ToXyz65_default = convertRec2020ToXyz65;

// node_modules/culori/src/rec2020/definition.js
var definition24 = {
  ...definition_default,
  mode: "rec2020",
  fromMode: {
    xyz65: convertXyz65ToRec2020_default,
    rgb: (color3) => convertXyz65ToRec2020_default(convertRgbToXyz65_default(color3))
  },
  toMode: {
    xyz65: convertRec2020ToXyz65_default,
    rgb: (color3) => convertXyz65ToRgb_default(convertRec2020ToXyz65_default(color3))
  },
  parse: ["rec2020"],
  serialize: "rec2020"
};
var definition_default24 = definition24;

// node_modules/culori/src/xyb/constants.js
var bias = 0.0037930732552754493;
var bias_cbrt = Math.cbrt(bias);

// node_modules/culori/src/xyb/convertRgbToXyb.js
var transfer = (v2) => Math.cbrt(v2) - bias_cbrt;
var convertRgbToXyb = (color3) => {
  const { r: r5, g: g3, b: b2, alpha } = convertRgbToLrgb_default(color3);
  const l3 = transfer(0.3 * r5 + 0.622 * g3 + 0.078 * b2 + bias);
  const m3 = transfer(0.23 * r5 + 0.692 * g3 + 0.078 * b2 + bias);
  const s3 = transfer(
    0.2434226892454782 * r5 + 0.2047674442449682 * g3 + 0.5518098665095535 * b2 + bias
  );
  const res = {
    mode: "xyb",
    x: (l3 - m3) / 2,
    y: (l3 + m3) / 2,
    /* Apply default chroma from luma (subtract Y from B) */
    b: s3 - (l3 + m3) / 2
  };
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertRgbToXyb_default = convertRgbToXyb;

// node_modules/culori/src/xyb/convertXybToRgb.js
var transfer2 = (v2) => Math.pow(v2 + bias_cbrt, 3);
var convertXybToRgb = ({ x: x6, y: y6, b: b2, alpha }) => {
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (b2 === void 0)
    b2 = 0;
  const l3 = transfer2(x6 + y6) - bias;
  const m3 = transfer2(y6 - x6) - bias;
  const s3 = transfer2(b2 + y6) - bias;
  const res = convertLrgbToRgb_default({
    r: 11.031566904639861 * l3 - 9.866943908131562 * m3 - 0.16462299650829934 * s3,
    g: -3.2541473810744237 * l3 + 4.418770377582723 * m3 - 0.16462299650829934 * s3,
    b: -3.6588512867136815 * l3 + 2.7129230459360922 * m3 + 1.9459282407775895 * s3
  });
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertXybToRgb_default = convertXybToRgb;

// node_modules/culori/src/xyb/definition.js
var definition25 = {
  mode: "xyb",
  channels: ["x", "y", "b", "alpha"],
  parse: ["--xyb"],
  serialize: "--xyb",
  toMode: {
    rgb: convertXybToRgb_default
  },
  fromMode: {
    rgb: convertRgbToXyb_default
  },
  ranges: {
    x: [-0.0154, 0.0281],
    y: [0, 0.8453],
    b: [-0.2778, 0.388]
  },
  interpolate: {
    x: interpolatorLinear,
    y: interpolatorLinear,
    b: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
};
var definition_default25 = definition25;

// node_modules/culori/src/xyz50/definition.js
var definition26 = {
  mode: "xyz50",
  parse: ["xyz-d50"],
  serialize: "xyz-d50",
  toMode: {
    rgb: convertXyz50ToRgb_default,
    lab: convertXyz50ToLab_default
  },
  fromMode: {
    rgb: convertRgbToXyz50_default,
    lab: convertLabToXyz50_default
  },
  channels: ["x", "y", "z", "alpha"],
  ranges: {
    x: [0, 0.964],
    y: [0, 0.999],
    z: [0, 0.825]
  },
  interpolate: {
    x: interpolatorLinear,
    y: interpolatorLinear,
    z: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
};
var definition_default26 = definition26;

// node_modules/culori/src/xyz65/convertXyz65ToXyz50.js
var convertXyz65ToXyz50 = (xyz652) => {
  let { x: x6, y: y6, z: z2, alpha } = xyz652;
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (z2 === void 0)
    z2 = 0;
  let res = {
    mode: "xyz50",
    x: 1.0479298208405488 * x6 + 0.0229467933410191 * y6 - 0.0501922295431356 * z2,
    y: 0.0296278156881593 * x6 + 0.990434484573249 * y6 - 0.0170738250293851 * z2,
    z: -0.0092430581525912 * x6 + 0.0150551448965779 * y6 + 0.7518742899580008 * z2
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz65ToXyz50_default = convertXyz65ToXyz50;

// node_modules/culori/src/xyz65/convertXyz50ToXyz65.js
var convertXyz50ToXyz65 = (xyz502) => {
  let { x: x6, y: y6, z: z2, alpha } = xyz502;
  if (x6 === void 0)
    x6 = 0;
  if (y6 === void 0)
    y6 = 0;
  if (z2 === void 0)
    z2 = 0;
  let res = {
    mode: "xyz65",
    x: 0.9554734527042182 * x6 - 0.0230985368742614 * y6 + 0.0632593086610217 * z2,
    y: -0.0283697069632081 * x6 + 1.0099954580058226 * y6 + 0.021041398966943 * z2,
    z: 0.0123140016883199 * x6 - 0.0205076964334779 * y6 + 1.3303659366080753 * z2
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertXyz50ToXyz65_default = convertXyz50ToXyz65;

// node_modules/culori/src/xyz65/definition.js
var definition27 = {
  mode: "xyz65",
  toMode: {
    rgb: convertXyz65ToRgb_default,
    xyz50: convertXyz65ToXyz50_default
  },
  fromMode: {
    rgb: convertRgbToXyz65_default,
    xyz50: convertXyz50ToXyz65_default
  },
  ranges: {
    x: [0, 0.95],
    y: [0, 1],
    z: [0, 1.088]
  },
  channels: ["x", "y", "z", "alpha"],
  parse: ["xyz", "xyz-d65"],
  serialize: "xyz-d65",
  interpolate: {
    x: interpolatorLinear,
    y: interpolatorLinear,
    z: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
};
var definition_default27 = definition27;

// node_modules/culori/src/yiq/convertRgbToYiq.js
var convertRgbToYiq = ({ r: r5, g: g3, b: b2, alpha }) => {
  if (r5 === void 0)
    r5 = 0;
  if (g3 === void 0)
    g3 = 0;
  if (b2 === void 0)
    b2 = 0;
  const res = {
    mode: "yiq",
    y: 0.29889531 * r5 + 0.58662247 * g3 + 0.11448223 * b2,
    i: 0.59597799 * r5 - 0.2741761 * g3 - 0.32180189 * b2,
    q: 0.21147017 * r5 - 0.52261711 * g3 + 0.31114694 * b2
  };
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertRgbToYiq_default = convertRgbToYiq;

// node_modules/culori/src/yiq/convertYiqToRgb.js
var convertYiqToRgb = ({ y: y6, i: i4, q: q2, alpha }) => {
  if (y6 === void 0)
    y6 = 0;
  if (i4 === void 0)
    i4 = 0;
  if (q2 === void 0)
    q2 = 0;
  const res = {
    mode: "rgb",
    r: y6 + 0.95608445 * i4 + 0.6208885 * q2,
    g: y6 - 0.27137664 * i4 - 0.6486059 * q2,
    b: y6 - 1.10561724 * i4 + 1.70250126 * q2
  };
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertYiqToRgb_default = convertYiqToRgb;

// node_modules/culori/src/yiq/definition.js
var definition28 = {
  mode: "yiq",
  toMode: {
    rgb: convertYiqToRgb_default
  },
  fromMode: {
    rgb: convertRgbToYiq_default
  },
  channels: ["y", "i", "q", "alpha"],
  parse: ["--yiq"],
  serialize: "--yiq",
  ranges: {
    i: [-0.595, 0.595],
    q: [-0.522, 0.522]
  },
  interpolate: {
    y: interpolatorLinear,
    i: interpolatorLinear,
    q: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
};
var definition_default28 = definition28;

// node_modules/culori/src/round.js
var r = (value, precision) => Math.round(value * (precision = Math.pow(10, precision))) / precision;
var round = (precision = 4) => (value) => typeof value === "number" ? r(value, precision) : value;
var round_default = round;

// node_modules/culori/src/formatter.js
var twoDecimals = round_default(2);
var clamp = (value) => Math.max(0, Math.min(1, value || 0));
var fixup = (value) => Math.round(clamp(value) * 255);
var rgb = converter_default("rgb");
var hsl = converter_default("hsl");
var serializeHex = (color3) => {
  if (color3 === void 0) {
    return void 0;
  }
  let r5 = fixup(color3.r);
  let g3 = fixup(color3.g);
  let b2 = fixup(color3.b);
  return "#" + (1 << 24 | r5 << 16 | g3 << 8 | b2).toString(16).slice(1);
};
var serializeHex8 = (color3) => {
  if (color3 === void 0) {
    return void 0;
  }
  let a3 = fixup(color3.alpha !== void 0 ? color3.alpha : 1);
  return serializeHex(color3) + (1 << 8 | a3).toString(16).slice(1);
};
var formatHex = (c4) => serializeHex(rgb(c4));
var formatHex8 = (c4) => serializeHex8(rgb(c4));

// node_modules/culori/src/wcag.js
function luminance(color3) {
  let c4 = converter_default("lrgb")(color3);
  return 0.2126 * c4.r + 0.7152 * c4.g + 0.0722 * c4.b;
}
function contrast(a3, b2) {
  let L1 = luminance(a3);
  let L22 = luminance(b2);
  return (Math.max(L1, L22) + 0.05) / (Math.min(L1, L22) + 0.05);
}

// node_modules/culori/src/index.js
var a98 = useMode(definition_default2);
var cubehelix = useMode(definition_default3);
var dlab = useMode(definition_default4);
var dlch = useMode(definition_default5);
var hsi = useMode(definition_default6);
var hsl2 = useMode(definition_default7);
var hsv = useMode(definition_default8);
var hwb = useMode(definition_default9);
var itp = useMode(definition_default10);
var jab = useMode(definition_default11);
var jch = useMode(definition_default12);
var lab = useMode(definition_default13);
var lab65 = useMode(definition_default14);
var lch = useMode(definition_default15);
var lch65 = useMode(definition_default16);
var lchuv = useMode(definition_default17);
var lrgb = useMode(definition_default18);
var luv = useMode(definition_default19);
var okhsl = useMode(modeOkhsl_default);
var okhsv = useMode(modeOkhsv_default);
var oklab = useMode(definition_default20);
var oklch = useMode(definition_default21);
var p3 = useMode(definition_default22);
var prophoto = useMode(definition_default23);
var rec2020 = useMode(definition_default24);
var rgb2 = useMode(definition_default);
var xyb = useMode(definition_default25);
var xyz50 = useMode(definition_default26);
var xyz65 = useMode(definition_default27);
var yiq = useMode(definition_default28);

// node_modules/@antv/infographic/esm/utils/color.js
function hasColor(fill2) {
  if (!fill2)
    return false;
  const normalizedFill = fill2.trim().toLowerCase();
  if (normalizedFill === "none" || normalizedFill === "transparent" || normalizedFill === "") {
    return false;
  }
  return true;
}
function isDarkColor(color3) {
  const c4 = parse_default(color3);
  if (!c4)
    return false;
  const luminance2 = luminance(c4);
  return luminance2 < 0.5;
}

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e8) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array3, iteratee) {
  var index2 = -1, length = array3 == null ? 0 : array3.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array3[index2], index2, array3);
  }
  return result;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string2) {
  var index2 = string2.length;
  while (index2-- && reWhitespace.test(string2.charAt(index2))) {
  }
  return index2;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex_default(string2) + 1).replace(reTrimStart, "") : string2;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY2 || value === -INFINITY2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// node_modules/lodash-es/identity.js
function identity2(value) {
  return value;
}
var identity_default = identity2;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e8) {
    }
    try {
      return func + "";
    } catch (e8) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object2, key) {
  var value = getValue_default(object2, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = function() {
  function object2() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object2.prototype = proto;
    var result = new object2();
    object2.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array3) {
  var index2 = -1, length = source.length;
  array3 || (array3 = Array(length));
  while (++index2 < length) {
    array3[index2] = source[index2];
  }
  return array3;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e8) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string2) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string2),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array3, iteratee) {
  var index2 = -1, length = array3 == null ? 0 : array3.length;
  while (++index2 < length) {
    if (iteratee(array3[index2], index2, array3) === false) {
      break;
    }
  }
  return array3;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object2, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object2[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function assignValue(object2, key, value) {
  var objValue = object2[key];
  if (!(hasOwnProperty3.call(object2, key) && eq_default(objValue, value)) || value === void 0 && !(key in object2)) {
    baseAssignValue_default(object2, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object2, customizer) {
  var isNew = !object2;
  object2 || (object2 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object2, key, newValue);
    } else {
      assignValue_default(object2, key, newValue);
    }
  }
  return object2;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
function overRest(func, start2, transform2) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array3 = Array(length);
    while (++index2 < length) {
      array3[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform2(array3);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start2) {
  return setToString_default(overRest_default(func, start2, identity_default), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index2, object2) {
  if (!isObject_default(object2)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike_default(object2) && isIndex_default(index2, object2.length) : type2 == "string" && index2 in object2) {
    return eq_default(object2[index2], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object2, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object2 = Object(object2);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object2, source, index2, customizer);
      }
    }
    return object2;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/_isPrototype.js
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n4, iteratee) {
  var index2 = -1, result = Array(n4);
  while (++index2 < n4) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e8) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function baseKeys(object2) {
  if (!isPrototype_default(object2)) {
    return nativeKeys_default(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty6.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object2) {
  return isArrayLike_default(object2) ? arrayLikeKeys_default(object2) : baseKeys_default(object2);
}
var keys_default = keys;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function baseKeysIn(object2) {
  if (!isObject_default(object2)) {
    return nativeKeysIn_default(object2);
  }
  var isProto = isPrototype_default(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty7.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object2) {
  return isArrayLike_default(object2) ? arrayLikeKeys_default(object2, true) : baseKeysIn_default(object2);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object2) {
  if (isArray_default(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty8.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty9.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array3, key) {
  var length = array3.length;
  while (length--) {
    if (eq_default(array3[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match, number5, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number5 || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value, object2) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object2) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object2, path2) {
  path2 = castPath_default(path2, object2);
  var index2 = 0, length = path2.length;
  while (object2 != null && index2 < length) {
    object2 = object2[toKey_default(path2[index2++])];
  }
  return index2 && index2 == length ? object2 : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get(object2, path2, defaultValue) {
  var result = object2 == null ? void 0 : baseGet_default(object2, path2);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array3, values) {
  var index2 = -1, length = values.length, offset = array3.length;
  while (++index2 < length) {
    array3[offset + index2] = values[index2];
  }
  return array3;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto12 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty10.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array3, start2, end) {
  var index2 = -1, length = array3.length;
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start2 > end ? 0 : end - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array3[index2 + start2];
  }
  return result;
}
var baseSlice_default = baseSlice;

// node_modules/lodash-es/_castSlice.js
function castSlice(array3, start2, end) {
  var length = array3.length;
  end = end === void 0 ? length : end;
  return !start2 && end >= length ? array3 : baseSlice_default(array3, start2, end);
}
var castSlice_default = castSlice;

// node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string2) {
  return reHasUnicode.test(string2);
}
var hasUnicode_default = hasUnicode;

// node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string2) {
  return string2.split("");
}
var asciiToArray_default = asciiToArray;

// node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string2) {
  return string2.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// node_modules/lodash-es/_stringToArray.js
function stringToArray(string2) {
  return hasUnicode_default(string2) ? unicodeToArray_default(string2) : asciiToArray_default(string2);
}
var stringToArray_default = stringToArray;

// node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string2) {
    string2 = toString_default(string2);
    var strSymbols = hasUnicode_default(string2) ? stringToArray_default(string2) : void 0;
    var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string2.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default = createCaseFirst;

// node_modules/lodash-es/upperFirst.js
var upperFirst = createCaseFirst_default("toUpperCase");
var upperFirst_default = upperFirst;

// node_modules/lodash-es/capitalize.js
function capitalize(string2) {
  return upperFirst_default(toString_default(string2).toLowerCase());
}
var capitalize_default = capitalize;

// node_modules/lodash-es/_arrayReduce.js
function arrayReduce(array3, iteratee, accumulator, initAccum) {
  var index2 = -1, length = array3 == null ? 0 : array3.length;
  if (initAccum && length) {
    accumulator = array3[++index2];
  }
  while (++index2 < length) {
    accumulator = iteratee(accumulator, array3[index2], index2, array3);
  }
  return accumulator;
}
var arrayReduce_default = arrayReduce;

// node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object2) {
  return function(key) {
    return object2 == null ? void 0 : object2[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  "\xC6": "Ae",
  "\xE6": "ae",
  "\xDE": "Th",
  "\xFE": "th",
  "\xDF": "ss",
  // Latin Extended-A block.
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  "\u0132": "IJ",
  "\u0133": "ij",
  "\u0152": "Oe",
  "\u0153": "oe",
  "\u0149": "'n",
  "\u017F": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsCombo2 = "[" + rsComboRange3 + "]";
var reComboMark = RegExp(rsCombo2, "g");
function deburr(string2) {
  string2 = toString_default(string2);
  return string2 && string2.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// node_modules/lodash-es/_asciiWords.js
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string2) {
  return string2.match(reAsciiWord) || [];
}
var asciiWords_default = asciiWords;

// node_modules/lodash-es/_hasUnicodeWord.js
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string2) {
  return reHasUnicodeWord.test(string2);
}
var hasUnicodeWord_default = hasUnicodeWord;

// node_modules/lodash-es/_unicodeWords.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange4 = "\\u0300-\\u036f";
var reComboHalfMarksRange4 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange4 = "\\u20d0-\\u20ff";
var rsComboRange4 = rsComboMarksRange4 + reComboHalfMarksRange4 + rsComboSymbolsRange4;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos = "['\u2019]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo3 = "[" + rsComboRange4 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo3 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ3 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string2) {
  return string2.match(reUnicodeWord) || [];
}
var unicodeWords_default = unicodeWords;

// node_modules/lodash-es/words.js
function words(string2, pattern, guard) {
  string2 = toString_default(string2);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord_default(string2) ? unicodeWords_default(string2) : asciiWords_default(string2);
  }
  return string2.match(pattern) || [];
}
var words_default = words;

// node_modules/lodash-es/_createCompounder.js
var rsApos2 = "['\u2019]";
var reApos = RegExp(rsApos2, "g");
function createCompounder(callback) {
  return function(string2) {
    return arrayReduce_default(words_default(deburr_default(string2).replace(reApos, "")), callback, "");
  };
}
var createCompounder_default = createCompounder;

// node_modules/lodash-es/camelCase.js
var camelCase = createCompounder_default(function(result, word, index2) {
  word = word.toLowerCase();
  return result + (index2 ? capitalize_default(word) : word);
});
var camelCase_default = camelCase;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object2, source) {
  return object2 && copyObject_default(source, keys_default(source), object2);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object2, source) {
  return object2 && copyObject_default(source, keysIn_default(source), object2);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer3 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array3, predicate) {
  var index2 = -1, length = array3 == null ? 0 : array3.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array3[index2];
    if (predicate(value, index2, array3)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto13 = Object.prototype;
var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter_default(nativeGetSymbols(object2), function(symbol) {
    return propertyIsEnumerable2.call(object2, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object2) {
  return copyObject_default(source, getSymbols_default(source), object2);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object2) {
  var result = [];
  while (object2) {
    arrayPush_default(result, getSymbols_default(object2));
    object2 = getPrototype_default(object2);
  }
  return result;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object2) {
  return copyObject_default(source, getSymbolsIn_default(source), object2);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray_default(object2) ? result : arrayPush_default(result, symbolsFunc(object2));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object2) {
  return baseGetAllKeys_default(object2, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object2) {
  return baseGetAllKeys_default(object2, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_initCloneArray.js
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
function initCloneArray(array3) {
  var length = array3.length, result = new array3.constructor(length);
  if (length && typeof array3[0] == "string" && hasOwnProperty11.call(array3, "index")) {
    result.index = array3.index;
    result.input = array3.input;
  }
  return result;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object2, tag, isDeep) {
  var Ctor = object2.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object2);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object2);
    case dataViewTag3:
      return cloneDataView_default(object2, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object2, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object2);
    case regexpTag2:
      return cloneRegExp_default(object2);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object2);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object2) {
  return typeof object2.constructor == "function" && !isPrototype_default(object2) ? baseCreate_default(getPrototype_default(object2)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object2, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result = object2 ? customizer(value, key, object2, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag4 || tag == argsTag3 || isFunc && !object2) {
      result = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object2 ? value : {};
      }
      result = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG2 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
}
var cloneDeep_default = cloneDeep;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object2, key, value) {
  if (value !== void 0 && !eq_default(object2[key], value) || value === void 0 && !(key in object2)) {
    baseAssignValue_default(object2, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/_safeGet.js
function safeGet(object2, key) {
  if (key === "constructor" && typeof object2[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object2[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object2, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object2, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object2, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object2, source, srcIndex, customizer, stack) {
  if (object2 === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object2, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object2, key), srcValue, key + "", object2, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object2, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_baseInRange.js
var nativeMax2 = Math.max;
var nativeMin = Math.min;
function baseInRange(number5, start2, end) {
  return number5 >= nativeMin(start2, end) && number5 < nativeMax2(start2, end);
}
var baseInRange_default = baseInRange;

// node_modules/lodash-es/inRange.js
function inRange(number5, start2, end) {
  start2 = toFinite_default(start2);
  if (end === void 0) {
    end = start2;
    start2 = 0;
  } else {
    end = toFinite_default(end);
  }
  number5 = toNumber_default(number5);
  return baseInRange_default(number5, start2, end);
}
var inRange_default = inRange;

// node_modules/lodash-es/kebabCase.js
var kebabCase = createCompounder_default(function(result, word, index2) {
  return result + (index2 ? "-" : "") + word.toLowerCase();
});
var kebabCase_default = kebabCase;

// node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object2, source, srcIndex) {
  baseMerge_default(object2, source, srcIndex);
});
var merge_default = merge;

// node_modules/@antv/infographic/esm/utils/data.js
function getDatumByIndexes(data, indexes) {
  if (indexes.length === 0)
    return {};
  const base = Array.isArray(data) ? data[indexes[0]] : data.items[indexes[0]];
  if (indexes.length === 1)
    return base;
  const path2 = indexes.slice(1).map((i4) => `children[${i4}]`).join(".");
  return get_default(base, path2);
}

// node_modules/@antv/infographic/esm/utils/design.js
function isNonNullableParsedDesignsOptions(options) {
  const { structure, item, items: items3 } = options;
  if (!structure)
    return false;
  if (!item)
    return false;
  if (items3.some((it) => !it))
    return false;
  return true;
}

// node_modules/@antv/infographic/esm/constants/components.js
var COMPONENT_ROLE = "infographic-component";

// node_modules/@antv/infographic/esm/constants/service.js
var ICON_SERVICE_URL = "https://www.weavefox.cn/api/open/v1/icon";

// node_modules/@antv/infographic/esm/utils/font.js
var GENERIC_FONT_FAMILIES = /* @__PURE__ */ new Set([
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui",
  "-apple-system",
  "ui-serif",
  "ui-sans-serif",
  "ui-monospace",
  "ui-rounded",
  "emoji",
  "math",
  "fangsong"
]);
function splitFontFamily(font) {
  const families = [];
  let current = "";
  let quote = null;
  const push = () => {
    const value = current.trim();
    if (value)
      families.push(value);
    current = "";
  };
  for (let i4 = 0; i4 < font.length; i4 += 1) {
    const char = font[i4];
    if (quote) {
      current += char;
      if (char === quote)
        quote = null;
      continue;
    }
    if (char === '"' || char === "'") {
      quote = char;
      current += char;
      continue;
    }
    if (char === ",") {
      push();
      continue;
    }
    current += char;
  }
  push();
  return families;
}
function stripWrappingQuotes(value) {
  const trimmed = value.trim();
  if (trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'")) {
    return trimmed.slice(1, -1);
  }
  return trimmed;
}
function isWrappedInQuotes(value) {
  const trimmed = value.trim();
  return trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'");
}
function needsQuoting(value) {
  return /^\d/.test(value) || /\s/.test(value);
}
function encodeSingleFontFamily(font) {
  const trimmed = font.trim();
  if (!trimmed)
    return trimmed;
  if (isWrappedInQuotes(trimmed))
    return trimmed;
  if (GENERIC_FONT_FAMILIES.has(trimmed.toLowerCase()))
    return trimmed;
  if (!needsQuoting(trimmed))
    return trimmed;
  const quote = trimmed.includes('"') && !trimmed.includes("'") ? "'" : '"';
  return `${quote}${trimmed}${quote}`;
}
function decodeFontFamily(font) {
  const families = splitFontFamily(font);
  if (!families.length)
    return "";
  if (families.length === 1)
    return stripWrappingQuotes(families[0]);
  return families.map((family) => stripWrappingQuotes(family)).join(", ");
}
function encodeFontFamily(font) {
  const families = splitFontFamily(font);
  if (!families.length)
    return font.trim();
  return families.map((family) => encodeSingleFontFamily(family)).join(", ");
}
var FontWeightNameMap = {
  "100": "thin",
  hairline: "thin",
  thin: "thin",
  "200": "extralight",
  ultralight: "extralight",
  extralight: "extralight",
  "300": "light",
  light: "light",
  "400": "regular",
  normal: "regular",
  regular: "regular",
  "500": "medium",
  medium: "medium",
  "600": "semibold",
  demibold: "semibold",
  semibold: "semibold",
  "700": "bold",
  bold: "bold",
  "800": "extrabold",
  ultrabold: "extrabold",
  extrabold: "extrabold",
  "900": "black",
  heavy: "black",
  black: "black",
  "950": "extrablack",
  ultrablack: "extrablack",
  extrablack: "extrablack"
};
function normalizeFontWeightName(fontWeight) {
  const key = String(fontWeight).toLowerCase();
  return FontWeightNameMap[key] || "regular";
}

// node_modules/measury/lib/font.js
var fontRegistry = /* @__PURE__ */ new Map();
var fontAliases = /* @__PURE__ */ new Map();
var defaultFontFamily = "sans-serif";
function resolveFontFamily(family) {
  if (!family)
    return family;
  if (fontRegistry.has(family))
    return family;
  return fontAliases.get(family) || family;
}
var fallbackFontData = {
  fontFamily: "sans-serif",
  fontWeight: 400,
  fontStyle: "normal",
  unitsPerEm: 2048,
  metrics: {
    ascender: 2189,
    descender: -555,
    lineGap: 0
  },
  // ASCII 
  glyphs: {
    '"': 727,
    "%": 1821,
    "'": 391,
    "(": 682,
    ")": 682,
    "*": 797,
    "+": 1196,
    "-": 682,
    "<": 1196,
    "=": 1196,
    ">": 1196,
    "@": 2079,
    C: 1479,
    D: 1479,
    F: 1251,
    G: 1593,
    H: 1479,
    J: 1024,
    M: 1706,
    N: 1479,
    O: 1593,
    Q: 1593,
    R: 1479,
    T: 1251,
    U: 1479,
    W: 1933,
    Z: 1251,
    "^": 961,
    _: 1024,
    "`": 682,
    c: 1024,
    i: 455,
    j: 455,
    k: 1024,
    l: 455,
    m: 1706,
    r: 682,
    s: 1024,
    v: 1024,
    w: 1479,
    x: 1024,
    y: 1024,
    z: 1024,
    "{": 684,
    "|": 532,
    "}": 684,
    "~": 1196
  },
  glyphsByWidth: {
    569: " !,./:;I[\\]ft",
    1139: "#$0123456789?Labdeghnopqu",
    1366: "&ABEKPSVXY"
  },
  defaultWidth: 1139
};
function normalizeWeight(weight) {
  if (weight === void 0 || weight === "normal")
    return "400";
  if (weight === "bold")
    return "700";
  const namedWeights = {
    thin: "100",
    hairline: "100",
    "extra-light": "200",
    "ultra-light": "200",
    light: "300",
    regular: "400",
    normal: "400",
    medium: "500",
    "semi-bold": "600",
    semibold: "600",
    "demi-bold": "600",
    demibold: "600",
    "extra-bold": "800",
    extrabold: "800",
    "ultra-bold": "800",
    ultrabold: "800",
    black: "900",
    heavy: "900",
    "extra-black": "950",
    extrablack: "950",
    "ultra-black": "950",
    ultrablack: "950",
    bolder: "900",
    lighter: "300"
  };
  if (typeof weight === "string") {
    const normalized = weight.toLowerCase();
    return namedWeights[normalized] || weight;
  }
  return String(weight);
}
function normalizeStyle(style) {
  return style || "normal";
}
function registerFont(data) {
  const family = data.fontFamily;
  const normalizedWeight = normalizeWeight(data.fontWeight);
  const normalizedStyle = normalizeStyle(data.fontStyle);
  if (data.aliases) {
    for (const alias of data.aliases) {
      if (!fontAliases.has(alias)) {
        fontAliases.set(alias, family);
      }
    }
  }
  if (data.glyphsByWidth) {
    const expandedGlyphs = { ...data.glyphs || {} };
    for (const [widthOrChar, valueOrWidth] of Object.entries(data.glyphsByWidth)) {
      if (typeof valueOrWidth === "string") {
        const width = Number(widthOrChar);
        for (const char of valueOrWidth) {
          expandedGlyphs[char] = width;
        }
      } else {
        expandedGlyphs[widthOrChar] = valueOrWidth;
      }
    }
    data = {
      ...data,
      glyphs: expandedGlyphs,
      //  glyphsByWidth
      glyphsByWidth: void 0
    };
  }
  if (!fontRegistry.has(family)) {
    fontRegistry.set(family, /* @__PURE__ */ new Map());
  }
  const familyMap = fontRegistry.get(family);
  if (!familyMap.has(normalizedWeight)) {
    familyMap.set(normalizedWeight, /* @__PURE__ */ new Map());
  }
  const weightMap = familyMap.get(normalizedWeight);
  weightMap.set(normalizedStyle, data);
}
function getFontData(family, weight, style) {
  const targetFamily = resolveFontFamily(family || defaultFontFamily);
  const normalizedWeight = normalizeWeight(weight);
  const normalizedStyle = normalizeStyle(style);
  const familyMap = fontRegistry.get(targetFamily);
  if (!familyMap) {
    console.warn(`Font family "${targetFamily}" not registered, using fallback font data`);
    return fallbackFontData;
  }
  let weightMap = familyMap.get(normalizedWeight);
  if (weightMap) {
    let fontData = weightMap.get(normalizedStyle);
    if (fontData)
      return fontData;
    if (normalizedStyle !== "normal") {
      fontData = weightMap.get("normal");
      if (fontData)
        return fontData;
    }
    const firstStyle = weightMap.values().next().value;
    if (firstStyle)
      return firstStyle;
  }
  weightMap = familyMap.get("400");
  if (weightMap) {
    let fontData = weightMap.get(normalizedStyle);
    if (fontData)
      return fontData;
    if (normalizedStyle !== "normal") {
      fontData = weightMap.get("normal");
      if (fontData)
        return fontData;
    }
    const firstStyle = weightMap.values().next().value;
    if (firstStyle)
      return firstStyle;
  }
  const firstWeightMap = familyMap.values().next().value;
  if (firstWeightMap) {
    const firstStyle = firstWeightMap.values().next().value;
    if (firstStyle)
      return firstStyle;
  }
  throw new Error(`No font data found for family "${targetFamily}" with weight "${normalizedWeight}" and style "${normalizedStyle}"`);
}

// node_modules/measury/lib/measure.js
function applyTextTransform(text, transform2) {
  if (!transform2 || transform2 === "none")
    return text;
  switch (transform2) {
    case "uppercase":
      return text.toUpperCase();
    case "lowercase":
      return text.toLowerCase();
    case "capitalize":
      return text.split(" ").map((word) => {
        if (word.length === 0)
          return word;
        return word[0].toUpperCase() + word.slice(1).toLowerCase();
      }).join(" ");
    default:
      return text;
  }
}
function normalizeFontSize(fontSize) {
  if (fontSize === void 0) {
    return 14;
  }
  if (typeof fontSize === "number") {
    return fontSize;
  }
  const parsed = parseFloat(fontSize);
  return isNaN(parsed) ? 16 : parsed;
}
function calculateLineHeight(style, fontData) {
  const fontSize = normalizeFontSize(style.fontSize);
  const lineHeight = style.lineHeight;
  if (lineHeight === void 0) {
    const { ascender, descender, lineGap = 0 } = fontData.metrics;
    const totalHeight = ascender - descender + lineGap;
    return totalHeight / fontData.unitsPerEm * fontSize;
  }
  if (typeof lineHeight === "number") {
    return lineHeight * fontSize;
  }
  if (lineHeight.type === "pixel") {
    return lineHeight.value;
  }
  if (lineHeight.type === "percent") {
    return lineHeight.value / 100 * fontSize;
  }
  return fontSize;
}
function measureText(text, style = {}) {
  var _a;
  const transformedText = applyTextTransform(text, style.textTransform);
  const fontData = getFontData(style.fontFamily, style.fontWeight, style.fontStyle);
  const fontSize = normalizeFontSize(style.fontSize);
  const letterSpacing = style.letterSpacing || 0;
  const wordSpacing = style.wordSpacing || 0;
  let totalWidth = 0;
  const chars = Array.from(transformedText);
  for (let i4 = 0; i4 < chars.length; i4++) {
    const char = chars[i4];
    const nextChar = i4 < chars.length - 1 ? chars[i4 + 1] : void 0;
    let advance = (_a = fontData.glyphs) == null ? void 0 : _a[char];
    if (advance === void 0) {
      advance = fontData.defaultWidth || fontData.unitsPerEm / 2;
    }
    const charWidth = advance / fontData.unitsPerEm * fontSize;
    totalWidth += charWidth;
    if (nextChar && fontData.kerning) {
      const pair = char + nextChar;
      const kernValue = fontData.kerning[pair];
      if (kernValue !== void 0) {
        totalWidth += kernValue / fontData.unitsPerEm * fontSize;
      }
    }
    if (i4 < chars.length - 1) {
      totalWidth += letterSpacing;
    }
    if (char === " ") {
      totalWidth += wordSpacing;
    }
  }
  const height = calculateLineHeight(style, fontData);
  const { ascender } = fontData.metrics;
  const baseline = ascender / fontData.unitsPerEm * fontSize;
  return {
    width: totalWidth,
    height,
    baseline
  };
}

// node_modules/measury/lib/fonts/AlibabaPuHuiTi-Regular.js
var AlibabaPuHuiTi_Regular_default = {
  fontFamily: "Alibaba PuHuiTi",
  aliases: ["AlibabaPuHuiTi", "AlibabaPuHuiTi-Regular"],
  fontWeight: 400,
  fontStyle: "normal",
  unitsPerEm: 1e3,
  metrics: {
    ascender: 1060,
    descender: -340,
    lineGap: 0
  },
  glyphs: {
    " ": 257,
    "!": 361,
    '"': 405,
    "#": 600,
    "%": 821,
    "&": 640,
    "'": 253,
    "(": 359,
    ")": 359,
    "*": 430,
    ",": 302,
    "-": 440,
    ".": 302,
    "/": 500,
    ":": 378,
    ";": 378,
    "?": 431,
    "@": 860,
    "B": 620,
    "C": 599,
    "D": 699,
    "F": 527,
    "G": 685,
    "H": 708,
    "J": 271,
    "K": 614,
    "L": 507,
    "M": 830,
    "N": 737,
    "P": 597,
    "R": 614,
    "S": 566,
    "T": 528,
    "V": 617,
    "W": 898,
    "X": 624,
    "Y": 594,
    "Z": 626,
    "[": 294,
    "\\": 510,
    "]": 294,
    "_": 500,
    "`": 346,
    "b": 635,
    "c": 497,
    "d": 635,
    "f": 349,
    "g": 636,
    "k": 518,
    "l": 286,
    "m": 921,
    "p": 635,
    "q": 636,
    "r": 379,
    "s": 479,
    "t": 337,
    "v": 526,
    "w": 828,
    "x": 516,
    "y": 527,
    "z": 506,
    "{": 299,
    "|": 183,
    "}": 299,
    "\xA0": 257,
    "\xA1": 357,
    "\xA6": 183,
    "\xA7": 479,
    "\xA8": 346,
    "\xA9": 806,
    "\xAA": 483,
    "\xAB": 511,
    "\xAD": 440,
    "\xAE": 404,
    "\xAF": 346,
    "\xB0": 363,
    "\xB4": 346,
    "\xB6": 593,
    "\xB7": 357,
    "\xB8": 346,
    "\xBA": 445,
    "\xBB": 511,
    "\xBC": 902,
    "\xBD": 914,
    "\xBE": 902,
    "\xBF": 431,
    "\xC6": 889,
    "\xC7": 599,
    "\xD0": 719,
    "\xD1": 737,
    "\xDD": 594,
    "\xDE": 597,
    "\xDF": 610,
    "\xE6": 926,
    "\xE7": 497,
    "\xFD": 527,
    "\xFE": 635,
    "\xFF": 527,
    "\u0106": 599,
    "\u0107": 497,
    "\u0108": 599,
    "\u0109": 497,
    "\u010A": 599,
    "\u010B": 497,
    "\u010C": 599,
    "\u010D": 497,
    "\u010E": 699,
    "\u010F": 640,
    "\u0110": 719,
    "\u0111": 635,
    "\u011C": 685,
    "\u011D": 636,
    "\u011E": 685,
    "\u011F": 636,
    "\u0120": 685,
    "\u0121": 636,
    "\u0122": 685,
    "\u0123": 636,
    "\u0124": 708,
    "\u0126": 708,
    "\u0132": 545,
    "\u0133": 536,
    "\u0134": 271,
    "\u0136": 614,
    "\u0137": 518,
    "\u0138": 518,
    "\u0139": 507,
    "\u013A": 286,
    "\u013B": 507,
    "\u013C": 286,
    "\u013D": 507,
    "\u013E": 290,
    "\u013F": 507,
    "\u0140": 291,
    "\u0141": 507,
    "\u0142": 286,
    "\u0143": 737,
    "\u0145": 737,
    "\u0147": 737,
    "\u0149": 669,
    "\u014A": 737,
    "\u0152": 987,
    "\u0153": 917,
    "\u0154": 614,
    "\u0155": 379,
    "\u0156": 614,
    "\u0157": 379,
    "\u0158": 614,
    "\u0159": 379,
    "\u015A": 566,
    "\u015B": 479,
    "\u015C": 566,
    "\u015D": 479,
    "\u015E": 566,
    "\u015F": 479,
    "\u0160": 566,
    "\u0161": 479,
    "\u0162": 528,
    "\u0163": 337,
    "\u0164": 528,
    "\u0165": 340,
    "\u0166": 528,
    "\u0167": 337,
    "\u0174": 898,
    "\u0175": 828,
    "\u0176": 594,
    "\u0177": 527,
    "\u0178": 594,
    "\u0179": 626,
    "\u017A": 506,
    "\u017B": 626,
    "\u017C": 506,
    "\u017D": 626,
    "\u017E": 506,
    "\u017F": 310,
    "\u018F": 719,
    "\u01CE": 608,
    "\u01D0": 265,
    "\u01D2": 614,
    "\u01D4": 609,
    "\u01D6": 609,
    "\u01D8": 609,
    "\u01DA": 609,
    "\u01DC": 609,
    "\u01FC": 889,
    "\u01FD": 926,
    "\u0218": 566,
    "\u0219": 479,
    "\u021A": 528,
    "\u021B": 337,
    "\u0374": 255,
    "\u0375": 255,
    "\u037E": 378,
    "\u0384": 346,
    "\u0385": 346,
    "\u0386": 670,
    "\u0387": 357,
    "\u0388": 628,
    "\u0389": 779,
    "\u038A": 346,
    "\u038C": 765,
    "\u038E": 726,
    "\u038F": 765,
    "\u0390": 312,
    "\u0392": 620,
    "\u0393": 507,
    "\u0396": 626,
    "\u0397": 708,
    "\u039A": 614,
    "\u039B": 617,
    "\u039C": 830,
    "\u039D": 737,
    "\u03A0": 708,
    "\u03A1": 597,
    "\u03A3": 596,
    "\u03A4": 528,
    "\u03A5": 594,
    "\u03A6": 831,
    "\u03A7": 624,
    "\u03A8": 804,
    "\u03AB": 594,
    "\u03AD": 509,
    "\u03AE": 643,
    "\u03AF": 312,
    "\u03B0": 593,
    "\u03B2": 610,
    "\u03B3": 526,
    "\u03B5": 509,
    "\u03B6": 465,
    "\u03B7": 643,
    "\u03B8": 638,
    "\u03B9": 312,
    "\u03BA": 518,
    "\u03BB": 514,
    "\u03BD": 526,
    "\u03BE": 465,
    "\u03C0": 616,
    "\u03C1": 619,
    "\u03C2": 497,
    "\u03C3": 639,
    "\u03C4": 437,
    "\u03C5": 593,
    "\u03C6": 774,
    "\u03C7": 509,
    "\u03C8": 745,
    "\u03C9": 782,
    "\u03CA": 312,
    "\u03CB": 593,
    "\u03CD": 593,
    "\u03CE": 782,
    "\u2010": 440,
    "\u2011": 440,
    "\u2013": 495,
    "\u2014": 684,
    "\u2015": 684,
    "\u2017": 500,
    "\u2018": 270,
    "\u2019": 270,
    "\u201A": 270,
    "\u201B": 270,
    "\u201C": 784,
    "\u201D": 784,
    "\u201E": 468,
    "\u2020": 500,
    "\u2021": 500,
    "\u2022": 308,
    "\u2026": 1085,
    "\u2030": 1174,
    "\u2032": 256,
    "\u2033": 472,
    "\u2034": 689,
    "\u2035": 256,
    "\u2036": 472,
    "\u2037": 689,
    "\u2039": 312,
    "\u203A": 312,
    "\u203C": 589,
    "\u203D": 433,
    "\u203E": 500,
    "\u2044": 120,
    "\u207A": 407,
    "\u207B": 407,
    "\u207C": 407,
    "\u207D": 225,
    "\u207E": 225,
    "\u207F": 486,
    "\u208A": 407,
    "\u208B": 407,
    "\u208C": 407,
    "\u208D": 225,
    "\u208E": 225,
    "\u2099": 486,
    "\u20A1": 599,
    "\u20A3": 527,
    "\u20A4": 600,
    "\u20A5": 921,
    "\u20A6": 625,
    "\u20A8": 1093,
    "\u20A9": 769,
    "\u20AA": 754,
    "\u20AB": 635,
    "\u20AD": 614,
    "\u20AE": 528,
    "\u20AF": 1288,
    "\u20B0": 950,
    "\u20B2": 685,
    "\u20B4": 576,
    "\u20B5": 599,
    "\u20B6": 576,
    "\u20B7": 700,
    "\u20B8": 528,
    "\u20BB": 750,
    "\u20BC": 683,
    "\u20BE": 577,
    "\u20BF": 620,
    "\u2103": 915,
    "\u2105": 825,
    "\u2109": 868,
    "\u2113": 385,
    "\u2116": 1176,
    "\u2117": 806,
    "\u2121": 1022,
    "\u2122": 903,
    "\u212E": 903,
    "\u215B": 930,
    "\u215C": 931,
    "\u215D": 931,
    "\u215E": 871,
    "\u2166": 1166,
    "\u2202": 587,
    "\u2208": 663,
    "\u220F": 708,
    "\u2211": 596,
    "\u221A": 604,
    "\u221E": 679,
    "\u2227": 617,
    "\u222B": 531,
    "\u222E": 654,
    "\u2248": 600,
    "\u2252": 662,
    "\u25CA": 600,
    "\u3000": 0,
    "\u301E": 472
  },
  glyphsByWidth: {
    268: "ij\xEC\xED\xEE\xEF\u0129\u012B\u012D\u012F\u0131\u0135\u0237",
    274: "I\xCC\xCD\xCE\xCF\u0128\u012A\u012C\u012E\u0130\u0399\u03AA",
    406: "\xB2\xB3\xB9\u2070\u2074\u2075\u2076\u2077\u2078\u2079\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089",
    552: "+<=>^~\xAC\xB1\xD7\xF7\u2212\u2215\u2219\u2260\u2264\u2265\u2266\u2267\u226E\u226F",
    556: "E\xC8\xC9\xCA\xCB\u0112\u0114\u0116\u0118\u011A\u0395\u039E",
    575: "$0123456789\xA2\xA3\xA4\xA5\u0192\u20A2\u20A7\u20AC\u20B1\u20B9\u20BA\u20BD",
    578: "e\xE8\xE9\xEA\xEB\u0113\u0115\u0117\u0119\u011B",
    612: "a\xE0\xE1\xE2\xE3\xE4\xE5\u0101\u0103\u0105\u01FB",
    613: "u\xB5\xF9\xFA\xFB\xFC\u0169\u016B\u016D\u016F\u0171\u0173\u03AC\u03B1\u03BC\u2228",
    618: "hno\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\u0125\u0127\u0144\u0146\u0148\u014B\u014D\u014F\u0151\u01FF\u03B4\u03BF\u03CC",
    667: "A\xC0\xC1\xC2\xC3\xC4\xC5\u0100\u0102\u0104\u01FA\u0391\u0394\u20B3\u2206",
    701: "U\xD9\xDA\xDB\xDC\u0168\u016A\u016C\u016E\u0170\u0172",
    743: "OQ\xD2\xD3\xD4\xD5\xD6\xD8\u014C\u014E\u0150\u01FE\u0398\u039F\u03A9\u2126",
    1e3: "\u2500\u2501\u2502\u2503\u2504\u2505\u2506\u2507\u2508\u2509\u250A\u250B\u250C\u250D\u250E\u250F\u2510\u2511\u2512\u2513\u2514\u2515\u2516\u2517\u2518\u2519\u251A\u251B\u251C\u251D\u251E\u251F\u2520\u2521\u2522\u2523\u2524\u2525\u2526\u2527\u2528\u2529\u252A\u252B\u252C\u252D\u252E\u252F\u2530\u2531\u2532\u2533\u2534\u2535\u2536\u2537\u2538\u2539\u253A\u253B\u253C\u253D\u253E\u253F\u2540\u2541\u2542\u2543\u2544\u2545\u2546\u2547\u2548\u2549\u254A\u254B\u2550\u2551\u2552\u2553\u2554\u2555\u2556\u2557\u2558\u2559\u255A\u255B\u255C\u255D\u255E\u255F\u2560\u2561\u2562\u2563\u2564\u2565\u2566\u2567\u2568\u2569\u256A\u256B\u256C\u256D\u256E\u256F\u2570\u2571\u2572\u2573\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588\u2589\u258A\u258B\u258C\u258D\u258E\u258F\u2593\u2594\u2595\u25A0\u25A1\u25B2\u25B3\u25BC\u25BD\u25C6\u25C7\u25CB\u25CE\u25CF\u25E2\u25E3\u25E4\u25E5\u2605\u2606\u2609\u2640\u2642\u303E"
  },
  defaultWidth: 984,
  kerning: {
    '""': -56,
    "\"'": -57,
    '",': -179,
    '".': -179,
    "'\"": -56,
    "''": -57,
    "',": -179,
    "'.": -179,
    "(j": 60,
    ',"': -160,
    ",'": -160,
    ",1": -140,
    ",7": -41,
    ",9": -39,
    '."': -160,
    ".'": -160,
    ".1": -140,
    ".7": -41,
    ".9": -39,
    "//": -120,
    "1,": -99,
    "1.": -99,
    "1:": -99,
    "1;": -99,
    "7,": -160,
    "7.": -160,
    "7:": -99,
    "7;": -99,
    ":1": -79,
    ":7": -59,
    ";1": -79,
    ";7": -59,
    'A"': -100,
    "A'": -100,
    "AC": -20,
    "AG": -20,
    "AO": -20,
    "AQ": -20,
    "AT": -80,
    "AU": -10,
    "AV": -70,
    "AW": -39,
    "AY": -81,
    "Af": -20,
    "Al": -10,
    "At": -20,
    "Av": -20,
    "Ay": -20,
    "BC": -10,
    "BG": -10,
    "BO": -10,
    "BQ": -10,
    "BT": -40,
    "BV": -20,
    "BX": -20,
    "BY": -21,
    "D,": -59,
    "D.": -59,
    "DA": -20,
    "DT": -36,
    "DV": -30,
    "DW": -19,
    "DX": -20,
    "DY": -40,
    "DZ": -20,
    "Da": -39,
    "Ej": 19,
    "F,": -159,
    "F.": -159,
    "FA": -40,
    "Fa": -59,
    "Fh": 1,
    "Fk": 1,
    "GV": -11,
    "GY": -21,
    "JJ": 7,
    "KA": -19,
    "KC": -20,
    "KG": -20,
    "KO": -20,
    "KQ": -20,
    "KT": -19,
    "KU": -39,
    "KV": -39,
    "KW": -39,
    "KY": -40,
    "Kc": -39,
    "Kd": -39,
    "Ke": -39,
    "Kg": -39,
    "Kl": -39,
    "Ko": -39,
    "Kq": -39,
    "Ks": -19,
    "Kt": -10,
    "Ku": -40,
    "Kv": -60,
    "Kw": -40,
    "Ky": -60,
    'L"': -99,
    "L'": -99,
    "LA": 20,
    "LC": -59,
    "LG": -59,
    "LO": -59,
    "LQ": -59,
    "LT": -79,
    "LU": -19,
    "LV": -79,
    "LW": -39,
    "LY": -100,
    "Lv": -41,
    "Lw": -21,
    "Ly": -41,
    "O,": -59,
    "O.": -59,
    "OA": -20,
    "OT": -36,
    "OV": -30,
    "OW": -19,
    "OX": -20,
    "OY": -40,
    "OZ": -20,
    "Oa": -39,
    "P,": -199,
    "P.": -199,
    "PA": -60,
    "PT": -29,
    "PV": -10,
    "PW": -10,
    "PX": -50,
    "PY": -20,
    "PZ": -39,
    "Pa": -60,
    "Q,": -59,
    "Q.": -59,
    "QA": -20,
    "QJ": 7,
    "QT": -36,
    "QV": -30,
    "QW": -19,
    "QX": -20,
    "QY": -40,
    "QZ": -20,
    "Qa": -39,
    "RC": -15,
    "RG": -15,
    "RO": -15,
    "RQ": -15,
    "RT": -40,
    "RU": -10,
    "RV": -21,
    "RW": -10,
    "RX": -29,
    "RY": -41,
    "Rc": -20,
    "Rd": -20,
    "Re": -20,
    "Rg": -20,
    "Ro": -20,
    "Rq": -20,
    "Rt": -20,
    "Ru": -10,
    "Rv": -10,
    "Rx": 20,
    "Ry": -10,
    "S,": -20,
    "S.": -20,
    "SS": -1,
    "ST": -1,
    "SV": -21,
    "SW": -10,
    "SY": -21,
    "St": -1,
    "Sv": -20,
    "Sw": -10,
    "Sx": -1,
    "Sy": -20,
    'T"': 2,
    "T'": 2,
    "T,": -154,
    "T.": -154,
    "TA": -80,
    "TC": -20,
    "TG": -20,
    "TO": -20,
    "TQ": -20,
    "TS": -1,
    "Ta": -80,
    "Tc": -59,
    "Td": -59,
    "Te": -59,
    "Tg": -59,
    "Ti": -20,
    "Tj": -19,
    "Tm": -59,
    "Tn": -59,
    "To": -59,
    "Tp": -58,
    "Tq": -59,
    "Tr": -59,
    "Ts": -60,
    "Tt": 20,
    "Tu": -79,
    "Tv": -39,
    "Tw": -19,
    "Tx": -39,
    "Ty": -39,
    "Tz": -59,
    "UA": -10,
    "UX": -19,
    "Ux": -1,
    "V,": -140,
    "V.": -140,
    "V:": -41,
    "V;": -41,
    "VA": -70,
    "VC": -30,
    "VG": -30,
    "VO": -30,
    "VQ": -30,
    "VS": -10,
    "Va": -41,
    "Vc": -21,
    "Vd": -21,
    "Ve": -21,
    "Vg": -21,
    "Vh": 1,
    "Vk": 1,
    "Vo": -21,
    "Vq": -21,
    "Vs": -21,
    "Vv": -1,
    "Vy": -1,
    "W,": -79,
    "W.": -79,
    "W:": -39,
    "W;": -39,
    "WA": -40,
    "WC": -19,
    "WG": -19,
    "WO": -19,
    "WQ": -19,
    "Wa": -40,
    "Wc": -20,
    "Wd": -20,
    "We": -20,
    "Wg": -20,
    "Wo": -20,
    "Wq": -20,
    "Ws": -20,
    "XA": -19,
    "XC": -20,
    "XG": -20,
    "XO": -20,
    "XQ": -20,
    "XT": -19,
    "XU": -39,
    "XV": -39,
    "XW": -39,
    "XY": -40,
    "Xc": -39,
    "Xd": -39,
    "Xe": -39,
    "Xg": -39,
    "Xl": -39,
    "Xo": -39,
    "Xq": -39,
    "Xs": -19,
    "Xt": -10,
    "Xu": -40,
    "Xv": -60,
    "Xw": -40,
    "Xy": -60,
    'Y"': 1,
    "Y'": 1,
    "Y,": -141,
    "Y.": -141,
    "Y:": -60,
    "Y;": -60,
    "YA": -81,
    "YC": -40,
    "YG": -40,
    "YO": -40,
    "YQ": -40,
    "YS": -1,
    "Ya": -101,
    "Yc": -60,
    "Yd": -60,
    "Ye": -60,
    "Yf": -1,
    "Yg": -60,
    "Yh": 1,
    "Yi": -19,
    "Yk": 1,
    "Ym": -41,
    "Yn": -41,
    "Yo": -60,
    "Yp": -40,
    "Yq": -60,
    "Yr": -41,
    "Ys": -61,
    "Yt": -1,
    "Yu": -40,
    "Yv": -40,
    "Yx": -41,
    "Yy": -40,
    "Yz": -41,
    "ZC": -20,
    "ZG": -20,
    "ZO": -20,
    "ZQ": -20,
    "[j": 80,
    "aT": -60,
    "aV": -21,
    "aY": -61,
    "av": -10,
    "aw": -10,
    "ay": -10,
    "b,": -40,
    "b.": -40,
    "bT": -59,
    "bV": -21,
    "bW": -20,
    "bX": -39,
    "bY": -60,
    "bv": -10,
    "bx": -20,
    "by": -10,
    "e,": -20,
    "e.": -20,
    "eT": -59,
    "eY": -40,
    "ej": 20,
    'f"': 3,
    "f'": 3,
    "f)": 1,
    "f*": 61,
    "f,": -1,
    "f.": -1,
    "f?": 40,
    "fT": 40,
    "fV": 21,
    "fW": 21,
    "fX": 21,
    "fY": 1,
    "f]": 21,
    "fa": -29,
    "fc": -19,
    "fd": -19,
    "fe": -19,
    "ff": 1,
    "fg": -39,
    "fh": -19,
    "fi": -19,
    "fj": -19,
    "fk": -19,
    "fl": -19,
    "fo": -19,
    "fq": -19,
    "fs": -19,
    "ft": 1,
    "f}": 3,
    "hT": -58,
    "hY": -39,
    "hv": -10,
    "hy": -10,
    'i"': 2,
    "i'": 2,
    "i)": 2,
    "i?": 3,
    "iT": -20,
    "i]": 41,
    "i}": 22,
    "jT": -20,
    "kT": -39,
    "kU": -1,
    "kW": -20,
    "ka": -20,
    "kc": -20,
    "kd": -20,
    "ke": -20,
    "kg": -20,
    "kl": -20,
    "ko": -20,
    "kq": -20,
    "ku": -10,
    "lf": -20,
    "lv": -19,
    "lw": -10,
    "ly": -19,
    "mT": -58,
    "mY": -39,
    "mv": -10,
    "my": -10,
    "nT": -58,
    "nY": -39,
    "nv": -10,
    "ny": -10,
    "o,": -40,
    "o.": -40,
    "oT": -59,
    "oV": -21,
    "oW": -20,
    "oX": -39,
    "oY": -60,
    "ov": -10,
    "ox": -20,
    "oy": -10,
    "p,": -40,
    "p.": -40,
    "pT": -59,
    "pV": -21,
    "pW": -20,
    "pX": -39,
    "pY": -60,
    "pv": -10,
    "px": -20,
    "py": -10,
    "qT": -19,
    "qY": -19,
    "qj": 20,
    'r"': 2,
    "r'": 2,
    "r,": -90,
    "r.": -90,
    "ra": -49,
    "rc": -19,
    "rd": -19,
    "re": -19,
    "rf": 1,
    "ro": -19,
    "rq": -19,
    "rt": 20,
    "sT": -59,
    "sV": -21,
    "sW": -20,
    "sX": -19,
    "sY": -60,
    "sv": -19,
    "sx": -10,
    "sy": -19,
    "tf": 1,
    "uT": -40,
    "uY": -19,
    "v,": -90,
    "v.": -90,
    "vT": -39,
    "vX": -39,
    "va": -35,
    "vc": -10,
    "vd": -10,
    "ve": -10,
    "vo": -10,
    "vq": -10,
    "w,": -50,
    "w.": -50,
    "wT": -19,
    "wX": -39,
    "wa": -30,
    "xT": -39,
    "xU": -1,
    "xW": -20,
    "xa": -20,
    "xc": -20,
    "xd": -20,
    "xe": -20,
    "xg": -20,
    "xl": -20,
    "xo": -20,
    "xq": -20,
    "xu": -10,
    "y,": -90,
    "y.": -90,
    "yT": -39,
    "yX": -39,
    "ya": -35,
    "yc": -10,
    "yd": -10,
    "ye": -10,
    "yo": -10,
    "yq": -10,
    "zT": -59,
    "{h": 2,
    "{j": 79,
    "{k": 2
  }
};

// node_modules/@antv/infographic/esm/resource/load-tracker.js
var __awaiter = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SVG_LOAD_PROMISE_MAP = /* @__PURE__ */ new WeakMap();
function getSvgLoadPromises(svg) {
  const map2 = SVG_LOAD_PROMISE_MAP.get(svg);
  return map2 ? Array.from(map2.values()) : [];
}
function getSvgLoadPromise(svg, key) {
  var _a;
  return (_a = SVG_LOAD_PROMISE_MAP.get(svg)) === null || _a === void 0 ? void 0 : _a.get(key);
}
function trackSvgLoadPromise(svg, key, promise) {
  let map2 = SVG_LOAD_PROMISE_MAP.get(svg);
  if (!map2) {
    map2 = /* @__PURE__ */ new Map();
    SVG_LOAD_PROMISE_MAP.set(svg, map2);
  }
  map2.set(key, promise);
  promise.finally(() => {
    const map3 = SVG_LOAD_PROMISE_MAP.get(svg);
    if (!map3)
      return;
    if (map3.get(key) === promise)
      map3.delete(key);
    if (map3.size === 0)
      SVG_LOAD_PROMISE_MAP.delete(svg);
  });
  return promise;
}
function waitForSvgLoads(svg) {
  return __awaiter(this, void 0, void 0, function* () {
    yield Promise.resolve();
    while (true) {
      const promises = getSvgLoadPromises(svg);
      if (!promises.length)
        break;
      yield Promise.allSettled(promises);
      yield Promise.resolve();
    }
  });
}

// node_modules/@antv/infographic/esm/renderer/fonts/registry.js
var FONT_REGISTRY = /* @__PURE__ */ new Map();
var DEFAULT_FONT = "Alibaba PuHuiTi";
function getFont(font) {
  const families = splitFontFamily(font);
  for (const family of families) {
    const fontObj = FONT_REGISTRY.get(decodeFontFamily(family));
    if (fontObj)
      return fontObj;
  }
  return null;
}
function getFonts() {
  return Array.from(FONT_REGISTRY.values());
}
function registerFont2(font) {
  const f5 = Object.assign({}, font);
  FONT_REGISTRY.set(f5.fontFamily, f5);
  f5.fontFamily = encodeFontFamily(f5.fontFamily);
  return f5;
}

// node_modules/@antv/infographic/esm/renderer/fonts/loader.js
function getFontURLs(font) {
  const urls = splitFontFamily(font).flatMap((family) => {
    const config = getFont(family);
    if (!config)
      return [];
    const { baseUrl, fontWeight } = config;
    return Object.values(fontWeight).filter((url) => !!url).map((url) => join(baseUrl, url));
  });
  return Array.from(new Set(urls));
}
function getWoff2BaseURL(font, fontWeightName) {
  const families = splitFontFamily(font);
  let config = null;
  for (const family of families) {
    config = getFont(family);
    if (config)
      break;
  }
  if (!config)
    return null;
  const name = normalizeFontWeightName(fontWeightName);
  const path2 = config.fontWeight[name];
  if (!path2)
    return null;
  return join(config.baseUrl, path2.replace(/\/result.css$/, ""));
}
var FONT_LOAD_MAP = /* @__PURE__ */ new WeakMap();
var FONT_PROMISE_MAP = /* @__PURE__ */ new WeakMap();
function trackFontPromise(target, id2, promise) {
  let map2 = FONT_PROMISE_MAP.get(target);
  if (!map2) {
    map2 = /* @__PURE__ */ new Map();
    FONT_PROMISE_MAP.set(target, map2);
  }
  map2.set(id2, promise);
  promise.finally(() => {
    const map3 = FONT_PROMISE_MAP.get(target);
    if (!map3)
      return;
    if (map3.get(id2) === promise)
      map3.delete(id2);
    if (map3.size === 0)
      FONT_PROMISE_MAP.delete(target);
  });
  return promise;
}
function isLinkLoaded(link) {
  if (link.getAttribute("data-infographic-font-loaded") === "true")
    return true;
  try {
    return !!link.sheet;
  } catch (_a) {
    return false;
  }
}
function getFontLoadPromise(target, id2, link) {
  var _a;
  const existing = (_a = FONT_PROMISE_MAP.get(target)) === null || _a === void 0 ? void 0 : _a.get(id2);
  if (existing)
    return existing;
  if (!link || isLinkLoaded(link)) {
    return trackFontPromise(target, id2, Promise.resolve());
  }
  const promise = new Promise((resolve) => {
    const done = () => {
      link.setAttribute("data-infographic-font-loaded", "true");
      resolve();
    };
    link.addEventListener("load", done, { once: true });
    link.addEventListener("error", done, { once: true });
  });
  return trackFontPromise(target, id2, promise);
}
function loadFont(svg, font) {
  const doc = svg.ownerDocument;
  const target = (doc === null || doc === void 0 ? void 0 : doc.head) || document.head;
  if (!target)
    return;
  if (!FONT_LOAD_MAP.has(target))
    FONT_LOAD_MAP.set(target, /* @__PURE__ */ new Map());
  const map2 = FONT_LOAD_MAP.get(target);
  const urls = getFontURLs(font);
  if (!urls.length)
    return;
  const links = [];
  urls.forEach((url) => {
    const id2 = `${font}-${url}`;
    const promiseKey = `font:${id2}`;
    if (getSvgLoadPromise(svg, promiseKey))
      return;
    let link = map2.get(id2);
    if (!link) {
      link = doc.createElement("link");
      link.id = id2;
      link.rel = "stylesheet";
      link.href = url;
      links.push(link);
      map2.set(id2, link);
    }
    const promise = getFontLoadPromise(target, id2, link);
    trackSvgLoadPromise(svg, promiseKey, promise);
  });
  if (!links.length)
    return;
  if (target.tagName === "HEAD") {
    links.forEach((link) => target.appendChild(link));
  }
}
function loadFonts(svg) {
  if (isNode)
    return;
  const fonts = getFonts();
  fonts.forEach((font) => loadFont(svg, font.fontFamily));
}

// node_modules/@antv/infographic/esm/renderer/fonts/built-in.js
var BASE_FONT_URL = "https://assets.antv.antgroup.com";
var getUrl = (name) => `${name}/result.css`;
var BUILT_IN_FONTS = [
  {
    fontFamily: "Alibaba PuHuiTi",
    name: "\u963F\u91CC\u5DF4\u5DF4\u666E\u60E0\u4F53",
    baseUrl: BASE_FONT_URL,
    fontWeight: {
      regular: getUrl("AlibabaPuHuiTi-Regular"),
      bold: getUrl("AlibabaPuHuiTi-Bold")
    }
  },
  {
    fontFamily: "Source Han Sans",
    name: "\u9ED1\u4F53",
    baseUrl: BASE_FONT_URL,
    fontWeight: { regular: getUrl("SourceHanSansCN-Regular") }
  },
  {
    fontFamily: "Source Han Serif",
    name: "\u5B8B\u4F53",
    baseUrl: BASE_FONT_URL,
    fontWeight: { regular: getUrl("SourceHanSerifCN-Regular") }
  },
  {
    fontFamily: "LXGW WenKai",
    name: "\u6977\u4F53",
    baseUrl: BASE_FONT_URL,
    fontWeight: { regular: getUrl("LXGWWenKai-Regular") }
  },
  {
    fontFamily: "851tegakizatsu",
    name: "\u624B\u5199\u4F53",
    baseUrl: BASE_FONT_URL,
    fontWeight: { regular: getUrl("851tegakizatsu-Regular") }
  }
];

// node_modules/@antv/infographic/esm/renderer/fonts/index.js
BUILT_IN_FONTS.forEach(registerFont2);

// node_modules/@antv/infographic/esm/renderer/palettes/registry.js
var PALETTE_REGISTRY = /* @__PURE__ */ new Map();
function registerPalette(name, palette2) {
  PALETTE_REGISTRY.set(name, palette2);
}
function getPalette(type2) {
  return PALETTE_REGISTRY.get(type2);
}

// node_modules/@antv/infographic/esm/renderer/palettes/built-in.js
var antv = [
  "#1783FF",
  "#00C9C9",
  "#F0884D",
  "#D580FF",
  "#7863FF",
  "#60C42D",
  "#BD8F24",
  "#FF80CA",
  "#2491B3",
  "#17C76F",
  "#70CAF8"
];
registerPalette("antv", antv);
var spectral = (_2, index2, count2) => {
  const colors = [
    ["#fc8d59", "#ffffbf", "#99d594"],
    ["#d7191c", "#fdae61", "#abdda4", "#2b83ba"],
    ["#d7191c", "#fdae61", "#ffffbf", "#abdda4", "#2b83ba"],
    ["#d53e4f", "#fc8d59", "#fee08b", "#e6f598", "#99d594", "#3288bd"],
    [
      "#d53e4f",
      "#fc8d59",
      "#fee08b",
      "#ffffbf",
      "#e6f598",
      "#99d594",
      "#3288bd"
    ],
    [
      "#d53e4f",
      "#f46d43",
      "#fdae61",
      "#fee08b",
      "#e6f598",
      "#abdda4",
      "#66c2a5",
      "#3288bd"
    ],
    [
      "#d53e4f",
      "#f46d43",
      "#fdae61",
      "#fee08b",
      "#ffffbf",
      "#e6f598",
      "#abdda4",
      "#66c2a5",
      "#3288bd"
    ],
    [
      "#9e0142",
      "#d53e4f",
      "#f46d43",
      "#fdae61",
      "#fee08b",
      "#e6f598",
      "#abdda4",
      "#66c2a5",
      "#3288bd",
      "#5e4fa2"
    ],
    [
      "#9e0142",
      "#d53e4f",
      "#f46d43",
      "#fdae61",
      "#fee08b",
      "#ffffbf",
      "#e6f598",
      "#abdda4",
      "#66c2a5",
      "#3288bd",
      "#5e4fa2"
    ]
  ];
  const size = Math.min(Math.max(count2, 3), 11);
  return colors[size - 3][index2 % size];
};
registerPalette("spectral", spectral);

// node_modules/@antv/infographic/esm/renderer/palettes/utils.js
var getPaletteColor = (args = [], indexes, total) => {
  var _a;
  const palette2 = typeof args === "string" ? getPalette(args) || [] : args;
  const index2 = (_a = indexes[0]) !== null && _a !== void 0 ? _a : 0;
  if (typeof palette2 === "function") {
    const ratio = total ? index2 / total : 0;
    return palette2(ratio, index2, total !== null && total !== void 0 ? total : 0);
  }
  if (Array.isArray(palette2)) {
    if (palette2.length === 0)
      return;
    return palette2[index2 % palette2.length];
  }
};

// node_modules/@antv/infographic/esm/renderer/composites/background.js
function renderBackground(svg, options) {
  var _a, _b;
  if (((_a = options.svg) === null || _a === void 0 ? void 0 : _a.background) === false)
    return;
  const { themeConfig: { colorBg: background } } = options;
  if (!background)
    return;
  const container = svg.parentElement;
  if (container)
    container.style.backgroundColor = background || "none";
  const element = getElementByRole(
    svg,
    "background"
    /* ElementTypeEnum.Background */
  );
  svg.style.backgroundColor = background;
  if (element) {
    element.setAttribute("fill", background);
  } else if ((_b = svg.viewBox) === null || _b === void 0 ? void 0 : _b.baseVal) {
    const { x: x6, y: y6, width, height } = svg.viewBox.baseVal;
    const rect = createElement("rect", {
      x: x6,
      y: y6,
      width,
      height,
      fill: background,
      "data-element-type": "background"
    });
    svg.prepend(rect);
  }
}

// node_modules/@antv/infographic/esm/renderer/utils/attrs.js
function parseDynamicAttributes(node, attributes) {
  const attrs = Object.entries(attributes).reduce((acc, [key, value]) => {
    if (typeof value === "function") {
      const staticValue = value(node.getAttribute(key), node);
      if (staticValue !== void 0 && staticValue !== null)
        acc[key] = staticValue;
    } else {
      Object.assign(acc, { [key]: value });
    }
    return acc;
  }, {});
  return attrs;
}

// node_modules/@antv/infographic/esm/renderer/utils/id.js
function getSafetyId(id2) {
  return id2.replace(/#|%|\.| |\/|\(|\)/g, "").replace(/,/g, "-");
}

// node_modules/@antv/infographic/esm/renderer/composites/base.js
function renderBaseElement(svg, attrs) {
  if (attrs && Object.keys(attrs).length > 0) {
    traverse(svg, (element) => {
      const parsedAttrs = parseDynamicAttributes(element, attrs);
      setAttributes(element, parsedAttrs);
    });
  }
}

// node_modules/@antv/infographic/esm/renderer/composites/button.js
var ADD_ICON_ID = "btn-add-icon";
var REMOVE_ICON_ID = "btn-remove-icon";
function renderButtonsGroup(svg, group) {
  setAttributes(group, { display: "none" });
  const addBtns = group.querySelectorAll('[id^="btn-add-"]');
  const removeBtns = group.querySelectorAll('[id^="btn-remove-"]');
  defineButtonIcon(svg);
  addBtns.forEach(renderAddButton);
  removeBtns.forEach(renderRemoveButton);
}
var btnIconDefRole = "btn-icon-defs";
function defineButtonIcon(svg) {
  const defs = createElement("defs");
  setElementRole(defs, btnIconDefRole);
  const addIconSymbol = parseSVG(`<symbol class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="200" height="200">
  <path
    d="M512 1024C229.216 1024 0 794.784 0 512S229.216 0 512 0s512 229.216 512 512-229.216 512-512 512z m0-960C264.576 64 64 264.576 64 512s200.576 448 448 448 448-200.576 448-448S759.424 64 512 64z m192 480h-160v160a32 32 0 0 1-64 0v-160h-160a32 32 0 0 1 0-64h160v-160a32 32 0 0 1 64 0v160h160a32 32 0 0 1 0 64z"
    fill="#339900"></path>
</symbol>`);
  if (addIconSymbol) {
    addIconSymbol.setAttribute("id", ADD_ICON_ID);
    defs.appendChild(addIconSymbol);
  }
  const removeIconSymbol = parseSVG(`<symbol viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="200" height="200">
  <path d="M874.971429 149.942857C776.228571 54.857143 648.228571 0 512.914286 0S245.942857 54.857143 150.857143 149.942857c-201.142857 201.142857-201.142857 522.971429 0 724.114286C245.942857 969.142857 377.6 1024 512.914286 1024s266.971429-54.857143 362.057143-149.942857c201.142857-201.142857 201.142857-522.971429 0-724.114286m-51.2 672.914286C739.657143 906.971429 629.942857 950.857143 512.914286 950.857143s-226.742857-43.885714-310.857143-128c-171.885714-171.885714-171.885714-449.828571 0-621.714286C286.171429 117.028571 395.885714 73.142857 512.914286 73.142857s226.742857 43.885714 310.857143 128c171.885714 171.885714 171.885714 449.828571 0 621.714286" fill="#E63C33"></path>
  <path d="M772.571429 475.428571H253.257143c-21.942857 0-36.571429 14.628571-36.571429 36.571429 0 10.971429 3.657143 18.285714 10.971429 25.6s14.628571 10.971429 25.6 10.971429H768.914286c21.942857 0 36.571429-14.628571 36.571428-36.571429s-14.628571-36.571429-32.914285-36.571429" fill="#E63C33"></path>
</symbol>`);
  if (removeIconSymbol) {
    removeIconSymbol.setAttribute("id", REMOVE_ICON_ID);
    defs.appendChild(removeIconSymbol);
  }
  svg.prepend(defs);
}
function renderButtonIcon(node, name) {
  const { id: id2, x: x6 = 0, y: y6 = 0, width = 0, height = 0 } = getAttributes(node, ["id", "x", "y", "width", "height"]);
  const group = createElement("g", {
    id: id2,
    class: "btn-group",
    transform: `translate(${x6}, ${y6})`
  });
  const dataItems = node.getAttribute("data-items");
  if (dataItems) {
    group.setAttribute("data-items", dataItems);
  }
  const r5 = Math.max(+width, +height) / 2;
  const bkg = createElement("circle", {
    cx: r5,
    cy: r5,
    r: r5,
    fill: "#fff",
    stroke: "transparent"
  });
  group.appendChild(bkg);
  const icon = createElement("use", {
    href: `#${name}`,
    width,
    height
  });
  group.appendChild(icon);
  group.style.cursor = "pointer";
  node.replaceWith(group);
}
function renderAddButton(node) {
  renderButtonIcon(node, ADD_ICON_ID);
}
function renderRemoveButton(node) {
  renderButtonIcon(node, REMOVE_ICON_ID);
}

// node_modules/@antv/infographic/esm/resource/loaders/image.js
var __awaiter2 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function isImageBase64Resource(resource) {
  return resource.startsWith("data:");
}
function loadImageBase64Resource(data) {
  return __awaiter2(this, void 0, void 0, function* () {
    var _a;
    if (!data || !isImageBase64Resource(data))
      return null;
    const mimeType = (_a = data.match(/^data:([^;]+)/)) === null || _a === void 0 ? void 0 : _a[1];
    if (!mimeType)
      return null;
    const analysis = () => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          const width2 = img.naturalWidth;
          const height2 = img.naturalHeight;
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          if (!ctx) {
            return resolve({ width: width2, height: height2, hasAlpha: false });
          }
          if (["image/jpeg", "image/jpg", "image/webp", "image/gif"].includes(mimeType)) {
            return resolve({ width: width2, height: height2, hasAlpha: false });
          }
          canvas.width = width2;
          canvas.height = height2;
          ctx.drawImage(img, 0, 0);
          let hasAlpha2 = false;
          const step = 10;
          for (let x6 = 0; x6 < width2; x6 += step) {
            if (hasAlpha2)
              break;
            for (let y6 = 0; y6 < height2; y6 += step) {
              const imageData = ctx.getImageData(x6, y6, 1, 1);
              if (imageData.data[3] < 255) {
                hasAlpha2 = true;
                break;
              }
            }
          }
          resolve({ width: width2, height: height2, hasAlpha: hasAlpha2 });
        };
        img.onerror = () => reject(new Error("Failed to analysis image"));
        img.src = data;
      });
    };
    const { width, height, hasAlpha } = yield analysis();
    const getPreserveAspectRatio = () => {
      if (hasAlpha)
        return "xMidYMid meet";
      if ((mimeType === null || mimeType === void 0 ? void 0 : mimeType.includes("image/gif")) || (mimeType === null || mimeType === void 0 ? void 0 : mimeType.includes("image/svg"))) {
        return "xMidYMid meet";
      }
      const minDimension = Math.min(width, height);
      if (minDimension <= 200)
        return "xMidYMid meet";
      const aspectRatio = width / height;
      if (aspectRatio >= 0.6 && aspectRatio <= 1.67)
        return "xMidYMid meet";
      if (aspectRatio < 0.3 || aspectRatio > 3.33)
        return "xMidYMid meet";
      return "xMidYMid slice";
    };
    const preserveAspectRatio = getPreserveAspectRatio();
    return parseSVG(`
<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="${preserveAspectRatio}">
  <image href="${data}" width="${width}" height="${height}" />
</symbol>`);
  });
}

// node_modules/@antv/infographic/esm/resource/loaders/svg.js
function isSVGResource(resource) {
  const trimmedResource = resource.trim();
  return /^(?:<\?xml[^>]*>\s*)?<svg[\s>]/i.test(trimmedResource) || trimmedResource.startsWith("<symbol");
}
function loadSVGResource(data) {
  if (!data || !isSVGResource(data))
    return null;
  const str = data.replace(/<svg(?=[\s/>])/i, "<symbol").replace(/<\/svg>/i, "</symbol>");
  return parseSVG(str);
}

// node_modules/@antv/infographic/esm/resource/loaders/remote.js
var __awaiter3 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function isRemoteResource(resource) {
  try {
    return Boolean(new URL(resource));
  } catch (_a) {
    return false;
  }
}
function shouldParseAsSVG(contentType, format2) {
  const normalized = contentType.toLowerCase();
  if (normalized.includes("image/svg"))
    return true;
  if (!contentType && format2 === "svg")
    return true;
  return false;
}
function loadRemoteResource(resource, format2) {
  return __awaiter3(this, void 0, void 0, function* () {
    if (!resource || !isRemoteResource(resource))
      return null;
    const response = yield fetchWithCache(resource);
    if (!response.ok)
      throw new Error("Failed to load resource");
    const contentType = response.headers.get("Content-Type") || "";
    if (shouldParseAsSVG(contentType, format2)) {
      const svgText = yield response.text();
      return loadSVGResource(svgText);
    }
    const blob = yield response.blob();
    const base64 = yield blobToBase64(blob);
    return loadImageBase64Resource(base64);
  });
}
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      resolve(reader.result);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// node_modules/@antv/infographic/esm/resource/loaders/search.js
var __awaiter4 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var queryIcon = (query) => __awaiter4(void 0, void 0, void 0, function* () {
  var _a;
  try {
    const params = new URLSearchParams({ text: query, topK: "1" });
    const url = `${ICON_SERVICE_URL}?${params.toString()}`;
    const response = yield fetchWithCache(url);
    if (!response.ok)
      return null;
    const result = yield response.json();
    if (!(result === null || result === void 0 ? void 0 : result.status) || !Array.isArray((_a = result.data) === null || _a === void 0 ? void 0 : _a.data))
      return null;
    return result.data.data[0] || null;
  } catch (error) {
    console.error(`Failed to query icon for "${query}":`, error);
    return null;
  }
});
function isDataURI(resource) {
  return resource.startsWith("data:");
}
function looksLikeSVG(resource) {
  const str = resource.trim();
  return str.startsWith("<svg") || str.startsWith("<symbol");
}
function loadSearchResource(query, format2) {
  return __awaiter4(this, void 0, void 0, function* () {
    var _a;
    if (!query)
      return null;
    const result = yield queryIcon(query);
    if (!result)
      return null;
    if (looksLikeSVG(result))
      return loadSVGResource(result);
    if (isDataURI(result)) {
      const mimeType = ((_a = result.match(/^data:([^;]+)/)) === null || _a === void 0 ? void 0 : _a[1]) || "";
      const isBase64 = result.includes(";base64,");
      if (mimeType === "image/svg+xml" && !isBase64) {
        const commaIndex = result.indexOf(",");
        const svgText = commaIndex >= 0 ? result.slice(commaIndex + 1) : result;
        return loadSVGResource(svgText);
      }
      if (mimeType === "image/svg+xml" && format2 === "svg" && isBase64) {
        return loadImageBase64Resource(result);
      }
      return loadImageBase64Resource(result);
    }
    return loadRemoteResource(result, format2);
  });
}

// node_modules/@antv/infographic/esm/resource/registry.js
var customResourceLoader = null;
function getCustomResourceLoader() {
  return customResourceLoader;
}

// node_modules/@antv/infographic/esm/resource/utils/data-uri.js
function parseDataURI(resource) {
  if (!resource.startsWith("data:"))
    return null;
  const commaIndex = resource.indexOf(",");
  if (commaIndex === -1)
    return null;
  const header = resource.slice(5, commaIndex);
  const data = resource.slice(commaIndex + 1);
  const parts = header.split(";");
  const mimeType = parts[0];
  const isBase64 = parts.includes("base64");
  if (mimeType === "image/svg+xml" && !isBase64) {
    const decoded = data.startsWith("%3C") ? decodeURIComponent(data) : data;
    return {
      source: "inline",
      format: "svg",
      encoding: "raw",
      data: decoded
    };
  }
  if (mimeType.startsWith("image/")) {
    const format2 = mimeType === "image/svg+xml" ? "svg" : "image";
    return {
      source: "inline",
      format: format2,
      encoding: isBase64 ? "base64" : "data-uri",
      data: resource
    };
  }
  return null;
}

// node_modules/@antv/infographic/esm/resource/utils/parser.js
var KNOWN_FORMATS = /* @__PURE__ */ new Set(["svg", "png", "jpg", "jpeg", "webp", "gif"]);
function looksLikeSVG2(resource) {
  const str = resource.trim();
  return str.startsWith("<svg") || str.startsWith("<symbol");
}
function inferFormatFromUrl(url) {
  const lower2 = url.toLowerCase();
  if (lower2.endsWith(".svg") || lower2.includes(".svg?"))
    return "svg";
  if (lower2.endsWith(".png") || lower2.endsWith(".jpg") || lower2.endsWith(".jpeg") || lower2.endsWith(".webp") || lower2.endsWith(".gif")) {
    return "image";
  }
  return void 0;
}
function parseRefResource(resource) {
  var _a;
  if (!resource.startsWith("ref:"))
    return null;
  const rest = resource.slice(4);
  const [source, ...restParts] = rest.split(":");
  if (!source || restParts.length === 0)
    return null;
  let format2;
  if (restParts.length > 1 && KNOWN_FORMATS.has(restParts[0].toLowerCase())) {
    format2 = (_a = restParts.shift()) === null || _a === void 0 ? void 0 : _a.toLowerCase();
  }
  const payload = restParts.join(":");
  if (!payload)
    return null;
  const normalizedSource = source === "url" ? "remote" : source;
  if (normalizedSource === "remote") {
    return {
      source: "remote",
      format: format2 || inferFormatFromUrl(payload) || void 0,
      data: payload
    };
  }
  if (normalizedSource === "search") {
    return {
      source: "search",
      format: format2 || "svg",
      data: payload
    };
  }
  if (normalizedSource === "svg") {
    return { source: "inline", format: "svg", data: payload, encoding: "raw" };
  }
  return { source: "custom", data: resource, format: format2 };
}
function parseResourceConfig(config) {
  if (!config)
    return null;
  if (typeof config !== "string") {
    if (config.source)
      return config;
    const legacy = config;
    if (legacy.type === "image") {
      return { source: "inline", format: "image", data: legacy.data };
    }
    if (legacy.type === "svg") {
      return {
        source: "inline",
        format: "svg",
        encoding: "raw",
        data: legacy.data
      };
    }
    if (legacy.type === "remote") {
      return { source: "remote", format: legacy.format, data: legacy.data };
    }
    if (legacy.type === "search") {
      return {
        source: "search",
        format: legacy.format || "svg",
        data: legacy.data
      };
    }
    if (legacy.type === "custom") {
      return { source: "custom", data: legacy.data };
    }
    return null;
  }
  const dataURIConfig = parseDataURI(config);
  if (dataURIConfig)
    return dataURIConfig;
  const refConfig = parseRefResource(config);
  if (refConfig)
    return refConfig;
  if (looksLikeSVG2(config)) {
    return { source: "inline", format: "svg", encoding: "raw", data: config };
  }
  return { source: "custom", data: config };
}

// node_modules/@antv/infographic/esm/resource/utils/ref.js
function getResourceId(config) {
  const cfg = typeof config === "string" ? parseResourceConfig(config) : config;
  if (!cfg)
    return null;
  return "rsc-" + getSimpleHash(JSON.stringify(cfg));
}
function getResourceHref(config) {
  const id2 = getResourceId(config);
  if (!id2)
    return null;
  return `#${id2}`;
}

// node_modules/@antv/infographic/esm/resource/loader.js
var __awaiter5 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getResource(scene, config, datum2) {
  return __awaiter5(this, void 0, void 0, function* () {
    const cfg = parseResourceConfig(config);
    if (!cfg)
      return null;
    cfg.scene || (cfg.scene = scene);
    const { source, data, format: format2, encoding } = cfg;
    let resource = null;
    try {
      if (source === "inline") {
        const isDataURI2 = data.startsWith("data:");
        if (format2 === "svg" && encoding === "raw") {
          resource = loadSVGResource(data);
        } else if (format2 === "svg" && isDataURI2) {
          resource = yield loadImageBase64Resource(data);
        } else if (isDataURI2 || format2 === "image") {
          resource = yield loadImageBase64Resource(data);
        } else {
          resource = loadSVGResource(data);
        }
      } else if (source === "remote") {
        resource = yield loadRemoteResource(data, format2);
      } else if (source === "search") {
        resource = yield loadSearchResource(data, format2);
      } else {
        const customLoader = getCustomResourceLoader();
        if (customLoader)
          resource = yield customLoader(cfg);
      }
    } catch (_a) {
      resource = null;
    }
    if (resource)
      return resource;
    return yield loadSearchResource(getFallbackQuery(cfg, scene, datum2), format2);
  });
}
var RESOURCE_MAP = /* @__PURE__ */ new Map();
var RESOURCE_LOAD_MAP = /* @__PURE__ */ new WeakMap();
function loadResource(svg, scene, config, datum2) {
  return __awaiter5(this, void 0, void 0, function* () {
    if (!svg)
      return null;
    const cfg = parseResourceConfig(config);
    if (!cfg)
      return null;
    const id2 = getResourceId(cfg);
    const promiseKey = `resource:${id2}`;
    const loadedMap = RESOURCE_LOAD_MAP.get(svg);
    if (loadedMap === null || loadedMap === void 0 ? void 0 : loadedMap.has(id2))
      return id2;
    const existingPromise = getSvgLoadPromise(svg, promiseKey);
    if (existingPromise)
      return yield existingPromise;
    const loadPromise = (() => __awaiter5(this, void 0, void 0, function* () {
      const resource = RESOURCE_MAP.has(id2) ? RESOURCE_MAP.get(id2) || null : yield getResource(scene, cfg, datum2);
      if (!resource)
        return null;
      if (!RESOURCE_LOAD_MAP.has(svg))
        RESOURCE_LOAD_MAP.set(svg, /* @__PURE__ */ new Map());
      const map2 = RESOURCE_LOAD_MAP.get(svg);
      if (map2.has(id2))
        return id2;
      const defs = getOrCreateDefs(svg);
      resource.id = id2;
      defs.appendChild(resource);
      map2.set(id2, resource);
      return id2;
    }))();
    trackSvgLoadPromise(svg, promiseKey, loadPromise);
    return yield loadPromise;
  });
}
function getFallbackQuery(cfg, scene, datum2) {
  const defaultQuery = scene === "illus" ? "illustration" : "icon";
  const datumQuery = normalizeQuery(cfg.data) || normalizeQuery(datum2 === null || datum2 === void 0 ? void 0 : datum2.label) || normalizeQuery(datum2 === null || datum2 === void 0 ? void 0 : datum2.desc);
  if (datumQuery)
    return datumQuery;
  const data = normalizeQuery(cfg.data);
  if (!data)
    return defaultQuery;
  if (cfg.source === "inline")
    return defaultQuery;
  if (data.startsWith("data:"))
    return defaultQuery;
  if (data.startsWith("<svg") || data.startsWith("<symbol"))
    return defaultQuery;
  return data;
}
function normalizeQuery(value) {
  if (typeof value !== "string")
    return null;
  const trimmed = value.trim();
  return trimmed ? trimmed : null;
}

// node_modules/@antv/infographic/esm/renderer/composites/icon.js
function renderItemIcon(svg, node, datum2, options) {
  var _a, _b;
  const value = datum2.icon;
  if (!value)
    return null;
  const { themeConfig } = options;
  const dataAttrs = (_a = datum2.attributes) === null || _a === void 0 ? void 0 : _a.icon;
  const attrs = Object.assign(Object.assign({}, (_b = themeConfig.item) === null || _b === void 0 ? void 0 : _b.icon), dataAttrs);
  const parsedAttrs = parseDynamicAttributes(node, attrs);
  return createIcon(svg, node, value, parsedAttrs, datum2);
}
function createIcon(svg, node, value, attrs, datum2) {
  loadResource(svg, "icon", value, datum2);
  return createIconElement(value, Object.assign(Object.assign({}, getAttributes(node, [
    "id",
    "x",
    "y",
    "width",
    "height",
    "fill",
    "stroke",
    "data-element-type",
    "data-indexes"
  ])), attrs));
}

// node_modules/@antv/infographic/esm/renderer/composites/illus.js
var __rest2 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
function renderIllus(svg, node, value, datum2, attrs = {}) {
  if (!value)
    return null;
  const config = parseResourceConfig(value);
  if (!config)
    return null;
  const id2 = getResourceId(config);
  if (attrs && Object.keys(attrs).length > 0) {
    setAttributes(node, attrs);
  }
  const clipPathId = createClipPath(svg, node, id2);
  loadResource(svg, "illus", config, datum2);
  const { data, color: color3 } = config;
  return createIllusElement(id2, Object.assign(Object.assign(Object.assign(Object.assign({}, parseIllusBounds(node)), color3 ? { color: color3 } : {}), attrs), { "clip-path": `url(#${clipPathId})` }), data);
}
function renderItemIllus(svg, node, datum2) {
  var _a;
  const value = datum2.illus;
  const attrs = (_a = datum2.attributes) === null || _a === void 0 ? void 0 : _a.illus;
  return renderIllus(svg, node, value, datum2, attrs);
}
function createClipPath(svg, node, id2) {
  const clipPathId = `clip-${id2}-${uuid()}`;
  if (svg.querySelector(`#${clipPathId}`)) {
    return clipPathId;
  }
  const defs = getOrCreateDefs(svg);
  const clipPath = createElement("clipPath", {
    id: clipPathId
  });
  const clonedNode = node.cloneNode();
  removeAttributes(clonedNode, [
    "id",
    "data-illus-bounds",
    "data-element-type"
  ]);
  clipPath.appendChild(clonedNode);
  defs.appendChild(clipPath);
  return clipPathId;
}
function createIllusElement(id2, attrs, value) {
  const { "clip-path": clipPath } = attrs, restAttrs = __rest2(attrs, ["clip-path"]);
  const { x: x6 = "0", y: y6 = "0", width = "0", height = "0" } = restAttrs;
  const bounds = createElement("rect", {
    id: `${id2}-volume`,
    "data-element-type": "illus-volume",
    x: x6,
    y: y6,
    width,
    height,
    fill: "transparent"
  });
  const g3 = createElement("g", {
    "data-element-type": "illus-group",
    "clip-path": clipPath,
    id: `${id2}-group`
  });
  g3.appendChild(bounds);
  const use = createElement("use", Object.assign(Object.assign({ id: id2, fill: "lightgray" }, restAttrs), {
    href: getResourceHref(value),
    "data-element-type": "illus"
    /* ElementTypeEnum.Illus */
  }));
  g3.appendChild(use);
  return g3;
}
function parseIllusBounds(node) {
  const dataIllusBounds = node.getAttribute("data-illus-bounds");
  if (!dataIllusBounds) {
    return Object.assign({ x: "0", y: "0", width: "0", height: "0" }, getAttributes(node, ["x", "y", "width", "height"]));
  }
  const [x6, y6, width, height] = dataIllusBounds.split(" ");
  return { x: x6, y: y6, width, height };
}

// node_modules/tinycolor2/esm/tinycolor.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color3, opts) {
  color3 = color3 ? color3 : "";
  opts = opts || {};
  if (color3 instanceof tinycolor) {
    return color3;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color3, opts);
  }
  var rgb4 = inputToRGB(color3);
  this._originalInput = color3, this._r = rgb4.r, this._g = rgb4.g, this._b = rgb4.b, this._a = rgb4.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb4.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb4.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb4 = this.toRgb();
    return (rgb4.r * 299 + rgb4.g * 587 + rgb4.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb4 = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R3, G3, B2;
    RsRGB = rgb4.r / 255;
    GsRGB = rgb4.g / 255;
    BsRGB = rgb4.b / 255;
    if (RsRGB <= 0.03928)
      R3 = RsRGB / 12.92;
    else
      R3 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G3 = GsRGB / 12.92;
    else
      G3 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B2 = BsRGB / 12.92;
    else
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R3 + 0.7152 * G3 + 0.0722 * B2;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv2 = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv2.h * 360,
      s: hsv2.s,
      v: hsv2.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv2 = rgbToHsv(this._r, this._g, this._b);
    var h4 = Math.round(hsv2.h * 360), s3 = Math.round(hsv2.s * 100), v2 = Math.round(hsv2.v * 100);
    return this._a == 1 ? "hsv(" + h4 + ", " + s3 + "%, " + v2 + "%)" : "hsva(" + h4 + ", " + s3 + "%, " + v2 + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl4 = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl4.h * 360,
      s: hsl4.s,
      l: hsl4.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl4 = rgbToHsl(this._r, this._g, this._b);
    var h4 = Math.round(hsl4.h * 360), s3 = Math.round(hsl4.s * 100), l3 = Math.round(hsl4.l * 100);
    return this._a == 1 ? "hsl(" + h4 + ", " + s3 + "%, " + l3 + "%)" : "hsla(" + h4 + ", " + s3 + "%, " + l3 + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s3 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s3._r, s3._g, s3._b, s3._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString2(format2) {
    var formatSet = !!format2;
    format2 = format2 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn5, args) {
    var color3 = fn5.apply(null, [this].concat([].slice.call(args)));
    this._r = color3._r;
    this._g = color3._g;
    this._b = color3._b;
    this.setAlpha(color3._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn5, args) {
    return fn5.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color3, opts) {
  if (_typeof(color3) == "object") {
    var newColor = {};
    for (var i4 in color3) {
      if (color3.hasOwnProperty(i4)) {
        if (i4 === "a") {
          newColor[i4] = color3[i4];
        } else {
          newColor[i4] = convertToPercentage(color3[i4]);
        }
      }
    }
    color3 = newColor;
  }
  return tinycolor(color3, opts);
};
function inputToRGB(color3) {
  var rgb4 = {
    r: 0,
    g: 0,
    b: 0
  };
  var a3 = 1;
  var s3 = null;
  var v2 = null;
  var l3 = null;
  var ok = false;
  var format2 = false;
  if (typeof color3 == "string") {
    color3 = stringInputToObject(color3);
  }
  if (_typeof(color3) == "object") {
    if (isValidCSSUnit(color3.r) && isValidCSSUnit(color3.g) && isValidCSSUnit(color3.b)) {
      rgb4 = rgbToRgb(color3.r, color3.g, color3.b);
      ok = true;
      format2 = String(color3.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color3.h) && isValidCSSUnit(color3.s) && isValidCSSUnit(color3.v)) {
      s3 = convertToPercentage(color3.s);
      v2 = convertToPercentage(color3.v);
      rgb4 = hsvToRgb(color3.h, s3, v2);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color3.h) && isValidCSSUnit(color3.s) && isValidCSSUnit(color3.l)) {
      s3 = convertToPercentage(color3.s);
      l3 = convertToPercentage(color3.l);
      rgb4 = hslToRgb(color3.h, s3, l3);
      ok = true;
      format2 = "hsl";
    }
    if (color3.hasOwnProperty("a")) {
      a3 = color3.a;
    }
  }
  a3 = boundAlpha(a3);
  return {
    ok,
    format: color3.format || format2,
    r: Math.min(255, Math.max(rgb4.r, 0)),
    g: Math.min(255, Math.max(rgb4.g, 0)),
    b: Math.min(255, Math.max(rgb4.b, 0)),
    a: a3
  };
}
function rgbToRgb(r5, g3, b2) {
  return {
    r: bound01(r5, 255) * 255,
    g: bound01(g3, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function rgbToHsl(r5, g3, b2) {
  r5 = bound01(r5, 255);
  g3 = bound01(g3, 255);
  b2 = bound01(b2, 255);
  var max3 = Math.max(r5, g3, b2), min3 = Math.min(r5, g3, b2);
  var h4, s3, l3 = (max3 + min3) / 2;
  if (max3 == min3) {
    h4 = s3 = 0;
  } else {
    var d3 = max3 - min3;
    s3 = l3 > 0.5 ? d3 / (2 - max3 - min3) : d3 / (max3 + min3);
    switch (max3) {
      case r5:
        h4 = (g3 - b2) / d3 + (g3 < b2 ? 6 : 0);
        break;
      case g3:
        h4 = (b2 - r5) / d3 + 2;
        break;
      case b2:
        h4 = (r5 - g3) / d3 + 4;
        break;
    }
    h4 /= 6;
  }
  return {
    h: h4,
    s: s3,
    l: l3
  };
}
function hslToRgb(h4, s3, l3) {
  var r5, g3, b2;
  h4 = bound01(h4, 360);
  s3 = bound01(s3, 100);
  l3 = bound01(l3, 100);
  function hue2rgb(p8, q3, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6)
      return p8 + (q3 - p8) * 6 * t2;
    if (t2 < 1 / 2)
      return q3;
    if (t2 < 2 / 3)
      return p8 + (q3 - p8) * (2 / 3 - t2) * 6;
    return p8;
  }
  if (s3 === 0) {
    r5 = g3 = b2 = l3;
  } else {
    var q2 = l3 < 0.5 ? l3 * (1 + s3) : l3 + s3 - l3 * s3;
    var p7 = 2 * l3 - q2;
    r5 = hue2rgb(p7, q2, h4 + 1 / 3);
    g3 = hue2rgb(p7, q2, h4);
    b2 = hue2rgb(p7, q2, h4 - 1 / 3);
  }
  return {
    r: r5 * 255,
    g: g3 * 255,
    b: b2 * 255
  };
}
function rgbToHsv(r5, g3, b2) {
  r5 = bound01(r5, 255);
  g3 = bound01(g3, 255);
  b2 = bound01(b2, 255);
  var max3 = Math.max(r5, g3, b2), min3 = Math.min(r5, g3, b2);
  var h4, s3, v2 = max3;
  var d3 = max3 - min3;
  s3 = max3 === 0 ? 0 : d3 / max3;
  if (max3 == min3) {
    h4 = 0;
  } else {
    switch (max3) {
      case r5:
        h4 = (g3 - b2) / d3 + (g3 < b2 ? 6 : 0);
        break;
      case g3:
        h4 = (b2 - r5) / d3 + 2;
        break;
      case b2:
        h4 = (r5 - g3) / d3 + 4;
        break;
    }
    h4 /= 6;
  }
  return {
    h: h4,
    s: s3,
    v: v2
  };
}
function hsvToRgb(h4, s3, v2) {
  h4 = bound01(h4, 360) * 6;
  s3 = bound01(s3, 100);
  v2 = bound01(v2, 100);
  var i4 = Math.floor(h4), f5 = h4 - i4, p7 = v2 * (1 - s3), q2 = v2 * (1 - f5 * s3), t2 = v2 * (1 - (1 - f5) * s3), mod = i4 % 6, r5 = [v2, q2, p7, p7, t2, v2][mod], g3 = [t2, v2, v2, q2, p7, p7][mod], b2 = [p7, p7, t2, v2, v2, q2][mod];
  return {
    r: r5 * 255,
    g: g3 * 255,
    b: b2 * 255
  };
}
function rgbToHex(r5, g3, b2, allow3Char) {
  var hex4 = [pad2(Math.round(r5).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b2).toString(16))];
  if (allow3Char && hex4[0].charAt(0) == hex4[0].charAt(1) && hex4[1].charAt(0) == hex4[1].charAt(1) && hex4[2].charAt(0) == hex4[2].charAt(1)) {
    return hex4[0].charAt(0) + hex4[1].charAt(0) + hex4[2].charAt(0);
  }
  return hex4.join("");
}
function rgbaToHex(r5, g3, b2, a3, allow4Char) {
  var hex4 = [pad2(Math.round(r5).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b2).toString(16)), pad2(convertDecimalToHex(a3))];
  if (allow4Char && hex4[0].charAt(0) == hex4[0].charAt(1) && hex4[1].charAt(0) == hex4[1].charAt(1) && hex4[2].charAt(0) == hex4[2].charAt(1) && hex4[3].charAt(0) == hex4[3].charAt(1)) {
    return hex4[0].charAt(0) + hex4[1].charAt(0) + hex4[2].charAt(0) + hex4[3].charAt(0);
  }
  return hex4.join("");
}
function rgbaToArgbHex(r5, g3, b2, a3) {
  var hex4 = [pad2(convertDecimalToHex(a3)), pad2(Math.round(r5).toString(16)), pad2(Math.round(g3).toString(16)), pad2(Math.round(b2).toString(16))];
  return hex4.join("");
}
tinycolor.equals = function(color1, color22) {
  if (!color1 || !color22)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color22).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl4 = tinycolor(color3).toHsl();
  hsl4.s -= amount / 100;
  hsl4.s = clamp01(hsl4.s);
  return tinycolor(hsl4);
}
function _saturate(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl4 = tinycolor(color3).toHsl();
  hsl4.s += amount / 100;
  hsl4.s = clamp01(hsl4.s);
  return tinycolor(hsl4);
}
function _greyscale(color3) {
  return tinycolor(color3).desaturate(100);
}
function _lighten(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl4 = tinycolor(color3).toHsl();
  hsl4.l += amount / 100;
  hsl4.l = clamp01(hsl4.l);
  return tinycolor(hsl4);
}
function _brighten(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb4 = tinycolor(color3).toRgb();
  rgb4.r = Math.max(0, Math.min(255, rgb4.r - Math.round(255 * -(amount / 100))));
  rgb4.g = Math.max(0, Math.min(255, rgb4.g - Math.round(255 * -(amount / 100))));
  rgb4.b = Math.max(0, Math.min(255, rgb4.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb4);
}
function _darken(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl4 = tinycolor(color3).toHsl();
  hsl4.l -= amount / 100;
  hsl4.l = clamp01(hsl4.l);
  return tinycolor(hsl4);
}
function _spin(color3, amount) {
  var hsl4 = tinycolor(color3).toHsl();
  var hue3 = (hsl4.h + amount) % 360;
  hsl4.h = hue3 < 0 ? 360 + hue3 : hue3;
  return tinycolor(hsl4);
}
function _complement(color3) {
  var hsl4 = tinycolor(color3).toHsl();
  hsl4.h = (hsl4.h + 180) % 360;
  return tinycolor(hsl4);
}
function polyad(color3, number5) {
  if (isNaN(number5) || number5 <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl4 = tinycolor(color3).toHsl();
  var result = [tinycolor(color3)];
  var step = 360 / number5;
  for (var i4 = 1; i4 < number5; i4++) {
    result.push(tinycolor({
      h: (hsl4.h + i4 * step) % 360,
      s: hsl4.s,
      l: hsl4.l
    }));
  }
  return result;
}
function _splitcomplement(color3) {
  var hsl4 = tinycolor(color3).toHsl();
  var h4 = hsl4.h;
  return [tinycolor(color3), tinycolor({
    h: (h4 + 72) % 360,
    s: hsl4.s,
    l: hsl4.l
  }), tinycolor({
    h: (h4 + 216) % 360,
    s: hsl4.s,
    l: hsl4.l
  })];
}
function _analogous(color3, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl4 = tinycolor(color3).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color3)];
  for (hsl4.h = (hsl4.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl4.h = (hsl4.h + part) % 360;
    ret.push(tinycolor(hsl4));
  }
  return ret;
}
function _monochromatic(color3, results) {
  results = results || 6;
  var hsv2 = tinycolor(color3).toHsv();
  var h4 = hsv2.h, s3 = hsv2.s, v2 = hsv2.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h4,
      s: s3,
      v: v2
    }));
    v2 = (v2 + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color22, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb22 = tinycolor(color22).toRgb();
  var p7 = amount / 100;
  var rgba2 = {
    r: (rgb22.r - rgb1.r) * p7 + rgb1.r,
    g: (rgb22.g - rgb1.g) * p7 + rgb1.g,
    b: (rgb22.b - rgb1.b) * p7 + rgb1.b,
    a: (rgb22.a - rgb1.a) * p7 + rgb1.a
  };
  return tinycolor(rgba2);
};
tinycolor.readability = function(color1, color22) {
  var c1 = tinycolor(color1);
  var c22 = tinycolor(color22);
  return (Math.max(c1.getLuminance(), c22.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c22.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color22, wcag2) {
  var readability = tinycolor.readability(color1, color22);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i4 = 0; i4 < colorList.length; i4++) {
    readability = tinycolor.readability(baseColor, colorList[i4]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i4]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o3) {
  var flipped = {};
  for (var i4 in o3) {
    if (o3.hasOwnProperty(i4)) {
      flipped[o3[i4]] = i4;
    }
  }
  return flipped;
}
function boundAlpha(a3) {
  a3 = parseFloat(a3);
  if (isNaN(a3) || a3 < 0 || a3 > 1) {
    a3 = 1;
  }
  return a3;
}
function bound01(n4, max3) {
  if (isOnePointZero(n4))
    n4 = "100%";
  var processPercent = isPercentage(n4);
  n4 = Math.min(max3, Math.max(0, parseFloat(n4)));
  if (processPercent) {
    n4 = parseInt(n4 * max3, 10) / 100;
  }
  if (Math.abs(n4 - max3) < 1e-6) {
    return 1;
  }
  return n4 % max3 / parseFloat(max3);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n4) {
  return typeof n4 == "string" && n4.indexOf(".") != -1 && parseFloat(n4) === 1;
}
function isPercentage(n4) {
  return typeof n4 === "string" && n4.indexOf("%") != -1;
}
function pad2(c4) {
  return c4.length == 1 ? "0" + c4 : "" + c4;
}
function convertToPercentage(n4) {
  if (n4 <= 1) {
    n4 = n4 * 100 + "%";
  }
  return n4;
}
function convertDecimalToHex(d3) {
  return Math.round(parseFloat(d3) * 255).toString(16);
}
function convertHexToDecimal(h4) {
  return parseIntFromHex(h4) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color3) {
  return !!matchers.CSS_UNIT.exec(color3);
}
function stringInputToObject(color3) {
  color3 = color3.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named3 = false;
  if (names[color3]) {
    color3 = names[color3];
    named3 = true;
  } else if (color3 == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color3)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color3)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color3)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named3 ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color3)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named3 ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color3)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named3 ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color3)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named3 ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}

// node_modules/@antv/infographic/esm/renderer/stylize/gradient.js
function applyGradientStyle(node, svg, config, attr) {
  const currentColor = node.getAttribute(attr);
  const actualConfig = inferGradientConfig(currentColor, config);
  const { type: type2, colors = [] } = actualConfig;
  const size = colors.length - 1;
  const stops = colors.map((color3, index2) => {
    if (typeof color3 === "string") {
      return createElement("stop", {
        offset: `${index2 / size}`,
        "stop-color": color3
      });
    } else {
      return createElement("stop", {
        offset: `${color3.offset}`,
        "stop-color": color3.color
      });
    }
  });
  const id2 = getGradientId(actualConfig);
  if (type2 === "linear-gradient") {
    const { angle = 0 } = actualConfig;
    const [[x1, y1], [x22, y22]] = angleToUnitVector(angle);
    const linearGradient = createElement("linearGradient", {
      id: id2,
      x1,
      y1,
      x2: x22,
      y2: y22
    });
    stops.forEach((stop) => linearGradient.appendChild(stop));
    upsertGradient(svg, id2, linearGradient);
  } else if (type2 === "radial-gradient") {
    const radialGradient = createElement("radialGradient", {
      id: id2
    });
    stops.forEach((stop) => radialGradient.appendChild(stop));
    upsertGradient(svg, id2, radialGradient);
  }
  const fill2 = node.getAttribute("fill");
  const stroke = node.getAttribute("stroke");
  if (hasColor(fill2))
    node.setAttribute("fill", `url(#${id2})`);
  if (hasColor(stroke))
    node.setAttribute("stroke", `url(#${id2})`);
}
function upsertGradient(svg, id2, gradient) {
  const defs = getOrCreateDefs(svg);
  gradient.setAttribute("id", id2);
  const exist = defs.querySelector(`#${id2}`);
  if (exist)
    exist.replaceWith(gradient);
  else
    defs.appendChild(gradient);
}
function inferGradientConfig(currentColor, config) {
  var _a;
  if (((_a = config.colors) === null || _a === void 0 ? void 0 : _a.length) || !currentColor)
    return config;
  const tc = tinycolor(currentColor);
  const inferConfig = Object.assign({}, config);
  inferConfig.colors = tc.isDark() ? [currentColor, tc.lighten(20).toHexString()] : [tc.darken(20).toHexString(), currentColor];
  if (!("angle" in config) && inferConfig.type === "linear-gradient") {
    inferConfig.angle = 225;
  }
  return inferConfig;
}
function getGradientId(config) {
  const { type: type2, colors = [] } = config;
  const colorId = getSafetyId(colors.map((color3) => {
    if (typeof color3 === "string")
      return color3;
    return `${color3.color}_${color3.offset}`;
  }).join("-"));
  if (type2 === "linear-gradient") {
    const { angle = 0 } = config;
    return `${type2}-${colorId}-${angle}`;
  }
  return `${type2}-${colorId}`;
}
function angleToUnitVector(angle) {
  const radians = Math.PI / 180 * angle;
  const x6 = Math.cos(radians);
  const y6 = Math.sin(radians);
  return [
    [0.5 - x6 / 2, 0.5 - y6 / 2],
    // 
    [0.5 + x6 / 2, 0.5 + y6 / 2]
    // 
  ];
}

// node_modules/@antv/infographic/esm/renderer/stylize/patterns/index.js
var patterns_exports = {};
__export(patterns_exports, {
  diamond: () => diamond,
  dot: () => dot,
  hex: () => hex2,
  line: () => line,
  mosaic: () => mosaic,
  square: () => square
});

// node_modules/@antv/infographic/esm/renderer/stylize/patterns/diamond.js
var diamond = ({ scale = 0.5, backgroundColor, foregroundColor }) => {
  const pattern = createElement("pattern", {
    id: "pattern-diamond",
    width: "20",
    height: "20",
    patternTransform: `scale(${scale})`,
    patternUnits: "userSpaceOnUse"
  });
  const rect = createElement("rect", {
    width: "100%",
    height: "100%",
    fill: backgroundColor
  });
  const path2 = createElement("path", {
    d: "M0,0 L20,20 M20,0 L0,20",
    stroke: foregroundColor,
    "stroke-width": "1"
  });
  pattern.appendChild(rect);
  pattern.appendChild(path2);
  return pattern;
};

// node_modules/@antv/infographic/esm/renderer/stylize/patterns/dot.js
var dot = ({ scale = 1, backgroundColor, foregroundColor }) => {
  const pattern = createElement("pattern", {
    id: "pattern-dot",
    width: "20",
    height: "20",
    patternTransform: `scale(${scale})`,
    patternUnits: "userSpaceOnUse"
  });
  const rect = createElement("rect", {
    width: "100%",
    height: "100%",
    fill: backgroundColor
  });
  const circle1 = createElement("circle", {
    cx: "5",
    cy: "5",
    r: "3",
    fill: foregroundColor
  });
  const circle2 = createElement("circle", {
    cx: "15",
    cy: "15",
    r: "3",
    fill: foregroundColor
  });
  pattern.appendChild(rect);
  pattern.appendChild(circle1);
  pattern.appendChild(circle2);
  return pattern;
};

// node_modules/@antv/infographic/esm/renderer/stylize/patterns/hex.js
var hex2 = ({ scale = 0.3, backgroundColor, foregroundColor }) => {
  const pattern = createElement("pattern", {
    id: "pattern-hex",
    width: "20",
    height: "20",
    patternTransform: `scale(${scale})`,
    patternUnits: "userSpaceOnUse"
  });
  const rect = createElement("rect", {
    width: "100%",
    height: "100%",
    fill: backgroundColor
  });
  const path2 = createElement("path", {
    d: "M10,0 L20,5 L20,15 L10,20 L0,15 L0,5 Z",
    fill: foregroundColor
  });
  pattern.appendChild(rect);
  pattern.appendChild(path2);
  return pattern;
};

// node_modules/@antv/infographic/esm/renderer/stylize/patterns/line.js
var line = ({ scale = 1, backgroundColor, foregroundColor }) => {
  const strokeWidth = 6;
  const hSW = strokeWidth / 2;
  const pattern = createElement("pattern", {
    id: "pattern-line",
    width: "20",
    height: "20",
    patternTransform: `scale(${scale})`,
    patternUnits: "userSpaceOnUse"
  });
  const rect = createElement("rect", {
    width: "100%",
    height: "100%",
    fill: backgroundColor
  });
  const line1 = createElement("line", {
    x1: `${10 - hSW}`,
    y1: `${0 - hSW}`,
    x2: `${20 + hSW}`,
    y2: `${10 + hSW}`,
    stroke: foregroundColor,
    "stroke-width": strokeWidth,
    "stroke-opacity": "0.5"
  });
  const line2 = createElement("line", {
    x1: `${0 - hSW}`,
    y1: `${10 - hSW}`,
    x2: `${10 + hSW}`,
    y2: `${20 + hSW}`,
    stroke: foregroundColor,
    "stroke-width": strokeWidth,
    "stroke-opacity": "0.5"
  });
  pattern.appendChild(rect);
  pattern.appendChild(line1);
  pattern.appendChild(line2);
  return pattern;
};

// node_modules/@antv/infographic/esm/renderer/stylize/patterns/mosaic.js
var mosaic = ({ scale = 1, backgroundColor = "#ffffff", foregroundColor = "#000000" }) => {
  const patternSize = 20;
  const tileSize = 5;
  const rows = patternSize / tileSize;
  const cols = patternSize / tileSize;
  const pattern = createElement("pattern", {
    id: "pattern-mosaic",
    width: patternSize,
    height: patternSize,
    patternUnits: "userSpaceOnUse",
    patternTransform: `scale(${scale})`
  });
  const background = createElement("rect", {
    width: "100%",
    height: "100%",
    fill: backgroundColor
  });
  pattern.appendChild(background);
  for (let y6 = 0; y6 < rows; y6++) {
    for (let x6 = 0; x6 < cols; x6++) {
      if ((x6 + y6) % 2 === 0) {
        const rect = createElement("rect", {
          x: x6 * tileSize,
          y: y6 * tileSize,
          width: tileSize,
          height: tileSize,
          fill: foregroundColor
        });
        pattern.appendChild(rect);
      }
    }
  }
  return pattern;
};

// node_modules/@antv/infographic/esm/renderer/stylize/patterns/square.js
var square = ({ scale = 0.3, backgroundColor, foregroundColor }) => {
  const pattern = createElement("pattern", {
    id: "pattern-square",
    width: "20",
    height: "20",
    patternTransform: `scale(${scale})`,
    patternUnits: "userSpaceOnUse"
  });
  const rect = createElement("rect", {
    width: "100%",
    height: "100%",
    fill: backgroundColor
  });
  const path2 = createElement("path", {
    d: "M0,0 L20,0 L20,20 L0,20 Z",
    fill: foregroundColor
  });
  pattern.appendChild(rect);
  pattern.appendChild(path2);
  return pattern;
};

// node_modules/@antv/infographic/esm/renderer/stylize/pattern.js
var __rest3 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var PATTERNS = /* @__PURE__ */ new Map();
function registerPattern(name, generator) {
  if (PATTERNS.has(name))
    console.warn(`Pattern ${name} will be overwritten`);
  PATTERNS.set(name, generator);
}
for (const [name, generator] of Object.entries(patterns_exports)) {
  registerPattern(name, generator);
}
function applyPatternStyle(node, svg, options) {
  const config = options.themeConfig.stylize;
  if (!config || config.type !== "pattern")
    return;
  const { pattern } = config, restConfig = __rest3(config, ["pattern"]);
  const generator = PATTERNS.get(pattern);
  if (!generator) {
    return console.warn(`Pattern ${pattern} not found`);
  }
  const { fill: fill2 } = getAttributes(node, ["fill", "stroke"]);
  const color3 = fill2;
  const style = Object.assign({ backgroundColor: color3 ? tinycolor(color3).setAlpha(0.5).toRgbString() : color3, foregroundColor: color3 }, restConfig);
  const id2 = getPatternId(Object.assign(Object.assign({}, config), style));
  upsertPattern(svg, id2, generator(style));
  if (hasColor(fill2)) {
    node.setAttribute("fill", `url(#${id2})`);
    if (!node.getAttribute("stroke") && fill2) {
      node.setAttribute("stroke", fill2);
    }
  }
}
function upsertPattern(svg, id2, pattern) {
  const defs = getOrCreateDefs(svg);
  pattern.setAttribute("id", id2);
  const exist = defs.querySelector(`pattern#${id2}`);
  if (exist)
    exist.replaceWith(pattern);
  else
    defs.appendChild(pattern);
}
function getPatternId(config) {
  const { pattern, foregroundColor = "unset", backgroundColor = "unset", scale = "unset" } = config;
  return getSafetyId(`pattern-${pattern}-${foregroundColor}-${backgroundColor}-${scale}`);
}

// node_modules/roughjs/bundled/rough.esm.js
function t(t2, e8, s3) {
  if (t2 && t2.length) {
    const [n4, o3] = e8, a3 = Math.PI / 180 * s3, h4 = Math.cos(a3), r5 = Math.sin(a3);
    for (const e9 of t2) {
      const [t3, s4] = e9;
      e9[0] = (t3 - n4) * h4 - (s4 - o3) * r5 + n4, e9[1] = (t3 - n4) * r5 + (s4 - o3) * h4 + o3;
    }
  }
}
function e4(t2, e8) {
  return t2[0] === e8[0] && t2[1] === e8[1];
}
function s(s3, n4, o3, a3 = 1) {
  const h4 = o3, r5 = Math.max(n4, 0.1), i4 = s3[0] && s3[0][0] && "number" == typeof s3[0][0] ? [s3] : s3, c4 = [0, 0];
  if (h4)
    for (const e8 of i4)
      t(e8, c4, h4);
  const l3 = function(t2, s4, n5) {
    const o4 = [];
    for (const s5 of t2) {
      const t3 = [...s5];
      e4(t3[0], t3[t3.length - 1]) || t3.push([t3[0][0], t3[0][1]]), t3.length > 2 && o4.push(t3);
    }
    const a4 = [];
    s4 = Math.max(s4, 0.1);
    const h5 = [];
    for (const t3 of o4)
      for (let e8 = 0; e8 < t3.length - 1; e8++) {
        const s5 = t3[e8], n6 = t3[e8 + 1];
        if (s5[1] !== n6[1]) {
          const t4 = Math.min(s5[1], n6[1]);
          h5.push({ ymin: t4, ymax: Math.max(s5[1], n6[1]), x: t4 === s5[1] ? s5[0] : n6[0], islope: (n6[0] - s5[0]) / (n6[1] - s5[1]) });
        }
      }
    if (h5.sort((t3, e8) => t3.ymin < e8.ymin ? -1 : t3.ymin > e8.ymin ? 1 : t3.x < e8.x ? -1 : t3.x > e8.x ? 1 : t3.ymax === e8.ymax ? 0 : (t3.ymax - e8.ymax) / Math.abs(t3.ymax - e8.ymax)), !h5.length)
      return a4;
    let r6 = [], i5 = h5[0].ymin, c5 = 0;
    for (; r6.length || h5.length; ) {
      if (h5.length) {
        let t3 = -1;
        for (let e8 = 0; e8 < h5.length && !(h5[e8].ymin > i5); e8++)
          t3 = e8;
        h5.splice(0, t3 + 1).forEach((t4) => {
          r6.push({ s: i5, edge: t4 });
        });
      }
      if (r6 = r6.filter((t3) => !(t3.edge.ymax <= i5)), r6.sort((t3, e8) => t3.edge.x === e8.edge.x ? 0 : (t3.edge.x - e8.edge.x) / Math.abs(t3.edge.x - e8.edge.x)), (1 !== n5 || c5 % s4 == 0) && r6.length > 1)
        for (let t3 = 0; t3 < r6.length; t3 += 2) {
          const e8 = t3 + 1;
          if (e8 >= r6.length)
            break;
          const s5 = r6[t3].edge, n6 = r6[e8].edge;
          a4.push([[Math.round(s5.x), i5], [Math.round(n6.x), i5]]);
        }
      i5 += n5, r6.forEach((t3) => {
        t3.edge.x = t3.edge.x + n5 * t3.edge.islope;
      }), c5++;
    }
    return a4;
  }(i4, r5, a3);
  if (h4) {
    for (const e8 of i4)
      t(e8, c4, -h4);
    !function(e8, s4, n5) {
      const o4 = [];
      e8.forEach((t2) => o4.push(...t2)), t(o4, s4, n5);
    }(l3, c4, -h4);
  }
  return l3;
}
function n(t2, e8) {
  var n4;
  const o3 = e8.hachureAngle + 90;
  let a3 = e8.hachureGap;
  a3 < 0 && (a3 = 4 * e8.strokeWidth), a3 = Math.round(Math.max(a3, 0.1));
  let h4 = 1;
  return e8.roughness >= 1 && ((null === (n4 = e8.randomizer) || void 0 === n4 ? void 0 : n4.next()) || Math.random()) > 0.7 && (h4 = a3), s(t2, a3, o3, h4 || 1);
}
var o = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e8) {
    return this._fillPolygons(t2, e8);
  }
  _fillPolygons(t2, e8) {
    const s3 = n(t2, e8);
    return { type: "fillSketch", ops: this.renderLines(s3, e8) };
  }
  renderLines(t2, e8) {
    const s3 = [];
    for (const n4 of t2)
      s3.push(...this.helper.doubleLineOps(n4[0][0], n4[0][1], n4[1][0], n4[1][1], e8));
    return s3;
  }
};
function a(t2) {
  const e8 = t2[0], s3 = t2[1];
  return Math.sqrt(Math.pow(e8[0] - s3[0], 2) + Math.pow(e8[1] - s3[1], 2));
}
var h = class extends o {
  fillPolygons(t2, e8) {
    let s3 = e8.hachureGap;
    s3 < 0 && (s3 = 4 * e8.strokeWidth), s3 = Math.max(s3, 0.1);
    const o3 = n(t2, Object.assign({}, e8, { hachureGap: s3 })), h4 = Math.PI / 180 * e8.hachureAngle, r5 = [], i4 = 0.5 * s3 * Math.cos(h4), c4 = 0.5 * s3 * Math.sin(h4);
    for (const [t3, e9] of o3)
      a([t3, e9]) && r5.push([[t3[0] - i4, t3[1] + c4], [...e9]], [[t3[0] + i4, t3[1] - c4], [...e9]]);
    return { type: "fillSketch", ops: this.renderLines(r5, e8) };
  }
};
var r2 = class extends o {
  fillPolygons(t2, e8) {
    const s3 = this._fillPolygons(t2, e8), n4 = Object.assign({}, e8, { hachureAngle: e8.hachureAngle + 90 }), o3 = this._fillPolygons(t2, n4);
    return s3.ops = s3.ops.concat(o3.ops), s3;
  }
};
var i = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e8) {
    const s3 = n(t2, e8 = Object.assign({}, e8, { hachureAngle: 0 }));
    return this.dotsOnLines(s3, e8);
  }
  dotsOnLines(t2, e8) {
    const s3 = [];
    let n4 = e8.hachureGap;
    n4 < 0 && (n4 = 4 * e8.strokeWidth), n4 = Math.max(n4, 0.1);
    let o3 = e8.fillWeight;
    o3 < 0 && (o3 = e8.strokeWidth / 2);
    const h4 = n4 / 4;
    for (const r5 of t2) {
      const t3 = a(r5), i4 = t3 / n4, c4 = Math.ceil(i4) - 1, l3 = t3 - c4 * n4, u4 = (r5[0][0] + r5[1][0]) / 2 - n4 / 4, p7 = Math.min(r5[0][1], r5[1][1]);
      for (let t4 = 0; t4 < c4; t4++) {
        const a3 = p7 + l3 + t4 * n4, r6 = u4 - h4 + 2 * Math.random() * h4, i5 = a3 - h4 + 2 * Math.random() * h4, c5 = this.helper.ellipse(r6, i5, o3, o3, e8);
        s3.push(...c5.ops);
      }
    }
    return { type: "fillSketch", ops: s3 };
  }
};
var c2 = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e8) {
    const s3 = n(t2, e8);
    return { type: "fillSketch", ops: this.dashedLine(s3, e8) };
  }
  dashedLine(t2, e8) {
    const s3 = e8.dashOffset < 0 ? e8.hachureGap < 0 ? 4 * e8.strokeWidth : e8.hachureGap : e8.dashOffset, n4 = e8.dashGap < 0 ? e8.hachureGap < 0 ? 4 * e8.strokeWidth : e8.hachureGap : e8.dashGap, o3 = [];
    return t2.forEach((t3) => {
      const h4 = a(t3), r5 = Math.floor(h4 / (s3 + n4)), i4 = (h4 + n4 - r5 * (s3 + n4)) / 2;
      let c4 = t3[0], l3 = t3[1];
      c4[0] > l3[0] && (c4 = t3[1], l3 = t3[0]);
      const u4 = Math.atan((l3[1] - c4[1]) / (l3[0] - c4[0]));
      for (let t4 = 0; t4 < r5; t4++) {
        const a3 = t4 * (s3 + n4), h5 = a3 + s3, r6 = [c4[0] + a3 * Math.cos(u4) + i4 * Math.cos(u4), c4[1] + a3 * Math.sin(u4) + i4 * Math.sin(u4)], l4 = [c4[0] + h5 * Math.cos(u4) + i4 * Math.cos(u4), c4[1] + h5 * Math.sin(u4) + i4 * Math.sin(u4)];
        o3.push(...this.helper.doubleLineOps(r6[0], r6[1], l4[0], l4[1], e8));
      }
    }), o3;
  }
};
var l = class {
  constructor(t2) {
    this.helper = t2;
  }
  fillPolygons(t2, e8) {
    const s3 = e8.hachureGap < 0 ? 4 * e8.strokeWidth : e8.hachureGap, o3 = e8.zigzagOffset < 0 ? s3 : e8.zigzagOffset, a3 = n(t2, e8 = Object.assign({}, e8, { hachureGap: s3 + o3 }));
    return { type: "fillSketch", ops: this.zigzagLines(a3, o3, e8) };
  }
  zigzagLines(t2, e8, s3) {
    const n4 = [];
    return t2.forEach((t3) => {
      const o3 = a(t3), h4 = Math.round(o3 / (2 * e8));
      let r5 = t3[0], i4 = t3[1];
      r5[0] > i4[0] && (r5 = t3[1], i4 = t3[0]);
      const c4 = Math.atan((i4[1] - r5[1]) / (i4[0] - r5[0]));
      for (let t4 = 0; t4 < h4; t4++) {
        const o4 = 2 * t4 * e8, a3 = 2 * (t4 + 1) * e8, h5 = Math.sqrt(2 * Math.pow(e8, 2)), i5 = [r5[0] + o4 * Math.cos(c4), r5[1] + o4 * Math.sin(c4)], l3 = [r5[0] + a3 * Math.cos(c4), r5[1] + a3 * Math.sin(c4)], u4 = [i5[0] + h5 * Math.cos(c4 + Math.PI / 4), i5[1] + h5 * Math.sin(c4 + Math.PI / 4)];
        n4.push(...this.helper.doubleLineOps(i5[0], i5[1], u4[0], u4[1], s3), ...this.helper.doubleLineOps(u4[0], u4[1], l3[0], l3[1], s3));
      }
    }), n4;
  }
};
var u = {};
var p4 = class {
  constructor(t2) {
    this.seed = t2;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
};
var f3 = 0;
var d = 1;
var g = 2;
var M3 = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function k4(t2, e8) {
  return t2.type === e8;
}
function b(t2) {
  const e8 = [], s3 = function(t3) {
    const e9 = new Array();
    for (; "" !== t3; )
      if (t3.match(/^([ \t\r\n,]+)/))
        t3 = t3.substr(RegExp.$1.length);
      else if (t3.match(/^([aAcChHlLmMqQsStTvVzZ])/))
        e9[e9.length] = { type: f3, text: RegExp.$1 }, t3 = t3.substr(RegExp.$1.length);
      else {
        if (!t3.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))
          return [];
        e9[e9.length] = { type: d, text: `${parseFloat(RegExp.$1)}` }, t3 = t3.substr(RegExp.$1.length);
      }
    return e9[e9.length] = { type: g, text: "" }, e9;
  }(t2);
  let n4 = "BOD", o3 = 0, a3 = s3[o3];
  for (; !k4(a3, g); ) {
    let h4 = 0;
    const r5 = [];
    if ("BOD" === n4) {
      if ("M" !== a3.text && "m" !== a3.text)
        return b("M0,0" + t2);
      o3++, h4 = M3[a3.text], n4 = a3.text;
    } else
      k4(a3, d) ? h4 = M3[n4] : (o3++, h4 = M3[a3.text], n4 = a3.text);
    if (!(o3 + h4 < s3.length))
      throw new Error("Path data ended short");
    for (let t3 = o3; t3 < o3 + h4; t3++) {
      const e9 = s3[t3];
      if (!k4(e9, d))
        throw new Error("Param not a number: " + n4 + "," + e9.text);
      r5[r5.length] = +e9.text;
    }
    if ("number" != typeof M3[n4])
      throw new Error("Bad segment: " + n4);
    {
      const t3 = { key: n4, data: r5 };
      e8.push(t3), o3 += h4, a3 = s3[o3], "M" === n4 && (n4 = "L"), "m" === n4 && (n4 = "l");
    }
  }
  return e8;
}
function y(t2) {
  let e8 = 0, s3 = 0, n4 = 0, o3 = 0;
  const a3 = [];
  for (const { key: h4, data: r5 } of t2)
    switch (h4) {
      case "M":
        a3.push({ key: "M", data: [...r5] }), [e8, s3] = r5, [n4, o3] = r5;
        break;
      case "m":
        e8 += r5[0], s3 += r5[1], a3.push({ key: "M", data: [e8, s3] }), n4 = e8, o3 = s3;
        break;
      case "L":
        a3.push({ key: "L", data: [...r5] }), [e8, s3] = r5;
        break;
      case "l":
        e8 += r5[0], s3 += r5[1], a3.push({ key: "L", data: [e8, s3] });
        break;
      case "C":
        a3.push({ key: "C", data: [...r5] }), e8 = r5[4], s3 = r5[5];
        break;
      case "c": {
        const t3 = r5.map((t4, n5) => n5 % 2 ? t4 + s3 : t4 + e8);
        a3.push({ key: "C", data: t3 }), e8 = t3[4], s3 = t3[5];
        break;
      }
      case "Q":
        a3.push({ key: "Q", data: [...r5] }), e8 = r5[2], s3 = r5[3];
        break;
      case "q": {
        const t3 = r5.map((t4, n5) => n5 % 2 ? t4 + s3 : t4 + e8);
        a3.push({ key: "Q", data: t3 }), e8 = t3[2], s3 = t3[3];
        break;
      }
      case "A":
        a3.push({ key: "A", data: [...r5] }), e8 = r5[5], s3 = r5[6];
        break;
      case "a":
        e8 += r5[5], s3 += r5[6], a3.push({ key: "A", data: [r5[0], r5[1], r5[2], r5[3], r5[4], e8, s3] });
        break;
      case "H":
        a3.push({ key: "H", data: [...r5] }), e8 = r5[0];
        break;
      case "h":
        e8 += r5[0], a3.push({ key: "H", data: [e8] });
        break;
      case "V":
        a3.push({ key: "V", data: [...r5] }), s3 = r5[0];
        break;
      case "v":
        s3 += r5[0], a3.push({ key: "V", data: [s3] });
        break;
      case "S":
        a3.push({ key: "S", data: [...r5] }), e8 = r5[2], s3 = r5[3];
        break;
      case "s": {
        const t3 = r5.map((t4, n5) => n5 % 2 ? t4 + s3 : t4 + e8);
        a3.push({ key: "S", data: t3 }), e8 = t3[2], s3 = t3[3];
        break;
      }
      case "T":
        a3.push({ key: "T", data: [...r5] }), e8 = r5[0], s3 = r5[1];
        break;
      case "t":
        e8 += r5[0], s3 += r5[1], a3.push({ key: "T", data: [e8, s3] });
        break;
      case "Z":
      case "z":
        a3.push({ key: "Z", data: [] }), e8 = n4, s3 = o3;
    }
  return a3;
}
function m(t2) {
  const e8 = [];
  let s3 = "", n4 = 0, o3 = 0, a3 = 0, h4 = 0, r5 = 0, i4 = 0;
  for (const { key: c4, data: l3 } of t2) {
    switch (c4) {
      case "M":
        e8.push({ key: "M", data: [...l3] }), [n4, o3] = l3, [a3, h4] = l3;
        break;
      case "C":
        e8.push({ key: "C", data: [...l3] }), n4 = l3[4], o3 = l3[5], r5 = l3[2], i4 = l3[3];
        break;
      case "L":
        e8.push({ key: "L", data: [...l3] }), [n4, o3] = l3;
        break;
      case "H":
        n4 = l3[0], e8.push({ key: "L", data: [n4, o3] });
        break;
      case "V":
        o3 = l3[0], e8.push({ key: "L", data: [n4, o3] });
        break;
      case "S": {
        let t3 = 0, a4 = 0;
        "C" === s3 || "S" === s3 ? (t3 = n4 + (n4 - r5), a4 = o3 + (o3 - i4)) : (t3 = n4, a4 = o3), e8.push({ key: "C", data: [t3, a4, ...l3] }), r5 = l3[0], i4 = l3[1], n4 = l3[2], o3 = l3[3];
        break;
      }
      case "T": {
        const [t3, a4] = l3;
        let h5 = 0, c5 = 0;
        "Q" === s3 || "T" === s3 ? (h5 = n4 + (n4 - r5), c5 = o3 + (o3 - i4)) : (h5 = n4, c5 = o3);
        const u4 = n4 + 2 * (h5 - n4) / 3, p7 = o3 + 2 * (c5 - o3) / 3, f5 = t3 + 2 * (h5 - t3) / 3, d3 = a4 + 2 * (c5 - a4) / 3;
        e8.push({ key: "C", data: [u4, p7, f5, d3, t3, a4] }), r5 = h5, i4 = c5, n4 = t3, o3 = a4;
        break;
      }
      case "Q": {
        const [t3, s4, a4, h5] = l3, c5 = n4 + 2 * (t3 - n4) / 3, u4 = o3 + 2 * (s4 - o3) / 3, p7 = a4 + 2 * (t3 - a4) / 3, f5 = h5 + 2 * (s4 - h5) / 3;
        e8.push({ key: "C", data: [c5, u4, p7, f5, a4, h5] }), r5 = t3, i4 = s4, n4 = a4, o3 = h5;
        break;
      }
      case "A": {
        const t3 = Math.abs(l3[0]), s4 = Math.abs(l3[1]), a4 = l3[2], h5 = l3[3], r6 = l3[4], i5 = l3[5], c5 = l3[6];
        if (0 === t3 || 0 === s4)
          e8.push({ key: "C", data: [n4, o3, i5, c5, i5, c5] }), n4 = i5, o3 = c5;
        else if (n4 !== i5 || o3 !== c5) {
          x(n4, o3, i5, c5, t3, s4, a4, h5, r6).forEach(function(t4) {
            e8.push({ key: "C", data: t4 });
          }), n4 = i5, o3 = c5;
        }
        break;
      }
      case "Z":
        e8.push({ key: "Z", data: [] }), n4 = a3, o3 = h4;
    }
    s3 = c4;
  }
  return e8;
}
function w(t2, e8, s3) {
  return [t2 * Math.cos(s3) - e8 * Math.sin(s3), t2 * Math.sin(s3) + e8 * Math.cos(s3)];
}
function x(t2, e8, s3, n4, o3, a3, h4, r5, i4, c4) {
  const l3 = (u4 = h4, Math.PI * u4 / 180);
  var u4;
  let p7 = [], f5 = 0, d3 = 0, g3 = 0, M4 = 0;
  if (c4)
    [f5, d3, g3, M4] = c4;
  else {
    [t2, e8] = w(t2, e8, -l3), [s3, n4] = w(s3, n4, -l3);
    const h5 = (t2 - s3) / 2, c5 = (e8 - n4) / 2;
    let u5 = h5 * h5 / (o3 * o3) + c5 * c5 / (a3 * a3);
    u5 > 1 && (u5 = Math.sqrt(u5), o3 *= u5, a3 *= u5);
    const p8 = o3 * o3, k6 = a3 * a3, b3 = p8 * k6 - p8 * c5 * c5 - k6 * h5 * h5, y7 = p8 * c5 * c5 + k6 * h5 * h5, m4 = (r5 === i4 ? -1 : 1) * Math.sqrt(Math.abs(b3 / y7));
    g3 = m4 * o3 * c5 / a3 + (t2 + s3) / 2, M4 = m4 * -a3 * h5 / o3 + (e8 + n4) / 2, f5 = Math.asin(parseFloat(((e8 - M4) / a3).toFixed(9))), d3 = Math.asin(parseFloat(((n4 - M4) / a3).toFixed(9))), t2 < g3 && (f5 = Math.PI - f5), s3 < g3 && (d3 = Math.PI - d3), f5 < 0 && (f5 = 2 * Math.PI + f5), d3 < 0 && (d3 = 2 * Math.PI + d3), i4 && f5 > d3 && (f5 -= 2 * Math.PI), !i4 && d3 > f5 && (d3 -= 2 * Math.PI);
  }
  let k5 = d3 - f5;
  if (Math.abs(k5) > 120 * Math.PI / 180) {
    const t3 = d3, e9 = s3, r6 = n4;
    d3 = i4 && d3 > f5 ? f5 + 120 * Math.PI / 180 * 1 : f5 + 120 * Math.PI / 180 * -1, p7 = x(s3 = g3 + o3 * Math.cos(d3), n4 = M4 + a3 * Math.sin(d3), e9, r6, o3, a3, h4, 0, i4, [d3, t3, g3, M4]);
  }
  k5 = d3 - f5;
  const b2 = Math.cos(f5), y6 = Math.sin(f5), m3 = Math.cos(d3), P3 = Math.sin(d3), v2 = Math.tan(k5 / 4), S2 = 4 / 3 * o3 * v2, O3 = 4 / 3 * a3 * v2, L3 = [t2, e8], T3 = [t2 + S2 * y6, e8 - O3 * b2], D3 = [s3 + S2 * P3, n4 - O3 * m3], A4 = [s3, n4];
  if (T3[0] = 2 * L3[0] - T3[0], T3[1] = 2 * L3[1] - T3[1], c4)
    return [T3, D3, A4].concat(p7);
  {
    p7 = [T3, D3, A4].concat(p7);
    const t3 = [];
    for (let e9 = 0; e9 < p7.length; e9 += 3) {
      const s4 = w(p7[e9][0], p7[e9][1], l3), n5 = w(p7[e9 + 1][0], p7[e9 + 1][1], l3), o4 = w(p7[e9 + 2][0], p7[e9 + 2][1], l3);
      t3.push([s4[0], s4[1], n5[0], n5[1], o4[0], o4[1]]);
    }
    return t3;
  }
}
var P = { randOffset: function(t2, e8) {
  return G(t2, e8);
}, randOffsetWithRange: function(t2, e8, s3) {
  return E(t2, e8, s3);
}, ellipse: function(t2, e8, s3, n4, o3) {
  const a3 = T(s3, n4, o3);
  return D(t2, e8, o3, a3).opset;
}, doubleLineOps: function(t2, e8, s3, n4, o3) {
  return $(t2, e8, s3, n4, o3, true);
} };
function v(t2, e8, s3, n4, o3) {
  return { type: "path", ops: $(t2, e8, s3, n4, o3) };
}
function S(t2, e8, s3) {
  const n4 = (t2 || []).length;
  if (n4 > 2) {
    const o3 = [];
    for (let e9 = 0; e9 < n4 - 1; e9++)
      o3.push(...$(t2[e9][0], t2[e9][1], t2[e9 + 1][0], t2[e9 + 1][1], s3));
    return e8 && o3.push(...$(t2[n4 - 1][0], t2[n4 - 1][1], t2[0][0], t2[0][1], s3)), { type: "path", ops: o3 };
  }
  return 2 === n4 ? v(t2[0][0], t2[0][1], t2[1][0], t2[1][1], s3) : { type: "path", ops: [] };
}
function O(t2, e8, s3, n4, o3) {
  return function(t3, e9) {
    return S(t3, true, e9);
  }([[t2, e8], [t2 + s3, e8], [t2 + s3, e8 + n4], [t2, e8 + n4]], o3);
}
function L(t2, e8) {
  if (t2.length) {
    const s3 = "number" == typeof t2[0][0] ? [t2] : t2, n4 = j(s3[0], 1 * (1 + 0.2 * e8.roughness), e8), o3 = e8.disableMultiStroke ? [] : j(s3[0], 1.5 * (1 + 0.22 * e8.roughness), z(e8));
    for (let t3 = 1; t3 < s3.length; t3++) {
      const a3 = s3[t3];
      if (a3.length) {
        const t4 = j(a3, 1 * (1 + 0.2 * e8.roughness), e8), s4 = e8.disableMultiStroke ? [] : j(a3, 1.5 * (1 + 0.22 * e8.roughness), z(e8));
        for (const e9 of t4)
          "move" !== e9.op && n4.push(e9);
        for (const t5 of s4)
          "move" !== t5.op && o3.push(t5);
      }
    }
    return { type: "path", ops: n4.concat(o3) };
  }
  return { type: "path", ops: [] };
}
function T(t2, e8, s3) {
  const n4 = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t2 / 2, 2) + Math.pow(e8 / 2, 2)) / 2)), o3 = Math.ceil(Math.max(s3.curveStepCount, s3.curveStepCount / Math.sqrt(200) * n4)), a3 = 2 * Math.PI / o3;
  let h4 = Math.abs(t2 / 2), r5 = Math.abs(e8 / 2);
  const i4 = 1 - s3.curveFitting;
  return h4 += G(h4 * i4, s3), r5 += G(r5 * i4, s3), { increment: a3, rx: h4, ry: r5 };
}
function D(t2, e8, s3, n4) {
  const [o3, a3] = F(n4.increment, t2, e8, n4.rx, n4.ry, 1, n4.increment * E(0.1, E(0.4, 1, s3), s3), s3);
  let h4 = q(o3, null, s3);
  if (!s3.disableMultiStroke && 0 !== s3.roughness) {
    const [o4] = F(n4.increment, t2, e8, n4.rx, n4.ry, 1.5, 0, s3), a4 = q(o4, null, s3);
    h4 = h4.concat(a4);
  }
  return { estimatedPoints: a3, opset: { type: "path", ops: h4 } };
}
function A(t2, e8, s3, n4, o3, a3, h4, r5, i4) {
  const c4 = t2, l3 = e8;
  let u4 = Math.abs(s3 / 2), p7 = Math.abs(n4 / 2);
  u4 += G(0.01 * u4, i4), p7 += G(0.01 * p7, i4);
  let f5 = o3, d3 = a3;
  for (; f5 < 0; )
    f5 += 2 * Math.PI, d3 += 2 * Math.PI;
  d3 - f5 > 2 * Math.PI && (f5 = 0, d3 = 2 * Math.PI);
  const g3 = 2 * Math.PI / i4.curveStepCount, M4 = Math.min(g3 / 2, (d3 - f5) / 2), k5 = V(M4, c4, l3, u4, p7, f5, d3, 1, i4);
  if (!i4.disableMultiStroke) {
    const t3 = V(M4, c4, l3, u4, p7, f5, d3, 1.5, i4);
    k5.push(...t3);
  }
  return h4 && (r5 ? k5.push(...$(c4, l3, c4 + u4 * Math.cos(f5), l3 + p7 * Math.sin(f5), i4), ...$(c4, l3, c4 + u4 * Math.cos(d3), l3 + p7 * Math.sin(d3), i4)) : k5.push({ op: "lineTo", data: [c4, l3] }, { op: "lineTo", data: [c4 + u4 * Math.cos(f5), l3 + p7 * Math.sin(f5)] })), { type: "path", ops: k5 };
}
function _(t2, e8) {
  const s3 = m(y(b(t2))), n4 = [];
  let o3 = [0, 0], a3 = [0, 0];
  for (const { key: t3, data: h4 } of s3)
    switch (t3) {
      case "M":
        a3 = [h4[0], h4[1]], o3 = [h4[0], h4[1]];
        break;
      case "L":
        n4.push(...$(a3[0], a3[1], h4[0], h4[1], e8)), a3 = [h4[0], h4[1]];
        break;
      case "C": {
        const [t4, s4, o4, r5, i4, c4] = h4;
        n4.push(...Z(t4, s4, o4, r5, i4, c4, a3, e8)), a3 = [i4, c4];
        break;
      }
      case "Z":
        n4.push(...$(a3[0], a3[1], o3[0], o3[1], e8)), a3 = [o3[0], o3[1]];
    }
  return { type: "path", ops: n4 };
}
function I(t2, e8) {
  const s3 = [];
  for (const n4 of t2)
    if (n4.length) {
      const t3 = e8.maxRandomnessOffset || 0, o3 = n4.length;
      if (o3 > 2) {
        s3.push({ op: "move", data: [n4[0][0] + G(t3, e8), n4[0][1] + G(t3, e8)] });
        for (let a3 = 1; a3 < o3; a3++)
          s3.push({ op: "lineTo", data: [n4[a3][0] + G(t3, e8), n4[a3][1] + G(t3, e8)] });
      }
    }
  return { type: "fillPath", ops: s3 };
}
function C(t2, e8) {
  return function(t3, e9) {
    let s3 = t3.fillStyle || "hachure";
    if (!u[s3])
      switch (s3) {
        case "zigzag":
          u[s3] || (u[s3] = new h(e9));
          break;
        case "cross-hatch":
          u[s3] || (u[s3] = new r2(e9));
          break;
        case "dots":
          u[s3] || (u[s3] = new i(e9));
          break;
        case "dashed":
          u[s3] || (u[s3] = new c2(e9));
          break;
        case "zigzag-line":
          u[s3] || (u[s3] = new l(e9));
          break;
        default:
          s3 = "hachure", u[s3] || (u[s3] = new o(e9));
      }
    return u[s3];
  }(e8, P).fillPolygons(t2, e8);
}
function z(t2) {
  const e8 = Object.assign({}, t2);
  return e8.randomizer = void 0, t2.seed && (e8.seed = t2.seed + 1), e8;
}
function W(t2) {
  return t2.randomizer || (t2.randomizer = new p4(t2.seed || 0)), t2.randomizer.next();
}
function E(t2, e8, s3, n4 = 1) {
  return s3.roughness * n4 * (W(s3) * (e8 - t2) + t2);
}
function G(t2, e8, s3 = 1) {
  return E(-t2, t2, e8, s3);
}
function $(t2, e8, s3, n4, o3, a3 = false) {
  const h4 = a3 ? o3.disableMultiStrokeFill : o3.disableMultiStroke, r5 = R(t2, e8, s3, n4, o3, true, false);
  if (h4)
    return r5;
  const i4 = R(t2, e8, s3, n4, o3, true, true);
  return r5.concat(i4);
}
function R(t2, e8, s3, n4, o3, a3, h4) {
  const r5 = Math.pow(t2 - s3, 2) + Math.pow(e8 - n4, 2), i4 = Math.sqrt(r5);
  let c4 = 1;
  c4 = i4 < 200 ? 1 : i4 > 500 ? 0.4 : -16668e-7 * i4 + 1.233334;
  let l3 = o3.maxRandomnessOffset || 0;
  l3 * l3 * 100 > r5 && (l3 = i4 / 10);
  const u4 = l3 / 2, p7 = 0.2 + 0.2 * W(o3);
  let f5 = o3.bowing * o3.maxRandomnessOffset * (n4 - e8) / 200, d3 = o3.bowing * o3.maxRandomnessOffset * (t2 - s3) / 200;
  f5 = G(f5, o3, c4), d3 = G(d3, o3, c4);
  const g3 = [], M4 = () => G(u4, o3, c4), k5 = () => G(l3, o3, c4), b2 = o3.preserveVertices;
  return a3 && (h4 ? g3.push({ op: "move", data: [t2 + (b2 ? 0 : M4()), e8 + (b2 ? 0 : M4())] }) : g3.push({ op: "move", data: [t2 + (b2 ? 0 : G(l3, o3, c4)), e8 + (b2 ? 0 : G(l3, o3, c4))] })), h4 ? g3.push({ op: "bcurveTo", data: [f5 + t2 + (s3 - t2) * p7 + M4(), d3 + e8 + (n4 - e8) * p7 + M4(), f5 + t2 + 2 * (s3 - t2) * p7 + M4(), d3 + e8 + 2 * (n4 - e8) * p7 + M4(), s3 + (b2 ? 0 : M4()), n4 + (b2 ? 0 : M4())] }) : g3.push({ op: "bcurveTo", data: [f5 + t2 + (s3 - t2) * p7 + k5(), d3 + e8 + (n4 - e8) * p7 + k5(), f5 + t2 + 2 * (s3 - t2) * p7 + k5(), d3 + e8 + 2 * (n4 - e8) * p7 + k5(), s3 + (b2 ? 0 : k5()), n4 + (b2 ? 0 : k5())] }), g3;
}
function j(t2, e8, s3) {
  if (!t2.length)
    return [];
  const n4 = [];
  n4.push([t2[0][0] + G(e8, s3), t2[0][1] + G(e8, s3)]), n4.push([t2[0][0] + G(e8, s3), t2[0][1] + G(e8, s3)]);
  for (let o3 = 1; o3 < t2.length; o3++)
    n4.push([t2[o3][0] + G(e8, s3), t2[o3][1] + G(e8, s3)]), o3 === t2.length - 1 && n4.push([t2[o3][0] + G(e8, s3), t2[o3][1] + G(e8, s3)]);
  return q(n4, null, s3);
}
function q(t2, e8, s3) {
  const n4 = t2.length, o3 = [];
  if (n4 > 3) {
    const a3 = [], h4 = 1 - s3.curveTightness;
    o3.push({ op: "move", data: [t2[1][0], t2[1][1]] });
    for (let e9 = 1; e9 + 2 < n4; e9++) {
      const s4 = t2[e9];
      a3[0] = [s4[0], s4[1]], a3[1] = [s4[0] + (h4 * t2[e9 + 1][0] - h4 * t2[e9 - 1][0]) / 6, s4[1] + (h4 * t2[e9 + 1][1] - h4 * t2[e9 - 1][1]) / 6], a3[2] = [t2[e9 + 1][0] + (h4 * t2[e9][0] - h4 * t2[e9 + 2][0]) / 6, t2[e9 + 1][1] + (h4 * t2[e9][1] - h4 * t2[e9 + 2][1]) / 6], a3[3] = [t2[e9 + 1][0], t2[e9 + 1][1]], o3.push({ op: "bcurveTo", data: [a3[1][0], a3[1][1], a3[2][0], a3[2][1], a3[3][0], a3[3][1]] });
    }
    if (e8 && 2 === e8.length) {
      const t3 = s3.maxRandomnessOffset;
      o3.push({ op: "lineTo", data: [e8[0] + G(t3, s3), e8[1] + G(t3, s3)] });
    }
  } else
    3 === n4 ? (o3.push({ op: "move", data: [t2[1][0], t2[1][1]] }), o3.push({ op: "bcurveTo", data: [t2[1][0], t2[1][1], t2[2][0], t2[2][1], t2[2][0], t2[2][1]] })) : 2 === n4 && o3.push(...R(t2[0][0], t2[0][1], t2[1][0], t2[1][1], s3, true, true));
  return o3;
}
function F(t2, e8, s3, n4, o3, a3, h4, r5) {
  const i4 = [], c4 = [];
  if (0 === r5.roughness) {
    t2 /= 4, c4.push([e8 + n4 * Math.cos(-t2), s3 + o3 * Math.sin(-t2)]);
    for (let a4 = 0; a4 <= 2 * Math.PI; a4 += t2) {
      const t3 = [e8 + n4 * Math.cos(a4), s3 + o3 * Math.sin(a4)];
      i4.push(t3), c4.push(t3);
    }
    c4.push([e8 + n4 * Math.cos(0), s3 + o3 * Math.sin(0)]), c4.push([e8 + n4 * Math.cos(t2), s3 + o3 * Math.sin(t2)]);
  } else {
    const l3 = G(0.5, r5) - Math.PI / 2;
    c4.push([G(a3, r5) + e8 + 0.9 * n4 * Math.cos(l3 - t2), G(a3, r5) + s3 + 0.9 * o3 * Math.sin(l3 - t2)]);
    const u4 = 2 * Math.PI + l3 - 0.01;
    for (let h5 = l3; h5 < u4; h5 += t2) {
      const t3 = [G(a3, r5) + e8 + n4 * Math.cos(h5), G(a3, r5) + s3 + o3 * Math.sin(h5)];
      i4.push(t3), c4.push(t3);
    }
    c4.push([G(a3, r5) + e8 + n4 * Math.cos(l3 + 2 * Math.PI + 0.5 * h4), G(a3, r5) + s3 + o3 * Math.sin(l3 + 2 * Math.PI + 0.5 * h4)]), c4.push([G(a3, r5) + e8 + 0.98 * n4 * Math.cos(l3 + h4), G(a3, r5) + s3 + 0.98 * o3 * Math.sin(l3 + h4)]), c4.push([G(a3, r5) + e8 + 0.9 * n4 * Math.cos(l3 + 0.5 * h4), G(a3, r5) + s3 + 0.9 * o3 * Math.sin(l3 + 0.5 * h4)]);
  }
  return [c4, i4];
}
function V(t2, e8, s3, n4, o3, a3, h4, r5, i4) {
  const c4 = a3 + G(0.1, i4), l3 = [];
  l3.push([G(r5, i4) + e8 + 0.9 * n4 * Math.cos(c4 - t2), G(r5, i4) + s3 + 0.9 * o3 * Math.sin(c4 - t2)]);
  for (let a4 = c4; a4 <= h4; a4 += t2)
    l3.push([G(r5, i4) + e8 + n4 * Math.cos(a4), G(r5, i4) + s3 + o3 * Math.sin(a4)]);
  return l3.push([e8 + n4 * Math.cos(h4), s3 + o3 * Math.sin(h4)]), l3.push([e8 + n4 * Math.cos(h4), s3 + o3 * Math.sin(h4)]), q(l3, null, i4);
}
function Z(t2, e8, s3, n4, o3, a3, h4, r5) {
  const i4 = [], c4 = [r5.maxRandomnessOffset || 1, (r5.maxRandomnessOffset || 1) + 0.3];
  let l3 = [0, 0];
  const u4 = r5.disableMultiStroke ? 1 : 2, p7 = r5.preserveVertices;
  for (let f5 = 0; f5 < u4; f5++)
    0 === f5 ? i4.push({ op: "move", data: [h4[0], h4[1]] }) : i4.push({ op: "move", data: [h4[0] + (p7 ? 0 : G(c4[0], r5)), h4[1] + (p7 ? 0 : G(c4[0], r5))] }), l3 = p7 ? [o3, a3] : [o3 + G(c4[f5], r5), a3 + G(c4[f5], r5)], i4.push({ op: "bcurveTo", data: [t2 + G(c4[f5], r5), e8 + G(c4[f5], r5), s3 + G(c4[f5], r5), n4 + G(c4[f5], r5), l3[0], l3[1]] });
  return i4;
}
function Q(t2) {
  return [...t2];
}
function H(t2, e8 = 0) {
  const s3 = t2.length;
  if (s3 < 3)
    throw new Error("A curve must have at least three points.");
  const n4 = [];
  if (3 === s3)
    n4.push(Q(t2[0]), Q(t2[1]), Q(t2[2]), Q(t2[2]));
  else {
    const s4 = [];
    s4.push(t2[0], t2[0]);
    for (let e9 = 1; e9 < t2.length; e9++)
      s4.push(t2[e9]), e9 === t2.length - 1 && s4.push(t2[e9]);
    const o3 = [], a3 = 1 - e8;
    n4.push(Q(s4[0]));
    for (let t3 = 1; t3 + 2 < s4.length; t3++) {
      const e9 = s4[t3];
      o3[0] = [e9[0], e9[1]], o3[1] = [e9[0] + (a3 * s4[t3 + 1][0] - a3 * s4[t3 - 1][0]) / 6, e9[1] + (a3 * s4[t3 + 1][1] - a3 * s4[t3 - 1][1]) / 6], o3[2] = [s4[t3 + 1][0] + (a3 * s4[t3][0] - a3 * s4[t3 + 2][0]) / 6, s4[t3 + 1][1] + (a3 * s4[t3][1] - a3 * s4[t3 + 2][1]) / 6], o3[3] = [s4[t3 + 1][0], s4[t3 + 1][1]], n4.push(o3[1], o3[2], o3[3]);
    }
  }
  return n4;
}
function N(t2, e8) {
  return Math.pow(t2[0] - e8[0], 2) + Math.pow(t2[1] - e8[1], 2);
}
function B(t2, e8, s3) {
  const n4 = N(e8, s3);
  if (0 === n4)
    return N(t2, e8);
  let o3 = ((t2[0] - e8[0]) * (s3[0] - e8[0]) + (t2[1] - e8[1]) * (s3[1] - e8[1])) / n4;
  return o3 = Math.max(0, Math.min(1, o3)), N(t2, J(e8, s3, o3));
}
function J(t2, e8, s3) {
  return [t2[0] + (e8[0] - t2[0]) * s3, t2[1] + (e8[1] - t2[1]) * s3];
}
function K(t2, e8, s3, n4) {
  const o3 = n4 || [];
  if (function(t3, e9) {
    const s4 = t3[e9 + 0], n5 = t3[e9 + 1], o4 = t3[e9 + 2], a4 = t3[e9 + 3];
    let h5 = 3 * n5[0] - 2 * s4[0] - a4[0];
    h5 *= h5;
    let r5 = 3 * n5[1] - 2 * s4[1] - a4[1];
    r5 *= r5;
    let i4 = 3 * o4[0] - 2 * a4[0] - s4[0];
    i4 *= i4;
    let c4 = 3 * o4[1] - 2 * a4[1] - s4[1];
    return c4 *= c4, h5 < i4 && (h5 = i4), r5 < c4 && (r5 = c4), h5 + r5;
  }(t2, e8) < s3) {
    const s4 = t2[e8 + 0];
    if (o3.length) {
      (a3 = o3[o3.length - 1], h4 = s4, Math.sqrt(N(a3, h4))) > 1 && o3.push(s4);
    } else
      o3.push(s4);
    o3.push(t2[e8 + 3]);
  } else {
    const n5 = 0.5, a4 = t2[e8 + 0], h5 = t2[e8 + 1], r5 = t2[e8 + 2], i4 = t2[e8 + 3], c4 = J(a4, h5, n5), l3 = J(h5, r5, n5), u4 = J(r5, i4, n5), p7 = J(c4, l3, n5), f5 = J(l3, u4, n5), d3 = J(p7, f5, n5);
    K([a4, c4, p7, d3], 0, s3, o3), K([d3, f5, u4, i4], 0, s3, o3);
  }
  var a3, h4;
  return o3;
}
function U(t2, e8) {
  return X(t2, 0, t2.length, e8);
}
function X(t2, e8, s3, n4, o3) {
  const a3 = o3 || [], h4 = t2[e8], r5 = t2[s3 - 1];
  let i4 = 0, c4 = 1;
  for (let n5 = e8 + 1; n5 < s3 - 1; ++n5) {
    const e9 = B(t2[n5], h4, r5);
    e9 > i4 && (i4 = e9, c4 = n5);
  }
  return Math.sqrt(i4) > n4 ? (X(t2, e8, c4 + 1, n4, a3), X(t2, c4, s3, n4, a3)) : (a3.length || a3.push(h4), a3.push(r5)), a3;
}
function Y(t2, e8 = 0.15, s3) {
  const n4 = [], o3 = (t2.length - 1) / 3;
  for (let s4 = 0; s4 < o3; s4++) {
    K(t2, 3 * s4, e8, n4);
  }
  return s3 && s3 > 0 ? X(n4, 0, n4.length, s3) : n4;
}
var tt = "none";
var et = class {
  constructor(t2) {
    this.defaultOptions = { maxRandomnessOffset: 2, roughness: 1, bowing: 1, stroke: "#000", strokeWidth: 1, curveTightness: 0, curveFitting: 0.95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, seed: 0, disableMultiStroke: false, disableMultiStrokeFill: false, preserveVertices: false, fillShapeRoughnessGain: 0.8 }, this.config = t2 || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return Math.floor(Math.random() * 2 ** 31);
  }
  _o(t2) {
    return t2 ? Object.assign({}, this.defaultOptions, t2) : this.defaultOptions;
  }
  _d(t2, e8, s3) {
    return { shape: t2, sets: e8 || [], options: s3 || this.defaultOptions };
  }
  line(t2, e8, s3, n4, o3) {
    const a3 = this._o(o3);
    return this._d("line", [v(t2, e8, s3, n4, a3)], a3);
  }
  rectangle(t2, e8, s3, n4, o3) {
    const a3 = this._o(o3), h4 = [], r5 = O(t2, e8, s3, n4, a3);
    if (a3.fill) {
      const o4 = [[t2, e8], [t2 + s3, e8], [t2 + s3, e8 + n4], [t2, e8 + n4]];
      "solid" === a3.fillStyle ? h4.push(I([o4], a3)) : h4.push(C([o4], a3));
    }
    return a3.stroke !== tt && h4.push(r5), this._d("rectangle", h4, a3);
  }
  ellipse(t2, e8, s3, n4, o3) {
    const a3 = this._o(o3), h4 = [], r5 = T(s3, n4, a3), i4 = D(t2, e8, a3, r5);
    if (a3.fill)
      if ("solid" === a3.fillStyle) {
        const s4 = D(t2, e8, a3, r5).opset;
        s4.type = "fillPath", h4.push(s4);
      } else
        h4.push(C([i4.estimatedPoints], a3));
    return a3.stroke !== tt && h4.push(i4.opset), this._d("ellipse", h4, a3);
  }
  circle(t2, e8, s3, n4) {
    const o3 = this.ellipse(t2, e8, s3, s3, n4);
    return o3.shape = "circle", o3;
  }
  linearPath(t2, e8) {
    const s3 = this._o(e8);
    return this._d("linearPath", [S(t2, false, s3)], s3);
  }
  arc(t2, e8, s3, n4, o3, a3, h4 = false, r5) {
    const i4 = this._o(r5), c4 = [], l3 = A(t2, e8, s3, n4, o3, a3, h4, true, i4);
    if (h4 && i4.fill)
      if ("solid" === i4.fillStyle) {
        const h5 = Object.assign({}, i4);
        h5.disableMultiStroke = true;
        const r6 = A(t2, e8, s3, n4, o3, a3, true, false, h5);
        r6.type = "fillPath", c4.push(r6);
      } else
        c4.push(function(t3, e9, s4, n5, o4, a4, h5) {
          const r6 = t3, i5 = e9;
          let c5 = Math.abs(s4 / 2), l4 = Math.abs(n5 / 2);
          c5 += G(0.01 * c5, h5), l4 += G(0.01 * l4, h5);
          let u4 = o4, p7 = a4;
          for (; u4 < 0; )
            u4 += 2 * Math.PI, p7 += 2 * Math.PI;
          p7 - u4 > 2 * Math.PI && (u4 = 0, p7 = 2 * Math.PI);
          const f5 = (p7 - u4) / h5.curveStepCount, d3 = [];
          for (let t4 = u4; t4 <= p7; t4 += f5)
            d3.push([r6 + c5 * Math.cos(t4), i5 + l4 * Math.sin(t4)]);
          return d3.push([r6 + c5 * Math.cos(p7), i5 + l4 * Math.sin(p7)]), d3.push([r6, i5]), C([d3], h5);
        }(t2, e8, s3, n4, o3, a3, i4));
    return i4.stroke !== tt && c4.push(l3), this._d("arc", c4, i4);
  }
  curve(t2, e8) {
    const s3 = this._o(e8), n4 = [], o3 = L(t2, s3);
    if (s3.fill && s3.fill !== tt)
      if ("solid" === s3.fillStyle) {
        const e9 = L(t2, Object.assign(Object.assign({}, s3), { disableMultiStroke: true, roughness: s3.roughness ? s3.roughness + s3.fillShapeRoughnessGain : 0 }));
        n4.push({ type: "fillPath", ops: this._mergedShape(e9.ops) });
      } else {
        const e9 = [], o4 = t2;
        if (o4.length) {
          const t3 = "number" == typeof o4[0][0] ? [o4] : o4;
          for (const n5 of t3)
            n5.length < 3 ? e9.push(...n5) : 3 === n5.length ? e9.push(...Y(H([n5[0], n5[0], n5[1], n5[2]]), 10, (1 + s3.roughness) / 2)) : e9.push(...Y(H(n5), 10, (1 + s3.roughness) / 2));
        }
        e9.length && n4.push(C([e9], s3));
      }
    return s3.stroke !== tt && n4.push(o3), this._d("curve", n4, s3);
  }
  polygon(t2, e8) {
    const s3 = this._o(e8), n4 = [], o3 = S(t2, true, s3);
    return s3.fill && ("solid" === s3.fillStyle ? n4.push(I([t2], s3)) : n4.push(C([t2], s3))), s3.stroke !== tt && n4.push(o3), this._d("polygon", n4, s3);
  }
  path(t2, e8) {
    const s3 = this._o(e8), n4 = [];
    if (!t2)
      return this._d("path", n4, s3);
    t2 = (t2 || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const o3 = s3.fill && "transparent" !== s3.fill && s3.fill !== tt, a3 = s3.stroke !== tt, h4 = !!(s3.simplification && s3.simplification < 1), r5 = function(t3, e9, s4) {
      const n5 = m(y(b(t3))), o4 = [];
      let a4 = [], h5 = [0, 0], r6 = [];
      const i5 = () => {
        r6.length >= 4 && a4.push(...Y(r6, e9)), r6 = [];
      }, c4 = () => {
        i5(), a4.length && (o4.push(a4), a4 = []);
      };
      for (const { key: t4, data: e11 } of n5)
        switch (t4) {
          case "M":
            c4(), h5 = [e11[0], e11[1]], a4.push(h5);
            break;
          case "L":
            i5(), a4.push([e11[0], e11[1]]);
            break;
          case "C":
            if (!r6.length) {
              const t5 = a4.length ? a4[a4.length - 1] : h5;
              r6.push([t5[0], t5[1]]);
            }
            r6.push([e11[0], e11[1]]), r6.push([e11[2], e11[3]]), r6.push([e11[4], e11[5]]);
            break;
          case "Z":
            i5(), a4.push([h5[0], h5[1]]);
        }
      if (c4(), !s4)
        return o4;
      const l3 = [];
      for (const t4 of o4) {
        const e11 = U(t4, s4);
        e11.length && l3.push(e11);
      }
      return l3;
    }(t2, 1, h4 ? 4 - 4 * (s3.simplification || 1) : (1 + s3.roughness) / 2), i4 = _(t2, s3);
    if (o3)
      if ("solid" === s3.fillStyle)
        if (1 === r5.length) {
          const e9 = _(t2, Object.assign(Object.assign({}, s3), { disableMultiStroke: true, roughness: s3.roughness ? s3.roughness + s3.fillShapeRoughnessGain : 0 }));
          n4.push({ type: "fillPath", ops: this._mergedShape(e9.ops) });
        } else
          n4.push(I(r5, s3));
      else
        n4.push(C(r5, s3));
    return a3 && (h4 ? r5.forEach((t3) => {
      n4.push(S(t3, false, s3));
    }) : n4.push(i4)), this._d("path", n4, s3);
  }
  opsToPath(t2, e8) {
    let s3 = "";
    for (const n4 of t2.ops) {
      const t3 = "number" == typeof e8 && e8 >= 0 ? n4.data.map((t4) => +t4.toFixed(e8)) : n4.data;
      switch (n4.op) {
        case "move":
          s3 += `M${t3[0]} ${t3[1]} `;
          break;
        case "bcurveTo":
          s3 += `C${t3[0]} ${t3[1]}, ${t3[2]} ${t3[3]}, ${t3[4]} ${t3[5]} `;
          break;
        case "lineTo":
          s3 += `L${t3[0]} ${t3[1]} `;
      }
    }
    return s3.trim();
  }
  toPaths(t2) {
    const e8 = t2.sets || [], s3 = t2.options || this.defaultOptions, n4 = [];
    for (const t3 of e8) {
      let e9 = null;
      switch (t3.type) {
        case "path":
          e9 = { d: this.opsToPath(t3), stroke: s3.stroke, strokeWidth: s3.strokeWidth, fill: tt };
          break;
        case "fillPath":
          e9 = { d: this.opsToPath(t3), stroke: tt, strokeWidth: 0, fill: s3.fill || tt };
          break;
        case "fillSketch":
          e9 = this.fillSketch(t3, s3);
      }
      e9 && n4.push(e9);
    }
    return n4;
  }
  fillSketch(t2, e8) {
    let s3 = e8.fillWeight;
    return s3 < 0 && (s3 = e8.strokeWidth / 2), { d: this.opsToPath(t2), stroke: e8.fill || tt, strokeWidth: s3, fill: tt };
  }
  _mergedShape(t2) {
    return t2.filter((t3, e8) => 0 === e8 || "move" !== t3.op);
  }
};
var st = class {
  constructor(t2, e8) {
    this.canvas = t2, this.ctx = this.canvas.getContext("2d"), this.gen = new et(e8);
  }
  draw(t2) {
    const e8 = t2.sets || [], s3 = t2.options || this.getDefaultOptions(), n4 = this.ctx, o3 = t2.options.fixedDecimalPlaceDigits;
    for (const a3 of e8)
      switch (a3.type) {
        case "path":
          n4.save(), n4.strokeStyle = "none" === s3.stroke ? "transparent" : s3.stroke, n4.lineWidth = s3.strokeWidth, s3.strokeLineDash && n4.setLineDash(s3.strokeLineDash), s3.strokeLineDashOffset && (n4.lineDashOffset = s3.strokeLineDashOffset), this._drawToContext(n4, a3, o3), n4.restore();
          break;
        case "fillPath": {
          n4.save(), n4.fillStyle = s3.fill || "";
          const e9 = "curve" === t2.shape || "polygon" === t2.shape || "path" === t2.shape ? "evenodd" : "nonzero";
          this._drawToContext(n4, a3, o3, e9), n4.restore();
          break;
        }
        case "fillSketch":
          this.fillSketch(n4, a3, s3);
      }
  }
  fillSketch(t2, e8, s3) {
    let n4 = s3.fillWeight;
    n4 < 0 && (n4 = s3.strokeWidth / 2), t2.save(), s3.fillLineDash && t2.setLineDash(s3.fillLineDash), s3.fillLineDashOffset && (t2.lineDashOffset = s3.fillLineDashOffset), t2.strokeStyle = s3.fill || "", t2.lineWidth = n4, this._drawToContext(t2, e8, s3.fixedDecimalPlaceDigits), t2.restore();
  }
  _drawToContext(t2, e8, s3, n4 = "nonzero") {
    t2.beginPath();
    for (const n5 of e8.ops) {
      const e9 = "number" == typeof s3 && s3 >= 0 ? n5.data.map((t3) => +t3.toFixed(s3)) : n5.data;
      switch (n5.op) {
        case "move":
          t2.moveTo(e9[0], e9[1]);
          break;
        case "bcurveTo":
          t2.bezierCurveTo(e9[0], e9[1], e9[2], e9[3], e9[4], e9[5]);
          break;
        case "lineTo":
          t2.lineTo(e9[0], e9[1]);
      }
    }
    "fillPath" === e8.type ? t2.fill(n4) : t2.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(t2, e8, s3, n4, o3) {
    const a3 = this.gen.line(t2, e8, s3, n4, o3);
    return this.draw(a3), a3;
  }
  rectangle(t2, e8, s3, n4, o3) {
    const a3 = this.gen.rectangle(t2, e8, s3, n4, o3);
    return this.draw(a3), a3;
  }
  ellipse(t2, e8, s3, n4, o3) {
    const a3 = this.gen.ellipse(t2, e8, s3, n4, o3);
    return this.draw(a3), a3;
  }
  circle(t2, e8, s3, n4) {
    const o3 = this.gen.circle(t2, e8, s3, n4);
    return this.draw(o3), o3;
  }
  linearPath(t2, e8) {
    const s3 = this.gen.linearPath(t2, e8);
    return this.draw(s3), s3;
  }
  polygon(t2, e8) {
    const s3 = this.gen.polygon(t2, e8);
    return this.draw(s3), s3;
  }
  arc(t2, e8, s3, n4, o3, a3, h4 = false, r5) {
    const i4 = this.gen.arc(t2, e8, s3, n4, o3, a3, h4, r5);
    return this.draw(i4), i4;
  }
  curve(t2, e8) {
    const s3 = this.gen.curve(t2, e8);
    return this.draw(s3), s3;
  }
  path(t2, e8) {
    const s3 = this.gen.path(t2, e8);
    return this.draw(s3), s3;
  }
};
var nt = "http://www.w3.org/2000/svg";
var ot = class {
  constructor(t2, e8) {
    this.svg = t2, this.gen = new et(e8);
  }
  draw(t2) {
    const e8 = t2.sets || [], s3 = t2.options || this.getDefaultOptions(), n4 = this.svg.ownerDocument || window.document, o3 = n4.createElementNS(nt, "g"), a3 = t2.options.fixedDecimalPlaceDigits;
    for (const h4 of e8) {
      let e9 = null;
      switch (h4.type) {
        case "path":
          e9 = n4.createElementNS(nt, "path"), e9.setAttribute("d", this.opsToPath(h4, a3)), e9.setAttribute("stroke", s3.stroke), e9.setAttribute("stroke-width", s3.strokeWidth + ""), e9.setAttribute("fill", "none"), s3.strokeLineDash && e9.setAttribute("stroke-dasharray", s3.strokeLineDash.join(" ").trim()), s3.strokeLineDashOffset && e9.setAttribute("stroke-dashoffset", `${s3.strokeLineDashOffset}`);
          break;
        case "fillPath":
          e9 = n4.createElementNS(nt, "path"), e9.setAttribute("d", this.opsToPath(h4, a3)), e9.setAttribute("stroke", "none"), e9.setAttribute("stroke-width", "0"), e9.setAttribute("fill", s3.fill || ""), "curve" !== t2.shape && "polygon" !== t2.shape || e9.setAttribute("fill-rule", "evenodd");
          break;
        case "fillSketch":
          e9 = this.fillSketch(n4, h4, s3);
      }
      e9 && o3.appendChild(e9);
    }
    return o3;
  }
  fillSketch(t2, e8, s3) {
    let n4 = s3.fillWeight;
    n4 < 0 && (n4 = s3.strokeWidth / 2);
    const o3 = t2.createElementNS(nt, "path");
    return o3.setAttribute("d", this.opsToPath(e8, s3.fixedDecimalPlaceDigits)), o3.setAttribute("stroke", s3.fill || ""), o3.setAttribute("stroke-width", n4 + ""), o3.setAttribute("fill", "none"), s3.fillLineDash && o3.setAttribute("stroke-dasharray", s3.fillLineDash.join(" ").trim()), s3.fillLineDashOffset && o3.setAttribute("stroke-dashoffset", `${s3.fillLineDashOffset}`), o3;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(t2, e8) {
    return this.gen.opsToPath(t2, e8);
  }
  line(t2, e8, s3, n4, o3) {
    const a3 = this.gen.line(t2, e8, s3, n4, o3);
    return this.draw(a3);
  }
  rectangle(t2, e8, s3, n4, o3) {
    const a3 = this.gen.rectangle(t2, e8, s3, n4, o3);
    return this.draw(a3);
  }
  ellipse(t2, e8, s3, n4, o3) {
    const a3 = this.gen.ellipse(t2, e8, s3, n4, o3);
    return this.draw(a3);
  }
  circle(t2, e8, s3, n4) {
    const o3 = this.gen.circle(t2, e8, s3, n4);
    return this.draw(o3);
  }
  linearPath(t2, e8) {
    const s3 = this.gen.linearPath(t2, e8);
    return this.draw(s3);
  }
  polygon(t2, e8) {
    const s3 = this.gen.polygon(t2, e8);
    return this.draw(s3);
  }
  arc(t2, e8, s3, n4, o3, a3, h4 = false, r5) {
    const i4 = this.gen.arc(t2, e8, s3, n4, o3, a3, h4, r5);
    return this.draw(i4);
  }
  curve(t2, e8) {
    const s3 = this.gen.curve(t2, e8);
    return this.draw(s3);
  }
  path(t2, e8) {
    const s3 = this.gen.path(t2, e8);
    return this.draw(s3);
  }
};
var at = { canvas: (t2, e8) => new st(t2, e8), svg: (t2, e8) => new ot(t2, e8), generator: (t2) => new et(t2), newSeed: () => et.newSeed() };

// node_modules/@antv/infographic/esm/renderer/stylize/rough.js
function applyRoughStyle(node, svg, config) {
  if (!node || !svg) {
    console.warn("Invalid node or svg element");
    return;
  }
  const rc = at.svg(svg, {
    options: {
      seed: 1e3
    }
  });
  const g3 = createElement("g");
  if (node.hasAttribute("transform")) {
    g3.setAttribute("transform", node.getAttribute("transform") || "");
  }
  const volume = node.cloneNode();
  setAttributes(volume, {
    opacity: 0.5
  });
  if (volume.hasAttribute("transform")) {
    volume.removeAttribute("transform");
  }
  volume.dataset.elementType = "rough-volume";
  g3.appendChild(volume);
  const result = createRoughShape(rc, node, config);
  if (result) {
    const { element, svgAttributes } = result;
    element.dataset.elementType = "rough-element";
    element.style.pointerEvents = "none";
    applySVGAttributes(element, svgAttributes);
    g3.appendChild(element);
  }
  if (node.id)
    g3.id = node.id;
  const classList2 = Array.from(node.classList);
  classList2.forEach((cls) => {
    if (!g3.classList.contains(cls)) {
      g3.classList.add(cls);
    }
  });
  Array.from(node.attributes).forEach((attr) => {
    if (attr.name.startsWith("data-")) {
      g3.setAttribute(attr.name, attr.value);
    }
  });
  if (g3.childElementCount > 0) {
    node.replaceWith(g3);
  } else {
    node.remove();
  }
}
function applySVGAttributes(element, attributes) {
  if (attributes.opacity !== void 0) {
    element.setAttribute("opacity", String(attributes.opacity));
  }
  if (attributes.fillOpacity !== void 0) {
    element.setAttribute("fill-opacity", String(attributes.fillOpacity));
  }
  if (attributes.strokeOpacity !== void 0) {
    element.setAttribute("stroke-opacity", String(attributes.strokeOpacity));
  }
  if (attributes.strokeLinecap) {
    element.setAttribute("stroke-linecap", attributes.strokeLinecap);
  }
  if (attributes.strokeLinejoin) {
    element.setAttribute("stroke-linejoin", attributes.strokeLinejoin);
  }
  if (attributes.strokeDasharray) {
    element.setAttribute("stroke-dasharray", attributes.strokeDasharray);
  }
  if (attributes.filter) {
    element.setAttribute("filter", attributes.filter);
  }
  if (attributes.clipPath) {
    element.setAttribute("clip-path", attributes.clipPath);
  }
  if (attributes.mask) {
    element.setAttribute("mask", attributes.mask);
  }
}
function createRoughShape(rc, node, config) {
  const shapeType = node.nodeName.toLowerCase();
  const getShapeAttrs = (node2, attrs) => {
    const allAttrs = getAttributes(node2, [
      ...attrs,
      "fill",
      "fill-opacity",
      "stroke",
      "stroke-opacity",
      "stroke-width",
      "stroke-dasharray",
      "stroke-linecap",
      "stroke-linejoin",
      "opacity",
      "filter",
      "clip-path",
      "mask"
    ], true);
    const shapeAttrs = {};
    const roughOptions = Object.assign({}, config);
    const svgAttributes = {};
    attrs.forEach((attr) => {
      if (allAttrs[attr] !== void 0) {
        shapeAttrs[attr] = allAttrs[attr];
      }
    });
    const { fill: fill2, "fill-opacity": fillOpacity, stroke, "stroke-opacity": strokeOpacity, "stroke-width": strokeWidth, "stroke-dasharray": strokeDasharray, "stroke-linecap": strokeLinecap, "stroke-linejoin": strokeLinejoin, opacity, filter: filter2, "clip-path": clipPath, mask } = allAttrs;
    roughOptions.fill = fill2 || "none";
    roughOptions.stroke = stroke || (fill2 && fill2 !== "none" ? fill2 : "currentColor");
    if (strokeWidth) {
      roughOptions.strokeWidth = parseFloat(strokeWidth);
    }
    if (strokeDasharray && strokeDasharray !== "none") {
      const dashArray = strokeDasharray.split(/[\s,]+/).map((v2) => parseFloat(v2)).filter((v2) => !isNaN(v2));
      if (dashArray.length > 0) {
        roughOptions.strokeLineDash = dashArray;
      }
    }
    if (fillOpacity) {
      svgAttributes.fillOpacity = parseFloat(fillOpacity);
    }
    if (strokeOpacity) {
      svgAttributes.strokeOpacity = parseFloat(strokeOpacity);
    }
    if (opacity) {
      svgAttributes.opacity = parseFloat(opacity);
    }
    if (strokeLinecap) {
      svgAttributes.strokeLinecap = strokeLinecap;
    }
    if (strokeLinejoin) {
      svgAttributes.strokeLinejoin = strokeLinejoin;
    }
    if (strokeDasharray && strokeDasharray !== "none") {
      svgAttributes.strokeDasharray = strokeDasharray;
    }
    if (filter2) {
      svgAttributes.filter = filter2;
    }
    if (clipPath) {
      svgAttributes.clipPath = clipPath;
    }
    if (mask) {
      svgAttributes.mask = mask;
    }
    return [shapeAttrs, roughOptions, svgAttributes];
  };
  try {
    let element = null;
    let svgAttributes = {};
    switch (shapeType) {
      case "circle": {
        const [attrs, options, svgAttrs] = getShapeAttrs(node, [
          "cx",
          "cy",
          "r"
        ]);
        const cx = parseFloat(attrs.cx) || 0;
        const cy = parseFloat(attrs.cy) || 0;
        const r5 = parseFloat(attrs.r) || 0;
        element = rc.circle(cx, cy, r5 * 2, options);
        svgAttributes = svgAttrs;
        break;
      }
      case "ellipse": {
        const [attrs, options, svgAttrs] = getShapeAttrs(node, [
          "cx",
          "cy",
          "rx",
          "ry"
        ]);
        const cx = parseFloat(attrs.cx) || 0;
        const cy = parseFloat(attrs.cy) || 0;
        const rx = parseFloat(attrs.rx) || 0;
        const ry = parseFloat(attrs.ry) || 0;
        element = rc.ellipse(cx, cy, rx * 2, ry * 2, options);
        svgAttributes = svgAttrs;
        break;
      }
      case "line": {
        const [attrs, options, svgAttrs] = getShapeAttrs(node, [
          "x1",
          "y1",
          "x2",
          "y2"
        ]);
        const x1 = parseFloat(attrs.x1) || 0;
        const y1 = parseFloat(attrs.y1) || 0;
        const x22 = parseFloat(attrs.x2) || 0;
        const y22 = parseFloat(attrs.y2) || 0;
        element = rc.line(x1, y1, x22, y22, options);
        svgAttributes = svgAttrs;
        break;
      }
      case "rect": {
        const [attrs, options, svgAttrs] = getShapeAttrs(node, [
          "x",
          "y",
          "width",
          "height",
          "rx",
          "ry"
        ]);
        const x6 = parseFloat(attrs.x) || 0;
        const y6 = parseFloat(attrs.y) || 0;
        const width = parseFloat(attrs.width) || 0;
        const height = parseFloat(attrs.height) || 0;
        const rx = parseFloat(attrs.rx) || 0;
        const ry = parseFloat(attrs.ry) || 0;
        if (rx > 0 || ry > 0) {
          const effectiveRx = rx || ry;
          const effectiveRy = ry || rx;
          const path2 = createRoundedRectPath(x6, y6, width, height, effectiveRx, effectiveRy);
          element = rc.path(path2, options);
        } else {
          element = rc.rectangle(x6, y6, width, height, options);
        }
        svgAttributes = svgAttrs;
        break;
      }
      case "path": {
        const [attrs, options, svgAttrs] = getShapeAttrs(node, ["d"]);
        const d3 = attrs.d || "";
        if (!d3) {
          console.warn("Path element has no d attribute");
          return null;
        }
        element = rc.path(d3, options);
        svgAttributes = svgAttrs;
        break;
      }
      case "polygon": {
        const [attrs, options, svgAttrs] = getShapeAttrs(node, ["points"]);
        const points = parsePolygonPoints(attrs.points || "");
        if (points.length < 3) {
          console.warn("Polygon needs at least 3 points");
          return null;
        }
        element = rc.polygon(points, options);
        svgAttributes = svgAttrs;
        break;
      }
      case "polyline": {
        const [attrs, options, svgAttrs] = getShapeAttrs(node, ["points"]);
        const points = parsePolygonPoints(attrs.points || "");
        if (points.length < 2) {
          console.warn("Polyline needs at least 2 points");
          return null;
        }
        element = rc.linearPath(points, options);
        svgAttributes = svgAttrs;
        break;
      }
      default:
        console.warn(`Unsupported shape type: ${shapeType}`);
        return null;
    }
    if (element) {
      return { element, svgAttributes };
    }
    return null;
  } catch (error) {
    console.error(`Error creating rough shape for ${shapeType}:`, error);
    return null;
  }
}
function createRoundedRectPath(x6, y6, width, height, rx, ry) {
  rx = Math.min(rx, width / 2);
  ry = Math.min(ry, height / 2);
  return `
    M ${x6 + rx} ${y6}
    L ${x6 + width - rx} ${y6}
    A ${rx} ${ry} 0 0 1 ${x6 + width} ${y6 + ry}
    L ${x6 + width} ${y6 + height - ry}
    A ${rx} ${ry} 0 0 1 ${x6 + width - rx} ${y6 + height}
    L ${x6 + rx} ${y6 + height}
    A ${rx} ${ry} 0 0 1 ${x6} ${y6 + height - ry}
    L ${x6} ${y6 + ry}
    A ${rx} ${ry} 0 0 1 ${x6 + rx} ${y6}
    Z
  `.replace(/\s+/g, " ").trim();
}
function parsePolygonPoints(points) {
  if (!points || typeof points !== "string") {
    return [];
  }
  try {
    const normalized = points.trim().replace(/,/g, " ").replace(/\s+/g, " ");
    const coords = normalized.split(" ").filter(Boolean);
    const result = [];
    for (let i4 = 0; i4 < coords.length - 1; i4 += 2) {
      const x6 = parseFloat(coords[i4]);
      const y6 = parseFloat(coords[i4 + 1]);
      if (isNaN(x6) || isNaN(y6)) {
        console.warn(`Invalid coordinate pair at index ${i4}: "${coords[i4]}", "${coords[i4 + 1]}"`);
        continue;
      }
      result.push([x6, y6]);
    }
    if (coords.length % 2 !== 0) {
      console.warn(`Odd number of coordinates in points attribute, last value ignored: "${coords[coords.length - 1]}"`);
    }
    return result;
  } catch (error) {
    console.error("Failed to parse polygon points:", points, error);
    return [];
  }
}

// node_modules/@antv/infographic/esm/renderer/composites/shape.js
function renderShape(svg, node, options) {
  var _a;
  const { themeConfig } = options;
  const attrs = Object.assign({}, (_a = themeConfig.base) === null || _a === void 0 ? void 0 : _a.shape, themeConfig.shape);
  const parsedAttrs = parseDynamicAttributes(node, attrs);
  setAttributes(node, parsedAttrs);
  stylizeShape(node, svg, options);
  return node;
}
function renderStaticShape(node, options) {
  var _a;
  setAttributes(node, ((_a = options.themeConfig.base) === null || _a === void 0 ? void 0 : _a.shape) || {});
}
function stylizeShape(node, svg, options) {
  const config = options.themeConfig.stylize;
  if (!config)
    return node;
  const { type: type2 } = config;
  if (!type2)
    return node;
  if (type2 === "rough") {
    return applyRoughStyle(node, svg, config);
  }
  if (type2 === "pattern") {
    return applyPatternStyle(node, svg, options);
  }
  if (type2 === "linear-gradient" || type2 === "radial-gradient") {
    const { fill: fill2, stroke } = getAttributes(node, ["fill", "stroke"]);
    if (hasColor(fill2)) {
      applyGradientStyle(node, svg, config, "fill");
    }
    if (hasColor(stroke)) {
      applyGradientStyle(node, svg, config, "stroke");
    }
    return;
  }
}

// node_modules/@antv/infographic/esm/renderer/composites/svg.js
function renderSVG(svg, options) {
  var _a;
  const { themeConfig } = options;
  const { "font-family": fontFamily = DEFAULT_FONT } = ((_a = themeConfig.base) === null || _a === void 0 ? void 0 : _a.text) || {};
  svg.setAttribute("font-family", fontFamily);
}

// node_modules/@antv/infographic/esm/renderer/composites/text.js
function renderText(node, text, attrs = {}) {
  if (!text)
    return null;
  const textElement = node;
  const staticAttrs = parseDynamicAttributes(textElement, attrs);
  setAttributes(textElement, staticAttrs);
  const renderedText = layoutText(text, textElement);
  for (const key in textElement.dataset) {
    renderedText.setAttribute(`data-${kebabCase_default(key)}`, textElement.dataset[key]);
  }
  return renderedText;
}
function renderItemText(type2, node, options) {
  var _a, _b, _c;
  const textShape = node.nodeName === "text" ? node : null;
  if (!textShape)
    return null;
  const { data, themeConfig } = options;
  const indexes = getItemIndexes(node.dataset.indexes || "0");
  const datum2 = getDatumByIndexes(data, indexes);
  const text = String(get_default(datum2, type2, ""));
  const dataAttrs = (_a = datum2 === null || datum2 === void 0 ? void 0 : datum2.attributes) === null || _a === void 0 ? void 0 : _a[type2];
  const attrs = Object.assign({}, (_b = themeConfig.base) === null || _b === void 0 ? void 0 : _b.text, (_c = themeConfig.item) === null || _c === void 0 ? void 0 : _c[type2], dataAttrs);
  const staticAttrs = parseDynamicAttributes(textShape, attrs);
  return renderText(node, node.textContent || text, staticAttrs);
}
function renderStaticText(text, options) {
  var _a;
  const attrs = ((_a = options.themeConfig.base) === null || _a === void 0 ? void 0 : _a.text) || {};
  setAttributes(text, attrs);
  if (attrs["font-family"]) {
    text.setAttribute("font-family", encodeFontFamily(attrs["font-family"]));
  }
  text.style.userSelect = "none";
  text.style.pointerEvents = "none";
}
var norm = (value, defaultValue) => {
  if (!value)
    return defaultValue;
  return parseFloat(value);
};
function layoutText(textContent, text) {
  const x6 = norm(text.dataset.x, 0);
  const y6 = norm(text.dataset.y, 0);
  const width = norm(text.getAttribute("width"));
  const height = norm(text.getAttribute("height"));
  const attributes = getTextAttributes(text);
  Object.assign(attributes, {
    x: x6,
    y: y6,
    width,
    height,
    "data-horizontal-align": text.dataset.horizontalAlign || "LEFT",
    "data-vertical-align": text.dataset.verticalAlign || "TOP"
  });
  const element = createTextElement(textContent, attributes);
  return element;
}
function getTextAttributes(textElement) {
  const attrs = getAttributes(textElement, [
    "font-family",
    "font-size",
    "font-weight",
    "font-style",
    "font-variant",
    "letter-spacing",
    "line-height",
    "fill",
    "stroke",
    "stroke-width"
  ]);
  return attrs;
}

// node_modules/@antv/infographic/esm/renderer/renderer.js
var upsert = (original, modified) => {
  if (original === modified)
    return;
  if (!modified)
    original.remove();
  else
    original.replaceWith(modified);
};
var Renderer = class {
  constructor(options, template) {
    this.options = options;
    this.template = template;
    this.rendered = false;
  }
  getOptions() {
    return this.options;
  }
  getSVG() {
    return this.template;
  }
  render() {
    const svg = this.getSVG();
    if (this.rendered)
      return svg;
    renderTemplate(svg, this.options);
    svg.style.visibility = "hidden";
    const postRender = () => {
      setView(this.template, this.options);
      loadFonts(this.template);
      svg.style.removeProperty("visibility");
    };
    if (isNode) {
      postRender();
    } else {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (node === svg || node.contains(svg)) {
              postRender();
              observer.disconnect();
            }
          });
        });
      });
      try {
        observer.observe(document, {
          childList: true,
          subtree: true
        });
      } catch (error) {
        postRender();
        console.error(error);
      }
    }
    this.rendered = true;
    return svg;
  }
};
function renderTemplate(svg, options) {
  fill(svg, options);
  setSVG(svg, options);
  renderBackground(svg, options);
}
function fill(svg, options) {
  var _a;
  const { themeConfig, data } = options;
  renderBaseElement(svg, (_a = themeConfig.base) === null || _a === void 0 ? void 0 : _a.global);
  const elements = svg.querySelectorAll(`[data-element-type]`);
  elements.forEach((element) => {
    var _a2, _b, _c, _d, _e, _f, _g;
    const id2 = element.id || "";
    if (isTitle(element)) {
      const modified = renderText(element, data.title || "", Object.assign({}, (_a2 = themeConfig.base) === null || _a2 === void 0 ? void 0 : _a2.text, themeConfig.title, (_b = data.attributes) === null || _b === void 0 ? void 0 : _b.title));
      return upsert(element, modified);
    }
    if (isDesc(element)) {
      const modified = renderText(element, data.desc || "", Object.assign({}, (_c = themeConfig.base) === null || _c === void 0 ? void 0 : _c.text, themeConfig.desc, (_d = data.attributes) === null || _d === void 0 ? void 0 : _d.desc));
      return upsert(element, modified);
    }
    if (isIllus(element)) {
      const modified = renderIllus(svg, element, (_e = data.illus) === null || _e === void 0 ? void 0 : _e[id2], void 0, (_f = data.attributes) === null || _f === void 0 ? void 0 : _f.illus);
      return upsert(element, modified);
    }
    if (isShapesGroup(element)) {
      return Array.from(element.children).forEach((child) => {
        renderShape(svg, child, options);
      });
    }
    if (isShape(element)) {
      const modified = renderShape(svg, element, options);
      return upsert(element, modified);
    }
    if (isBtnsGroup(element)) {
      return renderButtonsGroup(svg, element);
    }
    if ((_g = element.dataset.elementType) === null || _g === void 0 ? void 0 : _g.startsWith("item-")) {
      const indexes = getItemIndexes(element.dataset.indexes || "0");
      const itemType = element.dataset.elementType.replace("item-", "");
      const datum2 = getDatumByIndexes(data, indexes);
      if (isItemLabel(element) || isItemDesc(element) || isItemValue(element)) {
        const modified = renderItemText(itemType, element, options);
        return upsert(element, modified);
      }
      if (!datum2)
        return;
      if (isItemIllus(element)) {
        const modified = renderItemIllus(svg, element, datum2);
        return upsert(element, modified);
      }
      if (isItemIcon(element)) {
        const modified = renderItemIcon(svg, element, datum2, options);
        return upsert(element, modified);
      }
    }
    if (isText(element)) {
      return renderStaticText(element, options);
    }
    if (!isGroup(element)) {
      return renderStaticShape(element, options);
    }
  });
  renderSVG(svg, options);
}
function setSVG(svg, options) {
  const { width, height } = options;
  const { style = {}, attributes = {}, id: id2, className } = options.svg || {};
  if (id2)
    svg.id = id2;
  if (className)
    svg.classList.add(className);
  if (width !== void 0) {
    svg.setAttribute("width", typeof width === "number" ? `${width}px` : width);
  }
  if (height !== void 0) {
    svg.setAttribute("height", typeof height === "number" ? `${height}px` : height);
  }
  Object.assign(svg.style, style);
  setAttributes(svg, attributes);
}
function setView(svg, options) {
  const { padding = 0, viewBox } = options;
  if (viewBox) {
    svg.setAttribute("viewBox", viewBox);
  } else if (padding !== void 0) {
    setSVGPadding(svg, parsePadding(padding));
  }
}

// node_modules/@antv/infographic/esm/utils/is-browser.js
var IS_BROWSER;
function isBrowser() {
  if (IS_BROWSER)
    return true;
  if (typeof window === "undefined" || typeof document === "undefined") {
    return false;
  }
  const body = document.body;
  if (!body) {
    return false;
  }
  let hasRealLayout = false;
  try {
    const el = document.createElement("div");
    el.style.cssText = `
      position: absolute;
      left: 11px;
      top: 13px;
      width: 37px;
      height: 19px;
      padding: 0;
      margin: 0;
      border: 0;
      visibility: hidden;
    `;
    body.appendChild(el);
    void el.offsetHeight;
    const rect = el.getBoundingClientRect();
    body.removeChild(el);
    hasRealLayout = rect.width === 37 && rect.height === 19 && rect.left !== 0 && rect.top !== 0;
  } catch (_a) {
    hasRealLayout = false;
  }
  if (!hasRealLayout) {
    return false;
  }
  let hasRealCanvas = false;
  try {
    const canvas = document.createElement("canvas");
    canvas.width = 100;
    canvas.height = 50;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      return false;
    }
    ctx.font = "20px sans-serif";
    const metrics = ctx.measureText("Hello");
    hasRealCanvas = typeof metrics.width === "number" && metrics.width > 0 && metrics.width < 1e3;
  } catch (_b) {
    hasRealCanvas = false;
  }
  if (hasRealCanvas)
    IS_BROWSER = hasRealCanvas;
  return hasRealCanvas;
}

// node_modules/@antv/infographic/esm/utils/measure-text.js
var FONT_EXTEND_FACTOR = 1.01;
registerFont(AlibabaPuHuiTi_Regular_default);
var canvasContext = null;
var measureSpan = null;
function getCanvasContext() {
  if (canvasContext)
    return canvasContext;
  const canvas = document.createElement("canvas");
  canvasContext = canvas.getContext("2d");
  return canvasContext;
}
function getMeasureSpan() {
  if (!document.body)
    return null;
  if (measureSpan)
    return measureSpan;
  measureSpan = document.createElement("span");
  measureSpan.style.position = "absolute";
  measureSpan.style.top = "-10000px";
  measureSpan.style.left = "-10000px";
  measureSpan.style.visibility = "hidden";
  measureSpan.style.pointerEvents = "none";
  measureSpan.style.whiteSpace = "pre";
  measureSpan.style.display = "inline-block";
  measureSpan.style.padding = "0";
  measureSpan.style.margin = "0";
  document.body.appendChild(measureSpan);
  return measureSpan;
}
function resolveLineHeight(fontSize, lineHeight) {
  if (lineHeight === void 0 || lineHeight === null) {
    return fontSize * 1.4;
  }
  if (typeof lineHeight === "string") {
    const trimmed = lineHeight.trim();
    if (trimmed.endsWith("px")) {
      const value = Number.parseFloat(trimmed);
      return Number.isFinite(value) ? value : fontSize * 1.4;
    }
    lineHeight = Number(trimmed);
  }
  if (typeof lineHeight !== "number" || !Number.isFinite(lineHeight)) {
    return fontSize * 1.4;
  }
  return lineHeight > 4 ? lineHeight : lineHeight * fontSize;
}
function measureTextInBrowser(content, { fontFamily, fontSize, fontWeight, lineHeight }) {
  const lines = content.split(/\r?\n/);
  const normalizedFamily = encodeFontFamily(fontFamily);
  const normalizedWeight = fontWeight || "normal";
  const lineHeightPx = resolveLineHeight(fontSize, lineHeight);
  const context = getCanvasContext();
  if (context) {
    context.font = `${normalizedWeight} ${fontSize}px ${normalizedFamily}`;
    const width = lines.reduce((maxWidth, line2) => {
      const metrics = context.measureText(line2);
      return Math.max(maxWidth, metrics.width);
    }, 0);
    return { width, height: lineHeightPx * Math.max(lines.length, 1) };
  }
  const span = getMeasureSpan();
  if (!span)
    return null;
  span.style.fontFamily = normalizedFamily;
  span.style.fontSize = `${fontSize}px`;
  span.style.fontWeight = String(normalizedWeight);
  span.style.lineHeight = `${lineHeightPx}px`;
  span.textContent = content;
  const rect = span.getBoundingClientRect();
  return { width: rect.width, height: rect.height };
}
function measureText2(text = "", attrs) {
  var _a;
  if (attrs.width && attrs.height) {
    return { width: attrs.width, height: attrs.height };
  }
  if (typeof text !== "string" && typeof text !== "number") {
    return { width: 0, height: 0 };
  }
  const { fontFamily = DEFAULT_FONT, fontSize = 14, fontWeight = "normal", lineHeight = 1.4 } = attrs;
  const content = text.toString();
  const options = {
    fontFamily,
    fontSize: parseFloat(fontSize.toString()),
    fontWeight,
    lineHeight
  };
  const fallback = () => measureText(content, options);
  const metrics = isBrowser() ? (_a = measureTextInBrowser(content, options)) !== null && _a !== void 0 ? _a : fallback() : fallback();
  return {
    width: Math.ceil(metrics.width * FONT_EXTEND_FACTOR),
    height: Math.ceil(metrics.height * FONT_EXTEND_FACTOR)
  };
}

// node_modules/@antv/infographic/esm/utils/svg.js
function createElement(tagName, attributes = {}) {
  const element = document.createElementNS("http://www.w3.org/2000/svg", tagName);
  setAttributes(element, attributes);
  return element;
}
function parseSVG(svg) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(svg, "image/svg+xml");
  const errorNode = doc.querySelector("parsererror");
  if (errorNode) {
    throw new Error("Invalid SVG string");
  }
  return doc.documentElement;
}
function setAttributes(element, attrs) {
  Object.entries(attrs).forEach(([key, value]) => {
    if (value === null || value === void 0) {
      element.removeAttribute(key);
    } else {
      element.setAttribute(key, value);
    }
  });
}
function getAttributes(element, attrs, ignoreEmpty = true) {
  return attrs.reduce((acc, attr) => {
    const value = element.getAttribute(attr);
    if (!ignoreEmpty || value !== null && value !== "" && value !== void 0) {
      acc[attr] = value;
    }
    return acc;
  }, {});
}
function removeAttributes(element, attrs) {
  attrs.forEach((attr) => {
    element.removeAttribute(attr);
  });
}
function traverse(node, callback) {
  if (callback(node) === false)
    return;
  const children2 = Array.from(node.children);
  children2.forEach((child) => {
    traverse(child, callback);
  });
}
function getOrCreateDefs(svg, defsId = "infographic-defs") {
  const selector = defsId ? `defs#${defsId}` : "defs";
  const defs = svg.querySelector(selector);
  if (defs)
    return defs;
  const newDefs = createElement("defs");
  if (defsId)
    newDefs.id = defsId;
  svg.prepend(newDefs);
  return newDefs;
}

// node_modules/@antv/infographic/esm/utils/text.js
var __rest4 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
function getTextEntity(text) {
  if (!isForeignObjectElement(text))
    return null;
  return text.querySelector("span");
}
function createTextElement(textContent, attributes) {
  const entity = document.createElement("span");
  entity.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
  const foreignObject = createElement("foreignObject", { overflow: "visible" });
  foreignObject.appendChild(entity);
  updateTextElement(foreignObject, { textContent, attributes });
  return foreignObject;
}
function updateTextElement(text, props) {
  const { textContent, attributes } = props;
  if (textContent !== void 0) {
    setTextContent(text, textContent);
  }
  if (!attributes)
    return;
  const entity = getTextEntity(text);
  let { width, height } = attributes;
  const textAttrs = {};
  if (entity) {
    Object.assign(entity.style, getTextStyle(attributes));
    if (!width || !height) {
      const content = textContent !== null && textContent !== void 0 ? textContent : getTextContent(text);
      const { fontFamily, fontSize, fontWeight, lineHeight } = entity.style;
      const fSize = fontSize ? parseFloat(String(fontSize)) : 12;
      const rect = measureText2(content, {
        fontFamily,
        fontSize: fSize,
        fontWeight,
        lineHeight: lineHeight.endsWith("px") ? parseFloat(lineHeight) : (parseFloat(lineHeight) || 1.4) * fSize
      });
      if (!width && !text.hasAttribute("width"))
        width = String(rect.width);
      if (!height && !text.hasAttribute("height"))
        height = String(rect.height);
    }
    const { "data-horizontal-align": horizontal, "data-vertical-align": vertical } = attributes;
    Object.assign(entity.style, alignToFlex(horizontal, vertical));
  }
  const { id: id2, x: x6, y: y6 } = attributes;
  if (id2)
    textAttrs.id = id2;
  if (x6 !== void 0)
    textAttrs.x = String(x6);
  if (y6 !== void 0)
    textAttrs.y = String(y6);
  if (width !== void 0)
    textAttrs.width = String(width);
  if (height !== void 0)
    textAttrs.height = String(height);
  setAttributes(text, textAttrs);
}
function alignToFlex(horizontal, vertical) {
  const style = {
    width: "100%",
    height: "100%",
    display: "flex",
    flexWrap: "wrap",
    wordBreak: "break-word",
    whiteSpace: "pre-wrap"
  };
  switch (horizontal) {
    case "LEFT":
      style.textAlign = "left";
      style.justifyContent = "flex-start";
      break;
    case "CENTER":
      style.textAlign = "center";
      style.justifyContent = "center";
      break;
    case "RIGHT":
      style.textAlign = "right";
      style.justifyContent = "flex-end";
      break;
  }
  switch (vertical) {
    case "TOP":
      style.alignContent = "flex-start";
      style.alignItems = "flex-start";
      break;
    case "MIDDLE":
      style.alignContent = "center";
      style.alignItems = "center";
      break;
    case "BOTTOM":
      style.alignContent = "flex-end";
      style.alignItems = "flex-end";
      break;
  }
  return style;
}
function getTextStyle(attributes) {
  const {
    x: x6,
    y: y6,
    width,
    height,
    ["data-horizontal-align"]: horizontalAlign,
    // omit
    ["data-vertical-align"]: verticalAlign,
    // omit
    ["font-size"]: fontSize,
    ["letter-spacing"]: letterSpacing,
    ["line-height"]: lineHeight,
    fill: fill2,
    ["stroke-width"]: strokeWidth,
    ["text-anchor"]: textAnchor,
    // omit
    ["dominant-baseline"]: dominantBaseline,
    // omit
    ["font-family"]: fontFamily
  } = attributes, restAttrs = __rest4(attributes, ["x", "y", "width", "height", "data-horizontal-align", "data-vertical-align", "font-size", "letter-spacing", "line-height", "fill", "stroke-width", "text-anchor", "dominant-baseline", "font-family"]);
  const style = {
    overflow: "visible"
    // userSelect: 'none',
  };
  if (fill2)
    style.color = fill2;
  Object.entries(restAttrs).forEach(([key, value]) => {
    style[camelCase_default(key)] = value;
  });
  if (fontSize)
    style.fontSize = `${fontSize}px`;
  if (lineHeight)
    style.lineHeight = typeof lineHeight === "string" && lineHeight.endsWith("px") ? lineHeight : +lineHeight;
  if (letterSpacing)
    style.letterSpacing = `${letterSpacing}px`;
  if (strokeWidth)
    style.strokeWidth = `${strokeWidth}px`;
  if (fontFamily)
    style.fontFamily = encodeFontFamily(fontFamily);
  return style;
}
function getTextContent(text) {
  const entity = getTextEntity(text);
  if (!entity)
    return "";
  return entity.innerText || entity.textContent || "";
}
function setTextContent(text, content) {
  const entity = getTextEntity(text);
  if (entity) {
    try {
      entity.innerText = content;
    } catch (_a) {
      entity.textContent = content;
    }
  }
}
function getTextElementProps(text) {
  const entity = getTextEntity(text);
  if (!entity)
    return {};
  const { color: color3, fontSize, fontFamily, justifyContent, alignContent, fontWeight } = entity.style;
  const [horizontal, vertical] = flexToAlign(justifyContent, alignContent);
  const attrs = {
    "data-horizontal-align": horizontal,
    "data-vertical-align": vertical
  };
  if (fontFamily)
    attrs["font-family"] = decodeFontFamily(fontFamily);
  if (fontWeight)
    attrs["font-weight"] = fontWeight;
  if (fontSize)
    attrs["font-size"] = String(parseInt(fontSize));
  if (color3)
    attrs["fill"] = color3;
  return { attributes: attrs, textContent: getTextContent(text) };
}
function flexToAlign(justifyContent, alignContent) {
  let horizontal = "LEFT";
  let vertical = "TOP";
  switch (justifyContent) {
    case "flex-start":
      horizontal = "LEFT";
      break;
    case "center":
      horizontal = "CENTER";
      break;
    case "flex-end":
      horizontal = "RIGHT";
      break;
  }
  switch (alignContent) {
    case "flex-start":
      vertical = "TOP";
      break;
    case "center":
      vertical = "MIDDLE";
      break;
    case "flex-end":
      vertical = "BOTTOM";
      break;
  }
  return [horizontal, vertical];
}

// node_modules/@antv/infographic/esm/utils/recognizer.js
var is = (element, role) => {
  var _a;
  return ((_a = element === null || element === void 0 ? void 0 : element.dataset) === null || _a === void 0 ? void 0 : _a.elementType) === role;
};
var isTagName = (element, tagName) => {
  return element.tagName.toLowerCase() === tagName.toLowerCase();
};
var isTitle = (element) => is(element, "title");
var isDesc = (element) => is(element, "desc");
var isShape = (element) => is(element, "shape");
var isShapesGroup = (element) => is(element, "shapes-group");
var isIllus = (element) => is(element, "illus");
var isText = (element) => element instanceof SVGElement && isTagName(element, "text");
var isGroup = (element) => element instanceof SVGElement && isTagName(element, "g");
var isItemIcon = (element) => is(element, "item-icon");
var isItemIconGroup = (element) => is(element, "item-icon-group");
var isItemLabel = (element) => is(element, "item-label");
var isItemDesc = (element) => is(element, "item-desc");
var isItemValue = (element) => is(element, "item-value");
var isItemIllus = (element) => is(element, "item-illus");
var isEditArea = (element) => is(element, "edit-area");
var isBtnsGroup = (element) => is(element, "btns-group");
var isRoughElement = (element) => is(element, "rough-element");
var isRoughVolume = (element) => is(element, "rough-volume");
function isForeignObjectElement(element) {
  return isTagName(element, "foreignObject");
}
function isTextEntity(element) {
  return isTagName(element, "SPAN");
}
function isEditableText(node) {
  const role = getElementRole(node);
  return [
    "title",
    "desc",
    "item-label",
    "item-desc"
  ].includes(role);
}
function isEditingText(element) {
  if (!element)
    return false;
  if (!isEditableText(element))
    return false;
  const span = getTextEntity(element);
  if (!span)
    return false;
  return span.hasAttribute("contenteditable");
}
function isGeometryElement(element) {
  const tagName = element.tagName.toLowerCase();
  return [
    "rect",
    "circle",
    "ellipse",
    "line",
    "polygon",
    "polyline",
    "path"
  ].includes(tagName);
}
function isIconElement(element) {
  return isItemIcon(element) || isItemIconGroup(element);
}
function isInfographicComponent(element) {
  let current = element;
  while (current) {
    if (getElementByRole(current, COMPONENT_ROLE)) {
      return true;
    }
    current = current.parentElement;
  }
  return false;
}

// node_modules/@antv/infographic/esm/utils/element.js
function setElementRole(element, role) {
  element.setAttribute("data-element-type", role);
}
function getElementByRole(element, role) {
  return element.querySelector(`[data-element-type="${role}"]`);
}
function getElementRole(element) {
  if (isIconElement(element))
    return "item-icon";
  return element.getAttribute("data-element-type") || "unknown";
}

// node_modules/flru/dist/flru.mjs
function flru_default(max3) {
  var num3, curr, prev;
  var limit = max3 || 1;
  function keep(key, value) {
    if (++num3 > limit) {
      prev = curr;
      reset(1);
      ++num3;
    }
    curr[key] = value;
  }
  function reset(isPartial) {
    num3 = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0)
        return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value) {
      if (curr[key] !== void 0) {
        curr[key] = value;
      } else {
        keep(key, value);
      }
    }
  };
}

// node_modules/@antv/infographic/esm/utils/fetch.js
var __awaiter6 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var nativeFetch = globalThis.fetch;
var CACHE_MAX_ENTRIES = 1024;
var responseCache = flru_default(CACHE_MAX_ENTRIES);
var pendingRequests = /* @__PURE__ */ new Map();
function buildHeadersKey(request) {
  const entries = Array.from(request.headers.entries());
  if (entries.length === 0)
    return "";
  entries.sort(([nameA], [nameB]) => nameA.toLowerCase().localeCompare(nameB.toLowerCase()));
  return entries.map(([name, value]) => `${name.toLowerCase()}:${value}`).join("|");
}
function buildCacheKey(request) {
  const headersKey = buildHeadersKey(request);
  return headersKey ? `${request.method}:${request.url}:${headersKey}` : `${request.method}:${request.url}`;
}
function buildResponse(entry) {
  return new Response(entry.body.slice(0), entry.init);
}
function fetchAndCache(request, key) {
  return __awaiter6(this, void 0, void 0, function* () {
    try {
      const response = yield nativeFetch(request);
      const body = yield response.arrayBuffer();
      const entry = {
        body,
        init: {
          status: response.status,
          statusText: response.statusText,
          headers: Array.from(response.headers.entries())
        }
      };
      if (response.ok) {
        responseCache.set(key, entry);
      }
      return entry;
    } finally {
      pendingRequests.delete(key);
    }
  });
}
function fetchWithCache(input, init2) {
  return __awaiter6(this, void 0, void 0, function* () {
    const request = new Request(input, init2);
    if (request.method !== "GET") {
      return nativeFetch(request);
    }
    const key = buildCacheKey(request);
    if (responseCache.has(key)) {
      return buildResponse(responseCache.get(key));
    }
    let pending = pendingRequests.get(key);
    if (!pending) {
      pending = fetchAndCache(request, key);
      pendingRequests.set(key, pending);
    }
    const entry = yield pending;
    return buildResponse(entry);
  });
}

// node_modules/@antv/infographic/esm/utils/get-types.js
function getTypes(composites, commentsMap = {
  title: "\u4FE1\u606F\u56FE\u6807\u9898",
  desc: "\u4FE1\u606F\u56FE\u63CF\u8FF0",
  items: "\u4FE1\u606F\u56FE\u7684\u5185\u5BB9\u9879",
  label: "\u9879\u76EE\u6807\u7B7E\u6587\u672C",
  value: "\u9879\u76EE\u6570\u503C\u5185\u5BB9",
  icon: "\u9879\u76EE\u56FE\u6807",
  illus: "\u9879\u76EE\u63D2\u56FE",
  children: "\u5B50\u7EA7\u9879\u76EE\uFF08\u591A\u5C42\u7ED3\u6784\uFF09"
}) {
  const { structure, items: items3 } = composites;
  const lines = [];
  const indent = (level) => "  ".repeat(level);
  function fieldLine(name, type2, level) {
    const comment2 = commentsMap[name];
    return comment2 ? `${indent(level)}/** ${comment2} */
${indent(level)}${name}: ${type2};` : `${indent(level)}${name}: ${type2};`;
  }
  function buildItemType(level, indentLevel) {
    const fields = items3[level];
    const fieldLines = [];
    for (const field of fields) {
      const type2 = field === "value" ? "number" : "string";
      fieldLines.push(fieldLine(field, type2, indentLevel + 1));
    }
    if (items3[level + 1]) {
      fieldLines.push(fieldLine("children", `Array<${buildItemType(level + 1, indentLevel + 1)}>`, indentLevel + 1));
    }
    return `{
${fieldLines.join("\n")}
${indent(indentLevel)}}`;
  }
  lines.push("type InfographicType = {");
  if (structure.includes("title")) {
    lines.push(fieldLine("title", "string", 1));
    lines.push(fieldLine("desc", "string", 1));
  }
  if (structure.includes("item") && items3.length > 0) {
    lines.push(fieldLine("items", `Array<${buildItemType(0, 1)}>`, 1));
  }
  lines.push("}");
  return lines.join("\n");
}

// node_modules/@antv/infographic/esm/utils/hash.js
function getSimpleHash(str) {
  let hash = 0;
  if (str.length === 0)
    return hash.toString();
  for (let i4 = 0; i4 < str.length; i4++) {
    const char = str.charCodeAt(i4);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString();
}

// node_modules/@antv/infographic/esm/utils/icon.js
var ICON_RESOURCE_CACHE = /* @__PURE__ */ new WeakMap();
function createIconElement(value, attrs = {}) {
  const icon = createElement("use", Object.assign(Object.assign({}, attrs), { href: getResourceHref(value) }));
  applyIconColor(icon);
  ICON_RESOURCE_CACHE.set(icon, value);
  return icon;
}
function applyIconColor(icon) {
  const { stroke, fill: fill2 } = getAttributes(icon, ["fill", "stroke"]);
  icon.style.color = fill2 || stroke || "currentColor";
}
function getIconEntity(icon) {
  if (icon.tagName === "use") {
    return icon;
  }
  return icon.querySelector("use");
}
function getIconAttrs(icon) {
  const entity = getIconEntity(icon);
  if (!entity)
    return {};
  const attrs = getAttributes(entity, [
    "width",
    "height",
    "x",
    "y",
    "width",
    "height",
    "fill",
    "fill-opacity",
    "stroke",
    "opacity"
  ]);
  return attrs;
}
function updateIconElement(icon, value, attrs) {
  const entity = getIconEntity(icon);
  if (!entity)
    return;
  if (value)
    setAttributes(entity, { href: getResourceHref(value) });
  if (attrs)
    setAttributes(entity, attrs);
  applyIconColor(entity);
}

// node_modules/@antv/infographic/esm/utils/is-node.js
var isNode = !!(typeof process !== "undefined" && process.versions && process.versions.node);

// node_modules/@antv/infographic/esm/utils/item.js
var DEFAULT_SEPARATOR = ",";
var getIndexesFromItemKey = (key, separator = DEFAULT_SEPARATOR) => {
  return key.split(separator).map((value) => parseInt(value, 10));
};
var getItemIndexes = (indexesStr) => {
  return getIndexesFromItemKey(indexesStr);
};

// node_modules/@antv/infographic/esm/utils/join.js
function join(...paths) {
  return paths.map((path2) => path2.replace(/^\/+|\/+$/g, "")).filter((path2) => path2.trim().length > 0).join("/");
}

// node_modules/@antv/infographic/esm/utils/viewbox.js
function getViewBox(svg) {
  const viewBox = svg.getAttribute("viewBox");
  if (viewBox) {
    const [x6, y6, width2, height2] = viewBox.split(" ").map(Number);
    return { x: x6, y: y6, width: width2, height: height2 };
  }
  const widthStr = svg.getAttribute("width");
  const heightStr = svg.getAttribute("height");
  const width = Number(widthStr) || 0;
  const height = Number(heightStr) || 0;
  return { x: 0, y: 0, width, height };
}
function calculateZoomedViewBox(current, factor2, pivot) {
  const newWidth = current.width * factor2;
  const newHeight = current.height * factor2;
  const newX = pivot.x - (pivot.x - current.x) * factor2;
  const newY = pivot.y - (pivot.y - current.y) * factor2;
  return { x: newX, y: newY, width: newWidth, height: newHeight };
}
function viewBoxToString(box) {
  return `${box.x} ${box.y} ${box.width} ${box.height}`;
}

// node_modules/@antv/infographic/esm/utils/padding.js
function parsePadding(padding) {
  if (!padding)
    return [0, 0, 0, 0];
  if (typeof padding === "number") {
    return [padding, padding, padding, padding];
  }
  if (padding.length === 1) {
    return [padding[0], padding[0], padding[0], padding[0]];
  }
  if (padding.length === 2) {
    return [padding[0], padding[1], padding[0], padding[1]];
  }
  if (padding.length === 3) {
    return [padding[0], padding[1], padding[2], padding[1]];
  }
  if (padding.length === 4) {
    return [padding[0], padding[1], padding[2], padding[3]];
  }
  return [0, 0, 0, 0];
}
function setSVGPadding(svg, padding) {
  if (isNode) {
    setSVGPaddingInNode(svg, padding);
  } else {
    if (document.contains(svg)) {
      setSVGPaddingInBrowser(svg, padding);
    } else {
      try {
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node === svg || node.contains(svg)) {
                waitForLayout(svg, () => {
                  setSVGPaddingInBrowser(svg, padding);
                });
                observer.disconnect();
              }
            });
          });
        });
        observer.observe(document, {
          childList: true,
          subtree: true
        });
      } catch (_a) {
        setSVGPaddingInNode(svg, padding);
      }
    }
  }
}
function setSVGPaddingInNode(svg, padding) {
  const viewBox = getViewBox(svg);
  const [top, right, bottom, left] = padding;
  setAttributes(svg, {
    viewBox: `${viewBox.x - left} ${viewBox.y - top} ${viewBox.width + left + right} ${viewBox.height + top + bottom}`
  });
}
function setSVGPaddingInBrowser(svg, padding) {
  const bbox = svg.getBBox();
  const clientRect = svg.getBoundingClientRect();
  const scaleX = clientRect.width > 0 ? bbox.width / clientRect.width : 1;
  const scaleY = clientRect.height > 0 ? bbox.height / clientRect.height : 1;
  const [topPx, rightPx, bottomPx, leftPx] = padding;
  const topSvg = topPx * scaleY;
  const rightSvg = rightPx * scaleX;
  const bottomSvg = bottomPx * scaleY;
  const leftSvg = leftPx * scaleX;
  const newX = bbox.x - leftSvg;
  const newY = bbox.y - topSvg;
  const newWidth = bbox.width + leftSvg + rightSvg;
  const newHeight = bbox.height + topSvg + bottomSvg;
  setAttributes(svg, {
    viewBox: `${newX} ${newY} ${newWidth} ${newHeight}`
  });
}
function waitForLayout(element, callback) {
  requestAnimationFrame(() => {
    const check = () => {
      const rect = element.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        callback();
      } else {
        requestAnimationFrame(check);
      }
    };
    check();
  });
}

// node_modules/@antv/infographic/esm/utils/style.js
function injectStyleOnce(id2, styles) {
  if (document.getElementById(id2))
    return;
  const style = document.createElement("style");
  style.id = id2;
  style.textContent = styles;
  document.head.appendChild(style);
}

// node_modules/@antv/infographic/esm/utils/uuid.js
function uuid() {
  if (crypto && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return "xxxx-xxxx-4xxx-yxxx".replace(/[xy]/g, function(c4) {
    const r5 = Math.random() * 16 | 0;
    const v2 = c4 === "x" ? r5 : r5 & 3 | 8;
    return v2.toString(16);
  });
}

// node_modules/@antv/infographic/esm/jsx/components/Text.js
var __rest5 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
function Text(props) {
  const { id: id2, x: x6 = 0, y: y6 = 0, width: w3, height: h4, alignHorizontal = "left", alignVertical = "top", children: children2, fontSize = 14, fontFamily, fontStyle, fontWeight, textDecoration, letterSpacing, wordSpacing, opacity, fill: fill2 = "black", lineHeight, wordWrap, backgroundColor = "none", backgroundOpacity = 1, backgroundRadius = 0 } = props, restProps = __rest5(props, ["id", "x", "y", "width", "height", "alignHorizontal", "alignVertical", "children", "fontSize", "fontFamily", "fontStyle", "fontWeight", "textDecoration", "letterSpacing", "wordSpacing", "opacity", "fill", "lineHeight", "wordWrap", "backgroundColor", "backgroundOpacity", "backgroundRadius"]);
  let width = w3;
  let height = h4;
  let textX = 0;
  let textY = 0;
  if (!width || !height) {
    const metrics = measureText2(children2, props);
    width || (width = metrics.width);
    height || (height = metrics.height);
  }
  if (w3) {
    textX = alignHorizontal === "center" ? width / 2 : alignHorizontal === "right" ? width : 0;
  }
  if (h4) {
    textY = alignVertical === "middle" ? height / 2 : alignVertical === "bottom" ? height : 0;
  }
  const dataAttrs = Object.entries(Object.assign(Object.assign({
    width,
    height
  }, lineHeight !== void 0 && { "line-height": lineHeight }), wordWrap !== void 0 && { "data-word-wrap": wordWrap })).reduce((acc, [key, value]) => Object.assign(Object.assign({}, acc), { [key]: value }), {});
  const textAnchor = alignHorizontal === "center" ? "middle" : alignHorizontal === "right" ? "end" : "start";
  const dominantBaseline = alignVertical === "middle" ? "central" : alignVertical === "bottom" ? "baseline" : "hanging";
  const textProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
    "data-element-type": "text",
    width,
    height,
    x: textX,
    y: textY,
    "data-x": 0,
    "data-y": 0,
    fill: fill2,
    fontSize,
    textAnchor,
    dominantBaseline,
    "data-horizontal-align": alignHorizontal.toUpperCase(),
    "data-vertical-align": alignVertical.toUpperCase(),
    children: children2
  }, dataAttrs), restProps), fontFamily && { fontFamily }), fontStyle && { fontStyle }), fontWeight && { fontWeight }), textDecoration && textDecoration !== "none" && { textDecoration }), letterSpacing && { letterSpacing }), wordSpacing && { wordSpacing }), opacity !== void 0 && opacity !== 1 && { opacity });
  const containerProps = Object.assign(Object.assign(Object.assign({}, x6 !== 0 || y6 !== 0 ? { x: x6, y: y6, transform: `translate(${x6}, ${y6})` } : {}), {
    width,
    height
  }), id2 && { id: id2 });
  const hasBackground = backgroundColor && backgroundColor !== "none";
  const rectProps = hasBackground ? {
    "data-element-type": "shape",
    x: 0,
    y: 0,
    width,
    height,
    fill: backgroundColor,
    fillOpacity: backgroundOpacity,
    rx: backgroundRadius,
    ry: backgroundRadius
  } : void 0;
  return {
    type: "g",
    props: Object.assign(Object.assign({}, containerProps), { children: [
      ...rectProps ? [{ type: "rect", props: rectProps }] : [],
      { type: "text", props: textProps }
    ] })
  };
}

// node_modules/@antv/infographic/esm/jsx/utils/is-fragment.js
function isFragment(node) {
  if (!node || typeof node !== "object" || Array.isArray(node))
    return false;
  return node.type === Fragment;
}

// node_modules/@antv/infographic/esm/jsx/utils/is-jsx-element.js
function isJSXElement(element) {
  return element !== null && typeof element === "object" && !Array.isArray(element) && "type" in element;
}

// node_modules/@antv/infographic/esm/jsx/utils/element.js
function nodeToElements(node) {
  return nodeToRenderableNodes(node).filter(isJSXElement);
}
function nodeToRenderableNodes(node, result = []) {
  var _a;
  if (!node || typeof node === "boolean") {
    return result;
  }
  if (Array.isArray(node)) {
    node.forEach((child) => nodeToRenderableNodes(child, result));
  } else {
    if (isFragment(node)) {
      const children2 = (_a = node.props) === null || _a === void 0 ? void 0 : _a.children;
      (Array.isArray(children2) ? children2 : [children2]).filter(Boolean).forEach((child) => {
        nodeToRenderableNodes(child, result);
      });
    } else if (typeof node === "object")
      result.push(node);
    else
      result.push(node);
  }
  return result;
}

// node_modules/@antv/infographic/esm/jsx/utils/is-number.js
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value) && Number.isFinite(value);
}

// node_modules/@antv/infographic/esm/jsx/utils/bounds.js
var zero = () => ({ x: 0, y: 0, width: 0, height: 0 });
function getCombinedBounds(list3) {
  if (!list3 || list3.length === 0)
    return zero();
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const bounds of list3) {
    const { x: x6, y: y6, width, height } = bounds;
    const x22 = x6 + width;
    const y22 = y6 + height;
    if (x6 < minX)
      minX = x6;
    if (y6 < minY)
      minY = y6;
    if (x22 > maxX)
      maxX = x22;
    if (y22 > maxY)
      maxY = y22;
  }
  if (minX === Infinity || minY === Infinity || maxX === -Infinity || maxY === -Infinity) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  return {
    x: minX,
    y: minY,
    width: Math.max(0, maxX - minX),
    height: Math.max(0, maxY - minY)
  };
}
function getElementBounds(node) {
  var _a, _b, _c, _d;
  if (!node)
    return zero();
  if (Array.isArray(node)) {
    const elements = nodeToElements(node);
    return getElementsBounds(elements);
  }
  if (typeof node !== "object")
    return zero();
  const { type: type2, props = {} } = node;
  if (isLayoutComponent(node)) {
    const layoutResult = performLayout(node);
    return getElementBounds(layoutResult);
  }
  if (typeof type2 === "function") {
    const externalX = (_a = props.x) !== null && _a !== void 0 ? _a : 0;
    const externalY = (_b = props.y) !== null && _b !== void 0 ? _b : 0;
    const externalWidth = props.width;
    const externalHeight = props.height;
    if (isNumber(externalWidth) && isNumber(externalHeight)) {
      return {
        x: externalX,
        y: externalY,
        width: externalWidth,
        height: externalHeight
      };
    }
    const renderedResult = type2(props);
    if (!renderedResult) {
      return {
        x: externalX,
        y: externalY,
        width: externalWidth !== null && externalWidth !== void 0 ? externalWidth : 0,
        height: externalHeight !== null && externalHeight !== void 0 ? externalHeight : 0
      };
    }
    if (Array.isArray(renderedResult)) {
      const elements = nodeToElements(renderedResult);
      const innerBounds = getElementsBounds(elements);
      if (isNumber(externalWidth) && isNumber(externalHeight)) {
        return {
          x: externalX,
          y: externalY,
          width: externalWidth,
          height: externalHeight
        };
      }
      const width2 = innerBounds.width !== 0 ? innerBounds.width : externalWidth !== null && externalWidth !== void 0 ? externalWidth : 0;
      const height2 = innerBounds.height !== 0 ? innerBounds.height : externalHeight !== null && externalHeight !== void 0 ? externalHeight : 0;
      return {
        x: externalX + innerBounds.x,
        y: externalY + innerBounds.y,
        width: width2,
        height: height2
      };
    }
    if (isJSXElement(renderedResult)) {
      const innerElement = renderedResult;
      const innerBounds = getElementBounds(innerElement);
      if (isPassthrough(innerElement, props)) {
        return innerBounds;
      }
      const innerHasExplicitSize = innerElement.props && isNumber(innerElement.props.width) && isNumber(innerElement.props.height);
      const children3 = getChildrenFromElement(innerElement);
      const jsxChildren2 = children3.flatMap((child) => nodeToElements(child));
      const innerHasChildren = jsxChildren2.length > 0;
      const innerHasSamePosition = innerElement.props && innerElement.props.x === props.x && innerElement.props.y === props.y;
      if (innerHasExplicitSize) {
        return {
          x: innerHasSamePosition ? innerBounds.x : externalX + innerBounds.x,
          y: innerHasSamePosition ? innerBounds.y : externalY + innerBounds.y,
          width: innerBounds.width,
          height: innerBounds.height
        };
      }
      if (isNumber(externalWidth) && isNumber(externalHeight)) {
        if (innerHasChildren) {
          return {
            x: innerHasSamePosition ? innerBounds.x : externalX,
            y: innerHasSamePosition ? innerBounds.y : externalY,
            width: externalWidth,
            height: externalHeight
          };
        } else {
          return {
            x: innerHasSamePosition ? innerBounds.x : externalX + innerBounds.x,
            y: innerHasSamePosition ? innerBounds.y : externalY + innerBounds.y,
            width: externalWidth,
            height: externalHeight
          };
        }
      }
      const width2 = innerBounds.width !== 0 ? innerBounds.width : externalWidth !== null && externalWidth !== void 0 ? externalWidth : 0;
      const height2 = innerBounds.height !== 0 ? innerBounds.height : externalHeight !== null && externalHeight !== void 0 ? externalHeight : 0;
      return {
        x: innerHasSamePosition ? innerBounds.x : externalX + innerBounds.x,
        y: innerHasSamePosition ? innerBounds.y : externalY + innerBounds.y,
        width: width2,
        height: height2
      };
    }
    return {
      x: externalX,
      y: externalY,
      width: externalWidth !== null && externalWidth !== void 0 ? externalWidth : 0,
      height: externalHeight !== null && externalHeight !== void 0 ? externalHeight : 0
    };
  }
  const x6 = (_c = props.x) !== null && _c !== void 0 ? _c : 0;
  const y6 = (_d = props.y) !== null && _d !== void 0 ? _d : 0;
  const width = isNumber(props.width) ? props.width : void 0;
  const height = isNumber(props.height) ? props.height : void 0;
  if (isNumber(width) && isNumber(height)) {
    return { x: x6, y: y6, width, height };
  }
  const children2 = getChildrenFromElement(node);
  const jsxChildren = children2.flatMap((child) => nodeToElements(child));
  if (jsxChildren.length > 0) {
    const innerBounds = getElementsBounds(jsxChildren);
    return {
      x: x6 + innerBounds.x,
      y: y6 + innerBounds.y,
      width: isNumber(width) ? width : innerBounds.width,
      height: isNumber(height) ? height : innerBounds.height
    };
  }
  return {
    x: x6,
    y: y6,
    width: width !== null && width !== void 0 ? width : 0,
    height: height !== null && height !== void 0 ? height : 0
  };
}
function getElementsBounds(elements) {
  if (!elements || !Array.isArray(elements) || elements.length === 0) {
    return zero();
  }
  const list3 = [];
  for (const element of elements) {
    const validElements = nodeToElements(element);
    for (const validElement of validElements) {
      const bounds = getElementBounds(validElement);
      if (bounds) {
        list3.push(bounds);
      }
    }
  }
  return getCombinedBounds(list3);
}
function isPassthrough(innerElement, externalProps) {
  if (!(innerElement === null || innerElement === void 0 ? void 0 : innerElement.props) || !externalProps) {
    return false;
  }
  const inner = innerElement.props;
  if (isNumber(inner.x) && isNumber(inner.y) && isNumber(externalProps.x) && isNumber(externalProps.y)) {
    if (inner.x === externalProps.x && inner.y === externalProps.y) {
      const innerHasSize = isNumber(inner.width) && isNumber(inner.height);
      const externalHasSize = isNumber(externalProps.width) && isNumber(externalProps.height);
      if (!innerHasSize && !externalHasSize) {
        return true;
      }
    }
  }
  if (isNumber(inner.x) && isNumber(inner.y) && isNumber(inner.width) && isNumber(inner.height) && isNumber(externalProps.x) && isNumber(externalProps.y) && isNumber(externalProps.width) && isNumber(externalProps.height)) {
    return inner.x === externalProps.x && inner.y === externalProps.y && inner.width === externalProps.width && inner.height === externalProps.height;
  }
  return false;
}
function getChildrenFromElement(element) {
  var _a;
  const children2 = (_a = element.props) === null || _a === void 0 ? void 0 : _a.children;
  if (!children2) {
    return [];
  }
  return Array.isArray(children2) ? children2 : [children2];
}

// node_modules/@antv/infographic/esm/jsx/utils/children.js
function getRenderableChildrenOf(element) {
  var _a;
  if (element === null || element === void 0 || typeof element === "boolean") {
    return [];
  }
  if (Array.isArray(element))
    return nodeToRenderableNodes(element);
  if (typeof element === "object") {
    return nodeToRenderableNodes((_a = element.props) === null || _a === void 0 ? void 0 : _a.children);
  }
  return [element];
}

// node_modules/@antv/infographic/esm/jsx/utils/clone.js
var __rest6 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var cloneElement = (element, props) => {
  const { type: type2, props: originalProps } = element, rest = __rest6(element, ["type", "props"]);
  return Object.assign({ type: type2, props: Object.assign(Object.assign({}, originalProps), props) }, rest);
};

// node_modules/@antv/infographic/esm/jsx/utils/context.js
var createDefaultContext = () => ({
  defs: /* @__PURE__ */ new Map()
});

// node_modules/@antv/infographic/esm/jsx/utils/escape.js
function escapeHtml(str) {
  const htmlEscapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  return String(str).replace(/[&<>"']/g, (s3) => htmlEscapes[s3]);
}

// node_modules/@antv/infographic/esm/jsx/utils/svg.js
var SPECIFIC_ATTRS_MAP = {
  className: "class",
  // svg
  viewBox: "viewBox",
  preserveAspectRatio: "preserveAspectRatio",
  // Gradient
  gradientUnits: "gradientUnits",
  gradientTransform: "gradientTransform",
  // Pattern
  patternUnits: "patternUnits",
  patternContentUnits: "patternContentUnits",
  patternTransform: "patternTransform",
  // Mask / Clip
  maskUnits: "maskUnits",
  maskContentUnits: "maskContentUnits",
  clipPathUnits: "clipPathUnits",
  // Filter
  primitiveUnits: "primitiveUnits",
  filterUnits: "filterUnits",
  // Marker
  markerUnits: "markerUnits",
  markerWidth: "markerWidth",
  markerHeight: "markerHeight",
  refX: "refX",
  refY: "refY",
  // XML
  xmlLang: "xml:lang",
  xmlSpace: "xml:space",
  xmlnsXlink: "xmlns:xlink",
  // XLink
  xlinkHref: "href",
  xlinkTitle: "xlink:title",
  xlinkShow: "xlink:show",
  xlinkActuate: "xlink:actuate",
  // Text
  textLength: "textLength",
  lengthAdjust: "lengthAdjust",
  // Animation
  attributeName: "attributeName",
  attributeType: "attributeType",
  repeatCount: "repeatCount",
  repeatDur: "repeatDur",
  calcMode: "calcMode",
  keyTimes: "keyTimes",
  keySplines: "keySplines",
  keyPoints: "keyPoints",
  // filter
  stdDeviation: "stdDeviation",
  baseFrequency: "baseFrequency",
  numOctaves: "numOctaves",
  // path
  pathLength: "pathLength",
  // others
  systemLanguage: "systemLanguage",
  requiredFeatures: "requiredFeatures",
  requiredExtensions: "requiredExtensions"
};
function toSVGAttr(name) {
  if (SPECIFIC_ATTRS_MAP[name]) {
    return SPECIFIC_ATTRS_MAP[name];
  }
  return name.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}

// node_modules/@antv/infographic/esm/jsx/layout.js
var LAYOUT_FN_MAP = /* @__PURE__ */ new Map();
function createLayout(fn5) {
  const type2 = Symbol("layout");
  LAYOUT_FN_MAP.set(type2, fn5);
  const LayoutComponent = (props) => ({ type: type2, props });
  return LayoutComponent;
}
function isLayoutComponent(element) {
  return element != null && typeof element === "object" && !Array.isArray(element) && typeof element.type === "symbol" && LAYOUT_FN_MAP.has(element.type);
}
function performLayout(element, context = createDefaultContext()) {
  const layoutFn = LAYOUT_FN_MAP.get(element.type);
  if (!layoutFn) {
    console.warn("Layout function not found for symbol:", element.type);
    return element;
  }
  const children2 = getRenderableChildrenOf(element).filter((child) => {
    return typeof child === "object";
  });
  return layoutFn(children2, element.props, context);
}

// node_modules/@antv/infographic/esm/jsx/renderer.js
var __rest7 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
function processElement(element, context) {
  if (element == null || typeof element === "boolean")
    return null;
  if (typeof element === "string" || typeof element === "number") {
    return element;
  }
  if (Array.isArray(element)) {
    return element.map((child) => processElement(child, context)).filter(Boolean);
  }
  if (isLayoutComponent(element)) {
    const layoutResult = performLayout(element, context);
    return processElement(layoutResult, context);
  }
  if (typeof element.type === "function") {
    const rendered = element.type(element.props);
    return processElement(rendered, context);
  }
  const children2 = getRenderableChildrenOf(element).map((child) => processElement(child, context)).filter(Boolean);
  if (element.type === Fragment) {
    return children2;
  }
  if (element.type === DefsSymbol) {
    children2.forEach((child) => {
      if (typeof child === "object" && child.props.id) {
        context.defs.set(child.props.id, child);
      }
    });
    return null;
  }
  if (children2.length) {
    return cloneElement(element, { children: children2 });
  }
  return element;
}
function render(element, context) {
  if (element == null)
    return "";
  if (typeof element === "string")
    return escapeHtml(element);
  if (typeof element === "number")
    return String(element);
  const { type: type2, props } = element;
  if (!type2)
    return "";
  const children2 = getRenderableChildrenOf(element);
  if (type2 === Fragment) {
    return children2.map((child) => render(child, context)).filter(Boolean).join("");
  }
  if (type2 === DefsSymbol) {
    return "";
  }
  if (typeof type2 === "function" || isLayoutComponent(element)) {
    console.warn("Unexpected unprocessed component in render:", element);
    return "";
  }
  const attrs = renderAttrs(props);
  const childrenContent = children2.map((child) => render(child, context)).filter(Boolean).join("");
  const tagName = String(type2);
  if (!childrenContent)
    return `<${tagName}${attrs} />`;
  return `<${tagName}${attrs}>${childrenContent}</${tagName}>`;
}
function renderSVG2(element, props = {}) {
  const context = createDefaultContext();
  const processed = processElement(element, context);
  if (!processed)
    return "";
  const content = Array.isArray(processed) ? processed.map((el) => render(el, context)).join("") : render(processed, context);
  const { x: x6, y: y6, width, height, style } = props, rest = __rest7(props, ["x", "y", "width", "height", "style"]);
  const finalProps = Object.assign(Object.assign({}, rest), { xmlns: "http://www.w3.org/2000/svg" });
  if (!finalProps.viewBox) {
    if (width && height) {
      finalProps.viewBox = `${x6 !== null && x6 !== void 0 ? x6 : 0} ${y6 !== null && y6 !== void 0 ? y6 : 0} ${width !== null && width !== void 0 ? width : 0} ${height !== null && height !== void 0 ? height : 0}`;
    } else {
      const bounds = getElementBounds(processed);
      if (bounds) {
        const { x: x7, y: y7, width: width2, height: height2 } = bounds;
        finalProps.viewBox = `${x7} ${y7} ${width2} ${height2}`;
      }
    }
  }
  const attrs = renderAttrs(finalProps);
  const styleStr = renderStyle(style);
  const defsContent = context.defs.size ? `<defs>${Array.from(context.defs.values()).map((def) => render(def, context)).join("")}</defs>` : "";
  return `<svg${attrs}${styleStr}>${defsContent}${content}</svg>`;
}
function renderAttrs(props) {
  if (!props)
    return "";
  const { children: children2 } = props, attributes = __rest7(props, ["children"]);
  return Object.entries(attributes).filter(([, value]) => value !== void 0 && value !== null).map(([key, value]) => {
    const attrName = toSVGAttr(key);
    const attrValue = typeof value === "string" ? escapeHtml(String(value)) : String(value);
    return ` ${attrName}="${attrValue}"`;
  }).join("");
}
function renderStyle(style) {
  if (!style || Object.keys(style).length === 0)
    return "";
  const styleString = Object.entries(style).map(([key, value]) => {
    const cssKey = key.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);
    return `${cssKey}: ${value};`;
  }).join("");
  return ` style="${escapeHtml(styleString)}"`;
}

// node_modules/@antv/infographic/esm/designs/components/Btn.js
var __rest8 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var BtnAdd = (props) => {
  const { indexes } = props, restProps = __rest8(props, ["indexes"]);
  const defaultProps = {
    fill: "#B9EBCA",
    fillOpacity: 0.3,
    width: 20,
    height: 20,
    "data-indexes": indexes,
    "data-element-type": "btn-add"
  };
  return jsx(Rect, Object.assign({}, defaultProps, restProps));
};
var BtnRemove = (props) => {
  const { indexes } = props, restProps = __rest8(props, ["indexes"]);
  const defaultProps = {
    fill: "#F9C0C0",
    fillOpacity: 0.3,
    width: 20,
    height: 20,
    "data-indexes": indexes,
    "data-element-type": "btn-remove"
  };
  return jsx(Rect, Object.assign({}, defaultProps, restProps));
};

// node_modules/@antv/infographic/esm/designs/components/BtnsGroup.js
var BtnsGroup = (props) => {
  return jsx(Group, Object.assign({ "data-element-type": "btns-group", width: 0, height: 0 }, props, { display: "none" }));
};

// node_modules/@antv/infographic/esm/designs/components/Gap.js
var Gap = () => {
  return jsx(Fragment, {});
};

// node_modules/@antv/infographic/esm/designs/components/Illus.js
var __rest9 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var Illus = (_a) => {
  var { indexes } = _a, props = __rest9(_a, ["indexes"]);
  const defaultProps = {
    fill: "lightgray"
  };
  const finalProps = Object.assign(Object.assign({}, defaultProps), props);
  if (indexes) {
    finalProps["data-indexes"] = indexes;
    finalProps["data-element-type"] = "item-illus";
  } else {
    finalProps["data-element-type"] = "illus";
  }
  return jsx(Rect, Object.assign({}, finalProps));
};

// node_modules/@antv/infographic/esm/designs/components/ItemDesc.js
var __rest10 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var ItemDesc = (_a) => {
  var _b;
  var { indexes, lineNumber = 2, children: children2 } = _a, props = __rest10(_a, ["indexes", "lineNumber", "children"]);
  if (!children2)
    return null;
  const finalProps = Object.assign({ fontSize: 14, fill: "#666", wordWrap: true, lineHeight: 1.4, children: children2 }, props);
  (_b = finalProps.height) !== null && _b !== void 0 ? _b : finalProps.height = Math.ceil(lineNumber * +finalProps.lineHeight * +finalProps.fontSize);
  return jsx(Text, Object.assign({}, finalProps, {
    "data-indexes": indexes,
    "data-element-type": "item-desc"
    /* ElementTypeEnum.ItemDesc */
  }));
};

// node_modules/@antv/infographic/esm/designs/components/ItemIcon.js
var __rest11 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var ItemIcon = (props) => {
  const { indexes, size = 32 } = props, restProps = __rest11(props, ["indexes", "size"]);
  const finalProps = Object.assign({ fill: "lightgray", width: size, height: size }, restProps);
  return jsx(Rect, Object.assign({}, finalProps, { "data-indexes": indexes, "data-element-type": "item-icon" }));
};
var ItemIconCircle = (props) => {
  const { indexes, size = 50, fill: fill2, colorBg = "white" } = props, restProps = __rest11(props, ["indexes", "size", "fill", "colorBg"]);
  const innerSize = size / Math.SQRT2 * 0.9;
  const offset = (size - innerSize) / 2;
  const iconProps = Object.assign(Object.assign({ fill: colorBg }, restProps), { x: offset, y: offset, width: innerSize, height: innerSize });
  return jsxs(Group, Object.assign({}, restProps, { width: size, height: size, "data-element-type": "item-icon-group", children: [jsx(Ellipse, { width: size, height: size, fill: fill2, "data-element-type": "shape" }), jsx(Rect, Object.assign({}, iconProps, {
    "data-indexes": indexes,
    "data-element-type": "item-icon"
    /* ElementTypeEnum.ItemIcon */
  }))] }));
};

// node_modules/@antv/infographic/esm/designs/components/ItemLabel.js
var __rest12 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var ItemLabel = (_a) => {
  var _b;
  var { indexes, children: children2 } = _a, props = __rest12(_a, ["indexes", "children"]);
  const finalProps = Object.assign({ fontSize: 18, fontWeight: "bold", fill: "#252525", lineHeight: 1.4, children: children2 }, props);
  (_b = finalProps.height) !== null && _b !== void 0 ? _b : finalProps.height = Math.ceil(+finalProps.lineHeight * +finalProps.fontSize);
  return jsx(Text, Object.assign({}, finalProps, {
    "data-indexes": indexes,
    "data-element-type": "item-label"
    /* ElementTypeEnum.ItemLabel */
  }));
};

// node_modules/@antv/infographic/esm/designs/components/ItemsGroup.js
var ItemsGroup = (props) => {
  return jsx(Group, Object.assign({
    "data-element-type": "items-group"
    /* ElementTypeEnum.ItemsGroup */
  }, props));
};

// node_modules/@antv/infographic/esm/designs/components/ItemValue.js
var __rest13 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var ItemValue = (_a) => {
  var _b;
  var { indexes, value, formatter = (v2) => String(v2) } = _a, props = __rest13(_a, ["indexes", "value", "formatter"]);
  const finalProps = Object.assign({ fontSize: 14, fill: "#666", wordWrap: true, lineHeight: 1.4, children: formatter(value), "data-value": value }, props);
  (_b = finalProps.height) !== null && _b !== void 0 ? _b : finalProps.height = Math.ceil(+finalProps.lineHeight * +finalProps.fontSize);
  return jsx(Text, Object.assign({}, finalProps, {
    "data-indexes": indexes,
    "data-element-type": "item-value"
    /* ElementTypeEnum.ItemValue */
  }));
};

// node_modules/@antv/infographic/esm/designs/components/ShapesGroup.js
var ShapesGroup = (props) => {
  return jsx(Group, Object.assign({ "data-element-type": "shapes-group" }, props));
};

// node_modules/@antv/infographic/esm/designs/layouts/Align.js
var __rest14 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var AlignLayout = createLayout((children2, _a) => {
  var _b, _c, _d, _e;
  var { horizontal, vertical } = _a, props = __rest14(_a, ["horizontal", "vertical"]);
  if (!children2 || children2.length === 0) {
    return jsx(Group, Object.assign({}, props));
  }
  const childBounds = children2.map((child) => getElementBounds(child));
  const childrenBounds = getElementsBounds(children2);
  const containerX = (_b = props.x) !== null && _b !== void 0 ? _b : childrenBounds.x;
  const containerY = (_c = props.y) !== null && _c !== void 0 ? _c : childrenBounds.y;
  const containerWidth = (_d = props.width) !== null && _d !== void 0 ? _d : childrenBounds.width;
  const containerHeight = (_e = props.height) !== null && _e !== void 0 ? _e : childrenBounds.height;
  const positionedChildren = children2.map((child, index2) => {
    const bounds = childBounds[index2];
    const childProps = Object.assign({}, child.props);
    if (horizontal !== void 0) {
      switch (horizontal) {
        case "left":
          childProps.x = -bounds.x;
          break;
        case "center":
          childProps.x = (containerWidth - bounds.width) / 2 - bounds.x;
          break;
        case "right":
          childProps.x = containerWidth - bounds.width - bounds.x;
          break;
      }
    } else if (childProps.x === void 0) {
      childProps.x = bounds.x - containerX;
    }
    if (vertical !== void 0) {
      switch (vertical) {
        case "top":
          childProps.y = -bounds.y;
          break;
        case "middle":
          childProps.y = (containerHeight - bounds.height) / 2 - bounds.y;
          break;
        case "bottom":
          childProps.y = containerHeight - bounds.height - bounds.y;
          break;
      }
    } else if (childProps.y === void 0) {
      childProps.y = bounds.y - containerY;
    }
    return cloneElement(child, childProps);
  });
  const containerProps = Object.assign(Object.assign({}, props), { x: containerX, y: containerY, width: containerWidth, height: containerHeight });
  return jsx(Group, Object.assign({}, containerProps, { children: positionedChildren }));
});

// node_modules/@antv/infographic/esm/designs/layouts/Flex.js
var __rest15 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var FlexLayout = createLayout((children2, _a) => {
  var _b, _c, _d, _e, _f, _g;
  var { flexDirection = "row", justifyContent = "flex-start", alignItems = "flex-start", alignContent = "flex-start", flexWrap = "nowrap", gap = 0 } = _a, props = __rest15(_a, ["flexDirection", "justifyContent", "alignItems", "alignContent", "flexWrap", "gap"]);
  if (!children2 || children2.length === 0) {
    return jsx(Group, Object.assign({}, props));
  }
  const isRow = flexDirection === "row" || flexDirection === "row-reverse";
  const isReverse = flexDirection === "row-reverse" || flexDirection === "column-reverse";
  const childBounds = children2.map((child) => getElementBounds(child));
  const childrenBounds = getElementsBounds(children2);
  const containerWidth = (_b = props.width) !== null && _b !== void 0 ? _b : childrenBounds.width;
  const containerHeight = (_c = props.height) !== null && _c !== void 0 ? _c : childrenBounds.height;
  const hasContainerSize = props.width !== void 0 && props.height !== void 0;
  const lines = [];
  if (flexWrap === "wrap" && hasContainerSize) {
    let currentLine = [];
    let currentLineBounds = [];
    let currentLineSize = 0;
    for (let i4 = 0; i4 < children2.length; i4++) {
      const child = children2[i4];
      const bounds = childBounds[i4];
      const childSize = isRow ? bounds.width : bounds.height;
      const maxSize = isRow ? containerWidth : containerHeight;
      if (currentLine.length === 0 || currentLineSize + gap + childSize <= maxSize) {
        currentLine.push(child);
        currentLineBounds.push(bounds);
        currentLineSize += (currentLine.length > 1 ? gap : 0) + childSize;
      } else {
        lines.push({ children: currentLine, bounds: currentLineBounds });
        currentLine = [child];
        currentLineBounds = [bounds];
        currentLineSize = childSize;
      }
    }
    if (currentLine.length > 0) {
      lines.push({ children: currentLine, bounds: currentLineBounds });
    }
  } else {
    lines.push({ children: children2, bounds: childBounds });
  }
  const layoutChildren = [];
  let currentCrossPos = 0;
  const crossSizes = [];
  lines.forEach((line2) => {
    const { children: lineChildren, bounds: lineBounds } = line2;
    const totalMainSize = lineBounds.reduce((sum, bounds, index2) => {
      const childMainSize = isRow ? bounds.width : bounds.height;
      return sum + childMainSize + (index2 > 0 ? gap : 0);
    }, 0);
    const maxCrossSize = Math.max(...lineBounds.map((bounds) => isRow ? bounds.height : bounds.width));
    crossSizes.push(maxCrossSize);
    let mainStart = 0;
    const availableMainSpace = (isRow ? containerWidth : containerHeight) - totalMainSize;
    if (hasContainerSize) {
      switch (justifyContent) {
        case "flex-end":
          mainStart = availableMainSpace;
          break;
        case "center":
          mainStart = availableMainSpace / 2;
          break;
        case "space-between":
          mainStart = 0;
          break;
        default:
          mainStart = 0;
          break;
      }
    }
    let itemSpacing = gap;
    if (hasContainerSize && justifyContent === "space-between" && lineChildren.length > 1) {
      itemSpacing = availableMainSpace / (lineChildren.length - 1) + gap;
    }
    let currentMainPos = mainStart;
    lineChildren.forEach((child, childIndex) => {
      const bounds = lineBounds[childIndex];
      const childMainSize = isRow ? bounds.width : bounds.height;
      const childCrossSize = isRow ? bounds.height : bounds.width;
      const mainOffset = isRow ? bounds.x : bounds.y;
      const crossOffset = isRow ? bounds.y : bounds.x;
      let crossPos = currentCrossPos;
      if (hasContainerSize) {
        switch (alignItems) {
          case "flex-end":
            crossPos = currentCrossPos + maxCrossSize - childCrossSize;
            break;
          case "center":
            crossPos = currentCrossPos + (maxCrossSize - childCrossSize) / 2;
            break;
          default:
            crossPos = currentCrossPos;
            break;
        }
      }
      let x6, y6;
      if (isRow) {
        x6 = isReverse ? containerWidth - currentMainPos - childMainSize - mainOffset : currentMainPos - mainOffset;
        y6 = crossPos - crossOffset;
      } else {
        x6 = crossPos - crossOffset;
        y6 = isReverse ? containerHeight - currentMainPos - childMainSize - mainOffset : currentMainPos - mainOffset;
      }
      const clonedChild = cloneElement(child, { x: x6, y: y6 });
      layoutChildren.push(clonedChild);
      currentMainPos += childMainSize + itemSpacing;
    });
    currentCrossPos += maxCrossSize + gap;
  });
  if (lines.length > 1 && hasContainerSize) {
    const totalCrossSize = crossSizes.reduce((sum, size) => sum + size, 0) + (lines.length - 1) * gap;
    const availableCrossSpace = (isRow ? containerHeight : containerWidth) - totalCrossSize;
    let crossOffset = 0;
    switch (alignContent) {
      case "flex-end":
        crossOffset = availableCrossSpace;
        break;
      case "center":
        crossOffset = availableCrossSpace / 2;
        break;
      case "space-between":
        if (lines.length > 1) {
          const lineSpacing = availableCrossSpace / (lines.length - 1);
          let currentOffset = 0;
          lines.forEach((line2, lineIndex) => {
            const lineStartIndex = lines.slice(0, lineIndex).reduce((sum, l3) => sum + l3.children.length, 0);
            const lineEndIndex = lineStartIndex + line2.children.length;
            for (let i4 = lineStartIndex; i4 < lineEndIndex; i4++) {
              const child = layoutChildren[i4];
              const newProps = Object.assign({}, child.props);
              if (isRow) {
                newProps.y = (newProps.y || 0) + currentOffset;
              } else {
                newProps.x = (newProps.x || 0) + currentOffset;
              }
              layoutChildren[i4] = cloneElement(child, newProps);
            }
            currentOffset += crossSizes[lineIndex] + gap + (lineIndex < lines.length - 1 ? lineSpacing : 0);
          });
          break;
        }
        break;
      default:
        crossOffset = 0;
        break;
    }
    if (crossOffset !== 0 && alignContent !== "space-between") {
      layoutChildren.forEach((child, index2) => {
        const newProps = Object.assign({}, child.props);
        if (isRow) {
          newProps.y = (newProps.y || 0) + crossOffset;
        } else {
          newProps.x = (newProps.x || 0) + crossOffset;
        }
        layoutChildren[index2] = cloneElement(child, newProps);
      });
    }
  }
  if (!hasContainerSize) {
    if (alignItems === "center") {
      if (isRow) {
        const maxHeight = Math.max(...childBounds.map((b2) => b2.height));
        layoutChildren.forEach((child, index2) => {
          const bounds = childBounds[index2];
          const centerOffset = (maxHeight - bounds.height) / 2;
          const newProps = Object.assign({}, child.props);
          newProps.y = (newProps.y || 0) + centerOffset;
          layoutChildren[index2] = cloneElement(child, newProps);
        });
      } else {
        const maxWidth = Math.max(...childBounds.map((b2) => b2.width));
        layoutChildren.forEach((child, index2) => {
          const bounds = childBounds[index2];
          const centerOffset = (maxWidth - bounds.width) / 2;
          const newProps = Object.assign({}, child.props);
          newProps.x = (newProps.x || 0) + centerOffset;
          layoutChildren[index2] = cloneElement(child, newProps);
        });
      }
    }
  }
  const finalBounds = getElementsBounds(layoutChildren);
  const containerProps = Object.assign(Object.assign({}, props), { x: (_d = props.x) !== null && _d !== void 0 ? _d : childrenBounds.x, y: (_e = props.y) !== null && _e !== void 0 ? _e : childrenBounds.y, width: (_f = props.width) !== null && _f !== void 0 ? _f : finalBounds.width, height: (_g = props.height) !== null && _g !== void 0 ? _g : finalBounds.height });
  return jsx(Group, Object.assign({}, containerProps, { children: layoutChildren }));
});

// node_modules/@antv/infographic/esm/designs/components/Title.js
var Title = (props) => {
  const { x: x6 = 0, y: y6 = 0, alignHorizontal = "center", title, desc, descLineNumber: subTitleLineNumber = 2, themeColors } = props;
  const MainTitle = (props2) => {
    const defaultProps = {
      fontSize: 24,
      fill: themeColors.colorPrimaryText,
      lineHeight: 1.4,
      alignHorizontal
    };
    return jsx(Text, Object.assign({}, defaultProps, props2, { "data-element-type": "title", children: title }));
  };
  const Desc = (props2) => {
    const defaultProps = {
      fontSize: 16,
      fill: themeColors.colorTextSecondary,
      alignHorizontal,
      lineHeight: 1.4,
      height: subTitleLineNumber * 24
    };
    return jsx(Text, Object.assign({}, defaultProps, props2, { "data-element-type": "desc", children: desc }));
  };
  if (!title && !desc)
    return null;
  return jsxs(FlexLayout, { flexDirection: "column", justifyContent: "center", alignItems: "center", x: x6, y: y6, gap: 8, children: [title && jsx(MainTitle, {}), desc && jsx(Desc, {})] });
};

// node_modules/@antv/infographic/esm/themes/registry.js
var THEME_REGISTRY = /* @__PURE__ */ new Map();
function registerTheme(name, theme) {
  THEME_REGISTRY.set(name, theme);
}
function getTheme(name) {
  return THEME_REGISTRY.get(name);
}
function getThemes() {
  return Array.from(THEME_REGISTRY.keys());
}

// node_modules/@antv/infographic/esm/themes/built-in.js
registerTheme("dark", {
  colorBg: "#1F1F1F",
  base: {
    text: {
      fill: "#fff"
    }
  }
});
registerTheme("hand-drawn", {
  base: {
    text: {
      "font-family": "851tegakizatsu"
    }
  },
  stylize: {
    type: "rough"
  }
});

// node_modules/@antv/infographic/esm/themes/generator.js
useMode(definition_default21);
var generateThemeColors = ({ colorPrimary, colorBg = "#ffffff", isDarkMode = false }) => {
  const pc = parse_default(colorPrimary);
  const bg = parse_default(colorBg);
  const baseTheme = createBaseTheme({ primaryColor: pc, bgColor: bg });
  return addDerivedColors(baseTheme, {
    primaryColor: pc,
    bgColor: bg,
    isDarkMode
  });
};
var generatePrimaryBg = (primaryColor, isDarkMode) => {
  return formatHex8(Object.assign(Object.assign({}, primaryColor), { alpha: isDarkMode ? 0.2 : 0.1 })) || "#ffffff";
};
var generateTextColor = (bgColor, isDarkMode) => {
  if (isDarkMode) {
    return "#ffffff";
  }
  const darkText = parse_default("#262626");
  const contrast2 = contrast(darkText, bgColor);
  return contrast2 >= 7 ? formatHex(darkText) : "#000000";
};
var generateSecondaryTextColor = (colorText) => {
  const parsed = oklch(parse_default(colorText));
  const lighter = Object.assign(Object.assign({}, parsed), { l: Math.min(1, parsed.l + 0.2) });
  return formatHex(lighter);
};
var generatePrimaryTextColor = (colorPrimaryBg, isDarkMode) => {
  const bg = parse_default(colorPrimaryBg);
  const darkText = parse_default("#262626");
  const lightText = parse_default("#ffffff");
  const darkContrast = contrast(darkText, bg);
  const lightContrast = contrast(lightText, bg);
  if (lightContrast >= 3) {
    return formatHex(lightText);
  }
  if (darkContrast >= 4.5) {
    return formatHex(darkText);
  }
  return isDarkMode ? "#ffffff" : "#ffffff";
};
var generateElevatedBg = (bgColor, isDarkMode) => {
  const parsed = oklch(bgColor);
  if (isDarkMode) {
    const lightened = Object.assign(Object.assign({}, parsed), { l: Math.min(1, parsed.l + 0.1) });
    return safeFormatHex(lightened, "#1f1f1f");
  } else {
    if (parsed.l > 0.95) {
      return "#ffffff";
    } else {
      const lightened = Object.assign(Object.assign({}, parsed), { l: Math.min(1, parsed.l + 0.05) });
      return safeFormatHex(lightened, "#ffffff");
    }
  }
};
var createBaseTheme = ({ primaryColor, bgColor }) => ({
  colorPrimary: safeFormatHex(primaryColor, "#FF356A"),
  colorBg: safeFormatHex(bgColor, "#ffffff"),
  colorWhite: "#ffffff"
});
var addDerivedColors = (baseTheme, { primaryColor, bgColor, isDarkMode }) => {
  const textColor = generateTextColor(bgColor, isDarkMode);
  const colorPrimaryBg = generatePrimaryBg(primaryColor, isDarkMode);
  return Object.assign(Object.assign({}, baseTheme), {
    isDarkMode,
    colorPrimaryBg,
    colorText: textColor,
    colorTextSecondary: generateSecondaryTextColor(textColor),
    colorPrimaryText: generatePrimaryTextColor(colorPrimaryBg, isDarkMode),
    colorBgElevated: generateElevatedBg(bgColor, isDarkMode)
  });
};
function safeFormatHex(color3, fallback = "#000000") {
  var _a;
  return (_a = formatHex(color3)) !== null && _a !== void 0 ? _a : fallback;
}

// node_modules/@antv/infographic/esm/designs/utils/color.js
var DEFAULT_COLOR = "#FF356A";
function getColorPrimary(options) {
  var _a;
  return ((_a = options === null || options === void 0 ? void 0 : options.themeConfig) === null || _a === void 0 ? void 0 : _a.colorPrimary) || DEFAULT_COLOR;
}
function getPaletteColors(options) {
  var _a;
  const { themeConfig = {}, data } = options;
  const { colorPrimary, palette: palette2 } = themeConfig;
  if (!palette2 || palette2.length === 0) {
    return Array(((_a = data === null || data === void 0 ? void 0 : data.items) === null || _a === void 0 ? void 0 : _a.length) || 1).fill(colorPrimary || DEFAULT_COLOR);
  }
  return data.items.map((_2, i4) => getPaletteColor(palette2, [i4], data.items.length) || DEFAULT_COLOR);
}
function getPaletteColor2(options, indexes) {
  var _a, _b, _c;
  return getPaletteColor((_a = options === null || options === void 0 ? void 0 : options.themeConfig) === null || _a === void 0 ? void 0 : _a.palette, indexes, (_c = (_b = options.data) === null || _b === void 0 ? void 0 : _b.items) === null || _c === void 0 ? void 0 : _c.length);
}
function getThemeColors(colors, options) {
  var _a;
  const { colorBg = ((_a = options === null || options === void 0 ? void 0 : options.themeConfig) === null || _a === void 0 ? void 0 : _a.colorBg) || "white", colorPrimary = options ? getColorPrimary(options) : "black" } = colors;
  return generateThemeColors({
    colorPrimary,
    isDarkMode: isDarkColor(colorBg),
    colorBg
  });
}

// node_modules/@antv/infographic/esm/designs/utils/hierarchy-color.js
function getHierarchyColorIndexes(node, mode) {
  const { depth, originalIndexes, flatIndex } = node;
  switch (mode) {
    case "level":
      return [depth];
    case "branch":
      if (depth === 0) {
        return [0];
      } else if (depth === 1) {
        return [originalIndexes[1] + 1];
      } else {
        return [originalIndexes[1] + 1];
      }
    case "node":
      return originalIndexes;
    case "node-flat":
      if (flatIndex !== void 0) {
        return [flatIndex];
      }
      console.warn("node-flat mode requires flatIndex in HierarchyNode, falling back to originalIndexes");
      return originalIndexes;
    default:
      return [0];
  }
}

// node_modules/@antv/infographic/esm/designs/utils/item.js
function getItemProps(props, extKeys = []) {
  const restProps = Object.assign({}, props);
  const extProps = {};
  const keys2 = [
    "indexes",
    "data",
    "datum",
    "positionH",
    "positionV",
    "themeColors",
    "valueFormatter",
    ...extKeys
  ];
  keys2.forEach((key) => {
    if (key in restProps) {
      extProps[key] = restProps[key];
      delete restProps[key];
    }
  });
  ["x", "y", "width", "height"].forEach((key) => {
    if (key in props) {
      restProps[key] = props[key];
    }
  });
  return [extProps, restProps];
}
function getItemComponent(Items, level) {
  var _a;
  if (Items.length === 0)
    return () => null;
  if (level === void 0)
    return Items[0];
  return (_a = Items[level]) !== null && _a !== void 0 ? _a : Items[0];
}

// node_modules/@antv/infographic/esm/designs/utils/normalize-percent.js
function normalizePercent(value) {
  if (value === void 0 || value === null)
    return 0;
  if (typeof value === "string") {
    const trimmed = value.trim();
    const numStr = trimmed.endsWith("%") ? trimmed.slice(0, -1) : trimmed;
    const num3 = parseFloat(numStr);
    return isNaN(num3) ? 0 : num3;
  }
  return value;
}

// node_modules/@antv/infographic/esm/designs/items/registry.js
var ITEM_REGISTRY = /* @__PURE__ */ new Map();
function registerItem(type2, item) {
  ITEM_REGISTRY.set(type2, item);
}
function getItem(type2) {
  return ITEM_REGISTRY.get(type2);
}

// node_modules/@antv/infographic/esm/designs/items/BadgeCard.js
var BadgeCard = (props) => {
  const [{ datum: datum2, indexes, width = 200, height = 80, iconSize = 24, badgeSize = 32, gap = 8, positionH = "normal", themeColors, valueFormatter }, restProps] = getItemProps(props, ["width", "height", "iconSize", "badgeSize", "gap"]);
  const value = datum2.value;
  const hasValue = value !== void 0;
  const hasDesc = !!datum2.desc;
  const hasIcon = !!datum2.icon;
  const gradientId = `${themeColors.colorPrimary}-badge`;
  const badgeX = positionH === "flipped" ? width - gap - badgeSize : gap;
  const contentStartX = hasIcon ? positionH === "flipped" ? gap : badgeSize + 2 * gap : gap;
  const fullWidth = width - gap * 2;
  const contentWidth = hasIcon ? width - badgeSize - 3 * gap : fullWidth;
  const descY = gap + 14 + 18 + 8;
  const contentAreaHeight = descY - gap;
  const badgeY = !hasDesc ? (height - badgeSize) / 2 : gap;
  const contentY = !hasValue && !hasDesc ? (height - 14) / 2 : gap;
  const textAlign = !hasIcon && positionH === "center" ? "center" : positionH === "flipped" ? "right" : "left";
  return jsxs(Group, Object.assign({}, restProps, { width, height, children: [jsx(Defs, { children: jsxs("radialGradient", { id: gradientId, cx: "50%", cy: "50%", r: "50%", children: [jsx("stop", { offset: "0%", stopColor: themeColors.colorPrimary }), jsx("stop", { offset: "100%", stopColor: tinycolor(themeColors.colorPrimary).darken(20).toHexString() })] }) }), jsx(Rect, { "data-element-type": "shape", x: 0, y: 0, width, height, fill: themeColors.colorPrimaryBg, rx: 8, ry: 8 }), hasIcon && jsxs(Fragment, { children: [jsx(Ellipse, { x: badgeX, y: badgeY, width: badgeSize, height: badgeSize, fill: `url(#${gradientId})` }), jsx(ItemIcon, { indexes, x: badgeX + (badgeSize - iconSize) / 2, y: badgeY + (badgeSize - iconSize) / 2, size: iconSize, fill: themeColors.colorWhite })] }), jsxs(FlexLayout, { flexDirection: "column", x: contentStartX, y: contentY, width: contentWidth, height: !hasValue && !hasDesc ? void 0 : contentAreaHeight, alignItems: "center", justifyContent: "center", children: [jsx(ItemLabel, { indexes, width: contentWidth, alignHorizontal: textAlign, alignVertical: "middle", fontSize: 14, fill: themeColors.colorText, children: datum2.label }), hasValue && jsx(ItemValue, { indexes, width: contentWidth, alignHorizontal: positionH === "flipped" ? "right" : "left", alignVertical: "middle", fontSize: 18, lineHeight: 1, fontWeight: "bold", fill: themeColors.colorPrimary, value, formatter: valueFormatter })] }), hasDesc && jsx(ItemDesc, { indexes, x: gap, y: descY, width: fullWidth, alignHorizontal: textAlign, fontSize: 11, fill: themeColors.colorTextSecondary, lineNumber: 2, lineHeight: 1.2, wordWrap: true, children: datum2.desc })] }));
};
registerItem("badge-card", {
  component: BadgeCard,
  composites: ["icon", "label", "value", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/CandyCardLite.js
var CandyCardLite = (props) => {
  const [{ indexes, datum: datum2, width = 280, height = 140, themeColors }, restProps] = getItemProps(props, ["width", "height"]);
  return jsxs(Group, Object.assign({}, restProps, { children: [jsx("rect", { x: 0, y: 0, width, height, rx: 22, ry: 22, fill: themeColors.colorPrimaryBg, stroke: themeColors.colorPrimary, "data-element-type": "shape" }), jsx(Path, { x: width - 85, y: 0.5, width: 85, height: 65, d: "M0 0H62.4495C74.9557 0 85.4549 10.8574 84.4557 23.1875V60.1875L77.8772 62.5839C64.3776 67.6876 48.51 64.6893 37.8662 53.7441L10.2361 25.3312C4.91402 19.8571 1.65356 13.1736 0.435652 6.21819L0 0Z", fill: themeColors.colorBg, "data-element-type": "shape" }), jsx(ItemLabel, { indexes, x: 20, y: 24, width: 200, alignHorizontal: "left", alignVertical: "middle", fill: themeColors.colorText, children: datum2.label }), jsx(ItemDesc, { indexes, x: 20, y: 58, width: 220, height: 70, fill: themeColors.colorTextSecondary, alignHorizontal: "left", alignVertical: "top", children: datum2.desc }), jsx(ItemIcon, { indexes, x: width - 48, y: 12, width: 32, height: 32, fill: themeColors.colorPrimary })] }));
};
registerItem("candy-card-lite", {
  component: CandyCardLite,
  composites: ["icon", "label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/defs/DropShadow.js
var __rest16 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var DropShadow = (props) => {
  const { color: color3 = "black", opacity = 0.8 } = props, restProps = __rest16(props, ["color", "opacity"]);
  return jsx("filter", Object.assign({ id: "drop-shadow", x: "-25%", y: "-25%", width: "200%", height: "200%" }, restProps, { children: jsx("feDropShadow", { dx: "4", dy: "4", stdDeviation: "4", "flood-color": color3, "flood-opacity": opacity }) }));
};

// node_modules/@antv/infographic/esm/designs/defs/LinearGradient.js
var LinearGradient = (props) => {
  const { id: id2 = "linear-gradient", startColor = "black", stopColor = "white", direction = "left-right" } = props;
  const directionMap = {
    "left-right": { x1: "0%", y1: "0%", x2: "100%", y2: "0%" },
    "right-left": { x1: "100%", y1: "0%", x2: "0%", y2: "0%" },
    "top-bottom": { x1: "0%", y1: "0%", x2: "0%", y2: "100%" },
    "bottom-top": { x1: "0%", y1: "100%", x2: "0%", y2: "0%" }
  };
  return jsxs("linearGradient", Object.assign({ id: id2 }, directionMap[direction], { children: [jsx("stop", { offset: "0%", stopColor: startColor }), jsx("stop", { offset: "100%", stopColor })] }));
};

// node_modules/@antv/infographic/esm/designs/items/CapsuleItem.js
var CapsuleItem = (props) => {
  const [{ datum: datum2, indexes, width = 300, height = 80, gap = 12, positionH = "normal", iconPadding = height / 10, themeColors }, restProps] = getItemProps(props, ["width", "height", "gap", "iconPadding"]);
  const borderRadius = height / 2;
  const iconSize = height - iconPadding * 2;
  const isFlipped = positionH === "flipped";
  const hasIcon = !!datum2.icon;
  const textWidth = hasIcon ? width - height - gap : width - gap * 2;
  const textX = hasIcon ? isFlipped ? gap : height : gap;
  const textAlign = hasIcon ? isFlipped ? "right" : "left" : "center";
  const labelProps = {
    indexes,
    width: textWidth,
    alignHorizontal: textAlign,
    alignVertical: "middle",
    fontSize: 16,
    fontWeight: "600",
    fill: themeColors.colorWhite
  };
  const labelBounds = getElementBounds(jsx(ItemLabel, Object.assign({}, labelProps, { children: datum2.label })));
  const descProps = {
    indexes,
    width: textWidth,
    alignHorizontal: textAlign,
    alignVertical: "top",
    fontSize: 12,
    lineNumber: 1,
    fill: themeColors.colorWhite
  };
  const descBounds = getElementBounds(datum2.desc ? jsx(ItemDesc, Object.assign({}, descProps, { children: datum2.desc })) : null);
  const textGap = 4;
  const totalTextHeight = labelBounds.height + textGap + descBounds.height;
  const textStartY = (height - totalTextHeight) / 2;
  const labelY = textStartY;
  const descY = labelY + labelBounds.height + textGap;
  const iconX = isFlipped ? width - height + iconPadding : iconPadding;
  const iconY = iconPadding;
  return jsxs(Group, Object.assign({}, restProps, { children: [jsx(Defs, { children: jsx(DropShadow, {}) }), jsx(Rect, { x: 0, y: 0, width, height, fill: themeColors.colorPrimary, rx: borderRadius, ry: borderRadius, "data-element-type": "shape" }), datum2.icon && jsxs(Fragment, { children: [jsx(Ellipse, { x: iconX, y: iconY, width: iconSize, height: iconSize, fillOpacity: 0.5, fill: themeColors.colorBg, filter: "url(#drop-shadow)" }), jsx(ItemIconCircle, { indexes, x: iconX, y: iconY, size: iconSize, fill: themeColors.colorBg, colorBg: themeColors.colorPrimary })] }), datum2.label && jsx(ItemLabel, Object.assign({ x: textX, y: labelY }, labelProps, { children: datum2.label })), datum2.desc && jsx(ItemDesc, Object.assign({ x: textX, y: descY }, descProps, { children: datum2.desc }))] }));
};
registerItem("capsule-item", {
  component: CapsuleItem,
  composites: ["icon", "label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/CircleNode.js
var CircleNode = (props) => {
  const [{ indexes, datum: datum2, themeColors, positionH = "normal", width = 240, height = width }, restProps] = getItemProps(props, ["width", "height"]);
  const size = Math.min(width, height);
  const innerCircleSize = size * 0.7;
  const innerCircleOffset = (size - innerCircleSize) / 2;
  const labelSize = innerCircleSize * Math.sqrt(2) / 2;
  const labelOffset = (size - labelSize) / 2;
  const base = tinycolor(themeColors.colorPrimary);
  const colorOuterStart = fadeWithWhite(base, 80, 0.2);
  const colorOuterEnd = fadeWithWhite(base, 20, 0.8);
  const colorInnerStart = fadeWithWhite(base, 75, 0.32);
  const colorInnerEnd = fadeWithWhite(base, 45, 0.4);
  const colorText = base.clone().darken(5).toRgbString();
  const outerGradientId = `${themeColors.colorPrimary}-${positionH}-outer`;
  const innerGradientId = `${themeColors.colorPrimary}-${positionH}-inner`;
  const gradientDirection = positionH === "flipped" ? { x1: "0%", y1: "0%", x2: "100%", y2: "0%" } : { x1: "100%", y1: "0%", x2: "0%", y2: "0%" };
  return jsxs(Group, Object.assign({}, restProps, { children: [jsxs(Defs, { children: [jsxs("linearGradient", Object.assign({ id: outerGradientId }, gradientDirection, { children: [jsx("stop", { offset: "0%", stopColor: colorOuterStart }), jsx("stop", { offset: "100%", stopColor: colorOuterEnd })] })), jsxs("linearGradient", Object.assign({ id: innerGradientId }, gradientDirection, { children: [jsx("stop", { offset: "0%", stopColor: colorInnerStart }), jsx("stop", { offset: "100%", stopColor: colorInnerEnd })] }))] }), jsx(Ellipse, { width: size, height: size, fill: `url(#${outerGradientId})`, "data-element-type": "shape" }), jsx(Ellipse, { x: innerCircleOffset, y: innerCircleOffset, width: innerCircleSize, height: innerCircleSize, fill: `url(#${innerGradientId})`, stroke: "#FFFFFF", strokeWidth: 1, "data-element-type": "shape" }), jsx(ItemLabel, { indexes, x: labelOffset, y: labelOffset, width: labelSize, height: labelSize, lineHeight: 1.1, alignHorizontal: "center", alignVertical: "middle", fill: colorText, fontWeight: "500", children: datum2.label })] }));
};
registerItem("circle-node", {
  component: CircleNode,
  composites: ["label"]
});
function fadeWithWhite(color3, mixPct, alpha) {
  return tinycolor.mix(color3, "#ffffff", mixPct).setAlpha(alpha).toRgbString();
}

// node_modules/@antv/infographic/esm/designs/items/CircularProgress.js
var CircularProgress = (props) => {
  var _a;
  const [{ datum: datum2, indexes, size = 120, strokeWidth = 12, gap = 8, themeColors, valueFormatter = (value2) => `${Math.round(value2)}%` }, restProps] = getItemProps(props, ["size", "strokeWidth", "gap"]);
  const value = (_a = datum2.value) !== null && _a !== void 0 ? _a : 0;
  const maxValue = 100;
  const percentage = Math.min(Math.max(value / maxValue, 0), 1);
  const radius = (size - strokeWidth) / 2;
  const center = size / 2;
  const start2 = strokeWidth / 2;
  const d3 = size - strokeWidth;
  const isFullCircle = percentage >= 1;
  const angle = percentage * 360;
  const pathData = describeArc(center, center, radius, 0, angle);
  const bounds = { x: start2, y: start2, width: d3, height: d3 };
  return jsxs(Group, Object.assign({}, restProps, { width: size, height: size + gap + 20, children: [jsx(Rect, { width: size, height: size, fill: "none" }), jsx(Ellipse, Object.assign({}, bounds, { fill: "none", stroke: "#f0f0f0", strokeWidth, "data-element-type": "shape" })), isFullCircle ? jsx(Ellipse, Object.assign({}, bounds, { fill: "none", stroke: themeColors.colorPrimary, strokeWidth, "data-element-type": "shape" })) : jsx(Path, { d: pathData, fill: "none", stroke: themeColors.colorPrimary, strokeWidth, strokeLinecap: "round", "data-element-type": "shape" }), jsx(ItemValue, { indexes, x: strokeWidth, y: strokeWidth, width: d3 - strokeWidth, height: d3 - strokeWidth, fontSize: 24, fontWeight: "bold", fill: themeColors.colorPrimary, alignHorizontal: "center", alignVertical: "middle", value, formatter: valueFormatter }), jsx(ItemLabel, { indexes, x: 0, y: size + gap, width: size, alignHorizontal: "center", fontSize: 12, fill: themeColors.colorTextSecondary, children: datum2.label })] }));
};
function describeArc(x6, y6, radius, startAngle, endAngle) {
  const start2 = polarToCartesian(x6, y6, radius, endAngle);
  const end = polarToCartesian(x6, y6, radius, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
  return `M ${start2.x} ${start2.y} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${end.x} ${end.y}`;
}
function polarToCartesian(cx, cy, radius, angleInDegrees) {
  const rad = (angleInDegrees - 90) * Math.PI / 180;
  return {
    x: cx + radius * Math.cos(rad),
    y: cy + radius * Math.sin(rad)
  };
}
registerItem("circular-progress", {
  component: CircularProgress,
  composites: ["label", "value"]
});

// node_modules/@antv/infographic/esm/designs/items/CompactCard.js
var CompactCard = (props) => {
  const [{ datum: datum2, indexes, width = 200, height = 60, iconSize = 20, gap = 8, positionH = "normal", themeColors, valueFormatter }, restProps] = getItemProps(props, ["width", "height", "iconSize", "gap"]);
  const value = datum2.value;
  const hasValue = value !== void 0 && value !== null;
  const shadowId = "compact-shadow";
  const iconX = positionH === "flipped" ? width - gap - iconSize : gap;
  const textStartX = positionH === "flipped" ? gap : iconSize + 2 * gap;
  const textWidth = width - iconSize - 3 * gap;
  const labelWidth = hasValue ? textWidth * 0.8 : textWidth;
  const valueWidth = hasValue ? textWidth * 0.2 : 0;
  return jsxs(Group, Object.assign({}, restProps, { children: [jsx(Defs, { children: jsx("filter", { id: shadowId, children: jsx("feDropShadow", { dx: "0", dy: "2", stdDeviation: "2", floodOpacity: "0.15" }) }) }), jsx(Rect, { x: 0, y: 0, width, height, fill: themeColors.colorBgElevated, stroke: themeColors.colorBgElevated, strokeWidth: 1, rx: 6, ry: 6, filter: `url(#${shadowId})`, "data-element-type": "shape" }), jsx(Rect, { x: positionH === "flipped" ? width - 3 : 0, y: 0, width: 3, height, fill: themeColors.colorPrimary, rx: 1.5, ry: 1.5, "data-element-type": "shape" }), jsx(ItemIcon, { indexes, x: iconX, y: (height - iconSize) / 2, size: iconSize, fill: themeColors.colorPrimary }), jsxs(FlexLayout, { x: textStartX, y: gap, width: textWidth, height: height - gap * 2, flexDirection: "column", justifyContent: "center", alignItems: "flex-start", children: [jsxs(FlexLayout, { width: textWidth, flexDirection: "row", justifyContent: "space-between", alignItems: "center", children: [jsx(ItemLabel, { indexes, width: labelWidth, alignHorizontal: "left", fontSize: 12, fill: themeColors.colorText, children: datum2.label }), hasValue && jsx(ItemValue, { indexes, width: valueWidth, alignHorizontal: "right", fontSize: 12, fontWeight: "bold", fill: themeColors.colorPrimary, value, formatter: valueFormatter })] }), jsx(ItemDesc, { indexes, width: textWidth, alignHorizontal: "left", alignVertical: "middle", fontSize: 10, fill: themeColors.colorTextSecondary, lineNumber: 2, wordWrap: true, children: datum2.desc })] })] }));
};
registerItem("compact-card", {
  component: CompactCard,
  composites: ["icon", "label", "value", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/DoneList.js
var DoneList = (props) => {
  const [{ datum: datum2, indexes, width = 300, height = 30, iconSize = 30, gap = 5, positionH = "normal", positionV = "middle", themeColors }, restProps] = getItemProps(props, ["width", "height", "iconSize", "gap"]);
  const textWidth = width - iconSize - gap;
  const shapeY = positionV === "middle" ? (height - iconSize) / 2 : positionV === "flipped" ? height - iconSize : 0;
  return jsxs(Group, Object.assign({}, restProps, { children: [jsx(Path, { "data-element-type": "shape", x: positionH === "flipped" ? textWidth + gap : 0, y: shapeY, fill: themeColors.colorPrimary, width: iconSize, height: iconSize, d: "M14.7273 30C6.54538 30 0 22.9077 0 14.7269C0 6.54617 6.54538 0 14.7273 0C22.9092 0 30 6.54617 30 14.7269C30 22.9077 22.9092 30 14.7273 30ZM24.5454 10.9077C22.9092 9.27307 22.9092 9.27307 22.9092 9.27307C22.3638 8.72692 22.3638 8.7269 21.8181 8.7269C21.2727 8.7269 21.2727 8.72692 20.7273 9.27307C13.0908 16.9077 13.0908 16.9077 13.0908 16.9077C8.72731 12.5461 8.72731 12.5462 8.72731 12.5462C8.18193 12.5462 8.18193 12 7.63654 12L7.09077 12.5462C4.90923 14.1808 4.90923 14.1808 4.90923 14.1808C4.90923 14.7269 4.90923 14.7269 4.90923 15.2731C4.90923 15.8192 4.90923 15.8192 4.90923 16.3654C12 23.4539 12 23.4538 12 23.4538C12.5454 23.4538 12.5454 23.4538 13.0908 23.4538C13.6365 23.4538 13.6365 23.4538 14.1819 23.4538C24.5454 12.5461 24.5454 12.5462 24.5454 12.5462L25.0908 12C25.0908 11.4538 24.5454 10.9077 24.5454 10.9077Z" }), jsx(ItemLabel, { indexes, x: positionH === "flipped" ? 0 : iconSize + gap, width: textWidth, height, fontWeight: "normal", alignVertical: "middle", wordWrap: false, fill: "#666", children: datum2.label || datum2.desc })] }));
};
registerItem("done-list", {
  component: DoneList,
  composites: ["label"]
});

// node_modules/@antv/infographic/esm/designs/items/HorizontalIconArrow.js
var HorizontalIconArrow = (props) => {
  const [{ indexes, datum: datum2, width = 140, themeColors, positionV = "normal" }, restProps] = getItemProps(props, ["width"]);
  const isVNormal = positionV !== "flipped";
  const textAlignVertical = positionV === "normal" ? "bottom" : "top";
  const label = jsx(ItemLabel, { indexes, width, fill: themeColors.colorText, alignHorizontal: "center", alignVertical: textAlignVertical, fontSize: 14, children: datum2.label });
  const desc = jsx(ItemDesc, { indexes, width, fill: themeColors.colorTextSecondary, alignHorizontal: "center", alignVertical: textAlignVertical, children: datum2.desc });
  const icon = jsx(ItemIconCircle, { indexes, fill: themeColors.colorPrimary, colorBg: themeColors.colorWhite });
  const dotLine = jsx(DotLine, { width: 8, height: 30, fill: themeColors.colorPrimary, positionV });
  const dotLineGap = 5;
  const iconGap = 25;
  const arrowHeight = 30;
  const labelBounds = getElementBounds(label);
  const descBounds = getElementBounds(desc);
  const iconBounds = getElementBounds(icon);
  const dotLineBounds = getElementBounds(dotLine);
  const fixedGap = labelBounds.height + descBounds.height + dotLineGap + dotLineBounds.height - iconBounds.height - iconGap;
  const totalHeight = iconBounds.height + iconGap + arrowHeight + dotLineBounds.height + dotLineGap + labelBounds.height + descBounds.height;
  return jsx(Group, Object.assign({ width, height: totalHeight }, restProps, { children: jsxs(FlexLayout, { flexDirection: "column", alignItems: "center", children: [isVNormal ? jsxs(Fragment, { children: [desc, label, jsx(Gap, { height: dotLineGap }), dotLine] }) : jsxs(Fragment, { children: [jsx(Gap, { height: fixedGap }), icon, jsx(Gap, { height: iconGap })] }), jsxs(AlignLayout, { horizontal: "center", vertical: "middle", width, height: arrowHeight, children: [jsx(HorizontalArrow, { width, height: arrowHeight, fill: themeColors.colorPrimary }), jsx(Text, { width, height: arrowHeight, alignHorizontal: "center", alignVertical: "middle", fill: themeColors.colorWhite, fontWeight: "bold", fontSize: 16, children: datum2.time ? datum2.time : String(indexes[0] + 1).padStart(2, "0").slice(-2) })] }), !isVNormal ? jsxs(Fragment, { children: [dotLine, jsx(Gap, { height: dotLineGap }), label, desc] }) : jsxs(Fragment, { children: [jsx(Gap, { height: iconGap }), icon] })] }) }));
};
var HorizontalArrow = (props) => {
  const { x: x6 = 0, y: y6 = 0, width = 100, height = 40, fill: fill2 = "#FF356A", size = 10 } = props;
  return jsx(Polygon, { width, height, points: [
    { x: x6, y: y6 },
    { x: x6 + width - size, y: y6 },
    { x: x6 + width, y: y6 + height / 2 },
    { x: x6 + width - size, y: y6 + height },
    { x: x6, y: y6 + height },
    { x: x6 + size, y: y6 + height / 2 }
  ], fill: fill2, "data-element-type": "shape" });
};
var DotLine = (props) => {
  const { x: x6 = 0, y: y6 = 0, width = 10, height = 50, fill: fill2, positionV = "top" } = props;
  const r5 = width / 2;
  const lineLength = height - r5;
  const strokeWidth = 2;
  const lineX = r5;
  return jsxs(ShapesGroup, { x: x6, y: y6, width, height, children: [jsx(Ellipse, { width, height: width, fill: fill2, y: positionV === "top" ? 0 : lineLength - r5 }), jsx(Path, { d: positionV === "top" ? `M${lineX},${r5} L${lineX},${r5 + lineLength}` : `M${lineX},0 L${lineX},${lineLength - r5}`, strokeWidth, stroke: fill2 })] });
};
registerItem("horizontal-icon-arrow", {
  component: HorizontalIconArrow,
  composites: ["icon", "label", "desc", "time"]
});

// node_modules/@antv/infographic/esm/designs/items/HorizontalIconLine.js
var HorizontalIconLine = (props) => {
  const [{ indexes, datum: datum2, width = 160, themeColors, positionH = "center", positionV = "normal" }, restProps] = getItemProps(props, ["width"]);
  const textAlignHorizontal = positionH === "normal" ? "left" : positionH === "flipped" ? "right" : "center";
  const label = jsx(ItemLabel, { indexes, width, alignHorizontal: textAlignHorizontal, fill: themeColors.colorPrimary, children: datum2.label });
  const labelBounds = getElementBounds(label);
  const desc = datum2.desc ? jsx(ItemDesc, { indexes, width, fill: themeColors.colorTextSecondary, alignHorizontal: textAlignHorizontal, alignVertical: positionV === "flipped" ? "top" : "bottom", children: datum2.desc }) : null;
  const descBounds = getElementBounds(desc);
  const iconSize = 45;
  const icon = datum2.icon ? jsx(ItemIconCircle, { size: iconSize, indexes, colorBg: themeColors.colorBg, fill: themeColors.colorPrimary }) : null;
  const iconBounds = getElementBounds(icon);
  const time = datum2.time ? jsx(Text, { width, height: 30, alignHorizontal: "center", alignVertical: "middle", fill: themeColors.colorPrimary, fontSize: 18, fontWeight: "bold", children: datum2.time }) : null;
  const timeBounds = getElementBounds(time);
  const lineHeight = 18;
  const line2 = jsxs(AlignLayout, { horizontal: "center", vertical: "middle", width, height: lineHeight, children: [jsx(Rect, { width, height: lineHeight, fill: themeColors.colorPrimary, "data-element-type": "shape" }), jsx(Ellipse, { width: lineHeight + 6, height: lineHeight + 6, fill: themeColors.colorBg, fillOpacity: 0.5, "data-element-type": "shape" }), jsx(Ellipse, { width: 12, height: 12, fill: "white", "data-element-type": "shape" })] });
  const textSideHeight = labelBounds.height + descBounds.height;
  const iconSideHeight = iconBounds.height + timeBounds.height + 5;
  const heightDiff = Math.abs(iconSideHeight - textSideHeight);
  const topBalance = iconSideHeight > textSideHeight ? heightDiff : 0;
  const bottomBalance = textSideHeight > iconSideHeight ? heightDiff : 0;
  if (positionV === "flipped") {
    return jsxs(FlexLayout, Object.assign({}, restProps, { flexDirection: "column", alignItems: "center", children: [jsx(Gap, { height: bottomBalance }), time, icon, jsx(Gap, { height: 5 }), line2, label, desc, jsx(Gap, { height: topBalance })] }));
  }
  return jsxs(FlexLayout, Object.assign({}, restProps, { flexDirection: "column", alignItems: "center", children: [jsx(Gap, { height: topBalance }), label, desc, line2, jsx(Gap, { height: 5 }), icon, time, jsx(Gap, { height: bottomBalance })] }));
};
registerItem("horizontal-icon-line", {
  component: HorizontalIconLine,
  composites: ["icon", "label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/IconBadge.js
var IconBadge = (props) => {
  var _a;
  const [{ datum: datum2, indexes, size = 80, iconSize = 28, badgeSize = 24, gap = 8, themeColors, width = 84, height = 105 }, restProps] = getItemProps(props, ["size", "iconSize", "badgeSize", "gap"]);
  const value = (_a = datum2.value) !== null && _a !== void 0 ? _a : 0;
  const gradientId = `${themeColors.colorPrimary}-icon`;
  const badgeGradientId = "#ff6b6b-badge";
  return jsxs(Group, Object.assign({}, restProps, { width, height, children: [jsxs(Defs, { children: [jsxs("radialGradient", { id: gradientId, cx: "50%", cy: "30%", r: "70%", children: [jsx("stop", { offset: "0%", stopColor: tinycolor(themeColors.colorPrimary).lighten(30).toHexString() }), jsx("stop", { offset: "100%", stopColor: themeColors.colorPrimary })] }), jsxs("linearGradient", { id: badgeGradientId, x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [jsx("stop", { offset: "0%", stopColor: "#ff6b6b" }), jsx("stop", { offset: "100%", stopColor: "#ee5a52" })] })] }), jsx(Ellipse, { x: 0, y: 0, width: size, height: size, fill: `url(#${gradientId})`, "data-element-type": "shape" }), jsx(ItemIcon, { indexes, x: (size - iconSize) / 2, y: (size - iconSize) / 2, size: iconSize, fill: themeColors.colorPrimaryText }), jsx(Ellipse, { x: size - badgeSize + 4, width: badgeSize, height: badgeSize, fill: `url(#${badgeGradientId})` }), jsx(Text, { x: size - badgeSize + 4, width: badgeSize, height: badgeSize, fontSize: 10, fontWeight: "bold", fill: themeColors.colorWhite, alignHorizontal: "center", alignVertical: "middle", children: value > 99 ? "99+" : Math.round(value) }), jsx(ItemLabel, { indexes, x: 0, y: size + gap, width: size, alignHorizontal: "center", fontSize: 12, fill: themeColors.colorText, children: datum2.label })] }));
};
registerItem("icon-badge", {
  component: IconBadge,
  composites: ["icon", "label"]
});

// node_modules/@antv/infographic/esm/designs/items/IndexedCard.js
var IndexedCard = (props) => {
  const [{ datum: datum2, indexes, width = 200, borderRadius = 12, padding = 16, separatorHeight = 2, indexFontSize = 20, labelFontSize = 16, gap = 8, themeColors }, restProps] = getItemProps(props, [
    "width",
    "height",
    "borderRadius",
    "padding",
    "separatorHeight",
    "indexFontSize",
    "labelFontSize",
    "gap"
  ]);
  const indexNumber = indexes[0] + 1;
  const indexStr = String(indexNumber).padStart(2, "0");
  const showLabel = datum2.label !== void 0;
  const showDesc = datum2.desc !== void 0;
  const separatorColor = tinycolor.mix(themeColors.colorPrimary, themeColors.colorWhite, 40).toHexString();
  const cardBgColor = themeColors.colorBgElevated || themeColors.colorWhite;
  const contentWidth = width - 2 * padding;
  const indexBounds = getElementBounds(jsx(Text, { fontSize: indexFontSize, fontWeight: "bold", children: indexStr }));
  const labelAvailableWidth = contentWidth - indexBounds.width - gap;
  const labelBounds = showLabel ? getElementBounds(jsx(ItemLabel, { indexes, width: labelAvailableWidth, fontSize: labelFontSize, fontWeight: "bold", x: indexFontSize, children: datum2.label })) : { width: 0, height: 0 };
  const descBounds = showDesc ? getElementBounds(jsx(ItemDesc, { indexes, width: contentWidth, fontSize: 14, lineHeight: 1.5, wordWrap: true, children: datum2.desc })) : { width: 0, height: 0 };
  const titleRowHeight = Math.max(indexBounds.height, labelBounds.height);
  const contentHeight = padding * 2 + // 
  titleRowHeight + // 
  (showLabel || showDesc ? gap : 0) + // 
  separatorHeight + // 
  (showDesc ? gap : 0) + // 
  descBounds.height;
  return jsxs(Group, Object.assign({}, restProps, { width, height: contentHeight, children: [jsx(Rect, { x: 0, y: 0, width, height: contentHeight, rx: borderRadius, ry: borderRadius, fill: cardBgColor, stroke: tinycolor(cardBgColor).darken(5).toHexString(), strokeWidth: 0.5, "data-element-type": "shape" }), jsxs(Group, { x: padding, y: padding, children: [jsxs(Group, { x: 0, y: 0, children: [jsx(Text, { x: 0, y: 0, fontSize: indexFontSize, fontWeight: "bold", fill: themeColors.colorPrimary, alignVertical: "top", children: indexStr }), showLabel && jsx(ItemLabel, { indexes, x: indexFontSize + gap, y: 0, width: labelAvailableWidth, fontSize: labelFontSize, fontWeight: "bold", fill: themeColors.colorTextSecondary, alignVertical: "top", children: datum2.label })] }), jsx(Rect, { x: 0, y: titleRowHeight + gap, width: contentWidth, height: separatorHeight, fill: separatorColor, "data-element-type": "shape" }), showDesc && jsx(ItemDesc, { indexes, x: 0, y: titleRowHeight + gap + separatorHeight + gap, width: contentWidth, fontSize: 14, lineHeight: 1.5, wordWrap: true, fill: themeColors.colorTextSecondary, children: datum2.desc })] })] }));
};
registerItem("indexed-card", {
  component: IndexedCard,
  composites: ["label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/LCornerCard.js
var LCornerCard = (props) => {
  const [{ indexes, datum: datum2, width = 140, iconSize = 24, themeColors }, restProps] = getItemProps(props, ["width", "iconSize"]);
  const { label, desc } = datum2;
  const lStroke = 8;
  const arrowSize = 16;
  const arrowGap = 12;
  const descX = arrowSize + arrowGap;
  const descWidth = width - descX;
  const descHeight = 60;
  const verticalLen = iconSize + 44;
  const arrowX1 = arrowSize;
  const arrowY1 = descHeight + arrowGap;
  const arrowY2 = descHeight + arrowSize + arrowGap;
  const arrowVertices = [
    { x: 0, y: arrowY2 },
    { x: arrowX1, y: arrowY1 },
    { x: arrowX1, y: arrowY2 }
  ];
  const innerWidth = width - arrowX1 - arrowGap;
  const lx1 = arrowX1 + arrowGap;
  const lx2 = lx1 + innerWidth;
  const ly1 = arrowY1 + lStroke / 2;
  const ly2 = ly1 + verticalLen;
  const d3 = `M ${lx1} ${ly2} L ${lx1} ${ly1} L ${lx2} ${ly1}`;
  const halfStroke = lStroke / 2;
  const x1 = lx1 + halfStroke;
  const y1 = ly1 + halfStroke;
  const gap = 8;
  return jsxs(Group, Object.assign({}, restProps, { children: [jsx(ItemDesc, { indexes, x: descX, width: descWidth, height: descHeight, fontSize: 12, alignHorizontal: "left", alignVertical: "bottom", fill: themeColors.colorTextSecondary, children: desc }), jsx(Polygon, { points: arrowVertices, fill: themeColors.colorPrimary, opacity: 0.9, width: arrowSize, height: arrowSize, "data-element-type": "shape" }), jsx(Path, { d: d3, stroke: themeColors.colorPrimary, strokeWidth: lStroke, fill: "none", "data-element-type": "shape" }), jsx(ItemIcon, { indexes, x: x1 + innerWidth / 2 - iconSize / 2, y: y1 + gap, size: iconSize, fill: themeColors.colorPrimary }), jsx(ItemLabel, { indexes, x: x1, y: y1 + iconSize + gap * 2, width: innerWidth, fontSize: 14, fontWeight: "bold", alignHorizontal: "center", alignVertical: "middle", fill: themeColors.colorText, children: label })] }));
};
registerItem("l-corner-card", {
  component: LCornerCard,
  composites: ["icon", "label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/LetterCard.js
var LetterCard = (props) => {
  var _a, _b;
  const [{ datum: datum2, indexes, width = 280, height = 160, showStripe = true, showGradient = true, showBottomShade = true, themeColors }, restProps] = getItemProps(props, [
    "width",
    "height",
    "showStripe",
    "showGradient",
    "showBottomShade"
  ]);
  const displayLetter = (_a = datum2.label) === null || _a === void 0 ? void 0 : _a[0].toUpperCase();
  const displayTitle = (_b = datum2.label) === null || _b === void 0 ? void 0 : _b.toUpperCase();
  const baseColor = themeColors.colorPrimary;
  const base = tinycolor(baseColor);
  const stripeWidth = 4;
  const gapWidth = 6;
  const rotationDeg = 45;
  const bottomShadeHeight = 40;
  const gradientLighten = 12;
  const gradientDarken = 4;
  const gradStart = base.clone().darken(gradientDarken).toHexString();
  const gradEnd = base.clone().lighten(gradientLighten).toHexString();
  const lightStripe = "rgba(255, 255, 255, 0)";
  const darkStripe = "rgba(0, 0, 0, 0.03)";
  const uniqueId = `letter-card-${indexes.join("-")}`;
  const gradientId = `${uniqueId}-gradient`;
  const patternId = `${uniqueId}-pattern`;
  const shadeId = `${uniqueId}-shade`;
  const tile = stripeWidth + gapWidth;
  const ratio = 1;
  const letterFontSize = 96;
  const letterHeight = letterFontSize * ratio;
  const titleFontSize = 16;
  const titleHeight = titleFontSize * ratio;
  const textGap = height / 16;
  const textTotalHeight = letterHeight + textGap + titleHeight;
  const letterY = (height - textTotalHeight) / 2;
  const titleY = letterY + letterHeight + textGap;
  return jsxs(Group, Object.assign({}, restProps, { width, height, children: [jsxs(Defs, { children: [showGradient && jsxs("linearGradient", { id: gradientId, x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [jsx("stop", { offset: "0%", stopColor: gradStart }), jsx("stop", { offset: "100%", stopColor: gradEnd })] }), showStripe && jsxs("pattern", { id: patternId, patternUnits: "userSpaceOnUse", width: tile, height: tile, patternTransform: `rotate(${rotationDeg})`, children: [jsx("rect", { x: "0", y: "0", width: tile, height: tile, fill: lightStripe }), jsx("rect", { x: "0", y: "0", width: stripeWidth, height: tile, fill: darkStripe })] }), showBottomShade && jsxs("linearGradient", { id: shadeId, x1: "0%", y1: "0%", x2: "0%", y2: "100%", children: [jsx("stop", { offset: "0%", stopColor: "rgba(0,0,0,0)" }), jsx("stop", { offset: "100%", stopColor: "rgba(0,0,0,0.16)" })] })] }), jsx(Rect, { x: 0, y: 0, width, height, fill: showGradient ? `url(#${gradientId})` : baseColor, rx: 0, ry: 0, "data-element-type": "shape" }), showStripe && jsx(Rect, { x: 0, y: 0, width, height, fill: `url(#${patternId})`, rx: 0, ry: 0 }), showBottomShade && jsx(Rect, { x: 0, y: height - bottomShadeHeight, width, height: bottomShadeHeight, fill: `url(#${shadeId})`, rx: 0, ry: 0 }), displayLetter && jsx(ItemLabel, { indexes, x: 0, y: letterY, width, fontSize: letterFontSize, fontWeight: "bold", fill: "#FFFFFF", alignHorizontal: "center", alignVertical: "top", lineHeight: 1, children: displayLetter }), jsx(ItemLabel, { indexes, x: 0, y: titleY, width, fontSize: titleFontSize, fontWeight: "bold", fill: "#FFFFFF", alignHorizontal: "center", alignVertical: "middle", lineHeight: 1, children: displayTitle })] }));
};
registerItem("letter-card", {
  component: LetterCard,
  composites: ["label"]
});

// node_modules/@antv/infographic/esm/designs/items/LinedText.js
var LinedText = (props) => {
  var _a, _b, _c;
  const [{ datum: datum2, indexes, width, themeColors, positionH = "normal", positionV = "center", formatter = (text) => text || "", usePaletteColor = false, showUnderline = false, underlineGap = 6, underlineExtend = 8, underlineThickness = 2 }, restProps] = getItemProps(props, [
    "width",
    "formatter",
    "usePaletteColor",
    "showUnderline",
    "underlineGap",
    "underlineExtend",
    "underlineThickness"
  ]);
  const content = formatter((_b = (_a = datum2.label) !== null && _a !== void 0 ? _a : datum2.desc) !== null && _b !== void 0 ? _b : "");
  const alignH = positionH === "flipped" ? "right" : positionH === "center" ? "center" : "left";
  const measuredLabel = getElementBounds(jsx(ItemLabel, { indexes, width, children: content }));
  const contentWidth = width !== null && width !== void 0 ? width : measuredLabel.width;
  const labelHeight = measuredLabel.height;
  const underlineWidth2 = showUnderline ? contentWidth + underlineExtend * 2 : 0;
  const totalHeight = labelHeight + (showUnderline ? underlineGap + underlineThickness : 0);
  const finalWidth = showUnderline ? Math.max(contentWidth, underlineWidth2) : contentWidth;
  const finalHeight = (_c = restProps.height) !== null && _c !== void 0 ? _c : totalHeight;
  const offsetY = positionV === "middle" ? (finalHeight - totalHeight) / 2 : positionV === "flipped" ? finalHeight - totalHeight : 0;
  const labelX = alignH === "right" ? finalWidth - contentWidth : alignH === "center" ? (finalWidth - contentWidth) / 2 : 0;
  const labelY = offsetY;
  const underlineX = alignH === "right" ? finalWidth - underlineWidth2 : alignH === "center" ? (finalWidth - underlineWidth2) / 2 : 0;
  const underlineY = finalHeight;
  return jsxs(Group, Object.assign({}, restProps, { width: finalWidth, height: finalHeight, children: [jsx(ItemLabel, { indexes, x: labelX, y: labelY, width: contentWidth, height: labelHeight, alignHorizontal: alignH, alignVertical: positionV === "flipped" ? "bottom" : positionV === "center" ? "middle" : "top", fill: usePaletteColor ? themeColors.colorPrimary : themeColors.colorText, children: content }), showUnderline && jsx(Path, { d: `M 0 ${underlineThickness / 2} L ${underlineWidth2} ${underlineThickness / 2}`, x: underlineX, y: underlineY - underlineThickness / 2, width: underlineWidth2, height: underlineThickness, stroke: themeColors.colorPrimary, strokeWidth: underlineThickness, fill: "none", strokeLinecap: "round", "data-element-type": "shape" })] }));
};
registerItem("lined-text", {
  component: LinedText,
  composites: ["label"]
});

// node_modules/@antv/infographic/esm/designs/items/PillBadge.js
var PillBadge = (props) => {
  const [{ datum: datum2, indexes, width = 300, pillWidth = 120, pillHeight = 36, gap = 16, positionH = "normal", themeColors }, restProps] = getItemProps(props, ["width", "pillWidth", "pillHeight", "gap"]);
  const hasDesc = !!datum2.desc;
  const componentWidth = hasDesc ? width : pillWidth;
  const pillX = hasDesc ? positionH === "center" ? (componentWidth - pillWidth) / 2 : positionH === "flipped" ? componentWidth - pillWidth : 0 : 0;
  const pillY = 0;
  const contentX = hasDesc ? positionH === "center" ? 0 : positionH === "flipped" ? 0 : 0 : 0;
  const contentY = pillHeight + gap;
  const contentWidth = componentWidth;
  const dropShadowId = `drop-shadow-${themeColors.colorPrimary}`;
  const linearGradientId = `linear-gradient-white-top-bottom`;
  return jsxs(Group, Object.assign({}, restProps, { children: [jsxs(Defs, { children: [jsx(DropShadow, { id: dropShadowId, color: themeColors.colorPrimary }), jsx(LinearGradient, { id: linearGradientId, startColor: "#fff", stopColor: "#ffffff33", direction: "top-bottom" })] }), jsx(Rect, { x: pillX, y: pillY, width: pillWidth, height: pillHeight, fill: themeColors.colorPrimaryBg, stroke: themeColors.colorPrimary, rx: pillHeight / 2, ry: pillHeight / 2, filter: `url(#${dropShadowId})`, "data-element-type": "shape" }), jsx(Rect, { x: pillX, y: pillY, width: pillWidth, height: pillHeight, fill: `url(#${linearGradientId})`, opacity: themeColors.isDarkMode ? 0.4 : 0.7, rx: pillHeight / 2, ry: pillHeight / 2 }), jsx(ItemLabel, { indexes, x: pillX, y: pillY, width: pillWidth, height: pillHeight, alignHorizontal: "center", alignVertical: "middle", fontSize: 14, fontWeight: "500", fill: themeColors.colorText, children: datum2.label }), datum2.desc && jsx(ItemDesc, { indexes, x: contentX, y: contentY, width: contentWidth, alignHorizontal: positionH === "center" ? "center" : positionH === "flipped" ? "right" : "left", fontSize: 12, fill: themeColors.colorTextSecondary, lineNumber: 2, wordWrap: true, children: datum2.desc })] }));
};
registerItem("pill-badge", {
  component: PillBadge,
  composites: ["label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/PlainText.js
var LabelText = (props) => {
  var _a;
  const [{ indexes, datum: datum2, width = 120, themeColors, positionH = "normal", positionV = "center", formatter = (text) => text || "", usePaletteColor = false, lineNumber = 1 }, restProps] = getItemProps(props, [
    "width",
    "formatter",
    "usePaletteColor",
    "lineNumber"
  ]);
  const fontSize = 14;
  const lineHeight = 1.4;
  const height = (_a = restProps.height) !== null && _a !== void 0 ? _a : Math.ceil(lineNumber * lineHeight * fontSize);
  return jsx(ItemLabel, Object.assign({}, restProps, { indexes, width, height, lineHeight, fill: usePaletteColor ? themeColors.colorPrimary : themeColors.colorText, fontSize, fontWeight: "regular", alignHorizontal: positionH === "flipped" ? "right" : positionH === "center" ? "center" : "left", alignVertical: positionV === "flipped" ? "bottom" : positionV === "center" ? "middle" : "top", children: formatter(datum2.label || datum2.desc) }));
};
registerItem("plain-text", {
  component: LabelText,
  composites: ["label"]
});

// node_modules/d3-array/src/ascending.js
function ascending(a3, b2) {
  return a3 == null || b2 == null ? NaN : a3 < b2 ? -1 : a3 > b2 ? 1 : a3 >= b2 ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a3, b2) {
  return a3 == null || b2 == null ? NaN : b2 < a3 ? -1 : b2 > a3 ? 1 : b2 >= a3 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f5) {
  let compare1, compare2, delta;
  if (f5.length !== 2) {
    compare1 = ascending;
    compare2 = (d3, x6) => ascending(f5(d3), x6);
    delta = (d3, x6) => f5(d3) - x6;
  } else {
    compare1 = f5 === ascending || f5 === descending ? f5 : zero2;
    compare2 = f5;
    delta = f5;
  }
  function left(a3, x6, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x6, x6) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a3[mid], x6) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a3, x6, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x6, x6) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a3[mid], x6) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a3, x6, lo = 0, hi = a3.length) {
    const i4 = left(a3, x6, lo, hi - 1);
    return i4 > lo && delta(a3[i4 - 1], x6) > -delta(a3[i4], x6) ? i4 - 1 : i4;
  }
  return { left, center, right };
}
function zero2() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x6) {
  return x6 === null ? NaN : +x6;
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e22 = Math.sqrt(2);
function tickSpec(start2, stop, count2) {
  const step = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor2 = error >= e10 ? 10 : error >= e5 ? 5 : error >= e22 ? 2 : 1;
  let i1, i22, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor2;
    i1 = Math.round(start2 * inc);
    i22 = Math.round(stop * inc);
    if (i1 / inc < start2)
      ++i1;
    if (i22 / inc > stop)
      --i22;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor2;
    i1 = Math.round(start2 / inc);
    i22 = Math.round(stop / inc);
    if (i1 * inc < start2)
      ++i1;
    if (i22 * inc > stop)
      --i22;
  }
  if (i22 < i1 && 0.5 <= count2 && count2 < 2)
    return tickSpec(start2, stop, count2 * 2);
  return [i1, i22, inc];
}
function ticks(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  if (!(count2 > 0))
    return [];
  if (start2 === stop)
    return [start2];
  const reverse = stop < start2, [i1, i22, inc] = reverse ? tickSpec(stop, start2, count2) : tickSpec(start2, stop, count2);
  if (!(i22 >= i1))
    return [];
  const n4 = i22 - i1 + 1, ticks2 = new Array(n4);
  if (reverse) {
    if (inc < 0)
      for (let i4 = 0; i4 < n4; ++i4)
        ticks2[i4] = (i22 - i4) / -inc;
    else
      for (let i4 = 0; i4 < n4; ++i4)
        ticks2[i4] = (i22 - i4) * inc;
  } else {
    if (inc < 0)
      for (let i4 = 0; i4 < n4; ++i4)
        ticks2[i4] = (i1 + i4) / -inc;
    else
      for (let i4 = 0; i4 < n4; ++i4)
        ticks2[i4] = (i1 + i4) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  return tickSpec(start2, stop, count2)[2];
}
function tickStep(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  const reverse = stop < start2, inc = reverse ? tickIncrement(stop, start2, count2) : tickIncrement(start2, stop, count2);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i4 = 0, n4 = arguments.length, _2 = {}, t2; i4 < n4; ++i4) {
    if (!(t2 = arguments[i4] + "") || t2 in _2 || /[\s.]/.test(t2))
      throw new Error("illegal type: " + t2);
    _2[t2] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i4 = t2.indexOf(".");
    if (i4 >= 0)
      name = t2.slice(i4 + 1), t2 = t2.slice(0, i4);
    if (t2 && !types.hasOwnProperty(t2))
      throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T3 = parseTypenames(typename + "", _2), t2, i4 = -1, n4 = T3.length;
    if (arguments.length < 2) {
      while (++i4 < n4)
        if ((t2 = (typename = T3[i4]).type) && (t2 = get2(_2[t2], typename.name)))
          return t2;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i4 < n4) {
      if (t2 = (typename = T3[i4]).type)
        _2[t2] = set(_2[t2], typename.name, callback);
      else if (callback == null)
        for (t2 in _2)
          _2[t2] = set(_2[t2], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _2 = this._;
    for (var t2 in _2)
      copy2[t2] = _2[t2].slice();
    return new Dispatch(copy2);
  },
  call: function(type2, that) {
    if ((n4 = arguments.length - 2) > 0)
      for (var args = new Array(n4), i4 = 0, n4, t2; i4 < n4; ++i4)
        args[i4] = arguments[i4 + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t2 = this._[type2], i4 = 0, n4 = t2.length; i4 < n4; ++i4)
      t2[i4].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t2 = this._[type2], i4 = 0, n4 = t2.length; i4 < n4; ++i4)
      t2[i4].value.apply(that, args);
  }
};
function get2(type2, name) {
  for (var i4 = 0, n4 = type2.length, c4; i4 < n4; ++i4) {
    if ((c4 = type2[i4]).name === name) {
      return c4.value;
    }
  }
}
function set(type2, name, callback) {
  for (var i4 = 0, n4 = type2.length; i4 < n4; ++i4) {
    if (type2[i4].name === name) {
      type2[i4] = noop, type2 = type2.slice(0, i4).concat(type2.slice(i4 + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i4 = prefix.indexOf(":");
  if (i4 >= 0 && (prefix = name.slice(0, i4)) !== "xmlns")
    name = name.slice(i4 + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document3 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document3.documentElement.namespaceURI === xhtml ? document3.createElement(name) : document3.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m3 = groups.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    for (var group = groups[j2], n4 = group.length, subgroup = subgroups[j2] = new Array(n4), node, subnode, i4 = 0; i4 < n4; ++i4) {
      if ((node = group[i4]) && (subnode = select.call(node, node.__data__, i4, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i4] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x6) {
  return x6 == null ? [] : Array.isArray(x6) ? x6 : Array.from(x6);
}

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function")
    select = arrayAll(select);
  else
    select = selectorAll_default(select);
  for (var groups = this._groups, m3 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m3; ++j2) {
    for (var group = groups[j2], n4 = group.length, node, i4 = 0; i4 < n4; ++i4) {
      if (node = group[i4]) {
        subgroups.push(select.call(node, node.__data__, i4, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m3 = groups.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    for (var group = groups[j2], n4 = group.length, subgroup = subgroups[j2] = [], node, i4 = 0; i4 < n4; ++i4) {
      if ((node = group[i4]) && match.call(node, node.__data__, i4, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default2(x6) {
  return function() {
    return x6;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update, exit, data) {
  var i4 = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i4 < dataLength; ++i4) {
    if (node = group[i4]) {
      node.__data__ = data[i4];
      update[i4] = node;
    } else {
      enter[i4] = new EnterNode(parent, data[i4]);
    }
  }
  for (; i4 < groupLength; ++i4) {
    if (node = group[i4]) {
      exit[i4] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i4, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i4 = 0; i4 < groupLength; ++i4) {
    if (node = group[i4]) {
      keyValues[i4] = keyValue = key.call(node, node.__data__, i4, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i4] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i4 = 0; i4 < dataLength; ++i4) {
    keyValue = key.call(parent, data[i4], i4, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i4] = node;
      node.__data__ = data[i4];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i4] = new EnterNode(parent, data[i4]);
    }
  }
  for (i4 = 0; i4 < groupLength; ++i4) {
    if ((node = group[i4]) && nodeByKeyValue.get(keyValues[i4]) === node) {
      exit[i4] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant_default2(value);
  for (var m3 = groups.length, update = new Array(m3), enter = new Array(m3), exit = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    var parent = parents[j2], group = groups[j2], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j2, parents)), dataLength = data.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default2(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m3; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n4 = group0.length, merge2 = merges[j2] = new Array(n4), node, i4 = 0; i4 < n4; ++i4) {
      if (node = group0[i4] || group1[i4]) {
        merge2[i4] = node;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j2 = -1, m3 = groups.length; ++j2 < m3; ) {
    for (var group = groups[j2], i4 = group.length - 1, next = group[i4], node; --i4 >= 0; ) {
      if (node = group[i4]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending2;
  function compareNode(a3, b2) {
    return a3 && b2 ? compare(a3.__data__, b2.__data__) : !a3 - !b2;
  }
  for (var groups = this._groups, m3 = groups.length, sortgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    for (var group = groups[j2], n4 = group.length, sortgroup = sortgroups[j2] = new Array(n4), node, i4 = 0; i4 < n4; ++i4) {
      if (node = group[i4]) {
        sortgroup[i4] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a3, b2) {
  return a3 < b2 ? -1 : a3 > b2 ? 1 : a3 >= b2 ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j2 = 0, m3 = groups.length; j2 < m3; ++j2) {
    for (var group = groups[j2], i4 = 0, n4 = group.length; i4 < n4; ++i4) {
      var node = group[i4];
      if (node)
        return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j2 = 0, m3 = groups.length; j2 < m3; ++j2) {
    for (var group = groups[j2], i4 = 0, n4 = group.length, node; i4 < n4; ++i4) {
      if (node = group[i4])
        callback.call(node, node.__data__, i4, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v2);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v2, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      delete this[name];
    else
      this[name] = v2;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i4 = this._names.indexOf(name);
    if (i4 < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i4 = this._names.indexOf(name);
    if (i4 >= 0) {
      this._names.splice(i4, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names2) {
  var list3 = classList(node), i4 = -1, n4 = names2.length;
  while (++i4 < n4)
    list3.add(names2[i4]);
}
function classedRemove(node, names2) {
  var list3 = classList(node), i4 = -1, n4 = names2.length;
  while (++i4 < n4)
    list3.remove(names2[i4]);
}
function classedTrue(names2) {
  return function() {
    classedAdd(this, names2);
  };
}
function classedFalse(names2) {
  return function() {
    classedRemove(this, names2);
  };
}
function classedFunction(names2, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names2);
  };
}
function classed_default(name, value) {
  var names2 = classArray(name + "");
  if (arguments.length < 2) {
    var list3 = classList(this.node()), i4 = -1, n4 = names2.length;
    while (++i4 < n4)
      if (!list3.contains(names2[i4]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names2, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.textContent = v2 == null ? "" : v2;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.innerHTML = v2 == null ? "" : v2;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i4 = t2.indexOf(".");
    if (i4 >= 0)
      name = t2.slice(i4 + 1), t2 = t2.slice(0, i4);
    return { type: t2, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j2 = 0, i4 = -1, m3 = on.length, o3; j2 < m3; ++j2) {
      if (o3 = on[j2], (!typename.type || o3.type === typename.type) && o3.name === typename.name) {
        this.removeEventListener(o3.type, o3.listener, o3.options);
      } else {
        on[++i4] = o3;
      }
    }
    if (++i4)
      on.length = i4;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o3, listener = contextListener(value);
    if (on)
      for (var j2 = 0, m3 = on.length; j2 < m3; ++j2) {
        if ((o3 = on[j2]).type === typename.type && o3.name === typename.name) {
          this.removeEventListener(o3.type, o3.listener, o3.options);
          this.addEventListener(o3.type, o3.listener = listener, o3.options = options);
          o3.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o3 = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o3];
    else
      on.push(o3);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i4, n4 = typenames.length, t2;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j2 = 0, m3 = on.length, o3; j2 < m3; ++j2) {
        for (i4 = 0, o3 = on[j2]; i4 < n4; ++i4) {
          if ((t2 = typenames[i4]).type === o3.type && t2.name === o3.name) {
            return o3.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i4 = 0; i4 < n4; ++i4)
    this.each(on(typenames[i4], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j2 = 0, m3 = groups.length; j2 < m3; ++j2) {
    for (var group = groups[j2], i4 = 0, n4 = group.length, node; i4 < n4; ++i4) {
      if (node = group[i4])
        yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root2 = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root2);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default2,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition29) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition29)
    prototype[key] = definition29[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m3, l3;
  format2 = (format2 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format2)) ? (l3 = m3[1].length, m3 = parseInt(m3[1], 16), l3 === 6 ? rgbn(m3) : l3 === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l3 === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l3 === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format2)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format2)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format2)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format2)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format2)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format2)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named2.hasOwnProperty(format2) ? rgbn(named2[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n4) {
  return new Rgb(n4 >> 16 & 255, n4 >> 8 & 255, n4 & 255, 1);
}
function rgba(r5, g3, b2, a3) {
  if (a3 <= 0)
    r5 = g3 = b2 = NaN;
  return new Rgb(r5, g3, b2, a3);
}
function rgbConvert(o3) {
  if (!(o3 instanceof Color))
    o3 = color(o3);
  if (!o3)
    return new Rgb();
  o3 = o3.rgb();
  return new Rgb(o3.r, o3.g, o3.b, o3.opacity);
}
function rgb3(r5, g3, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r5) : new Rgb(r5, g3, b2, opacity == null ? 1 : opacity);
}
function Rgb(r5, g3, b2, opacity) {
  this.r = +r5;
  this.g = +g3;
  this.b = +b2;
  this.opacity = +opacity;
}
define_default(Rgb, rgb3, extend(Color, {
  brighter(k5) {
    k5 = k5 == null ? brighter : Math.pow(brighter, k5);
    return new Rgb(this.r * k5, this.g * k5, this.b * k5, this.opacity);
  },
  darker(k5) {
    k5 = k5 == null ? darker : Math.pow(darker, k5);
    return new Rgb(this.r * k5, this.g * k5, this.b * k5, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex3(this.r)}${hex3(this.g)}${hex3(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex3(this.r)}${hex3(this.g)}${hex3(this.b)}${hex3((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a3 = clampa(this.opacity);
  return `${a3 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a3 === 1 ? ")" : `, ${a3})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex3(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h4, s3, l3, a3) {
  if (a3 <= 0)
    h4 = s3 = l3 = NaN;
  else if (l3 <= 0 || l3 >= 1)
    h4 = s3 = NaN;
  else if (s3 <= 0)
    h4 = NaN;
  return new Hsl(h4, s3, l3, a3);
}
function hslConvert(o3) {
  if (o3 instanceof Hsl)
    return new Hsl(o3.h, o3.s, o3.l, o3.opacity);
  if (!(o3 instanceof Color))
    o3 = color(o3);
  if (!o3)
    return new Hsl();
  if (o3 instanceof Hsl)
    return o3;
  o3 = o3.rgb();
  var r5 = o3.r / 255, g3 = o3.g / 255, b2 = o3.b / 255, min3 = Math.min(r5, g3, b2), max3 = Math.max(r5, g3, b2), h4 = NaN, s3 = max3 - min3, l3 = (max3 + min3) / 2;
  if (s3) {
    if (r5 === max3)
      h4 = (g3 - b2) / s3 + (g3 < b2) * 6;
    else if (g3 === max3)
      h4 = (b2 - r5) / s3 + 2;
    else
      h4 = (r5 - g3) / s3 + 4;
    s3 /= l3 < 0.5 ? max3 + min3 : 2 - max3 - min3;
    h4 *= 60;
  } else {
    s3 = l3 > 0 && l3 < 1 ? 0 : h4;
  }
  return new Hsl(h4, s3, l3, o3.opacity);
}
function hsl3(h4, s3, l3, opacity) {
  return arguments.length === 1 ? hslConvert(h4) : new Hsl(h4, s3, l3, opacity == null ? 1 : opacity);
}
function Hsl(h4, s3, l3, opacity) {
  this.h = +h4;
  this.s = +s3;
  this.l = +l3;
  this.opacity = +opacity;
}
define_default(Hsl, hsl3, extend(Color, {
  brighter(k5) {
    k5 = k5 == null ? brighter : Math.pow(brighter, k5);
    return new Hsl(this.h, this.s, this.l * k5, this.opacity);
  },
  darker(k5) {
    k5 = k5 == null ? darker : Math.pow(darker, k5);
    return new Hsl(this.h, this.s, this.l * k5, this.opacity);
  },
  rgb() {
    var h4 = this.h % 360 + (this.h < 0) * 360, s3 = isNaN(h4) || isNaN(this.s) ? 0 : this.s, l3 = this.l, m22 = l3 + (l3 < 0.5 ? l3 : 1 - l3) * s3, m1 = 2 * l3 - m22;
    return new Rgb(
      hsl2rgb(h4 >= 240 ? h4 - 240 : h4 + 120, m1, m22),
      hsl2rgb(h4, m1, m22),
      hsl2rgb(h4 < 120 ? h4 + 240 : h4 - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a3 = clampa(this.opacity);
    return `${a3 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a3 === 1 ? ")" : `, ${a3})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h4, m1, m22) {
  return (h4 < 60 ? m1 + (m22 - m1) * h4 / 60 : h4 < 180 ? m22 : h4 < 240 ? m1 + (m22 - m1) * (240 - h4) / 60 : m1) * 255;
}

// node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values) {
  var n4 = values.length - 1;
  return function(t2) {
    var i4 = t2 <= 0 ? t2 = 0 : t2 >= 1 ? (t2 = 1, n4 - 1) : Math.floor(t2 * n4), v1 = values[i4], v2 = values[i4 + 1], v0 = i4 > 0 ? values[i4 - 1] : 2 * v1 - v2, v3 = i4 < n4 - 1 ? values[i4 + 2] : 2 * v2 - v1;
    return basis((t2 - i4 / n4) * n4, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n4 = values.length;
  return function(t2) {
    var i4 = Math.floor(((t2 %= 1) < 0 ? ++t2 : t2) * n4), v0 = values[(i4 + n4 - 1) % n4], v1 = values[i4 % n4], v2 = values[(i4 + 1) % n4], v3 = values[(i4 + 2) % n4];
    return basis((t2 - i4 / n4) * n4, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x6) => () => x6;

// node_modules/d3-interpolate/src/color.js
function linear(a3, d3) {
  return function(t2) {
    return a3 + t2 * d3;
  };
}
function exponential(a3, b2, y6) {
  return a3 = Math.pow(a3, y6), b2 = Math.pow(b2, y6) - a3, y6 = 1 / y6, function(t2) {
    return Math.pow(a3 + t2 * b2, y6);
  };
}
function gamma4(y6) {
  return (y6 = +y6) === 1 ? nogamma : function(a3, b2) {
    return b2 - a3 ? exponential(a3, b2, y6) : constant_default3(isNaN(a3) ? b2 : a3);
  };
}
function nogamma(a3, b2) {
  var d3 = b2 - a3;
  return d3 ? linear(a3, d3) : constant_default3(isNaN(a3) ? b2 : a3);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y6) {
  var color3 = gamma4(y6);
  function rgb4(start2, end) {
    var r5 = color3((start2 = rgb3(start2)).r, (end = rgb3(end)).r), g3 = color3(start2.g, end.g), b2 = color3(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t2) {
      start2.r = r5(t2);
      start2.g = g3(t2);
      start2.b = b2(t2);
      start2.opacity = opacity(t2);
      return start2 + "";
    };
  }
  rgb4.gamma = rgbGamma;
  return rgb4;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n4 = colors.length, r5 = new Array(n4), g3 = new Array(n4), b2 = new Array(n4), i4, color3;
    for (i4 = 0; i4 < n4; ++i4) {
      color3 = rgb3(colors[i4]);
      r5[i4] = color3.r || 0;
      g3[i4] = color3.g || 0;
      b2[i4] = color3.b || 0;
    }
    r5 = spline(r5);
    g3 = spline(g3);
    b2 = spline(b2);
    color3.opacity = 1;
    return function(t2) {
      color3.r = r5(t2);
      color3.g = g3(t2);
      color3.b = b2(t2);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a3, b2) {
  if (!b2)
    b2 = [];
  var n4 = a3 ? Math.min(b2.length, a3.length) : 0, c4 = b2.slice(), i4;
  return function(t2) {
    for (i4 = 0; i4 < n4; ++i4)
      c4[i4] = a3[i4] * (1 - t2) + b2[i4] * t2;
    return c4;
  };
}
function isNumberArray(x6) {
  return ArrayBuffer.isView(x6) && !(x6 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a3, b2) {
  var nb = b2 ? b2.length : 0, na = a3 ? Math.min(nb, a3.length) : 0, x6 = new Array(na), c4 = new Array(nb), i4;
  for (i4 = 0; i4 < na; ++i4)
    x6[i4] = value_default(a3[i4], b2[i4]);
  for (; i4 < nb; ++i4)
    c4[i4] = b2[i4];
  return function(t2) {
    for (i4 = 0; i4 < na; ++i4)
      c4[i4] = x6[i4](t2);
    return c4;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a3, b2) {
  var d3 = new Date();
  return a3 = +a3, b2 = +b2, function(t2) {
    return d3.setTime(a3 * (1 - t2) + b2 * t2), d3;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a3, b2) {
  return a3 = +a3, b2 = +b2, function(t2) {
    return a3 * (1 - t2) + b2 * t2;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a3, b2) {
  var i4 = {}, c4 = {}, k5;
  if (a3 === null || typeof a3 !== "object")
    a3 = {};
  if (b2 === null || typeof b2 !== "object")
    b2 = {};
  for (k5 in b2) {
    if (k5 in a3) {
      i4[k5] = value_default(a3[k5], b2[k5]);
    } else {
      c4[k5] = b2[k5];
    }
  }
  return function(t2) {
    for (k5 in i4)
      c4[k5] = i4[k5](t2);
    return c4;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero3(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function string_default(a3, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i4 = -1, s3 = [], q2 = [];
  a3 = a3 + "", b2 = b2 + "";
  while ((am = reA.exec(a3)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s3[i4])
        s3[i4] += bs;
      else
        s3[++i4] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s3[i4])
        s3[i4] += bm;
      else
        s3[++i4] = bm;
    } else {
      s3[++i4] = null;
      q2.push({ i: i4, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s3[i4])
      s3[i4] += bs;
    else
      s3[++i4] = bs;
  }
  return s3.length < 2 ? q2[0] ? one(q2[0].x) : zero3(b2) : (b2 = q2.length, function(t2) {
    for (var i5 = 0, o3; i5 < b2; ++i5)
      s3[(o3 = q2[i5]).i] = o3.x(t2);
    return s3.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a3, b2) {
  var t2 = typeof b2, c4;
  return b2 == null || t2 === "boolean" ? constant_default3(b2) : (t2 === "number" ? number_default : t2 === "string" ? (c4 = color(b2)) ? (b2 = c4, rgb_default) : string_default : b2 instanceof color ? rgb_default : b2 instanceof Date ? date_default : isNumberArray(b2) ? numberArray_default : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object_default : number_default)(a3, b2);
}

// node_modules/d3-interpolate/src/round.js
function round_default2(a3, b2) {
  return a3 = +a3, b2 = +b2, function(t2) {
    return Math.round(a3 * (1 - t2) + b2 * t2);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a3, b2, c4, d3, e8, f5) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a3 * a3 + b2 * b2))
    a3 /= scaleX, b2 /= scaleX;
  if (skewX = a3 * c4 + b2 * d3)
    c4 -= a3 * skewX, d3 -= b2 * skewX;
  if (scaleY = Math.sqrt(c4 * c4 + d3 * d3))
    c4 /= scaleY, d3 /= scaleY, skewX /= scaleY;
  if (a3 * d3 < b2 * c4)
    a3 = -a3, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e8,
    translateY: f5,
    rotate: Math.atan2(b2, a3) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m3.isIdentity ? identity3 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value) {
  if (value == null)
    return identity3;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity3;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse3, pxComma, pxParen, degParen) {
  function pop(s3) {
    return s3.length ? s3.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s3, q2) {
    if (xa !== xb || ya !== yb) {
      var i4 = s3.push("translate(", null, pxComma, null, pxParen);
      q2.push({ i: i4 - 4, x: number_default(xa, xb) }, { i: i4 - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s3.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a3, b2, s3, q2) {
    if (a3 !== b2) {
      if (a3 - b2 > 180)
        b2 += 360;
      else if (b2 - a3 > 180)
        a3 += 360;
      q2.push({ i: s3.push(pop(s3) + "rotate(", null, degParen) - 2, x: number_default(a3, b2) });
    } else if (b2) {
      s3.push(pop(s3) + "rotate(" + b2 + degParen);
    }
  }
  function skewX(a3, b2, s3, q2) {
    if (a3 !== b2) {
      q2.push({ i: s3.push(pop(s3) + "skewX(", null, degParen) - 2, x: number_default(a3, b2) });
    } else if (b2) {
      s3.push(pop(s3) + "skewX(" + b2 + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s3, q2) {
    if (xa !== xb || ya !== yb) {
      var i4 = s3.push(pop(s3) + "scale(", null, ",", null, ")");
      q2.push({ i: i4 - 4, x: number_default(xa, xb) }, { i: i4 - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s3.push(pop(s3) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a3, b2) {
    var s3 = [], q2 = [];
    a3 = parse3(a3), b2 = parse3(b2);
    translate(a3.translateX, a3.translateY, b2.translateX, b2.translateY, s3, q2);
    rotate(a3.rotate, b2.rotate, s3, q2);
    skewX(a3.skewX, b2.skewX, s3, q2);
    scale(a3.scaleX, a3.scaleY, b2.scaleX, b2.scaleY, s3, q2);
    a3 = b2 = null;
    return function(t2) {
      var i4 = -1, n4 = q2.length, o3;
      while (++i4 < n4)
        s3[(o3 = q2[i4]).i] = o3.x(t2);
      return s3.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f5) {
  setTimeout(f5, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t2 = new Timer();
  t2.restart(callback, delay, time);
  return t2;
}
function timerFlush() {
  now();
  ++frame;
  var t2 = taskHead, e8;
  while (t2) {
    if ((e8 = clockNow - t2._time) >= 0)
      t2._call.call(void 0, e8);
    t2 = t2._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
  var t2 = new Timer();
  delay = delay == null ? 0 : +delay;
  t2.restart((elapsed) => {
    t2.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t2;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index2, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index: index2,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get3(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get3(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get3(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule, 0, self2.time);
  function schedule(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i4, j2, n4, o3;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i4 in schedules) {
      o3 = schedules[i4];
      if (o3.name !== self2.name)
        continue;
      if (o3.state === STARTED)
        return timeout_default(start2);
      if (o3.state === RUNNING) {
        o3.state = ENDED;
        o3.timer.stop();
        o3.on.call("interrupt", node, node.__data__, o3.index, o3.group);
        delete schedules[i4];
      } else if (+i4 < id2) {
        o3.state = ENDED;
        o3.timer.stop();
        o3.on.call("cancel", node, node.__data__, o3.index, o3.group);
        delete schedules[i4];
      }
    }
    timeout_default(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n4 = self2.tween.length);
    for (i4 = 0, j2 = -1; i4 < n4; ++i4) {
      if (o3 = self2.tween[i4].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j2] = o3;
      }
    }
    tween.length = j2 + 1;
  }
  function tick(elapsed) {
    var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i4 = -1, n4 = tween.length;
    while (++i4 < n4) {
      tween[i4].call(node, t2);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i4 in schedules)
      return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty2 = true, i4;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i4 in schedules) {
    if ((schedule = schedules[i4]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i4];
  }
  if (empty2)
    delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i4 = 0, n4 = tween1.length; i4 < n4; ++i4) {
        if (tween1[i4].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i4, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t2 = { name, value }, i4 = 0, n4 = tween1.length; i4 < n4; ++i4) {
        if (tween1[i4].name === name) {
          tween1[i4] = t2;
          break;
        }
      }
      if (i4 === n4)
        tween1.push(t2);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get3(this.node(), id2).tween;
    for (var i4 = 0, n4 = tween.length, t2; i4 < n4; ++i4) {
      if ((t2 = tween[i4]).name === name) {
        return t2.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get3(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a3, b2) {
  var c4;
  return (typeof b2 === "number" ? number_default : b2 instanceof color ? rgb_default : (c4 = color(b2)) ? (b2 = c4, rgb_default) : string_default)(a3, b2);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i4 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i4, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i4, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i4) {
  return function(t2) {
    this.setAttribute(name, i4.call(this, t2));
  };
}
function attrInterpolateNS(fullname, i4) {
  return function(t2) {
    this.setAttributeNS(fullname.space, fullname.local, i4.call(this, t2));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i4 = value.apply(this, arguments);
    if (i4 !== i0)
      t0 = (i0 = i4) && attrInterpolateNS(fullname, i4);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i4 = value.apply(this, arguments);
    if (i4 !== i0)
      t0 = (i0 = i4) && attrInterpolate(name, i4);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get3(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get3(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get3(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (typeof v2 !== "function")
      throw new Error();
    set2(this, id2).ease = v2;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m3 = groups.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    for (var group = groups[j2], n4 = group.length, subgroup = subgroups[j2] = [], node, i4 = 0; i4 < n4; ++i4) {
      if ((node = group[i4]) && match.call(node, node.__data__, i4, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default3(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m3; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n4 = group0.length, merge2 = merges[j2] = new Array(n4), node, i4 = 0; i4 < n4; ++i4) {
      if (node = group0[i4] || group1[i4]) {
        merge2[i4] = node;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t2) {
    var i4 = t2.indexOf(".");
    if (i4 >= 0)
      t2 = t2.slice(0, i4);
    return !t2 || t2 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get3(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i4 in this.__transition)
      if (+i4 !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default2(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m3 = groups.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
    for (var group = groups[j2], n4 = group.length, subgroup = subgroups[j2] = new Array(n4), node, subnode, i4 = 0; i4 < n4; ++i4) {
      if ((node = group[i4]) && (subnode = select.call(node, node.__data__, i4, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i4] = subnode;
        schedule_default(subgroup[i4], name, id2, i4, subgroup, get3(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default2(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selectorAll_default(select);
  for (var groups = this._groups, m3 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m3; ++j2) {
    for (var group = groups[j2], n4 = group.length, node, i4 = 0; i4 < n4; ++i4) {
      if (node = group[i4]) {
        for (var children2 = select.call(node, node.__data__, i4, group), child, inherit2 = get3(node, id2), k5 = 0, l3 = children2.length; k5 < l3; ++k5) {
          if (child = children2[k5]) {
            schedule_default(child, name, id2, k5, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i4 = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i4)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i4, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i4, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i4, priority) {
  return function(t2) {
    this.style.setProperty(name, i4.call(this, t2), priority);
  };
}
function styleTween(name, value, priority) {
  var t2, i0;
  function tween() {
    var i4 = value.apply(this, arguments);
    if (i4 !== i0)
      t2 = (i0 = i4) && styleInterpolate(name, i4, priority);
    return t2;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i4) {
  return function(t2) {
    this.textContent = i4.call(this, t2);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i4 = value.apply(this, arguments);
    if (i4 !== i0)
      t0 = (i0 = i4) && textInterpolate(i4);
    return t0;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m3 = groups.length, j2 = 0; j2 < m3; ++j2) {
    for (var group = groups[j2], n4 = group.length, node, i4 = 0; i4 < n4; ++i4) {
      if (node = group[i4]) {
        var inherit2 = get3(node, id0);
        schedule_default(node, name, id1, i4, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default2,
  selectAll: selectAll_default2,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default3,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
}

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m3 = groups.length, j2 = 0; j2 < m3; ++j2) {
    for (var group = groups[j2], n4 = group.length, node, i4 = 0; i4 < n4; ++i4) {
      if (node = group[i4]) {
        schedule_default(node, name, id2, i4, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-brush/src/brush.js
var { abs: abs2, max, min } = Math;
function number1(e8) {
  return [+e8[0], +e8[1]];
}
function number2(e8) {
  return [number1(e8[0]), number1(e8[1])];
}
var X2 = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x6, e8) {
    return x6 == null ? null : [[+x6[0], e8[0][1]], [+x6[1], e8[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y2 = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y6, e8) {
    return y6 == null ? null : [[e8[0][0], +y6[0]], [e8[1][0], +y6[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number2(xy);
  },
  output: function(xy) {
    return xy;
  }
};
function type(t2) {
  return { type: t2 };
}

// node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;
function append(strings) {
  this._ += strings[0];
  for (let i4 = 1, n4 = strings.length; i4 < n4; ++i4) {
    this._ += arguments[i4] + strings[i4];
  }
}
function appendRound(digits2) {
  let d3 = Math.floor(digits2);
  if (!(d3 >= 0))
    throw new Error(`invalid digits: ${digits2}`);
  if (d3 > 15)
    return append;
  const k5 = 10 ** d3;
  return function(strings) {
    this._ += strings[0];
    for (let i4 = 1, n4 = strings.length; i4 < n4; ++i4) {
      this._ += Math.round(arguments[i4] * k5) / k5 + strings[i4];
    }
  };
}
var Path2 = class {
  constructor(digits2) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits2 == null ? append : appendRound(digits2);
  }
  moveTo(x6, y6) {
    this._append`M${this._x0 = this._x1 = +x6},${this._y0 = this._y1 = +y6}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x6, y6) {
    this._append`L${this._x1 = +x6},${this._y1 = +y6}`;
  }
  quadraticCurveTo(x1, y1, x6, y6) {
    this._append`Q${+x1},${+y1},${this._x1 = +x6},${this._y1 = +y6}`;
  }
  bezierCurveTo(x1, y1, x22, y22, x6, y6) {
    this._append`C${+x1},${+y1},${+x22},${+y22},${this._x1 = +x6},${this._y1 = +y6}`;
  }
  arcTo(x1, y1, x22, y22, r5) {
    x1 = +x1, y1 = +y1, x22 = +x22, y22 = +y22, r5 = +r5;
    if (r5 < 0)
      throw new Error(`negative radius: ${r5}`);
    let x0 = this._x1, y0 = this._y1, x21 = x22 - x1, y21 = y22 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r5) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x22 - x0, y20 = y22 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l3 = r5 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l3 / l01, t21 = l3 / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r5},${r5},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x6, y6, r5, a0, a1, ccw) {
    x6 = +x6, y6 = +y6, r5 = +r5, ccw = !!ccw;
    if (r5 < 0)
      throw new Error(`negative radius: ${r5}`);
    let dx = r5 * Math.cos(a0), dy = r5 * Math.sin(a0), x0 = x6 + dx, y0 = y6 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }
    if (!r5)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._append`A${r5},${r5},0,1,${cw},${x6 - dx},${y6 - dy}A${r5},${r5},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon) {
      this._append`A${r5},${r5},0,${+(da >= pi)},${cw},${this._x1 = x6 + r5 * Math.cos(a1)},${this._y1 = y6 + r5 * Math.sin(a1)}`;
    }
  }
  rect(x6, y6, w3, h4) {
    this._append`M${this._x0 = this._x1 = +x6},${this._y0 = this._y1 = +y6}h${w3 = +w3}v${+h4}h${-w3}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path2();
}
path.prototype = Path2.prototype;

// node_modules/d3-force/src/center.js
function center_default(x6, y6) {
  var nodes, strength = 1;
  if (x6 == null)
    x6 = 0;
  if (y6 == null)
    y6 = 0;
  function force() {
    var i4, n4 = nodes.length, node, sx = 0, sy = 0;
    for (i4 = 0; i4 < n4; ++i4) {
      node = nodes[i4], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n4 - x6) * strength, sy = (sy / n4 - y6) * strength, i4 = 0; i4 < n4; ++i4) {
      node = nodes[i4], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x6 = +_2, force) : x6;
  };
  force.y = function(_2) {
    return arguments.length ? (y6 = +_2, force) : y6;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}

// node_modules/d3-quadtree/src/add.js
function add_default(d3) {
  const x6 = +this._x.call(null, d3), y6 = +this._y.call(null, d3);
  return add(this.cover(x6, y6), x6, y6, d3);
}
function add(tree, x6, y6, d3) {
  if (isNaN(x6) || isNaN(y6))
    return tree;
  var parent, node = tree._root, leaf = { data: d3 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i4, j2;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x6 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom = y6 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
    if (parent = node, !(node = node[i4 = bottom << 1 | right]))
      return parent[i4] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x6 === xp && y6 === yp)
    return leaf.next = node, parent ? parent[i4] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i4] = new Array(4) : tree._root = new Array(4);
    if (right = x6 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom = y6 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
  } while ((i4 = bottom << 1 | right) === (j2 = (yp >= ym) << 1 | xp >= xm));
  return parent[j2] = node, parent[i4] = leaf, tree;
}
function addAll(data) {
  var d3, i4, n4 = data.length, x6, y6, xz = new Array(n4), yz = new Array(n4), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i4 = 0; i4 < n4; ++i4) {
    if (isNaN(x6 = +this._x.call(null, d3 = data[i4])) || isNaN(y6 = +this._y.call(null, d3)))
      continue;
    xz[i4] = x6;
    yz[i4] = y6;
    if (x6 < x0)
      x0 = x6;
    if (x6 > x1)
      x1 = x6;
    if (y6 < y0)
      y0 = y6;
    if (y6 > y1)
      y1 = y6;
  }
  if (x0 > x1 || y0 > y1)
    return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i4 = 0; i4 < n4; ++i4) {
    add(this, xz[i4], yz[i4], data[i4]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x6, y6) {
  if (isNaN(x6 = +x6) || isNaN(y6 = +y6))
    return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x6)) + 1;
    y1 = (y0 = Math.floor(y6)) + 1;
  } else {
    var z2 = x1 - x0 || 1, node = this._root, parent, i4;
    while (x0 > x6 || x6 >= x1 || y0 > y6 || y6 >= y1) {
      i4 = (y6 < y0) << 1 | x6 < x0;
      parent = new Array(4), parent[i4] = node, node = parent, z2 *= 2;
      switch (i4) {
        case 0:
          x1 = x0 + z2, y1 = y0 + z2;
          break;
        case 1:
          x0 = x1 - z2, y1 = y0 + z2;
          break;
        case 2:
          x1 = x0 + z2, y0 = y1 - z2;
          break;
        case 3:
          x0 = x1 - z2, y0 = y1 - z2;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default2() {
  var data = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data.push(node.data);
      while (node = node.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

// node_modules/d3-quadtree/src/find.js
function find_default(x6, y6, radius) {
  var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q2, i4;
  if (node)
    quads.push(new quad_default(node, x0, y0, x32, y32));
  if (radius == null)
    radius = Infinity;
  else {
    x0 = x6 - radius, y0 = y6 - radius;
    x32 = x6 + radius, y32 = y6 + radius;
    radius *= radius;
  }
  while (q2 = quads.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x32 || (y1 = q2.y0) > y32 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0)
      continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x1, ym, xm, y22),
        new quad_default(node[1], xm, y1, x22, ym),
        new quad_default(node[0], x1, y1, xm, ym)
      );
      if (i4 = (y6 >= ym) << 1 | x6 >= xm) {
        q2 = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i4];
        quads[quads.length - 1 - i4] = q2;
      }
    } else {
      var dx = x6 - +this._x.call(null, node.data), dy = y6 - +this._y.call(null, node.data), d22 = dx * dx + dy * dy;
      if (d22 < radius) {
        var d3 = Math.sqrt(radius = d22);
        x0 = x6 - d3, y0 = y6 - d3;
        x32 = x6 + d3, y32 = y6 + d3;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default3(d3) {
  if (isNaN(x6 = +this._x.call(null, d3)) || isNaN(y6 = +this._y.call(null, d3)))
    return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x6, y6, xm, ym, right, bottom, i4, j2;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x6 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (bottom = y6 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
      if (!(parent = node, node = node[i4 = bottom << 1 | right]))
        return this;
      if (!node.length)
        break;
      if (parent[i4 + 1 & 3] || parent[i4 + 2 & 3] || parent[i4 + 3 & 3])
        retainer = parent, j2 = i4;
    }
  while (node.data !== d3)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i4] = next : delete parent[i4];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j2] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i4 = 0, n4 = data.length; i4 < n4; ++i4)
    this.remove(data[i4]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default2() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default2() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size;
      while (node = node.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q2, node = this._root, child, x0, y0, x1, y1;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x1, y1));
      if (child = node[2])
        quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x0, y0, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q2;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x0, y0, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x1, y1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.y0, q2.x1, q2.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d3) {
  return d3[0];
}
function x_default(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d3) {
  return d3[1];
}
function y_default(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x6, y6) {
  var tree = new Quadtree(x6 == null ? defaultX : x6, y6 == null ? defaultY : y6, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x6, y6, x0, y0, x1, y1) {
  this._x = x6;
  this._y = y6;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy2 = { data: leaf.data }, next = copy2;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy2;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy2;
  if (!node.length)
    return copy2._root = leaf_copy(node), copy2;
  nodes = [{ source: node, target: copy2._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i4 = 0; i4 < 4; ++i4) {
      if (child = node.source[i4]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i4] = new Array(4) });
        else
          node.target[i4] = leaf_copy(child);
      }
    }
  }
  return copy2;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default2;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default3;
treeProto.removeAll = removeAll;
treeProto.root = root_default2;
treeProto.size = size_default2;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default5(x6) {
  return function() {
    return x6;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random) {
  return (random() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/collide.js
function x2(d3) {
  return d3.x + d3.vx;
}
function y2(d3) {
  return d3.y + d3.vy;
}
function collide_default(radius) {
  var nodes, radii, random, strength = 1, iterations = 1;
  if (typeof radius !== "function")
    radius = constant_default5(radius == null ? 1 : +radius);
  function force() {
    var i4, n4 = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k5 = 0; k5 < iterations; ++k5) {
      tree = quadtree(nodes, x2, y2).visitAfter(prepare2);
      for (i4 = 0; i4 < n4; ++i4) {
        node = nodes[i4];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply2);
      }
    }
    function apply2(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r5 = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x6 = xi - data.x - data.vx, y6 = yi - data.y - data.vy, l3 = x6 * x6 + y6 * y6;
          if (l3 < r5 * r5) {
            if (x6 === 0)
              x6 = jiggle_default(random), l3 += x6 * x6;
            if (y6 === 0)
              y6 = jiggle_default(random), l3 += y6 * y6;
            l3 = (r5 - (l3 = Math.sqrt(l3))) / l3 * strength;
            node.vx += (x6 *= l3) * (r5 = (rj *= rj) / (ri2 + rj));
            node.vy += (y6 *= l3) * r5;
            data.vx -= x6 * (r5 = 1 - r5);
            data.vy -= y6 * r5;
          }
        }
        return;
      }
      return x0 > xi + r5 || x1 < xi - r5 || y0 > yi + r5 || y1 < yi - r5;
    }
  }
  function prepare2(quad) {
    if (quad.data)
      return quad.r = radii[quad.data.index];
    for (var i4 = quad.r = 0; i4 < 4; ++i4) {
      if (quad[i4] && quad[i4].r > quad.r) {
        quad.r = quad[i4].r;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i4, n4 = nodes.length, node;
    radii = new Array(n4);
    for (i4 = 0; i4 < n4; ++i4)
      node = nodes[i4], radii[node.index] = +radius(node, i4, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default5(+_2), initialize(), force) : radius;
  };
  return force;
}

// node_modules/d3-force/src/link.js
function index(d3) {
  return d3.index;
}
function find2(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id2 = index, strength = defaultStrength, strengths, distance = constant_default5(30), distances, nodes, count2, bias2, random, iterations = 1;
  if (links == null)
    links = [];
  function defaultStrength(link) {
    return 1 / Math.min(count2[link.source.index], count2[link.target.index]);
  }
  function force(alpha) {
    for (var k5 = 0, n4 = links.length; k5 < iterations; ++k5) {
      for (var i4 = 0, link, source, target, x6, y6, l3, b2; i4 < n4; ++i4) {
        link = links[i4], source = link.source, target = link.target;
        x6 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
        y6 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
        l3 = Math.sqrt(x6 * x6 + y6 * y6);
        l3 = (l3 - distances[i4]) / l3 * alpha * strengths[i4];
        x6 *= l3, y6 *= l3;
        target.vx -= x6 * (b2 = bias2[i4]);
        target.vy -= y6 * b2;
        source.vx += x6 * (b2 = 1 - b2);
        source.vy += y6 * b2;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i4, n4 = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d3, i5) => [id2(d3, i5, nodes), d3])), link;
    for (i4 = 0, count2 = new Array(n4); i4 < m3; ++i4) {
      link = links[i4], link.index = i4;
      if (typeof link.source !== "object")
        link.source = find2(nodeById, link.source);
      if (typeof link.target !== "object")
        link.target = find2(nodeById, link.target);
      count2[link.source.index] = (count2[link.source.index] || 0) + 1;
      count2[link.target.index] = (count2[link.target.index] || 0) + 1;
    }
    for (i4 = 0, bias2 = new Array(m3); i4 < m3; ++i4) {
      link = links[i4], bias2[i4] = count2[link.source.index] / (count2[link.source.index] + count2[link.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i4 = 0, n4 = links.length; i4 < n4; ++i4) {
      strengths[i4] = +strength(links[i4], i4, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i4 = 0, n4 = links.length; i4 < n4; ++i4) {
      distances[i4] = +distance(links[i4], i4, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id2 = _2, force) : id2;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default5(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance = typeof _2 === "function" ? _2 : constant_default5(+_2), initializeDistance(), force) : distance;
  };
  return force;
}

// node_modules/d3-force/src/lcg.js
var a2 = 1664525;
var c3 = 1013904223;
var m2 = 4294967296;
function lcg_default() {
  let s3 = 1;
  return () => (s3 = (a2 * s3 + c3) % m2) / m2;
}

// node_modules/d3-force/src/simulation.js
function x3(d3) {
  return d3.x;
}
function y3(d3) {
  return d3.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default();
  if (nodes == null)
    nodes = [];
  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick(iterations) {
    var i4, n4 = nodes.length, node;
    if (iterations === void 0)
      iterations = 1;
    for (var k5 = 0; k5 < iterations; ++k5) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i4 = 0; i4 < n4; ++i4) {
        node = nodes[i4];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i4 = 0, n4 = nodes.length, node; i4 < n4; ++i4) {
      node = nodes[i4], node.index = i4;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i4), angle = i4 * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random = _2, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
    },
    find: function(x6, y6, radius) {
      var i4 = 0, n4 = nodes.length, dx, dy, d22, node, closest;
      if (radius == null)
        radius = Infinity;
      else
        radius *= radius;
      for (i4 = 0; i4 < n4; ++i4) {
        node = nodes[i4];
        dx = x6 - node.x;
        dy = y6 - node.y;
        d22 = dx * dx + dy * dy;
        if (d22 < radius)
          closest = node, radius = d22;
      }
      return closest;
    },
    on: function(name, _2) {
      return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random, alpha, strength = constant_default5(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i4, n4 = nodes.length, tree = quadtree(nodes, x3, y3).visitAfter(accumulate);
    for (alpha = _2, i4 = 0; i4 < n4; ++i4)
      node = nodes[i4], tree.visit(apply2);
  }
  function initialize() {
    if (!nodes)
      return;
    var i4, n4 = nodes.length, node2;
    strengths = new Array(n4);
    for (i4 = 0; i4 < n4; ++i4)
      node2 = nodes[i4], strengths[node2.index] = +strength(node2, i4, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q2, c4, weight = 0, x6, y6, i4;
    if (quad.length) {
      for (x6 = y6 = i4 = 0; i4 < 4; ++i4) {
        if ((q2 = quad[i4]) && (c4 = Math.abs(q2.value))) {
          strength2 += q2.value, weight += c4, x6 += c4 * q2.x, y6 += c4 * q2.y;
        }
      }
      quad.x = x6 / weight;
      quad.y = y6 / weight;
    } else {
      q2 = quad;
      q2.x = q2.data.x;
      q2.y = q2.data.y;
      do
        strength2 += strengths[q2.data.index];
      while (q2 = q2.next);
    }
    quad.value = strength2;
  }
  function apply2(quad, x1, _2, x22) {
    if (!quad.value)
      return true;
    var x6 = quad.x - node.x, y6 = quad.y - node.y, w3 = x22 - x1, l3 = x6 * x6 + y6 * y6;
    if (w3 * w3 / theta2 < l3) {
      if (l3 < distanceMax2) {
        if (x6 === 0)
          x6 = jiggle_default(random), l3 += x6 * x6;
        if (y6 === 0)
          y6 = jiggle_default(random), l3 += y6 * y6;
        if (l3 < distanceMin2)
          l3 = Math.sqrt(distanceMin2 * l3);
        node.vx += x6 * quad.value * alpha / l3;
        node.vy += y6 * quad.value * alpha / l3;
      }
      return true;
    } else if (quad.length || l3 >= distanceMax2)
      return;
    if (quad.data !== node || quad.next) {
      if (x6 === 0)
        x6 = jiggle_default(random), l3 += x6 * x6;
      if (y6 === 0)
        y6 = jiggle_default(random), l3 += y6 * y6;
      if (l3 < distanceMin2)
        l3 = Math.sqrt(distanceMin2 * l3);
    }
    do
      if (quad.data !== node) {
        w3 = strengths[quad.data.index] * alpha / l3;
        node.vx += x6 * w3;
        node.vy += y6 * w3;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default5(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x6) {
  return Math.abs(x6 = Math.round(x6)) >= 1e21 ? x6.toLocaleString("en").replace(/,/g, "") : x6.toString(10);
}
function formatDecimalParts(x6, p7) {
  if (!isFinite(x6) || x6 === 0)
    return null;
  var i4 = (x6 = p7 ? x6.toExponential(p7 - 1) : x6.toExponential()).indexOf("e"), coefficient = x6.slice(0, i4);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x6.slice(i4 + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x6) {
  return x6 = formatDecimalParts(Math.abs(x6)), x6 ? x6[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i4 = value.length, t2 = [], j2 = 0, g3 = grouping[0], length = 0;
    while (i4 > 0 && g3 > 0) {
      if (length + g3 + 1 > width)
        g3 = Math.max(1, width - length);
      t2.push(value.substring(i4 -= g3, i4 + g3));
      if ((length += g3 + 1) > width)
        break;
      g3 = grouping[j2 = (j2 + 1) % grouping.length];
    }
    return t2.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i4) {
      return numerals[+i4];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s3) {
  out:
    for (var n4 = s3.length, i4 = 1, i0 = -1, i1; i4 < n4; ++i4) {
      switch (s3[i4]) {
        case ".":
          i0 = i1 = i4;
          break;
        case "0":
          if (i0 === 0)
            i0 = i4;
          i1 = i4;
          break;
        default:
          if (!+s3[i4])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x6, p7) {
  var d3 = formatDecimalParts(x6, p7);
  if (!d3)
    return prefixExponent = void 0, x6.toPrecision(p7);
  var coefficient = d3[0], exponent = d3[1], i4 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n4 = coefficient.length;
  return i4 === n4 ? coefficient : i4 > n4 ? coefficient + new Array(i4 - n4 + 1).join("0") : i4 > 0 ? coefficient.slice(0, i4) + "." + coefficient.slice(i4) : "0." + new Array(1 - i4).join("0") + formatDecimalParts(x6, Math.max(0, p7 + i4 - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x6, p7) {
  var d3 = formatDecimalParts(x6, p7);
  if (!d3)
    return x6 + "";
  var coefficient = d3[0], exponent = d3[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x6, p7) => (x6 * 100).toFixed(p7),
  "b": (x6) => Math.round(x6).toString(2),
  "c": (x6) => x6 + "",
  "d": formatDecimal_default,
  "e": (x6, p7) => x6.toExponential(p7),
  "f": (x6, p7) => x6.toFixed(p7),
  "g": (x6, p7) => x6.toPrecision(p7),
  "o": (x6) => Math.round(x6).toString(8),
  "p": (x6, p7) => formatRounded_default(x6 * 100, p7),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x6) => Math.round(x6).toString(16).toUpperCase(),
  "x": (x6) => Math.round(x6).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default2(x6) {
  return x6;
}

// node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default2 : formatGroup_default(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default2 : formatNumerals_default(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier, options) {
    specifier = formatSpecifier(specifier);
    var fill2 = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero4 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero4 || fill2 === "0" && align === "=")
      zero4 = true, fill2 = "0", align = "=";
    var prefix = (options && options.prefix !== void 0 ? options.prefix : "") + (symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : ""), suffix = (symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "") + (options && options.suffix !== void 0 ? options.suffix : "");
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i4, n4, c4;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type2 === "s" && !isNaN(value) && prefixExponent !== void 0 ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i4 = -1, n4 = value.length;
          while (++i4 < n4) {
            if (c4 = value.charCodeAt(i4), 48 > c4 || c4 > 57) {
              valueSuffix = (c4 === 46 ? decimal + value.slice(i4 + 1) : value.slice(i4)) + valueSuffix;
              value = value.slice(0, i4);
              break;
            }
          }
        }
      }
      if (comma && !zero4)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill2) : "";
      if (comma && zero4)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var e8 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k5 = Math.pow(10, -e8), f5 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier), { suffix: prefixes[8 + e8 / 3] });
    return function(value2) {
      return f5(k5 * value2);
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition29) {
  locale = locale_default(definition29);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max3) {
  step = Math.abs(step), max3 = Math.abs(max3) - step;
  return Math.max(0, exponent_default(max3) - exponent_default(step)) + 1;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum = 0, children2 = node.children, i4 = children2 && children2.length;
  if (!i4)
    sum = 1;
  else
    while (--i4 >= 0)
      sum += children2[i4].value;
  node.value = sum;
}
function count_default() {
  return this.eachAfter(count);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children2, i4, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children2 = node.children) {
      for (i4 = children2.length - 1; i4 >= 0; --i4) {
        nodes.push(children2[i4]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children2, i4, n4, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children2 = node.children) {
      for (i4 = 0, n4 = children2.length; i4 < n4; ++i4) {
        nodes.push(children2[i4]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0, children2 = node.children, i4 = children2 && children2.length;
    while (--i4 >= 0)
      sum += children2[i4].value;
    node.value = sum;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default2(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k5 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k5, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a3, b2) {
  if (a3 === b2)
    return a3;
  var aNodes = a3.ancestors(), bNodes = b2.ancestors(), c4 = null;
  a3 = aNodes.pop();
  b2 = bNodes.pop();
  while (a3 === b2) {
    c4 = a3;
    a3 = aNodes.pop();
    b2 = bNodes.pop();
  }
  return c4;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root4 = this, links = [];
  root4.each(function(node) {
    if (node !== root4) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default2() {
  var node = this, current, next = [node], children2, i4, n4;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children2 = node.children) {
        for (i4 = 0, n4 = children2.length; i4 < n4; ++i4) {
          next.push(children2[i4]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children2) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children2 === void 0)
      children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root4 = new Node2(data), node, nodes = [root4], child, childs, i4, n4;
  while (node = nodes.pop()) {
    if ((childs = children2(node.data)) && (n4 = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i4 = n4 - 1; i4 >= 0; --i4) {
        nodes.push(child = childs[i4] = new Node2(childs[i4]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root4.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d3) {
  return d3.children;
}
function mapChildren(d3) {
  return Array.isArray(d3) ? d3[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node2(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node2.prototype = hierarchy.prototype = {
  constructor: Node2,
  count: count_default,
  each: each_default2,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default2,
  path: path_default,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default2
};

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation(a3, b2) {
  return a3.parent === b2.parent ? 1 : 2;
}
function nextLeft(v2) {
  var children2 = v2.children;
  return children2 ? children2[0] : v2.t;
}
function nextRight(v2) {
  var children2 = v2.children;
  return children2 ? children2[children2.length - 1] : v2.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v2) {
  var shift = 0, change = 0, children2 = v2.children, i4 = children2.length, w3;
  while (--i4 >= 0) {
    w3 = children2[i4];
    w3.z += shift;
    w3.m += shift;
    shift += w3.s + (change += w3.c);
  }
}
function nextAncestor(vim, v2, ancestor) {
  return vim.a.parent === v2.parent ? vim.a : ancestor;
}
function TreeNode(node, i4) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i4;
}
TreeNode.prototype = Object.create(Node2.prototype);
function treeRoot(root4) {
  var tree = new TreeNode(root4, 0), node, nodes = [tree], child, children2, i4, n4;
  while (node = nodes.pop()) {
    if (children2 = node._.children) {
      node.children = new Array(n4 = children2.length);
      for (i4 = n4 - 1; i4 >= 0; --i4) {
        nodes.push(child = node.children[i4] = new TreeNode(children2[i4], i4));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
  function tree(root4) {
    var t2 = treeRoot(root4);
    t2.eachAfter(firstWalk), t2.parent.m = -t2.z;
    t2.eachBefore(secondWalk);
    if (nodeSize)
      root4.eachBefore(sizeNode);
    else {
      var left = root4, right = root4, bottom = root4;
      root4.eachBefore(function(node) {
        if (node.x < left.x)
          left = node;
        if (node.x > right.x)
          right = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s3 = left === right ? 1 : separation(left, right) / 2, tx = s3 - left.x, kx = dx / (right.x + s3 + tx), ky = dy / (bottom.depth || 1);
      root4.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root4;
  }
  function firstWalk(v2) {
    var children2 = v2.children, siblings = v2.parent.children, w3 = v2.i ? siblings[v2.i - 1] : null;
    if (children2) {
      executeShifts(v2);
      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
      if (w3) {
        v2.z = w3.z + separation(v2._, w3._);
        v2.m = v2.z - midpoint;
      } else {
        v2.z = midpoint;
      }
    } else if (w3) {
      v2.z = w3.z + separation(v2._, w3._);
    }
    v2.parent.A = apportion(v2, w3, v2.parent.A || siblings[0]);
  }
  function secondWalk(v2) {
    v2._.x = v2.z + v2.parent.m;
    v2.m += v2.parent.m;
  }
  function apportion(v2, w3, ancestor) {
    if (w3) {
      var vip = v2, vop = v2, vim = w3, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v2;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v2;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x6) {
    return arguments.length ? (separation = x6, tree) : separation;
  };
  tree.size = function(x6) {
    return arguments.length ? (nodeSize = false, dx = +x6[0], dy = +x6[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x6) {
    return arguments.length ? (nodeSize = true, dx = +x6[0], dy = +x6[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-scale/src/constant.js
function constants(x6) {
  return function() {
    return x6;
  };
}

// node_modules/d3-scale/src/number.js
function number3(x6) {
  return +x6;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity4(x6) {
  return x6;
}
function normalize(a3, b2) {
  return (b2 -= a3 = +a3) ? function(x6) {
    return (x6 - a3) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a3, b2) {
  var t2;
  if (a3 > b2)
    t2 = a3, a3 = b2, b2 = t2;
  return function(x6) {
    return Math.max(a3, Math.min(b2, x6));
  };
}
function bimap(domain, range, interpolate) {
  var d03 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d03)
    d03 = normalize(d1, d03), r0 = interpolate(r1, r0);
  else
    d03 = normalize(d03, d1), r0 = interpolate(r0, r1);
  return function(x6) {
    return r0(d03(x6));
  };
}
function polymap(domain, range, interpolate) {
  var j2 = Math.min(domain.length, range.length) - 1, d3 = new Array(j2), r5 = new Array(j2), i4 = -1;
  if (domain[j2] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i4 < j2) {
    d3[i4] = normalize(domain[i4], domain[i4 + 1]);
    r5[i4] = interpolate(range[i4], range[i4 + 1]);
  }
  return function(x6) {
    var i5 = bisect_default(domain, x6, 1, j2) - 1;
    return r5[i5](d3[i5](x6));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range = unit, interpolate = value_default, transform2, untransform, unknown, clamp2 = identity4, piecewise, output, input;
  function rescale() {
    var n4 = Math.min(domain.length, range.length);
    if (clamp2 !== identity4)
      clamp2 = clamper(domain[0], domain[n4 - 1]);
    piecewise = n4 > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x6) {
    return x6 == null || isNaN(x6 = +x6) ? unknown : (output || (output = piecewise(domain.map(transform2), range, interpolate)))(transform2(clamp2(x6)));
  }
  scale.invert = function(y6) {
    return clamp2(untransform((input || (input = piecewise(range, domain.map(transform2), number_default)))(y6)));
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number3), rescale()) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range = Array.from(_2), rescale()) : range.slice();
  };
  scale.rangeRound = function(_2) {
    return range = Array.from(_2), interpolate = round_default2, rescale();
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp2 = _2 ? true : identity4, rescale()) : clamp2 !== identity4;
  };
  scale.interpolate = function(_2) {
    return arguments.length ? (interpolate = _2, rescale()) : interpolate;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t2, u4) {
    transform2 = t2, untransform = u4;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity4, identity4);
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count2, specifier) {
  var step = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d3 = domain();
    return ticks(d3[0], d3[d3.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d3 = domain();
    return tickFormat(d3[0], d3[d3.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d3 = domain();
    var i0 = 0;
    var i1 = d3.length - 1;
    var start2 = d3[i0];
    var stop = d3[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count2);
      if (step === prestep) {
        d3[i0] = start2;
        d3[i1] = stop;
        return domain(d3);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-shape/src/constant.js
function constant_default6(x6) {
  return function constant2() {
    return x6;
  };
}

// node_modules/d3-shape/src/math.js
var abs3 = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max2 = Math.max;
var min2 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon2 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var tau2 = 2 * pi2;
function acos(x6) {
  return x6 > 1 ? 0 : x6 < -1 ? pi2 : Math.acos(x6);
}
function asin(x6) {
  return x6 >= 1 ? halfPi : x6 <= -1 ? -halfPi : Math.asin(x6);
}

// node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits2 = 3;
  shape.digits = function(_2) {
    if (!arguments.length)
      return digits2;
    if (_2 == null) {
      digits2 = null;
    } else {
      const d3 = Math.floor(_2);
      if (!(d3 >= 0))
        throw new RangeError(`invalid digits: ${_2}`);
      digits2 = d3;
    }
    return shape;
  };
  return () => new Path2(digits2);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d3) {
  return d3.innerRadius;
}
function arcOuterRadius(d3) {
  return d3.outerRadius;
}
function arcStartAngle(d3) {
  return d3.startAngle;
}
function arcEndAngle(d3) {
  return d3.endAngle;
}
function arcPadAngle(d3) {
  return d3 && d3.padAngle;
}
function intersect(x0, y0, x1, y1, x22, y22, x32, y32) {
  var x10 = x1 - x0, y10 = y1 - y0, x322 = x32 - x22, y322 = y32 - y22, t2 = y322 * x10 - x322 * y10;
  if (t2 * t2 < epsilon2)
    return;
  t2 = (x322 * (y0 - y22) - y322 * (x0 - x22)) / t2;
  return [x0 + t2 * x10, y0 + t2 * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d22 = dx * dx + dy * dy, r5 = r1 - rc, D3 = x11 * y10 - x10 * y11, d3 = (dy < 0 ? -1 : 1) * sqrt(max2(0, r5 * r5 * d22 - D3 * D3)), cx0 = (D3 * dy - dx * d3) / d22, cy0 = (-D3 * dx - dy * d3) / d22, cx1 = (D3 * dy + dx * d3) / d22, cy1 = (-D3 * dx + dy * d3) / d22, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r5 - 1),
    y11: cy0 * (r1 / r5 - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default6(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
  function arc() {
    var buffer, r5, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs3(a1 - a0), cw = a1 > a0;
    if (!context)
      context = buffer = path2();
    if (r1 < r0)
      r5 = r1, r1 = r0, r0 = r5;
    if (!(r1 > epsilon2))
      context.moveTo(0, 0);
    else if (da > tau2 - epsilon2) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon2) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon2 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min2(abs3(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
      if (rp > epsilon2) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon2)
          p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon2)
          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon2) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
        if (da < pi2) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min2(rc, (r0 - lc) / (kc - 1));
            rc1 = min2(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon2))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon2) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc1 < rc)
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon2) || !(da0 > epsilon2))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon2) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc0 < rc)
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r5 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a3 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi2 / 2;
    return [cos(a3) * r5, sin(a3) * r5];
  };
  arc.innerRadius = function(_2) {
    return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant_default6(+_2), arc) : innerRadius;
  };
  arc.outerRadius = function(_2) {
    return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant_default6(+_2), arc) : outerRadius;
  };
  arc.cornerRadius = function(_2) {
    return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant_default6(+_2), arc) : cornerRadius;
  };
  arc.padRadius = function(_2) {
    return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default6(+_2), arc) : padRadius;
  };
  arc.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant_default6(+_2), arc) : startAngle;
  };
  arc.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant_default6(+_2), arc) : endAngle;
  };
  arc.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant_default6(+_2), arc) : padAngle;
  };
  arc.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, arc) : context;
  };
  return arc;
}

// node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default(x6) {
  return typeof x6 === "object" && "length" in x6 ? x6 : Array.from(x6);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y6) {
    x6 = +x6, y6 = +y6;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y6) : this._context.moveTo(x6, y6);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x6, y6);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x4(p7) {
  return p7[0];
}
function y4(p7) {
  return p7[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x6, y6) {
  var defined = constant_default6(true), context = null, curve = linear_default, output = null, path2 = withPath(line2);
  x6 = typeof x6 === "function" ? x6 : x6 === void 0 ? x4 : constant_default6(x6);
  y6 = typeof y6 === "function" ? y6 : y6 === void 0 ? y4 : constant_default6(y6);
  function line2(data) {
    var i4, n4 = (data = array_default(data)).length, d3, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path2());
    for (i4 = 0; i4 <= n4; ++i4) {
      if (!(i4 < n4 && defined(d3 = data[i4], i4, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x6(d3, i4, data), +y6(d3, i4, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line2.x = function(_2) {
    return arguments.length ? (x6 = typeof _2 === "function" ? _2 : constant_default6(+_2), line2) : x6;
  };
  line2.y = function(_2) {
    return arguments.length ? (y6 = typeof _2 === "function" ? _2 : constant_default6(+_2), line2) : y6;
  };
  line2.defined = function(_2) {
    return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant_default6(!!_2), line2) : defined;
  };
  line2.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line2) : curve;
  };
  line2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line2) : context;
  };
  return line2;
}

// node_modules/d3-shape/src/descending.js
function descending_default(a3, b2) {
  return b2 < a3 ? -1 : b2 > a3 ? 1 : b2 >= a3 ? 0 : NaN;
}

// node_modules/d3-shape/src/identity.js
function identity_default3(d3) {
  return d3;
}

// node_modules/d3-shape/src/pie.js
function pie_default() {
  var value = identity_default3, sortValues = descending_default, sort = null, startAngle = constant_default6(0), endAngle = constant_default6(tau2), padAngle = constant_default6(0);
  function pie(data) {
    var i4, n4 = (data = array_default(data)).length, j2, k5, sum = 0, index2 = new Array(n4), arcs = new Array(n4), a0 = +startAngle.apply(this, arguments), da = Math.min(tau2, Math.max(-tau2, endAngle.apply(this, arguments) - a0)), a1, p7 = Math.min(Math.abs(da) / n4, padAngle.apply(this, arguments)), pa = p7 * (da < 0 ? -1 : 1), v2;
    for (i4 = 0; i4 < n4; ++i4) {
      if ((v2 = arcs[index2[i4] = i4] = +value(data[i4], i4, data)) > 0) {
        sum += v2;
      }
    }
    if (sortValues != null)
      index2.sort(function(i5, j3) {
        return sortValues(arcs[i5], arcs[j3]);
      });
    else if (sort != null)
      index2.sort(function(i5, j3) {
        return sort(data[i5], data[j3]);
      });
    for (i4 = 0, k5 = sum ? (da - n4 * pa) / sum : 0; i4 < n4; ++i4, a0 = a1) {
      j2 = index2[i4], v2 = arcs[j2], a1 = a0 + (v2 > 0 ? v2 * k5 : 0) + pa, arcs[j2] = {
        data: data[j2],
        index: i4,
        value: v2,
        startAngle: a0,
        endAngle: a1,
        padAngle: p7
      };
    }
    return arcs;
  }
  pie.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant_default6(+_2), pie) : value;
  };
  pie.sortValues = function(_2) {
    return arguments.length ? (sortValues = _2, sort = null, pie) : sortValues;
  };
  pie.sort = function(_2) {
    return arguments.length ? (sort = _2, sortValues = null, pie) : sort;
  };
  pie.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant_default6(+_2), pie) : startAngle;
  };
  pie.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant_default6(+_2), pie) : endAngle;
  };
  pie.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant_default6(+_2), pie) : padAngle;
  };
  return pie;
}

// node_modules/d3-zoom/src/transform.js
function Transform(k5, x6, y6) {
  this.k = k5;
  this.x = x6;
  this.y = y6;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k5) {
    return k5 === 1 ? this : new Transform(this.k * k5, this.x, this.y);
  },
  translate: function(x6, y6) {
    return x6 === 0 & y6 === 0 ? this : new Transform(this.k, this.x + this.k * x6, this.y + this.k * y6);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x6) {
    return x6 * this.k + this.x;
  },
  applyY: function(y6) {
    return y6 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x6) {
    return (x6 - this.x) / this.k;
  },
  invertY: function(y6) {
    return (y6 - this.y) / this.k;
  },
  rescaleX: function(x6) {
    return x6.copy().domain(x6.range().map(this.invertX, this).map(x6.invert, x6));
  },
  rescaleY: function(y6) {
    return y6.copy().domain(y6.range().map(this.invertY, this).map(y6.invert, y6));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity5 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity5;
  return node.__zoom;
}

// node_modules/@antv/infographic/esm/designs/items/ProgressCard.js
var ProgressCard = (props) => {
  const [{ datum: datum2, data, indexes, width = 280, height = 120, iconSize = 32, gap = 12, progressHeight = 8, borderRadius = 12, positionH = "normal", themeColors, valueFormatter = (v2) => `${v2}%` }, restProps] = getItemProps(props, [
    "width",
    "height",
    "iconSize",
    "gap",
    "progressHeight",
    "borderRadius"
  ]);
  const value = datum2.value;
  const displayValue = value !== null && value !== void 0 ? value : 0;
  const maxValue = Math.max(...data.items.map((item) => {
    var _a;
    return (_a = item.value) !== null && _a !== void 0 ? _a : 0;
  }), 100);
  const progressWidth = width - 2 * gap;
  const progressScale = linear2().domain([0, maxValue]).range([0, progressWidth]);
  const progressFillWidth = progressScale(displayValue);
  const gradientId = `${themeColors.colorPrimary}-progress`;
  const progressBgId = `${themeColors.colorPrimaryBg}-progress-bg`;
  const labelBounds = getElementBounds(jsx(ItemLabel, { indexes }));
  const contentY = gap;
  const iconX = positionH === "flipped" ? width - gap - iconSize : gap;
  const iconY = contentY;
  const textStartX = positionH === "flipped" ? gap : iconSize + 2 * gap;
  const textWidth = width - iconSize - 3 * gap;
  const textY = iconY;
  const progressY = height - gap - progressHeight;
  const hasValue = value !== void 0;
  return jsxs(Group, Object.assign({}, restProps, { children: [jsxs(Defs, { children: [jsxs("linearGradient", { id: gradientId, x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [jsx("stop", { offset: "0%", stopColor: themeColors.colorPrimary }), jsx("stop", { offset: "100%", stopColor: tinycolor.mix(themeColors.colorPrimary, "#fff", 20).toHexString() })] }), jsxs("linearGradient", { id: progressBgId, x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [jsx("stop", { offset: "0%", stopColor: themeColors.colorPrimaryBg }), jsx("stop", { offset: "100%", stopColor: themeColors.colorBg })] })] }), jsx(Rect, { x: 0, y: 0, width, height, fill: themeColors.colorBgElevated, stroke: themeColors.colorPrimaryBg, strokeWidth: 1, rx: borderRadius, ry: borderRadius, "data-element-type": "shape" }), jsx(ItemIcon, { indexes, x: iconX, y: iconY, size: iconSize, fill: themeColors.colorPrimary }), jsx(ItemLabel, { indexes, x: textStartX, y: textY, width: textWidth, alignHorizontal: positionH === "flipped" ? "right" : "left", alignVertical: "top", fontSize: 16, fontWeight: "medium", fill: themeColors.colorText, children: datum2.label }), hasValue && jsx(ItemValue, { indexes, x: textStartX, y: textY + labelBounds.height, width: textWidth, alignHorizontal: positionH === "flipped" ? "right" : "left", alignVertical: "top", lineHeight: 1, fontSize: 24, fontWeight: "bold", fill: themeColors.colorPrimary, value: displayValue, formatter: valueFormatter }), jsx(ItemDesc, { indexes, x: textStartX, y: textY + labelBounds.height + (hasValue ? 27 : 4), width: textWidth, alignHorizontal: positionH === "flipped" ? "right" : "left", alignVertical: "top", fontSize: 11, fill: themeColors.colorTextSecondary, lineNumber: hasValue ? 2 : 3, wordWrap: true, children: datum2.desc }), jsx(Rect, { x: gap, y: progressY, width: progressWidth, height: progressHeight, fill: `url(#${progressBgId})`, rx: progressHeight / 2, ry: progressHeight / 2, "data-element-type": "shape" }), jsx(Rect, { x: gap, y: progressY, width: progressFillWidth, height: progressHeight, fill: `url(#${gradientId})`, rx: progressHeight / 2, ry: progressHeight / 2, "data-element-type": "shape" })] }));
};
registerItem("progress-card", {
  component: ProgressCard,
  composites: ["icon", "label", "value", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/QuarterCircular.js
var QuarterCircular = (props) => {
  const [{ datum: datum2, indexes, width = 280, height = 120, iconSize = 30, circleRadius = 80, positionH = "normal", positionV = "normal", themeColors }, restProps] = getItemProps(props, ["width", "height", "iconSize", "circleRadius"]);
  const CIRCLE_MASS = 4 * circleRadius / (3 * Math.PI);
  const LINE_WIDTH = 2;
  const DOT_RADIUS = 4;
  const VALUE_SIZE = 28;
  const CARD_Y = 20;
  const CARD_CONTENT_Y = CARD_Y + 20;
  const LABEL_Y = CARD_Y;
  const DESC_Y_OFFSET = 8;
  const DECORATION_VERTICAL_SPACING = 35;
  const DECORATION_HORIZONTAL_SPACING = 40;
  const DECORATION_END_SPACING = 30;
  const indexStr = String(indexes[0] + 1).padStart(2, "0");
  const isFlipped = positionH === "flipped";
  const isVFlipped = positionV === "flipped";
  const getDecorationCoords = () => {
    if (isFlipped) {
      return {
        diagonalStartX: width - DOT_RADIUS,
        diagonalStartY: isVFlipped ? height - DECORATION_VERTICAL_SPACING : DECORATION_VERTICAL_SPACING,
        diagonalEndX: width - DECORATION_HORIZONTAL_SPACING,
        diagonalEndY: isVFlipped ? height - DOT_RADIUS : DOT_RADIUS,
        topLineStartX: width - DECORATION_HORIZONTAL_SPACING,
        topLineEndX: CIRCLE_MASS,
        topLineY: isVFlipped ? height - DOT_RADIUS : DOT_RADIUS
      };
    } else {
      return {
        diagonalStartX: DOT_RADIUS,
        diagonalStartY: isVFlipped ? height - DECORATION_VERTICAL_SPACING : DECORATION_VERTICAL_SPACING,
        diagonalEndX: DECORATION_HORIZONTAL_SPACING,
        diagonalEndY: isVFlipped ? height - DOT_RADIUS : DOT_RADIUS,
        topLineStartX: DECORATION_HORIZONTAL_SPACING,
        topLineEndX: width - CIRCLE_MASS,
        topLineY: isVFlipped ? height - DOT_RADIUS : DOT_RADIUS
      };
    }
  };
  const getContentCoords = () => {
    if (isFlipped) {
      const contentX = circleRadius + 10;
      const contentWidth = width - contentX - DECORATION_HORIZONTAL_SPACING;
      return {
        valueX: width - DECORATION_END_SPACING,
        contentX,
        contentWidth,
        circleX: 0,
        circleY: isVFlipped ? 0 : height,
        iconX: CIRCLE_MASS - iconSize / 2
      };
    } else {
      return {
        valueX: 0,
        contentX: DECORATION_HORIZONTAL_SPACING,
        contentWidth: width - DECORATION_HORIZONTAL_SPACING - circleRadius - 10,
        circleX: width,
        circleY: isVFlipped ? 0 : height,
        iconX: width - CIRCLE_MASS - iconSize / 2
      };
    }
  };
  const decorationCoords = getDecorationCoords();
  const contentCoords = getContentCoords();
  const iconY = isVFlipped ? CIRCLE_MASS - iconSize / 2 : height - CIRCLE_MASS - iconSize / 2;
  const labelBounds = getElementBounds(jsx(ItemLabel, { indexes, width: contentCoords.contentWidth, children: datum2.label }));
  const descY = LABEL_Y + labelBounds.height + DESC_Y_OFFSET;
  const getQuarterCirclePath = () => {
    const { circleX, circleY } = contentCoords;
    if (isFlipped) {
      return isVFlipped ? `M ${circleX} ${circleY} L ${circleX} ${circleY + circleRadius} A ${circleRadius} ${circleRadius} 0 0 0 ${circleX + circleRadius} ${circleY} Z` : `M ${circleX} ${circleY} L ${circleX} ${circleY - circleRadius} A ${circleRadius} ${circleRadius} 0 0 1 ${circleX + circleRadius} ${circleY} Z`;
    } else {
      return isVFlipped ? `M ${circleX} ${circleY} L ${circleX} ${circleY + circleRadius} A ${circleRadius} ${circleRadius} 0 0 1 ${circleX - circleRadius} ${circleY} Z` : `M ${circleX} ${circleY} L ${circleX} ${circleY - circleRadius} A ${circleRadius} ${circleRadius} 0 0 0 ${circleX - circleRadius} ${circleY} Z`;
    }
  };
  return jsxs(Group, Object.assign({}, restProps, { width, height, children: [jsxs(ShapesGroup, { children: [jsx(Path, { d: `M ${decorationCoords.diagonalStartX} ${decorationCoords.diagonalStartY} L ${decorationCoords.diagonalEndX} ${decorationCoords.diagonalEndY}`, stroke: themeColors.colorPrimary, strokeWidth: LINE_WIDTH, fill: "none" }), jsx(Path, { d: `M ${decorationCoords.topLineStartX} ${decorationCoords.topLineY} L ${decorationCoords.topLineEndX} ${decorationCoords.topLineY}`, stroke: themeColors.colorPrimary, strokeWidth: LINE_WIDTH, fill: "none" }), jsx(Ellipse, { x: decorationCoords.diagonalStartX - DOT_RADIUS, y: decorationCoords.diagonalStartY - DOT_RADIUS, width: DOT_RADIUS * 2, height: DOT_RADIUS * 2, fill: themeColors.colorPrimary }), jsx(Ellipse, { x: decorationCoords.topLineEndX - DOT_RADIUS, y: decorationCoords.topLineY - DOT_RADIUS, width: DOT_RADIUS * 2, height: DOT_RADIUS * 2, fill: themeColors.colorPrimary })] }), jsxs(Group, { children: [jsx(Text, { x: contentCoords.valueX, y: CARD_CONTENT_Y, fontSize: VALUE_SIZE, fontWeight: "bold", fill: themeColors.colorPrimary, children: indexStr }), jsx(Path, { d: getQuarterCirclePath(), fill: themeColors.colorPrimary, "data-element-type": "shape" }), datum2.icon && jsx(ItemIcon, { indexes, x: contentCoords.iconX, y: iconY, size: iconSize, fill: themeColors.colorWhite }), datum2.label && jsx(ItemLabel, { indexes, x: contentCoords.contentX, y: LABEL_Y, width: contentCoords.contentWidth, fontWeight: "bold", fill: themeColors.colorText, alignHorizontal: isFlipped ? "right" : "left", children: datum2.label }), datum2.desc && jsx(ItemDesc, { indexes, x: contentCoords.contentX, y: descY, width: contentCoords.contentWidth, fill: themeColors.colorTextSecondary, alignHorizontal: isFlipped ? "right" : "left", children: datum2.desc })] })] }));
};
registerItem("quarter-circular", {
  component: QuarterCircular,
  composites: ["icon", "label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/QuarterSimpleCard.js
var QuarterSimpleCard = (props) => {
  const [{ datum: datum2, indexes, width = 150, height = 150, iconSize = 30, padding = 20, borderRadius = 16, positionH = "center", positionV = "middle", themeColors }, restProps] = getItemProps(props, [
    "width",
    "height",
    "iconSize",
    "padding",
    "borderRadius"
  ]);
  const contentWidth = width - padding * 2;
  const contentX = padding;
  const contentY = padding;
  const iconX = positionH === "flipped" ? width - padding - iconSize : positionH === "center" ? (width - iconSize) / 2 : contentX;
  const iconY = contentY;
  const labelY = iconY + iconSize + 8;
  const labelBounds = getElementBounds(jsx(ItemLabel, { indexes, width: contentWidth, children: datum2.label }));
  const labelX = positionH === "flipped" ? width - padding - contentWidth : positionH === "center" ? padding : contentX;
  const descY = labelY + labelBounds.height + 4;
  const descX = labelX;
  const r5 = borderRadius;
  let cardPath = "";
  if (positionH === "center" && positionV === "middle") {
    cardPath = `
  M ${r5} 0
  L ${width - r5} 0
  Q ${width} 0 ${width} ${r5}
  L ${width} ${height - r5}
  Q ${width} ${height} ${width - r5} ${height}
  L ${r5} ${height}
  Q 0 ${height} 0 ${height - r5}
  L 0 ${r5}
  Q 0 0 ${r5} 0
  Z
`;
  } else if (positionH === "flipped" && positionV === "flipped") {
    cardPath = `
  M ${r5} 0
  L ${width - r5} 0
  Q ${width} 0 ${width} ${r5}
  L ${width} ${height - r5}
  Q ${width} ${height} ${width - r5} ${height}
  L ${r5} ${height}
  Q 0 ${height} 0 ${height - r5}
  L 0 0
  L ${r5} 0
  Z
`;
  } else if (positionH === "normal" && positionV === "flipped") {
    cardPath = `
  M 0 0
  L ${width} 0
  L ${width} ${height - r5}
  Q ${width} ${height} ${width - r5} ${height}
  L ${r5} ${height}
  Q 0 ${height} 0 ${height - r5}
  L 0 ${r5}
  Q 0 0 ${r5} 0
  Z
`;
  } else if (positionH === "flipped") {
    cardPath = `
  M ${r5} 0
  L ${width - r5} 0
  Q ${width} 0 ${width} ${r5}
  L ${width} ${height - r5}
  Q ${width} ${height} ${width - r5} ${height}
  L 0 ${height}
  L 0 ${r5}
  Q 0 0 ${r5} 0
  Z
`;
  } else {
    cardPath = `
  M ${r5} 0
  L ${width - r5} 0
  Q ${width} 0 ${width} ${r5}
  L ${width} ${height}
  L ${r5} ${height}
  Q 0 ${height} 0 ${height - r5}
  L 0 ${r5}
  Q 0 0 ${r5} 0
  Z
`;
  }
  return jsxs(Group, Object.assign({}, restProps, { children: [jsx(Path, { d: cardPath, x: 0, y: 0, width, height, fill: themeColors.colorPrimary, "data-element-type": "shape" }), jsx(ItemIcon, { indexes, x: iconX, y: iconY, size: iconSize, fill: themeColors.colorBg }), jsx(ItemLabel, { indexes, x: labelX, y: labelY, width: contentWidth, fontSize: 14, fontWeight: "bold", fill: themeColors.colorBg, alignHorizontal: positionH === "flipped" ? "right" : "left", children: datum2.label }), datum2.desc && jsx(ItemDesc, { indexes, x: descX, y: descY, width: contentWidth, fontSize: 11, wordWrap: true, fill: themeColors.colorBg, alignHorizontal: positionH === "flipped" ? "right" : "left", children: datum2.desc })] }));
};
registerItem("quarter-simple-card", {
  component: QuarterSimpleCard,
  composites: ["icon", "label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/RibbonCard.js
var RibbonCard = (props) => {
  const [{ datum: datum2, indexes, width = 240, height = 140, iconSize = 28, gap = 12, ribbonHeight = 32, themeColors }, restProps] = getItemProps(props, [
    "width",
    "height",
    "iconSize",
    "gap",
    "ribbonHeight"
  ]);
  const gradientId = `${themeColors.colorPrimary}-ribbon`;
  return jsxs(Group, Object.assign({}, restProps, { children: [jsx(Defs, { children: jsxs("linearGradient", { id: gradientId, x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [jsx("stop", { offset: "0%", stopColor: themeColors.colorPrimary }), jsx("stop", { offset: "100%", stopColor: tinycolor(themeColors.colorPrimary).darken(15).toHexString() })] }) }), jsxs(ShapesGroup, { children: [jsx(Rect, { x: 0, y: 0, width, height, fill: themeColors.colorBgElevated, stroke: themeColors.colorPrimaryBg, strokeWidth: 1, rx: 8, ry: 8 }), jsx(Rect, { x: 0, y: 0, width, height: ribbonHeight, fill: `url(#${gradientId})`, rx: 8, ry: 8 }), jsx(Rect, { x: 0, y: 8, width, height: ribbonHeight - 8, fill: `url(#${gradientId})` }), jsx(Path, { x: width - 20, y: ribbonHeight, width: 20, height: 8, fill: tinycolor(themeColors.colorPrimary).darken(25).toHexString(), d: "M0,0 L20,0 L15,8 L5,8 Z" })] }), jsx(ItemIcon, { indexes, x: gap, y: ribbonHeight + gap, size: iconSize, fill: themeColors.colorPrimary }), jsx(ItemLabel, { indexes, x: iconSize + 2 * gap, y: ribbonHeight + gap, width: width - iconSize - 3 * gap, height: iconSize, alignHorizontal: "left", alignVertical: "middle", lineHeight: 1, fontWeight: "bold", fill: themeColors.colorText, children: datum2.label }), jsx(ItemDesc, { indexes, x: gap, y: ribbonHeight + iconSize + gap + 5, width: width - 2 * gap, alignHorizontal: "left", fill: themeColors.colorTextSecondary, lineNumber: 3, wordWrap: true, children: datum2.desc }), jsx(ItemIcon, { indexes, x: width - gap - 8, y: gap / 2, size: 16, fill: themeColors.colorWhite })] }));
};
registerItem("ribbon-card", {
  component: RibbonCard,
  composites: ["icon", "label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/RoundedRectNode.js
var RoundedRectNode = (props) => {
  const [{ indexes, datum: datum2, themeColors, width = 300, height = 40, padding = 4, positionH = "normal" }, restProps] = getItemProps(props, ["width", "height", "borderRadius", "padding"]);
  const borderRadius = height / 2;
  const textX = borderRadius;
  const textY = padding;
  const textWidth = width - borderRadius * 2;
  const textHeight = height - padding * 2;
  return jsxs(Group, Object.assign({}, restProps, { children: [jsx(Rect, { "data-element-type": "shape", width, height, rx: borderRadius, ry: borderRadius, fill: themeColors.colorPrimaryBg, stroke: themeColors.colorPrimary, strokeWidth: 1, opacity: 0.8 }), jsx(ItemLabel, { indexes, x: textX, y: textY, width: textWidth, height: textHeight, alignHorizontal: positionH === "flipped" ? "right" : positionH === "center" ? "center" : "left", alignVertical: "middle", fontSize: 14, fontWeight: "500", fill: themeColors.colorText, children: datum2.label })] }));
};
registerItem("rounded-rect-node", {
  component: RoundedRectNode,
  composites: ["label"]
});

// node_modules/@antv/infographic/esm/designs/items/SimpleCircleNode.js
var SimpleCircleNode = (props) => {
  const [{ width = 24, height = width, strokeWidth = 2, themeColors, datum: datum2 }, restProps] = getItemProps(props, ["width", "height"]);
  const size = Math.min(width, height) - strokeWidth;
  const offset = strokeWidth / 2;
  return jsxs(Group, Object.assign({}, restProps, { width, height, children: [jsx(Rect, { width, height, fill: "none", visibility: "hidden" }), jsx(Ellipse, { x: offset, y: offset, width: size, height: size, fill: themeColors.colorPrimary, stroke: themeColors.isDarkMode ? "#FFF" : "#000", strokeWidth, "data-element-type": "shape", children: jsx("title", { children: datum2.label || datum2.desc }) })] }));
};
registerItem("simple-circle-node", {
  component: SimpleCircleNode,
  composites: []
});

// node_modules/@antv/infographic/esm/designs/items/SimpleHorizontalArrow.js
var SimpleHorizontalArrow = (props) => {
  const [{ indexes, datum: datum2, width = 140, themeColors, positionV = "normal" }, restProps] = getItemProps(props, ["width"]);
  const isVNormal = positionV !== "flipped";
  const textAlignVertical = isVNormal ? "bottom" : "top";
  const label = jsx(ItemLabel, { indexes, width, fill: themeColors.colorText, alignHorizontal: "center", alignVertical: textAlignVertical, fontSize: 14, children: datum2.label });
  const desc = jsx(ItemDesc, { indexes, width, fill: themeColors.colorTextSecondary, alignHorizontal: "center", alignVertical: textAlignVertical, children: datum2.desc });
  const arrowHeight = 30;
  const labelGap = 10;
  const labelBounds = getElementBounds(label);
  const descBounds = getElementBounds(desc);
  const textHeight = labelBounds.height + descBounds.height;
  const totalHeight = textHeight + labelGap + arrowHeight + labelGap + textHeight;
  return jsx(Group, Object.assign({ width, height: totalHeight }, restProps, { children: jsxs(FlexLayout, { flexDirection: "column", alignItems: "center", children: [isVNormal ? jsxs(Fragment, { children: [desc, label, jsx(Gap, { height: labelGap })] }) : jsx(Fragment, { children: jsx(Gap, { height: textHeight + labelGap }) }), jsxs(AlignLayout, { horizontal: "center", vertical: "middle", children: [jsx(HorizontalArrow2, { width, height: arrowHeight, fill: themeColors.colorPrimary }), jsx(Text, { width, height: arrowHeight, alignHorizontal: "center", alignVertical: "middle", fill: themeColors.colorWhite, fontWeight: "bold", fontSize: 16, children: datum2.time ? datum2.time : String(indexes[0] + 1).padStart(2, "0").slice(-2) })] }), !isVNormal ? jsxs(Fragment, { children: [jsx(Gap, { height: labelGap }), label, desc] }) : jsx(Fragment, { children: jsx(Gap, { height: textHeight + labelGap }) })] }) }));
};
var HorizontalArrow2 = (props) => {
  const { x: x6 = 0, y: y6 = 0, width = 100, height = 40, fill: fill2 = "#FF356A", size = 10 } = props;
  return jsx(Polygon, { width, height, points: [
    { x: x6, y: y6 },
    { x: x6 + width - size, y: y6 },
    { x: x6 + width, y: y6 + height / 2 },
    { x: x6 + width - size, y: y6 + height },
    { x: x6, y: y6 + height },
    { x: x6 + size, y: y6 + height / 2 }
  ], fill: fill2, "data-element-type": "shape" });
};
registerItem("simple-horizontal-arrow", {
  component: SimpleHorizontalArrow,
  composites: ["label", "desc", "time"]
});

// node_modules/@antv/infographic/esm/designs/items/SimpleIllusItem.js
var SimpleIllusItem = (props) => {
  const [{ indexes, datum: datum2, width = 180, illusSize = width, gap = 8, themeColors, usePaletteColor = false }, restProps] = getItemProps(props, ["width", "illusSize", "gap", "usePaletteColor"]);
  const { label, desc } = datum2;
  const labelColor = usePaletteColor ? themeColors.colorPrimary : themeColors.colorText;
  const labelContent = jsx(ItemLabel, { indexes, width, alignHorizontal: "center", alignVertical: "middle", fill: labelColor, children: label });
  const labelBounds = getElementBounds(labelContent);
  return jsxs(FlexLayout, Object.assign({}, restProps, { width, height: illusSize + gap + labelBounds.height + gap + 48, flexDirection: "column", alignItems: "center", justifyContent: "center", gap, children: [jsx(Illus, { indexes, width: illusSize, height: illusSize }), labelContent, jsx(ItemDesc, { indexes, width, alignHorizontal: "center", alignVertical: "top", fill: themeColors.colorTextSecondary, lineNumber: 3, children: desc })] }));
};
registerItem("simple-illus", {
  component: SimpleIllusItem,
  composites: ["illus", "label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/SimpleItem.js
var SimpleItem = (props) => {
  const [{ indexes, datum: datum2, width = 200, height, gap = 4, showIcon = true, iconSize = 30, iconType = "default", positionH = "normal", positionV = "normal", usePaletteColor = false, themeColors }, restProps] = getItemProps(props, [
    "width",
    "height",
    "gap",
    "showIcon",
    "iconSize",
    "iconType",
    "usePaletteColor"
  ]);
  const { label, desc, icon } = datum2;
  const getTextAlign = (position) => {
    return position === "normal" ? "left" : position === "flipped" ? "right" : "center";
  };
  const textAlign = getTextAlign(positionH);
  const labelColor = usePaletteColor ? themeColors.colorPrimary : themeColors.colorText;
  const descFontSize = 14;
  const descLineHeight = 1.4;
  const labelContent = jsx(ItemLabel, { indexes, width, alignHorizontal: "center", alignVertical: "middle", fill: labelColor, children: label });
  const labelBounds = getElementBounds(labelContent);
  const iconContent = showIcon ? iconType === "circle" ? jsx(ItemIconCircle, { indexes, size: iconSize, fill: themeColors.colorPrimary, colorBg: themeColors.colorBg }) : jsx(ItemIcon, { indexes, size: iconSize, fill: themeColors.colorTextSecondary }) : null;
  if (!showIcon || !icon) {
    const descHeight2 = height ? Math.max(0, height - labelBounds.height - gap) : void 0;
    const descLineNumber2 = descHeight2 ? descHeight2 <= 60 ? 1 : Math.floor(descHeight2 / (descLineHeight * descFontSize)) : 2;
    const labelY2 = height ? positionV === "middle" ? (height - labelBounds.height - (descHeight2 || 0) - gap) / 2 : positionV === "flipped" ? height - labelBounds.height - (descHeight2 || 0) - gap : 0 : 0;
    return jsxs(Group, Object.assign({}, restProps, { children: [jsx(ItemLabel, { indexes, width, y: labelY2, alignHorizontal: textAlign, alignVertical: "middle", fill: labelColor, children: label }), jsx(ItemDesc, { indexes, width, height: descHeight2, y: labelY2 + labelBounds.height + gap, alignHorizontal: textAlign, alignVertical: getDescVerticalAlign(positionV, false), lineNumber: descLineNumber2, fill: themeColors.colorTextSecondary, children: desc })] }));
  }
  if (positionH === "center") {
    const iconHeight = showIcon && icon ? iconSize : 0;
    const descHeight2 = height ? Math.max(0, height - labelBounds.height - iconHeight - gap * 2) : void 0;
    const descLineNumber2 = descHeight2 ? descHeight2 <= 60 ? 1 : Math.floor(descHeight2 / (descLineHeight * descFontSize)) : 2;
    const contentHeight = labelBounds.height + (descHeight2 || 0) + gap;
    const labelY2 = height ? positionV === "middle" ? (height - contentHeight - iconHeight - gap) / 2 : positionV === "flipped" ? height - contentHeight - iconHeight - gap : 0 : 0;
    return jsx(FlexLayout, Object.assign({}, restProps, { flexDirection: "column", gap, alignItems: "center", children: positionV === "flipped" ? jsxs(Fragment, { children: [jsxs(Group, { children: [jsx(ItemLabel, { indexes, width, y: labelY2, alignHorizontal: "center", alignVertical: "middle", fill: labelColor, children: label }), jsx(ItemDesc, { indexes, width, height: descHeight2, y: labelY2 + labelBounds.height + gap, alignHorizontal: "center", alignVertical: "bottom", lineNumber: descLineNumber2, fill: themeColors.colorTextSecondary, children: desc })] }), iconContent] }) : jsxs(Fragment, { children: [iconContent, jsxs(Group, { children: [jsx(ItemLabel, { indexes, width, y: labelY2, alignHorizontal: "center", alignVertical: "middle", fill: labelColor, children: label }), jsx(ItemDesc, { indexes, width, height: descHeight2, y: labelY2 + labelBounds.height + gap, alignHorizontal: "center", alignVertical: "top", lineNumber: descLineNumber2, fill: themeColors.colorTextSecondary, children: desc })] })] }) }));
  }
  const iconBounds = getElementBounds(iconContent);
  const textWidth = Math.max(width - iconBounds.width - gap, 0);
  const descHeight = height ? Math.max(0, height - labelBounds.height - gap) : void 0;
  const descLineNumber = descHeight ? descHeight <= 60 ? 1 : Math.floor(descHeight / (descLineHeight * descFontSize)) : 2;
  const labelY = height ? positionV === "middle" ? (height - labelBounds.height - (descHeight || 0) - gap) / 2 : positionV === "flipped" ? height - labelBounds.height - (descHeight || 0) - gap : 0 : 0;
  return jsx(FlexLayout, Object.assign({}, restProps, { flexDirection: "row", gap, alignItems: getIconVerticalAlign(positionV), children: positionH === "flipped" ? jsxs(Fragment, { children: [jsxs(Group, { children: [jsx(ItemLabel, { indexes, width: textWidth, y: labelY, alignHorizontal: "right", alignVertical: "middle", fill: labelColor, children: label }), jsx(ItemDesc, { indexes, width: textWidth, height: descHeight, y: labelY + labelBounds.height + gap, alignHorizontal: "right", alignVertical: getDescVerticalAlign(positionV, true), lineNumber: descLineNumber, fill: themeColors.colorTextSecondary, children: desc })] }), iconContent] }) : jsxs(Fragment, { children: [iconContent, jsxs(Group, { children: [jsx(ItemLabel, { indexes, width: textWidth, y: labelY, alignHorizontal: "left", alignVertical: "middle", fill: labelColor, children: label }), jsx(ItemDesc, { indexes, width: textWidth, height: descHeight, y: labelY + labelBounds.height + gap, alignHorizontal: "left", alignVertical: getDescVerticalAlign(positionV, true), lineNumber: descLineNumber, fill: themeColors.colorTextSecondary, children: desc })] })] }) }));
  function getDescVerticalAlign(positionV2, hasIcon) {
    return "top";
    return hasIcon ? "middle" : "top";
  }
  function getIconVerticalAlign(positionV2) {
    if (positionV2 === "normal")
      return "flex-start";
    if (positionV2 === "flipped")
      return "flex-end";
    return "center";
  }
};
registerItem("simple", {
  component: SimpleItem,
  composites: ["icon", "label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/SimpleVerticalArrow.js
var SimpleVerticalArrow = (props) => {
  const [{ indexes, datum: datum2, height = 140, themeColors, positionH = "normal" }, restProps] = getItemProps(props, ["height"]);
  const textAlignHorizontal = positionH === "normal" ? "right" : "left";
  const label = jsx(ItemLabel, { indexes, width: 120, fill: themeColors.colorText, alignHorizontal: textAlignHorizontal, alignVertical: "middle", fontSize: 14, children: datum2.label });
  const desc = jsx(ItemDesc, { indexes, width: 120, fill: themeColors.colorTextSecondary, alignHorizontal: textAlignHorizontal, alignVertical: "top", children: datum2.desc });
  const isNormal = positionH !== "flipped";
  const labelGap = 15;
  const arrowWidth = 30;
  const textWidth = 120;
  const totalWidth = textWidth + labelGap + arrowWidth + labelGap + textWidth;
  return jsx(Group, Object.assign({ width: totalWidth, height }, restProps, { children: jsxs(FlexLayout, { flexDirection: "row", alignItems: "center", children: [isNormal ? jsxs(Fragment, { children: [jsxs(FlexLayout, { flexDirection: "column", alignItems: "flex-end", children: [label, desc] }), jsx(Gap, { width: labelGap })] }) : jsx(Fragment, { children: jsx(Gap, { width: textWidth + labelGap }) }), jsxs(AlignLayout, { horizontal: "center", vertical: "middle", children: [jsx(VerticalArrow, { width: arrowWidth, height, fill: themeColors.colorPrimary }), jsx(Text, { width: arrowWidth, height, alignHorizontal: "center", alignVertical: "middle", fill: themeColors.colorWhite, fontWeight: "bold", fontSize: 16, children: String(indexes[0] + 1).padStart(2, "0").slice(-2) })] }), !isNormal ? jsxs(Fragment, { children: [jsx(Gap, { width: labelGap }), jsxs(FlexLayout, { flexDirection: "column", alignItems: "flex-start", children: [label, desc] })] }) : jsx(Fragment, { children: jsx(Gap, { width: textWidth + labelGap }) })] }) }));
};
var VerticalArrow = (props) => {
  const { x: x6 = 0, y: y6 = 0, width = 30, height = 100, fill: fill2 = "#FF356A", size = 10 } = props;
  return jsx(Polygon, { width, height, points: [
    { x: x6, y: y6 },
    { x: x6 + width / 2, y: y6 + size },
    { x: x6 + width, y: y6 },
    { x: x6 + width, y: y6 + height - size },
    { x: x6 + width / 2, y: y6 + height },
    { x: x6, y: y6 + height - size }
  ], fill: fill2, "data-element-type": "shape" });
};
registerItem("simple-vertical-arrow", {
  component: SimpleVerticalArrow,
  composites: ["label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/UnderlineText.js
var underlineWidth = 80;
var underlineHeight = 3;
var UnderlineText = (props) => {
  const [{ datum: datum2, indexes, width = 200, gap = 4, positionH = "center", themeColors }, restProps] = getItemProps(props, ["width", "height", "gap"]);
  const labelBounds = getElementBounds(jsx(ItemLabel, { indexes, fontSize: 18, fontWeight: "bold", width, children: datum2.label }));
  const descBounds = datum2.desc ? getElementBounds(jsx(ItemDesc, { indexes, width, wordWrap: true, children: datum2.desc })) : { width: 0, height: 0 };
  const contentHeight = labelBounds.height + gap + underlineHeight + (datum2.desc ? gap * 2 + descBounds.height : 0);
  const titleX = 0;
  const titleY = 0;
  const alignHorizontal = positionH === "center" ? "center" : positionH === "flipped" ? "right" : "left";
  const underlineX = positionH === "center" ? (width - underlineWidth) / 2 : positionH === "flipped" ? width - underlineWidth : 0;
  const underlineY = titleY + labelBounds.height + gap;
  const descX = 0;
  const descY = underlineY + underlineHeight + gap * 2;
  return jsxs(Group, Object.assign({ width, height: contentHeight }, restProps, { children: [datum2.label && jsx(ItemLabel, { indexes, x: titleX, y: titleY, width, alignHorizontal, fill: themeColors.colorPrimary, fontSize: 18, fontWeight: "bold", children: datum2.label }), datum2.label && jsx(Rect, { x: underlineX, y: underlineY, width: underlineWidth, height: underlineHeight, fill: themeColors.colorPrimary, "data-element-type": "shape" }), datum2.desc && jsx(ItemDesc, { indexes, width, x: descX, y: descY, alignHorizontal, wordWrap: true, fill: themeColors.colorText, children: datum2.desc })] }));
};
registerItem("underline-text", {
  component: UnderlineText,
  composites: ["label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/items/VerticalIconArrow.js
var VerticalIconArrow = (props) => {
  const [{ indexes, datum: datum2, height = 140, themeColors, positionH = "normal" }, restProps] = getItemProps(props, ["height"]);
  const isHNormal = positionH !== "flipped";
  const textAlignHorizontal = isHNormal ? "right" : "left";
  const label = jsx(ItemLabel, { indexes, width: 120, fill: themeColors.colorText, alignHorizontal: textAlignHorizontal, alignVertical: "middle", fontSize: 14, children: datum2.label });
  const desc = jsx(ItemDesc, { indexes, width: 120, fill: themeColors.colorTextSecondary, alignHorizontal: textAlignHorizontal, alignVertical: "top", children: datum2.desc });
  const icon = jsx(ItemIconCircle, { indexes, fill: themeColors.colorPrimary, colorBg: themeColors.colorWhite });
  const dotLine = jsx(DotLine2, { width: 30, height: 8, fill: themeColors.colorPrimary, positionH });
  const isNormal = positionH !== "flipped";
  const dotLineGap = 5;
  const iconGap = 25;
  const arrowWidth = 30;
  const labelBounds = getElementBounds(label);
  const iconBounds = getElementBounds(icon);
  const dotLineBounds = getElementBounds(dotLine);
  const fixedGap = labelBounds.width + dotLineGap + dotLineBounds.width - iconBounds.width - iconGap;
  const totalWidth = Math.max(labelBounds.width + dotLineGap + dotLineBounds.width, iconGap + iconBounds.width) * 2 + arrowWidth;
  return jsx(Group, Object.assign({ width: totalWidth, height }, restProps, { children: jsxs(FlexLayout, { flexDirection: "row", alignItems: "center", children: [isNormal ? jsxs(Fragment, { children: [jsxs(FlexLayout, { flexDirection: "column", alignItems: "flex-end", children: [label, desc] }), jsx(Gap, { width: dotLineGap }), dotLine] }) : jsxs(Fragment, { children: [jsx(Gap, { width: fixedGap }), icon, jsx(Gap, { width: iconGap })] }), jsxs(AlignLayout, { horizontal: "center", vertical: "middle", children: [jsx(VerticalArrow2, { width: arrowWidth, height, fill: themeColors.colorPrimary }), jsx(Text, { width: arrowWidth, height, alignHorizontal: "center", alignVertical: "middle", fill: themeColors.colorWhite, fontWeight: "bold", fontSize: 16, children: String(indexes[0] + 1).padStart(2, "0").slice(-2) })] }), !isNormal ? jsxs(Fragment, { children: [dotLine, jsx(Gap, { width: dotLineGap }), jsxs(FlexLayout, { flexDirection: "column", alignItems: "flex-start", children: [label, desc] })] }) : jsxs(Fragment, { children: [jsx(Gap, { width: iconGap }), icon] })] }) }));
};
var VerticalArrow2 = (props) => {
  const { x: x6 = 0, y: y6 = 0, width = 30, height = 100, fill: fill2 = "#FF356A", size = 10 } = props;
  return jsx(Polygon, { width, height, points: [
    { x: x6, y: y6 },
    { x: x6 + width / 2, y: y6 + size },
    { x: x6 + width, y: y6 },
    { x: x6 + width, y: y6 + height - size },
    { x: x6 + width / 2, y: y6 + height },
    { x: x6, y: y6 + height - size }
  ], fill: fill2, "data-element-type": "shape" });
};
var DotLine2 = (props) => {
  const { x: x6 = 0, y: y6 = 0, width = 50, height = 10, fill: fill2, positionH = "normal" } = props;
  const r5 = height / 2;
  const lineLength = width - r5;
  const strokeWidth = 2;
  const lineY = r5;
  return jsxs(Group, { x: x6, y: y6, width, height, children: [jsx(Ellipse, { width: height, height, fill: fill2, x: positionH === "normal" ? 0 : lineLength - r5, "data-element-type": "shape" }), jsx(Path, { d: positionH === "normal" ? `M${r5},${lineY} L${r5 + lineLength},${lineY}` : `M0,${lineY} L${lineLength - r5},${lineY}`, strokeWidth, stroke: fill2, "data-element-type": "shape" })] });
};
registerItem("vertical-icon-arrow", {
  component: VerticalIconArrow,
  composites: ["icon", "label", "desc"]
});

// node_modules/@antv/infographic/esm/designs/structures/registry.js
var STRUCTURE_REGISTRY = /* @__PURE__ */ new Map();
function registerStructure(type2, structure) {
  STRUCTURE_REGISTRY.set(type2, structure);
}
function getStructure(type2) {
  return STRUCTURE_REGISTRY.get(type2);
}

// node_modules/@antv/infographic/esm/designs/structures/chart-bar.js
var ChartBar = (props) => {
  var _a, _b, _c;
  const { Title: Title2, Item, data, width, gap, barGap, barHeight = 28, barAreaWidth, labelGap = 16, padding = 24, showValue = true, options, valueFormatter = (value) => value.toString() } = props;
  const resolvedBarAreaWidth = (_a = barAreaWidth !== null && barAreaWidth !== void 0 ? barAreaWidth : width) !== null && _a !== void 0 ? _a : 480;
  const { title, desc, items: items3 = [], xTitle, yTitle } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  if (items3.length === 0) {
    return jsx(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: titleContent });
  }
  const [paddingTop, paddingRight, paddingBottom, paddingLeft] = parsePadding(padding);
  const sampleDatum = (_b = items3[0]) !== null && _b !== void 0 ? _b : { label: "", value: 0 };
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], datum: sampleDatum, data }));
  const labelWidth = itemBounds.width || 140;
  const labelHeight = itemBounds.height || barHeight;
  const rowHeight = Math.max(barHeight, labelHeight);
  const gapByHeight = Math.max(12, rowHeight * 0.35);
  const resolvedGap = (_c = barGap !== null && barGap !== void 0 ? barGap : gap) !== null && _c !== void 0 ? _c : gapByHeight;
  const values = items3.map((item) => {
    var _a2;
    return (_a2 = item.value) !== null && _a2 !== void 0 ? _a2 : 0;
  });
  const maxValue = Math.max(...values, 0);
  const minValue = Math.min(...values, 0);
  const domainMin = minValue < 0 ? minValue * 1.1 : 0;
  let domainMax = maxValue > 0 ? maxValue * 1.1 : 0;
  if (domainMax === domainMin) {
    domainMax = domainMin + 1;
  }
  const scale = linear2().domain([domainMin, domainMax]).range([0, resolvedBarAreaWidth]);
  const zeroX = Math.min(Math.max(scale(0), 0), resolvedBarAreaWidth);
  const minBarWidth = Math.max(2, resolvedBarAreaWidth * 0.02);
  const chartHeight = items3.length * (rowHeight + resolvedGap) - resolvedGap;
  const yTitleSpace = yTitle ? 24 : 0;
  const xTickSpace = 20;
  const xTitleSpace = xTitle ? 24 : 0;
  const yStart = paddingTop + yTitleSpace;
  const barStartX = paddingLeft + labelWidth + labelGap;
  const valueSpace = showValue ? 80 : 0;
  const axisGap = Math.max(8, rowHeight * 0.2);
  const totalWidth = barStartX + resolvedBarAreaWidth + valueSpace + paddingRight;
  const totalHeight = yStart + chartHeight + axisGap + xTickSpace + xTitleSpace + paddingBottom;
  const themeColors = getThemeColors(options.themeConfig);
  const axisColor = themeColors.colorText || "#666";
  const colorPrimary = getColorPrimary(options);
  const barElements = [];
  const valueElements = [];
  const itemElements = [];
  const axisElements = [];
  const tickElements = [];
  const gridElements = [];
  const titleElements = [];
  const axisY = yStart + chartHeight + axisGap;
  const formatTick = (value) => Number.isInteger(value) ? value.toString() : value.toFixed(1);
  items3.forEach((item, index2) => {
    var _a2;
    const indexes = [index2];
    const value = (_a2 = item.value) !== null && _a2 !== void 0 ? _a2 : 0;
    const rowY = yStart + index2 * (rowHeight + resolvedGap);
    const barY = rowY + (rowHeight - barHeight) / 2;
    const barX = value >= 0 ? barStartX + zeroX : barStartX + scale(value);
    const barWidthRaw = value >= 0 ? scale(value) - zeroX : zeroX - scale(value);
    const barWidth = barWidthRaw === 0 ? minBarWidth : barWidthRaw;
    const barColor = getPaletteColor2(options, [index2]) || themeColors.colorPrimary;
    barElements.push(jsx(Rect, { x: barX, y: barY, width: barWidth, height: barHeight, fill: barColor, rx: 6, ry: 6, "data-element-type": "shape" }));
    if (showValue) {
      const valueX = value >= 0 ? barX + barWidth + 8 : barX - 8;
      valueElements.push(jsx(Text, { x: valueX, y: barY + barHeight / 2, alignHorizontal: value >= 0 ? "left" : "right", alignVertical: "middle", fontSize: 14, fontWeight: "bold", fill: barColor, children: valueFormatter(value, item) }));
    }
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: paddingLeft, y: rowY + (rowHeight - labelHeight) / 2, width: labelWidth, height: labelHeight, positionV: "middle" }));
  });
  const tickCount = Math.max(3, Math.min(7, Math.floor(resolvedBarAreaWidth / 80)));
  const ticks2 = scale.ticks(tickCount);
  ticks2.forEach((tick) => {
    const tickX = barStartX + scale(tick);
    gridElements.push(jsx(Path, { d: `M${tickX} ${yStart} L${tickX} ${yStart + chartHeight}`, stroke: axisColor, strokeOpacity: 0.08, "data-element-type": "shape" }));
    tickElements.push(jsx(Path, { d: `M${tickX - 0.5} ${axisY} L${tickX - 0.5} ${axisY + 6}`, stroke: axisColor, "data-element-type": "shape" }));
    tickElements.push(jsx(Text, { x: tickX, y: axisY + 14, alignHorizontal: "center", alignVertical: "middle", fontSize: 12, fill: axisColor, children: formatTick(tick) }));
  });
  axisElements.push(jsx(Path, { d: `M${barStartX} ${axisY} L${barStartX + resolvedBarAreaWidth} ${axisY}`, stroke: axisColor, "data-element-type": "shape" }));
  if (domainMin < 0) {
    axisElements.push(jsx(Rect, { x: barStartX + zeroX - 0.5, y: yStart, width: 1, height: chartHeight, fill: colorPrimary, "data-element-type": "shape" }));
  }
  if (yTitle) {
    titleElements.push(jsx(Text, { x: paddingLeft + labelWidth / 2, y: paddingTop + yTitleSpace / 2, alignHorizontal: "center", alignVertical: "middle", fontSize: 14, fontWeight: "bold", fill: axisColor, children: yTitle }));
  }
  if (xTitle) {
    titleElements.push(jsx(Text, { x: barStartX + resolvedBarAreaWidth / 2, y: axisY + xTickSpace + xTitleSpace / 2, alignHorizontal: "center", alignVertical: "middle", fontSize: 14, fontWeight: "bold", fill: axisColor, children: xTitle }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { width: totalWidth, height: totalHeight, children: [jsx(Group, { children: gridElements }), jsx(Group, { children: barElements }), jsx(Group, { children: valueElements }), jsx(Group, { children: titleElements }), jsx(Group, { children: [...axisElements, ...tickElements] }), jsx(ItemsGroup, { children: itemElements })] })] });
};
registerStructure("chart-bar", {
  component: ChartBar,
  composites: ["title", "item", "xTitle", "yTitle"]
});

// node_modules/@antv/infographic/esm/designs/structures/chart-column.js
var ChartColumn = (props) => {
  const { Title: Title2, Item, data, columnGap = 60, columnWidth = 50, padding = 20, showValue = true, options, valueFormatter = (value) => value.toString() } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  if (items3.length === 0) {
    return jsx(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: titleContent });
  }
  const themeColors = getThemeColors(options.themeConfig);
  const values = items3.map((item) => {
    var _a;
    return (_a = item.value) !== null && _a !== void 0 ? _a : 0;
  });
  const sortedValues = [...values, 0].sort((a3, b2) => a3 - b2);
  const hasNegative = sortedValues[0] < 0;
  const chartWidth = items3.length * columnWidth + (items3.length - 1) * columnGap;
  const chartHeight = 300;
  const [paddingTop, paddingRight, paddingBottom, paddingLeft] = parsePadding(padding);
  const valueTextHeight = showValue ? 24 : 0;
  const itemGap = 10;
  const extraBottomSpace = hasNegative && showValue ? valueTextHeight + itemGap : itemGap;
  const totalWidth = chartWidth + paddingLeft + paddingRight;
  const totalHeight = chartHeight + paddingTop + paddingBottom + extraBottomSpace;
  const yScale = linear2().domain([sortedValues[0], sortedValues[sortedValues.length - 1]]).range([chartHeight, 0]);
  const zeroY = yScale(0);
  const columnElements = [];
  const valueElements = [];
  const itemElements = [];
  const gradientDefs = [];
  items3.forEach((item, index2) => {
    var _a;
    const indexes = [index2];
    const value = (_a = item.value) !== null && _a !== void 0 ? _a : 0;
    const columnX = paddingLeft + index2 * (columnWidth + columnGap);
    const columnY = value >= 0 ? yScale(value) : zeroY;
    const columnHeight = Math.abs(yScale(value) - zeroY);
    const color3 = getPaletteColor2(options, [index2]) || themeColors.colorPrimary;
    const gradientPositiveId = `${color3}-column-positive-${index2}`;
    const gradientNegativeId = `${color3}-column-negative-${index2}`;
    gradientDefs.push(jsxs("linearGradient", { id: value >= 0 ? gradientPositiveId : gradientNegativeId, x1: "0%", y1: value >= 0 ? "0%" : "100%", x2: "0%", y2: value >= 0 ? "100%" : "0%", children: [jsx("stop", { offset: "0%", stopColor: color3 }), jsx("stop", { offset: "100%", stopColor: tinycolor.mix(color3, "#fff", 40).toHexString() })] }));
    columnElements.push(jsx(Rect, { x: columnX, y: paddingTop + columnY, width: columnWidth, height: columnHeight, fill: `url(#${value >= 0 ? gradientPositiveId : gradientNegativeId})`, rx: 8, ry: 8, "data-element-type": "shape" }));
    if (showValue) {
      valueElements.push(jsx(Text, { x: columnX + columnWidth / 2, y: value >= 0 ? paddingTop + columnY - 10 : paddingTop + columnY + columnHeight + 20, fontSize: 16, fontWeight: "bold", alignHorizontal: "center", alignVertical: value >= 0 ? "bottom" : "top", fill: color3, children: valueFormatter(value, item) }));
    }
    const itemWidth = columnWidth + columnGap;
    const itemY = paddingTop + chartHeight + extraBottomSpace;
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: columnX + columnWidth / 2 - itemWidth / 2, y: itemY, width: itemWidth, positionH: "center" }));
  });
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { width: totalWidth, height: totalHeight, children: [jsx(Defs, { children: gradientDefs }), jsx(Group, { children: columnElements }), jsx(Group, { children: valueElements }), jsx(ItemsGroup, { children: itemElements })] })] });
};
registerStructure("chart-column", {
  component: ChartColumn,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/chart-line.js
var ChartLine = (props) => {
  const { Title: Title2, Item, data, width, height = 260, gap = 10, padding = 24, showValue = true, options, valueFormatter = (value) => value.toString() } = props;
  const { title, desc, items: items3 = [], xTitle, yTitle } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  if (items3.length === 0) {
    return jsx(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: titleContent });
  }
  const [paddingTop, paddingRight, paddingBottom, paddingLeft] = parsePadding(padding);
  const itemProps = {
    indexes: [0],
    datum: items3[0],
    data,
    positionH: "center",
    positionV: "normal"
  };
  const sampleBounds = getElementBounds(jsx(Item, Object.assign({}, itemProps)));
  const labelWidth = sampleBounds.width;
  const labelHeight = sampleBounds.height;
  const xTickSpace = Math.max(28, labelHeight + 14);
  const yTickSpace = 44;
  const yTitleSpace = yTitle ? 26 : 0;
  const xTitleSpace = xTitle ? 22 : 0;
  const baseSpacing = labelWidth + gap;
  const naturalChartWidth = items3.length > 0 ? (items3.length - 1) * baseSpacing + labelWidth : 0;
  const targetChartWidth = width !== void 0 ? width : Math.max(200, naturalChartWidth || 320);
  const spacing = items3.length > 1 ? Math.max(baseSpacing, (targetChartWidth - labelWidth) / (items3.length - 1)) : 0;
  const derivedChartWidth = items3.length > 0 ? Math.max(labelWidth, (items3.length - 1) * spacing + labelWidth) : 0;
  const chartOriginX = paddingLeft + yTickSpace + yTitleSpace;
  const chartOriginY = paddingTop + yTitleSpace;
  const totalWidth = chartOriginX + derivedChartWidth + paddingRight;
  const totalHeight = chartOriginY + height + xTickSpace + xTitleSpace + paddingBottom;
  const values = items3.map((item) => {
    var _a;
    return (_a = item.value) !== null && _a !== void 0 ? _a : 0;
  });
  const maxValue = Math.max(...values, 0);
  const minValue = Math.min(...values, 0);
  const domainPadding = Math.max(Math.abs(maxValue), Math.abs(minValue)) * 0.1;
  const domainMin = minValue < 0 ? minValue - domainPadding : 0;
  let domainMax = maxValue > 0 ? maxValue + domainPadding : 1;
  if (domainMax === domainMin) {
    domainMax = domainMin + 1;
  }
  const scaleY = linear2().domain([domainMin, domainMax]).nice().range([height, 0]);
  const zeroY = Math.max(0, Math.min(height, scaleY(0)));
  const axisBaseY = domainMax <= 0 ? 0 : domainMin >= 0 ? height : zeroY;
  const colorPrimary = getColorPrimary(options);
  const themeColors = getThemeColors(options.themeConfig);
  const axisColor = themeColors.colorText || "#666";
  const gridElements = [];
  const axisElements = [];
  const lineElements = [];
  const pointElements = [];
  const valueElements = [];
  const titleElements = [];
  const tickElements = [];
  const ticksY = scaleY.ticks(6);
  ticksY.forEach((tick) => {
    const yPos = chartOriginY + scaleY(tick);
    gridElements.push(jsx(Path, { d: `M ${chartOriginX} ${yPos} L ${chartOriginX + derivedChartWidth} ${yPos}`, width: derivedChartWidth, height: 1, stroke: axisColor, strokeWidth: 1, "data-element-type": "shape", opacity: 0.08 }));
    tickElements.push(jsx(Text, { x: chartOriginX - 8, y: yPos, alignHorizontal: "right", alignVertical: "middle", fontSize: 12, fill: axisColor, children: Number.isInteger(tick) ? tick.toString() : tick.toFixed(1) }));
  });
  const xLabels = [];
  const pointPositions = [];
  const colorStopsData = [];
  const createSmoothPath = (points) => {
    if (points.length === 0)
      return "";
    if (points.length === 1) {
      const p7 = points[0];
      return `M ${p7.x} ${p7.y}`;
    }
    const segments = [];
    segments.push(`M ${points[0].x} ${points[0].y}`);
    for (let i4 = 0; i4 < points.length - 1; i4++) {
      const p0 = points[i4 - 1] || points[i4];
      const p1 = points[i4];
      const p22 = points[i4 + 1];
      const p32 = points[i4 + 2] || p22;
      const cp1x = p1.x + (p22.x - p0.x) / 6;
      const cp1y = p1.y + (p22.y - p0.y) / 6;
      const cp2x = p22.x - (p32.x - p1.x) / 6;
      const cp2y = p22.y - (p32.y - p1.y) / 6;
      segments.push(`C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${p22.x} ${p22.y}`);
    }
    return segments.join(" ");
  };
  items3.forEach((item, index2) => {
    var _a;
    const x6 = chartOriginX + index2 * spacing + labelWidth / 2;
    const y6 = chartOriginY + scaleY((_a = item.value) !== null && _a !== void 0 ? _a : 0);
    pointPositions.push({ x: x6, y: y6, datum: item });
    xLabels.push(jsx(Item, Object.assign({}, itemProps, { indexes: [index2], datum: item, x: x6 - labelWidth / 2, y: chartOriginY + height + 4 })));
    const stopColor = getPaletteColor2(options, [index2]) || themeColors.colorPrimary;
    colorStopsData.push({ x: x6, color: stopColor });
  });
  const minStopX = colorStopsData.length > 0 ? Math.min(...colorStopsData.map((s3) => s3.x)) : chartOriginX;
  const maxStopX = colorStopsData.length > 0 ? Math.max(...colorStopsData.map((s3) => s3.x)) : chartOriginX + derivedChartWidth;
  const stopSpan = Math.max(1, maxStopX - minStopX);
  const gradientStops = colorStopsData.map((s3) => jsx("stop", { offset: `${(s3.x - minStopX) / stopSpan * 100}%`, stopColor: s3.color }));
  const areaStops = colorStopsData.map((s3) => jsx("stop", { offset: `${(s3.x - minStopX) / stopSpan * 100}%`, stopColor: s3.color, stopOpacity: "0.18" }));
  if (colorStopsData.length > 0) {
    const lastColor = colorStopsData[colorStopsData.length - 1].color;
    gradientStops.push(jsx("stop", { offset: "100%", stopColor: lastColor }));
    areaStops.push(jsx("stop", { offset: "100%", stopColor: lastColor, stopOpacity: "0.04" }));
  }
  const gradientIdBase = `chart-line-${getSimpleHash([
    derivedChartWidth,
    height,
    axisColor,
    colorPrimary,
    colorStopsData.map((s3) => `${s3.x.toFixed(2)}-${s3.color}`).join()
  ].join(":"))}`;
  const gradientStrokeId = `${gradientIdBase}-stroke`;
  const gradientAreaId = `${gradientIdBase}-area`;
  const smoothLinePath = createSmoothPath(pointPositions);
  lineElements.push(jsx(Path, { d: smoothLinePath, width: derivedChartWidth, height, stroke: `url(#${gradientStrokeId})`, strokeWidth: 3, fill: "none", "data-element-type": "shape" }));
  const areaCurveTail = smoothLinePath.includes("C") ? smoothLinePath.slice(smoothLinePath.indexOf("C")) : "";
  const areaPath = [
    `M ${pointPositions[0].x} ${chartOriginY + axisBaseY}`,
    `L ${pointPositions[0].x} ${pointPositions[0].y}`,
    areaCurveTail,
    `L ${pointPositions[pointPositions.length - 1].x} ${chartOriginY + axisBaseY}`,
    "Z"
  ].join(" ");
  lineElements.push(jsx(Path, { d: areaPath, width: derivedChartWidth, height, fill: `url(#${gradientAreaId})`, stroke: "none", "data-element-type": "shape" }));
  pointPositions.forEach((pos, index2) => {
    var _a;
    const paletteColor = getPaletteColor2(options, [index2]) || themeColors.colorPrimary;
    pointElements.push(jsx(Ellipse, { x: pos.x - 6, y: pos.y - 6, width: 12, height: 12, fill: paletteColor, "data-element-type": "shape" }));
    if (showValue) {
      valueElements.push(jsx(Text, { x: pos.x, y: pos.y - 12, alignHorizontal: "center", alignVertical: "bottom", fontSize: 12, fontWeight: "bold", fill: paletteColor, children: valueFormatter((_a = pos.datum.value) !== null && _a !== void 0 ? _a : 0, pos.datum) }));
    }
  });
  axisElements.push(jsx(Path, { d: `M ${chartOriginX} ${chartOriginY + axisBaseY} L ${chartOriginX + derivedChartWidth} ${chartOriginY + axisBaseY}`, width: derivedChartWidth, height: 1, stroke: axisColor, strokeWidth: 1, "data-element-type": "shape" }));
  axisElements.push(jsx(Path, { d: `M ${chartOriginX} ${chartOriginY} L ${chartOriginX} ${chartOriginY + height}`, width: 1, height, stroke: axisColor, strokeWidth: 1, "data-element-type": "shape" }));
  if (xTitle) {
    titleElements.push(jsx(Text, { x: chartOriginX + derivedChartWidth / 2, y: chartOriginY + height + xTickSpace + xTitleSpace / 2, alignHorizontal: "center", alignVertical: "middle", fontSize: 14, fontWeight: "bold", fill: axisColor, children: xTitle }));
  }
  if (yTitle) {
    titleElements.push(jsx(Text, { x: paddingLeft + yTitleSpace / 2, y: chartOriginY + height / 2, alignHorizontal: "center", alignVertical: "middle", fontSize: 14, fontWeight: "bold", fill: axisColor, children: yTitle }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { width: totalWidth, height: totalHeight, children: [jsxs(Defs, { children: [jsx("linearGradient", { id: gradientStrokeId, x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: gradientStops }), jsxs("linearGradient", { id: gradientAreaId, x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [areaStops, jsx("stop", { offset: "100%", stopColor: colorPrimary, stopOpacity: "0.04" })] })] }), jsx(Group, { children: gridElements }), jsx(Group, { children: [...axisElements, ...tickElements] }), jsx(Group, { children: lineElements }), jsx(Group, { children: pointElements }), jsx(Group, { children: valueElements }), jsx(Group, { children: titleElements }), jsx(ItemsGroup, { children: xLabels })] })] });
};
registerStructure("chart-line", {
  component: ChartLine,
  composites: ["title", "item", "xTitle", "yTitle"]
});

// node_modules/@antv/infographic/esm/designs/structures/chart-pie.js
var EXTENSION_FACTOR = 1.35;
var TEXT_GAP = 8;
var SMOOTH_FACTOR = 0.3;
var MAX_EXPECTED_SHIFT_FACTOR = 0.2;
var FIXED_TEXT_RADIUS_GAP = 20;
var ELBOW_RADIUS_FACTOR = 1.15;
var PERCENT_TEXT_POSITION = 0.5;
var DELETE_BUTTON_RADIUS_FACTOR = 0.85;
var ADD_BUTTON_RADIUS_FACTOR = 1;
var CONNECTOR_STROKE_OPACITY = 0.45;
var CONNECTOR_STROKE_WIDTH = 2;
var ChartPie = (props) => {
  var _a;
  const { Title: Title2, Item, data, radius = 140, innerRadius = 0, padding = 30, showPercentage = true, avoidLabelOverlap = false, minShowLabelPercent: rawMinShowLabelPercent = 0, options } = props;
  const minShowLabelPercent = normalizePercent(rawMinShowLabelPercent);
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const sampleDatum = (_a = items3[0]) !== null && _a !== void 0 ? _a : { label: "", value: 0 };
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], datum: sampleDatum, data, positionH: "center", positionV: "middle" }));
  const labelWidth = itemBounds.width || 140;
  const labelHeight = itemBounds.height || 32;
  const outerRadius = Math.max(radius, 60);
  const maxHorizontalDistance = outerRadius * EXTENSION_FACTOR + TEXT_GAP + labelWidth;
  const maxVerticalDistance = outerRadius;
  const centerX = padding + maxHorizontalDistance;
  const centerY = padding + maxVerticalDistance;
  const totalWidth = centerX * 2;
  const totalHeight = centerY * 2;
  if (items3.length === 0) {
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { width: totalWidth, height: totalHeight, children: jsx(BtnsGroup, { children: jsx(BtnAdd, { indexes: [0], x: centerX - btnBounds.width / 2, y: centerY - btnBounds.height / 2 }) }) })] });
  }
  const totalValue = items3.reduce((sum, item) => {
    var _a2;
    return sum + Math.max((_a2 = item.value) !== null && _a2 !== void 0 ? _a2 : 0, 0);
  }, 0);
  const colorPrimary = getColorPrimary(options);
  const themeColors = getThemeColors(options.themeConfig);
  const pieGenerator = pie_default().value((item) => {
    var _a2;
    return Math.max((_a2 = item.value) !== null && _a2 !== void 0 ? _a2 : 0, 0);
  }).sort(null).startAngle(0).endAngle(Math.PI * 2);
  const arcData = pieGenerator(items3);
  const arcGenerator = arc_default().innerRadius(innerRadius).outerRadius(outerRadius).cornerRadius(2);
  const innerArc = arc_default().innerRadius(outerRadius).outerRadius(outerRadius);
  const outerArc = arc_default().innerRadius(outerRadius * ELBOW_RADIUS_FACTOR).outerRadius(outerRadius * ELBOW_RADIUS_FACTOR);
  const percentTextRadius = innerRadius + (outerRadius - innerRadius) * PERCENT_TEXT_POSITION;
  const percentageArc = arc_default().innerRadius(percentTextRadius).outerRadius(percentTextRadius);
  const deleteButtonArc = arc_default().innerRadius(outerRadius * DELETE_BUTTON_RADIUS_FACTOR).outerRadius(outerRadius * DELETE_BUTTON_RADIUS_FACTOR);
  const sliceElements = [];
  const percentElements = [];
  const connectorElements = [];
  const itemElements = [];
  const btnElements = [];
  const labelItems = [];
  arcData.forEach((arcDatum) => {
    const originalIndex = arcDatum.index;
    const color3 = getPaletteColor2(options, [originalIndex]) || themeColors.colorPrimary || colorPrimary;
    const pathD = arcGenerator(arcDatum) || "";
    sliceElements.push(jsx(Path, { d: pathD, fill: color3, stroke: themeColors.colorBg, strokeWidth: 1, "data-element-type": "shape", width: outerRadius * 2, height: outerRadius * 2 }));
    const midAngle = arcDatum.startAngle + (arcDatum.endAngle - arcDatum.startAngle) / 2;
    const normalizedAngle = midAngle < 0 ? midAngle + Math.PI * 2 : midAngle;
    const isRight = normalizedAngle < Math.PI;
    const slicePercent = totalValue > 0 ? arcDatum.value / totalValue * 100 : 0;
    if (slicePercent < minShowLabelPercent) {
      return;
    }
    const centroid = outerArc.centroid(arcDatum);
    labelItems.push({
      arcDatum,
      originalIndex,
      x: centroid[0],
      y: centroid[1],
      //  Y 
      height: labelHeight,
      isRight,
      color: color3
    });
  });
  let finalLabels = labelItems;
  if (avoidLabelOverlap) {
    const labelMinY = -maxVerticalDistance * EXTENSION_FACTOR;
    const labelMaxY = maxVerticalDistance * EXTENSION_FACTOR;
    const leftItems = labelItems.filter((item) => !item.isRight);
    const rightItems = labelItems.filter((item) => item.isRight);
    const labelSpacing = labelHeight;
    const adjustedRight = distributeLabels(rightItems, labelSpacing, labelMinY, labelMaxY);
    const adjustedLeft = distributeLabels(leftItems, labelSpacing, labelMinY, labelMaxY);
    finalLabels = [...adjustedLeft, ...adjustedRight];
  }
  finalLabels.forEach((item) => {
    const { arcDatum, originalIndex, isRight, color: color3, y: adjustedY } = item;
    const p0 = innerArc.centroid(arcDatum);
    const p1 = outerArc.centroid(arcDatum);
    const labelCenterY = adjustedY;
    const deltaY = Math.abs(labelCenterY - p1[1]);
    const dynamicShift = deltaY * SMOOTH_FACTOR;
    const baseElbowRadius = outerRadius * EXTENSION_FACTOR;
    const currentElbowRadius = baseElbowRadius + dynamicShift;
    const maxExpectedShift = outerRadius * MAX_EXPECTED_SHIFT_FACTOR;
    const fixedTextRadius = baseElbowRadius + maxExpectedShift + FIXED_TEXT_RADIUS_GAP;
    const elbowRadiusClamped = Math.min(currentElbowRadius, fixedTextRadius);
    const elbowX = elbowRadiusClamped * (isRight ? 1 : -1);
    const textX = fixedTextRadius * (isRight ? 1 : -1);
    const p22 = [elbowX, labelCenterY];
    const p32 = [textX, labelCenterY];
    connectorElements.push(jsx(Path, { d: `M${centerX + p0[0]} ${centerY + p0[1]} 
        L${centerX + p1[0]} ${centerY + p1[1]} 
        L${centerX + p22[0]} ${centerY + p22[1]}
        L${centerX + p32[0]} ${centerY + p32[1]}
        `, stroke: color3, strokeOpacity: CONNECTOR_STROKE_OPACITY, strokeWidth: CONNECTOR_STROKE_WIDTH, fill: "none", "data-element-type": "shape" }));
    const itemX = centerX + p32[0] + (isRight ? TEXT_GAP : -TEXT_GAP - labelWidth);
    const itemY = centerY + adjustedY - labelHeight / 2;
    itemElements.push(jsx(Item, { indexes: [originalIndex], datum: arcDatum.data, data, x: itemX, y: itemY, width: labelWidth, height: labelHeight, positionH: isRight ? "normal" : "flipped", positionV: "middle", themeColors: getThemeColors({ colorPrimary: color3 }, options) }));
    if (showPercentage && totalValue > 0) {
      const percentPos = percentageArc.centroid(arcDatum);
      const value = Math.max(arcDatum.value, 0);
      const percentText = (value * 100 / totalValue).toFixed(1);
      const textWidth = 50;
      const textHeight = 20;
      percentElements.push(jsx(Text, { x: centerX + percentPos[0] - textWidth / 2, y: centerY + percentPos[1] - textHeight / 2, width: textWidth, height: textHeight, alignHorizontal: "center", alignVertical: "middle", fontSize: 12, fontWeight: "bold", fill: "#ffffff", "data-value": value, "data-indexes": [originalIndex], "data-element-type": "item-value", children: `${percentText}%` }));
    }
    const deletePos = deleteButtonArc.centroid(arcDatum);
    btnElements.push(jsx(BtnRemove, { indexes: [originalIndex], x: centerX + deletePos[0] - btnBounds.width / 2, y: centerY + deletePos[1] - btnBounds.height / 2 }));
  });
  arcData.forEach((arcDatum, index2) => {
    const nextIndex = (index2 + 1) % arcData.length;
    const currentEnd = arcDatum.endAngle;
    const nextStart = arcData[nextIndex].startAngle + (nextIndex === 0 ? Math.PI * 2 : 0);
    const midAngle = (currentEnd + nextStart) / 2;
    const btnR = outerRadius * ADD_BUTTON_RADIUS_FACTOR;
    const btnX = Math.sin(midAngle) * btnR;
    const btnY = -Math.cos(midAngle) * btnR;
    btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: centerX + btnX - btnBounds.width / 2, y: centerY + btnY - btnBounds.height / 2 }));
  });
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: 30, children: [titleContent, jsxs(Group, { width: totalWidth, height: totalHeight, children: [jsx(Group, { x: centerX, y: centerY, children: sliceElements }), jsx(Group, { children: connectorElements }), jsx(Group, { children: percentElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("chart-pie", {
  component: ChartPie,
  composites: ["title", "item"]
});
function distributeLabels(items3, spacing, minY, maxY) {
  if (items3.length <= 1)
    return items3.map((item) => Object.assign({}, item));
  const sorted = items3.map((item) => Object.assign({}, item)).sort((a3, b2) => a3.y - b2.y);
  const hasOverlap = sorted.some((item, i4) => {
    if (i4 === 0)
      return false;
    const prev = sorted[i4 - 1];
    return item.y - prev.y < (prev.height + item.height) / 2;
  });
  const firstItem = sorted[0];
  const lastItem = sorted[sorted.length - 1];
  const isOutOfBounds = firstItem.y - firstItem.height / 2 < minY || lastItem.y + lastItem.height / 2 > maxY;
  if (!hasOverlap && !isOutOfBounds) {
    return sorted;
  }
  const totalLabelsHeight = sorted.reduce((sum, item) => sum + item.height, 0);
  const availableSpace = maxY - minY;
  const requiredSpaceWithIdealSpacing = totalLabelsHeight + spacing * (sorted.length - 1);
  let actualSpacing = spacing;
  if (requiredSpaceWithIdealSpacing > availableSpace) {
    const excessSpace = availableSpace - totalLabelsHeight;
    actualSpacing = Math.max(0, excessSpace / (sorted.length - 1));
  }
  for (let i4 = 1; i4 < sorted.length; i4++) {
    const prev = sorted[i4 - 1];
    const curr = sorted[i4];
    const minAllowedY = prev.y + (prev.height + curr.height) / 2 + actualSpacing;
    if (curr.y < minAllowedY) {
      curr.y = minAllowedY;
    }
  }
  const lastIdx = sorted.length - 1;
  const last = sorted[lastIdx];
  if (last.y + last.height / 2 > maxY) {
    last.y = maxY - last.height / 2;
    for (let i4 = lastIdx - 1; i4 >= 0; i4--) {
      const next = sorted[i4 + 1];
      const curr = sorted[i4];
      const maxAllowedY = next.y - (next.height + curr.height) / 2 - actualSpacing;
      if (curr.y > maxAllowedY) {
        curr.y = maxAllowedY;
      }
    }
  }
  const first = sorted[0];
  if (first.y - first.height / 2 < minY) {
    const shift = minY - (first.y - first.height / 2);
    sorted.forEach((item) => item.y += shift);
  }
  return sorted;
}

// node_modules/@antv/infographic/esm/designs/structures/chart-wordcloud.js
var DEFAULT_ROTATE_ANGLES = [0, 30, -30, 60, -60];
var GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));
function getRotatedSize(width, height, angle) {
  const rad = Math.PI / 180 * angle;
  const cos2 = Math.cos(rad);
  const sin2 = Math.sin(rad);
  return {
    width: Math.abs(width * cos2) + Math.abs(height * sin2),
    height: Math.abs(width * sin2) + Math.abs(height * cos2)
  };
}
function hasCollision(x6, y6, width, height, placed, padding) {
  const left = x6 - padding;
  const right = x6 + width + padding;
  const top = y6 - padding;
  const bottom = y6 + height + padding;
  return placed.some((word) => {
    const wLeft = word.box.x - padding;
    const wRight = word.box.x + word.box.width + padding;
    const wTop = word.box.y - padding;
    const wBottom = word.box.y + word.box.height + padding;
    return !(right <= wLeft || left >= wRight || bottom <= wTop || top >= wBottom);
  });
}
function placeWords(words2, enableRotate, padding, spiralStep, radiusStep) {
  const placed = [];
  const rotationAngles = enableRotate ? DEFAULT_ROTATE_ANGLES : [0];
  const maxAttempts = Math.max(1600, words2.length * 28);
  words2.forEach((word, wordIndex) => {
    const sizeBias = Math.max(word.width, word.height);
    const angleOffset = wordIndex * GOLDEN_ANGLE;
    let extraRadius = 0;
    let placedWord = null;
    for (let attempt = 0; attempt < maxAttempts && !placedWord; attempt++) {
      if (attempt === Math.floor(maxAttempts * 0.6)) {
        extraRadius = sizeBias;
      }
      const theta = angleOffset + attempt * spiralStep;
      const radius = radiusStep * Math.sqrt(attempt + 1) + extraRadius + sizeBias * 0.25;
      const centerX = radius * Math.cos(theta);
      const centerY = radius * Math.sin(theta);
      for (const angle of rotationAngles) {
        const rotated = getRotatedSize(word.width, word.height, angle);
        const x6 = centerX - rotated.width / 2;
        const y6 = centerY - rotated.height / 2;
        if (!hasCollision(x6, y6, rotated.width, rotated.height, placed, padding)) {
          placedWord = Object.assign(Object.assign({}, word), {
            angle,
            centerX,
            centerY,
            box: { x: x6, y: y6, width: rotated.width, height: rotated.height }
          });
          break;
        }
      }
    }
    if (!placedWord) {
      const fallbackAngle = rotationAngles[wordIndex % rotationAngles.length];
      const farRadius = radiusStep * Math.sqrt(maxAttempts + 1) + sizeBias;
      const theta = angleOffset;
      const centerX = farRadius * Math.cos(theta);
      const centerY = farRadius * Math.sin(theta);
      const rotated = getRotatedSize(word.width, word.height, fallbackAngle);
      placedWord = Object.assign(Object.assign({}, word), {
        angle: fallbackAngle,
        centerX,
        centerY,
        box: {
          x: centerX - rotated.width / 2,
          y: centerY - rotated.height / 2,
          width: rotated.width,
          height: rotated.height
        }
      });
    }
    placed.push(placedWord);
  });
  return placed;
}
var ChartWordCloud = (props) => {
  const { data, options, minFontSize = 16, maxFontSize = 48, enableRotate = true, padding = 6, spiralStep = 0.45, radiusStep = 10 } = props;
  const { items: items3 = [] } = data;
  const validItems = items3.map((datum2, index2) => ({ datum: datum2, index: index2 })).filter(({ datum: datum2 }) => datum2.label);
  if (validItems.length === 0) {
    return jsx(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: jsx(Group, { children: jsx(ItemsGroup, {}) }) });
  }
  const values = validItems.map(({ datum: datum2 }) => datum2.value).filter((v2) => typeof v2 === "number");
  const hasValues = values.length > 0;
  const minValue = hasValues ? Math.min(...values) : 0;
  const maxValue = hasValues ? Math.max(...values) : 0;
  const sameValue = hasValues && minValue === maxValue;
  const uniformSize = (minFontSize + maxFontSize) / 2;
  const mapFontSize = (value) => {
    if (!hasValues || sameValue)
      return uniformSize;
    if (value == null)
      return minFontSize;
    const ratio = (value - minValue) / (maxValue - minValue || 1);
    return minFontSize + ratio * (maxFontSize - minFontSize);
  };
  const words2 = validItems.map(({ datum: datum2, index: index2 }) => {
    const fontSize = mapFontSize(datum2.value);
    const measured = getElementBounds(jsx(Text, { fontSize, fontWeight: "bold", children: datum2.label }));
    const color3 = getPaletteColor2(options, [index2]) || getColorPrimary(options) || "#333333";
    return {
      label: datum2.label,
      value: datum2.value,
      color: color3,
      fontSize,
      width: measured.width * 1.05,
      height: measured.height
    };
  }).sort((a3, b2) => b2.fontSize - a3.fontSize);
  const placedWords = placeWords(words2, enableRotate, padding, spiralStep, radiusStep);
  const minX = Math.min(...placedWords.map((w3) => w3.box.x));
  const minY = Math.min(...placedWords.map((w3) => w3.box.y));
  const maxX = Math.max(...placedWords.map((w3) => w3.box.x + w3.box.width));
  const maxY = Math.max(...placedWords.map((w3) => w3.box.y + w3.box.height));
  const offsetX = -minX + padding;
  const offsetY = -minY + padding;
  const containerWidth = maxX - minX + padding * 2;
  const containerHeight = maxY - minY + padding * 2;
  const wordElements = placedWords.map((word, index2) => {
    const translateX = word.centerX - word.width / 2 + offsetX;
    const translateY = word.centerY - word.height / 2 + offsetY;
    const rotationOriginX = word.width / 2;
    const rotationOriginY = word.height / 2;
    const transform2 = `translate(${translateX}, ${translateY}) rotate(${word.angle}, ${rotationOriginX}, ${rotationOriginY})`;
    return jsx(Group, { transform: transform2, children: jsx(Text, { width: word.width, height: word.height, fontSize: word.fontSize, fontWeight: "bold", alignHorizontal: "center", alignVertical: "middle", fill: word.color, "data-indexes": index2, "data-element-type": "item-label", children: word.label }) });
  });
  return jsx(ItemsGroup, { id: "infographic-container", width: containerWidth, height: containerHeight, children: wordElements });
};
registerStructure("chart-wordcloud", {
  component: ChartWordCloud,
  composites: []
});

// node_modules/@antv/infographic/esm/designs/structures/compare-binary-horizontal/dividers/types.js
var dividerRegistry = /* @__PURE__ */ new Map();
var registerDivider = (type2, component) => {
  dividerRegistry.set(type2, component);
};
var getDividerComponent = (type2) => {
  var _a;
  if (!type2)
    return null;
  return (_a = dividerRegistry.get(type2)) !== null && _a !== void 0 ? _a : null;
};

// node_modules/@antv/infographic/esm/designs/structures/compare-binary-horizontal/dividers/pros-cons-arrow.js
var ProsConsArrow = (props) => {
  const { x: x6, y: y6, colorPositive, colorNegative, colorBg } = props;
  const width = 200;
  const height = 141;
  const textAttrs = {
    width: 90,
    height: 40,
    fontSize: 22,
    alignHorizontal: "center",
    alignVertical: "middle",
    fontWeight: "bold",
    fill: colorBg
  };
  return jsxs(Group, { x: x6, y: y6, width, height, children: [jsxs(ShapesGroup, { children: [jsx("path", { d: "M137 54C137 54.2903 137 54.5806 136.706 54.7742L108.614 86.0323H64.7619C64.4071 86.0204 64.0557 86.1043 63.7453 86.2747C63.4349 86.4452 63.1773 86.6959 63 87C63.0037 86.7447 63.1092 86.5012 63.2936 86.3226L91.3862 55.0645H135.238C135.593 55.0763 135.944 54.9925 136.255 54.822C136.565 54.6516 136.823 54.4009 137 54.0968V54Z", fill: "#D9D9D9" }), jsx("path", { d: "M39.3272 0.484649C39.6146 0.234929 39.9662 0.0736935 40.3407 0.0198929C40.7152 -0.0339076 41.0971 0.0219605 41.4414 0.180925C41.7857 0.33989 42.0783 0.595358 42.2846 0.917314C42.491 1.23927 42.6026 1.61434 42.6063 1.99848V14.8156H136.013C136.54 14.8156 137.045 15.0282 137.418 15.4068C137.791 15.7853 138 16.2987 138 16.834V53.166C138 53.7013 137.791 54.2147 137.418 54.5932C137.045 54.9718 136.54 55.1844 136.013 55.1844H42.6063V68.0015C42.6026 68.3857 42.491 68.7607 42.2846 69.0827C42.0783 69.4046 41.7857 69.6601 41.4414 69.8191C41.0971 69.9781 40.7152 70.0339 40.3407 69.9801C39.9662 69.9263 39.6146 69.7651 39.3272 69.5154L0.672847 36.5138C0.461378 36.3244 0.292014 36.0915 0.176005 35.8305C0.0599968 35.5695 0 35.2864 0 35C0 34.7136 0.0599968 34.4306 0.176005 34.1696C0.292014 33.9085 0.461378 33.6756 0.672847 33.4862L39.4265 0.484649H39.3272Z", fill: colorPositive }), jsx("path", { d: "M157.394 73.0007C157.397 72.6162 157.509 72.2407 157.715 71.9183C157.922 71.596 158.214 71.3403 158.559 71.1811C158.903 71.022 159.285 70.9661 159.659 71.0199C160.034 71.0738 160.385 71.2352 160.673 71.4852L199.327 104.524C199.539 104.714 199.708 104.947 199.824 105.208C199.94 105.47 200 105.753 200 106.04C200 106.326 199.94 106.61 199.824 106.871C199.708 107.132 199.539 107.366 199.327 107.555L160.573 140.594C160.285 140.815 159.943 140.951 159.584 140.989C159.225 141.027 158.862 140.965 158.535 140.809C158.208 140.653 157.929 140.41 157.728 140.105C157.527 139.8 157.411 139.445 157.394 139.078V126.247H63.9874C63.4603 126.247 62.9548 126.034 62.5821 125.655C62.2094 125.276 62 124.762 62 124.226V87.8531C62 87.3172 62.2094 86.8032 62.5821 86.4242C62.9548 86.0453 63.4603 85.8324 63.9874 85.8324H157.394V73.0007Z", fill: colorNegative })] }), jsx(Text, Object.assign({ x: 40, y: 15 }, textAttrs, { children: "Pros" })), jsx(Text, Object.assign({ x: 70, y: 85 }, textAttrs, { children: "Cons" }))] });
};
registerDivider("pros-cons-arrow", ProsConsArrow);

// node_modules/@antv/infographic/esm/designs/structures/compare-binary-horizontal/dividers/pros-cons-fold.js
var ProsConsFold = (props) => {
  const { x: x6, y: y6, colorPositive, colorNegative, colorBg } = props;
  const width = 240;
  const height = 300;
  const textAttrs = {
    width: 85,
    height: 30,
    fontSize: 20,
    alignHorizontal: "center",
    alignVertical: "middle",
    fontWeight: "bold",
    fill: colorBg
  };
  return jsxs(Group, { x: x6, y: y6, width, height, children: [jsxs(ShapesGroup, { children: [jsx("path", { d: "M136.914 38.7755C137.303 38.7733 137.683 38.6617 138.011 38.4534C138.339 38.2451 138.602 37.9485 138.77 37.5977C138.937 37.247 139.002 36.8561 138.957 36.4701C138.913 36.084 138.76 35.7183 138.517 35.415L110.741 0.982313C110.548 0.735138 110.301 0.535238 110.018 0.397762C109.736 0.260286 109.426 0.188841 109.112 0.188841C108.798 0.188841 108.488 0.260286 108.206 0.397762C107.924 0.535238 107.676 0.735138 107.483 0.982313L79.7069 35.415C79.4639 35.7183 79.3113 36.084 79.2667 36.4701C79.222 36.8561 79.2871 37.247 79.4545 37.5977C79.6219 37.9485 79.8847 38.2451 80.213 38.4534C80.5412 38.6617 80.9216 38.7733 81.3104 38.7755H92.8965C93.0517 57.1293 97.5517 64.9878 105.259 73.7252C107.017 75.7932 108.983 77.8612 111.103 80.1361C113.276 82.4626 122.121 88.9252 131.069 95.181C129.362 88.7701 128.172 81.2218 127.293 73.7252C125.224 55.9918 125.017 38.7755 125.017 38.7755H136.914Z", fill: colorPositive, fillOpacity: 0.4 }), jsx("path", { d: "M237.931 109.967C238.48 109.967 239.006 109.749 239.394 109.362C239.782 108.974 240 108.448 240 107.899V75.7932C240 75.2447 239.782 74.7187 239.394 74.3309C239.006 73.9431 238.48 73.7252 237.931 73.7252H127.241C128.172 81.2218 129.362 88.7701 131.069 95.181C138.182 100.171 145.337 105.1 152.534 109.967H237.931Z", fill: colorPositive }), jsx("path", { d: "M152.586 109.967C152.586 109.967 141.724 102.678 131.069 95.181C124.122 90.5838 117.455 85.5772 111.103 80.1878C109.034 77.8612 107.017 75.7415 105.259 73.7252H48.6207V56.6639C48.6091 56.2797 48.4905 55.9063 48.2784 55.5857C48.0662 55.2651 47.7689 55.0099 47.4197 54.8488C47.0705 54.6878 46.6833 54.6271 46.3016 54.6738C45.9199 54.7204 45.5587 54.8725 45.2586 55.1129L1.50002 90.2694C1.26208 90.4633 1.07029 90.7078 0.938585 90.985C0.80688 91.2622 0.738558 91.5652 0.738558 91.8721C0.738558 92.179 0.80688 92.482 0.938585 92.7592C1.07029 93.0365 1.26208 93.2809 1.50002 93.4748L45.2586 128.631C45.5621 128.874 45.928 129.027 46.3142 129.071C46.7005 129.116 47.0914 129.051 47.4424 128.884C47.7933 128.716 48.09 128.454 48.2984 128.125C48.5068 127.797 48.6185 127.417 48.6207 127.029V109.967H152.586Z", fill: "#BFBFBF" }), jsx("path", { d: "M36.1034 88.9252H28.9655V93.785H36.1034V101.85H41.4828V93.785H48.6207V88.8735H41.4828V81.1701H36.1034V88.9252Z", fill: "#404040" }), jsx("path", { d: "M103.086 261.224C102.697 261.227 102.317 261.338 101.989 261.547C101.661 261.755 101.398 262.051 101.23 262.402C101.063 262.753 100.998 263.144 101.043 263.53C101.087 263.916 101.24 264.282 101.483 264.585L129.259 299.018C129.452 299.265 129.699 299.465 129.982 299.602C130.264 299.74 130.574 299.811 130.888 299.811C131.202 299.811 131.512 299.74 131.794 299.602C132.076 299.465 132.324 299.265 132.517 299.018L160.293 264.585C160.536 264.282 160.689 263.916 160.733 263.53C160.778 263.144 160.713 262.753 160.546 262.402C160.378 262.051 160.115 261.755 159.787 261.547C159.459 261.338 159.078 261.227 158.69 261.224H147.103C146.948 242.871 142.448 235.012 134.741 226.275C132.983 224.207 131.017 222.139 128.897 219.864C126.724 217.537 117.879 211.075 108.931 204.819C110.677 211.877 111.938 219.045 112.707 226.275C114.776 244.008 114.983 261.224 114.983 261.224H103.086Z", fill: colorNegative, fillOpacity: 0.4 }), jsx("path", { d: "M2.06897 190.033C1.52025 190.033 0.993996 190.251 0.605989 190.638C0.217983 191.026 5.00679e-06 191.552 5.00679e-06 192.101V224.207C5.00679e-06 224.755 0.217983 225.281 0.605989 225.669C0.993996 226.057 1.52025 226.275 2.06897 226.275H112.759C111.828 218.778 110.638 211.23 108.931 204.819C99.9827 198.512 90.931 192.411 88.2414 190.55C87.7206 190.204 87.1077 190.024 86.4828 190.033H2.06897Z", fill: colorNegative }), jsx("path", { d: "M87.4138 190.033C87.4138 190.033 98.2759 197.322 108.931 204.819C115.878 209.416 122.545 214.423 128.897 219.812C130.966 222.139 132.983 224.258 134.741 226.275H191.379V243.336C191.391 243.72 191.51 244.094 191.722 244.414C191.934 244.735 192.231 244.99 192.58 245.151C192.929 245.312 193.317 245.373 193.698 245.326C194.08 245.28 194.441 245.128 194.741 244.887L238.5 209.731C238.738 209.537 238.93 209.292 239.061 209.015C239.193 208.738 239.261 208.435 239.261 208.128C239.261 207.821 239.193 207.518 239.061 207.241C238.93 206.964 238.738 206.719 238.5 206.525L194.741 171.369C194.438 171.126 194.072 170.973 193.686 170.929C193.3 170.884 192.909 170.949 192.558 171.116C192.207 171.284 191.91 171.546 191.702 171.875C191.493 172.203 191.382 172.583 191.379 172.971V190.033H87.4138Z", fill: "#BFBFBF" }), jsx("path", { d: "M192.414 205.905V210.816H212.069V205.905H192.414Z", fill: "#404040" })] }), jsx(Text, Object.assign({ x: 153, y: 77 }, textAttrs, { children: "PROS" })), jsx(Text, Object.assign({ x: 2, y: 193 }, textAttrs, { children: "CONS" }))] });
};
registerDivider("pros-cons-fold", ProsConsFold);

// node_modules/@antv/infographic/esm/designs/structures/compare-binary-horizontal/dividers/vs.js
var VSDivider = (props) => {
  const { x: x6, y: y6, colorPrimary, colorBg } = props;
  const width = 100;
  const height = 100;
  const lightColor = tinycolor(colorPrimary).lighten(20).toString();
  return jsxs(Group, { x: x6, y: y6, width, height, children: [jsxs(Defs, { children: [jsx("filter", { id: "vs-divider-glow-filter", x: "-50%", y: "-50%", width: "200%", height: "200%", children: jsx("feGaussianBlur", { in: "SourceGraphic", stdDeviation: "8", result: "blur" }) }), jsx(DropShadow, {})] }), jsx(Ellipse, { x: 0, y: 0, width, height, fill: lightColor, filter: "url(#vs-divider-glow-filter)", opacity: 0.6 }), jsx(Ellipse, { x: 0, y: 0, width, height, fill: colorPrimary, "data-element-type": "shape" }), jsx("text", { x: width / 2, y: height / 2, fontSize: Math.min(width, height) / 1.5, fontWeight: "bold", fill: colorBg, textAnchor: "middle", dominantBaseline: "central", filter: "url(#drop-shadow)", children: "VS" })] });
};
registerDivider("vs", VSDivider);

// node_modules/@antv/infographic/esm/designs/structures/compare-binary-horizontal/index.js
var CompareBinaryHorizontal = (props) => {
  const { Title: Title2, Item, data, gap = 20, groupGap = 20, opposite = true, flipped = true, dividerType = "vs", options } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  if (items3.length === 0) {
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { children: jsx(BtnsGroup, { children: jsx(BtnAdd, { indexes: [0], x: 0, y: 0 }) }) })] });
  }
  const leftRoot = items3[0] || { children: [] };
  const rightRoot = items3[1] || { children: [] };
  const leftChildren = leftRoot.children || [];
  const rightChildren = rightRoot.children || [];
  const colors = getThemeColors(options.themeConfig);
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0, 0], data, datum: leftChildren[0] || {} }));
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const Divider = getDividerComponent(dividerType);
  const dividerBounds = Divider ? getElementBounds(jsx(Divider, { x: 0, y: 0, colorPrimary: colors.colorPrimary, colorBg: colors.colorBg, colorPositive: colors.colorPrimary, colorNegative: colors.colorPrimary })) : { width: 0, height: 0 };
  const itemElements = [];
  const btnElements = [];
  const decorElements = [];
  const maxChildren = Math.max(leftChildren.length, rightChildren.length);
  const itemsHeight = maxChildren > 0 ? maxChildren * (itemBounds.height + gap) - gap : 0;
  const btnSpacing = 5;
  const topOffset = maxChildren > 0 ? gap / 2 + btnBounds.height / 2 : btnBounds.height / 2;
  const leftX = btnBounds.width + btnSpacing;
  const dividerX = leftX + itemBounds.width + groupGap;
  const rightX = dividerX + dividerBounds.width + groupGap;
  const leftPositionH = flipped ? "flipped" : opposite ? "normal" : "normal";
  const rightPositionH = flipped ? "normal" : opposite ? "flipped" : "normal";
  leftChildren.forEach((child, index2) => {
    const childY = topOffset + index2 * (itemBounds.height + gap);
    const indexes = [0, index2];
    itemElements.push(jsx(Item, { indexes, datum: child, data, x: leftX, y: childY, positionH: leftPositionH, positionV: "middle" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: leftX - btnBounds.width - btnSpacing, y: childY + (itemBounds.height - btnBounds.height) / 2 }));
    if (index2 < leftChildren.length - 1) {
      btnElements.push(jsx(BtnAdd, { indexes: [0, index2 + 1], x: leftX + (itemBounds.width - btnBounds.width) / 2, y: childY + itemBounds.height + gap / 2 - btnBounds.height / 2 }));
    }
  });
  if (leftChildren.length > 0) {
    btnElements.push(jsx(BtnAdd, { indexes: [0, 0], x: leftX + (itemBounds.width - btnBounds.width) / 2, y: topOffset - gap / 2 - btnBounds.height / 2 }));
    const lastChildY = topOffset + (leftChildren.length - 1) * (itemBounds.height + gap);
    btnElements.push(jsx(BtnAdd, { indexes: [0, leftChildren.length], x: leftX + (itemBounds.width - btnBounds.width) / 2, y: lastChildY + itemBounds.height + gap / 2 - btnBounds.height / 2 }));
  } else if (items3.length >= 1) {
    btnElements.push(jsx(BtnAdd, { indexes: [0, 0], x: leftX + (itemBounds.width - btnBounds.width) / 2, y: topOffset - btnBounds.height / 2 }));
  }
  rightChildren.forEach((child, index2) => {
    const childY = topOffset + index2 * (itemBounds.height + gap);
    const indexes = [1, index2];
    itemElements.push(jsx(Item, { indexes, datum: child, data, x: rightX, y: childY, positionH: rightPositionH, positionV: "middle" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: rightX + itemBounds.width + btnSpacing, y: childY + (itemBounds.height - btnBounds.height) / 2 }));
    if (index2 < rightChildren.length - 1) {
      btnElements.push(jsx(BtnAdd, { indexes: [1, index2 + 1], x: rightX + (itemBounds.width - btnBounds.width) / 2, y: childY + itemBounds.height + gap / 2 - btnBounds.height / 2 }));
    }
  });
  if (rightChildren.length > 0) {
    btnElements.push(jsx(BtnAdd, { indexes: [1, 0], x: rightX + (itemBounds.width - btnBounds.width) / 2, y: topOffset - gap / 2 - btnBounds.height / 2 }));
    const lastChildY = topOffset + (rightChildren.length - 1) * (itemBounds.height + gap);
    btnElements.push(jsx(BtnAdd, { indexes: [1, rightChildren.length], x: rightX + (itemBounds.width - btnBounds.width) / 2, y: lastChildY + itemBounds.height + gap / 2 - btnBounds.height / 2 }));
  } else if (items3.length >= 2) {
    btnElements.push(jsx(BtnAdd, { indexes: [1, 0], x: rightX + (itemBounds.width - btnBounds.width) / 2, y: topOffset - btnBounds.height / 2 }));
  }
  if (items3.length < 2) {
    btnElements.push(jsx(BtnAdd, { indexes: [1], x: rightX + (itemBounds.width - btnBounds.width) / 2, y: topOffset + (itemsHeight - btnBounds.height) / 2 }));
  }
  if (Divider) {
    decorElements.push(jsx(Divider, { x: dividerX, y: topOffset + (itemsHeight - dividerBounds.height) / 2, colorPrimary: colors.colorPrimary, colorBg: colors.colorBg, colorPositive: getPaletteColor2(options, [0]) || colors.colorPrimary, colorNegative: getPaletteColor2(options, [1]) || colors.colorPrimary }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(Group, { children: decorElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("compare-binary-horizontal", {
  component: CompareBinaryHorizontal,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/compare-hierarchy-left-right.js
var decorationWidthMap = {
  none: 5,
  "dot-line": 100,
  "arc-dot": 20,
  "split-line": 5
};
var CompareHierarchyLeftRight = (props) => {
  var _a, _b;
  const { Title: Title2, Items, data, gap = 20, groupGap = 0, decoration = "none", surround = true, flipRoot = false, flipLeaf = false, options } = props;
  const [RootItem, Item] = Items;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const rootItemContent = jsx(RootItem, { indexes: [0], data, datum: data.items[0], themeColors: {} });
  const itemContent = jsx(Item, { indexes: [0, 0], data, datum: ((_b = (_a = items3[0]) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b[0]) || items3[2] });
  const rootItemBounds = getElementBounds(rootItemContent);
  const itemBounds = getElementBounds(itemContent);
  const itemElements = [];
  const decoElements = [];
  const [leftRoot, rightRoot] = items3;
  const leftItems = (leftRoot === null || leftRoot === void 0 ? void 0 : leftRoot.children) || [];
  const rightItems = (rightRoot === null || rightRoot === void 0 ? void 0 : rightRoot.children) || [];
  const totalHeight = Math.max(rootItemBounds.height, leftItems.length * (itemBounds.height + gap) - gap, rightItems.length * (itemBounds.height + gap) - gap);
  const decorationWidth = decorationWidthMap[decoration] || 0;
  const leftRootX = itemBounds.width + decorationWidth;
  const rightRootX = leftRootX + rootItemBounds.width + groupGap;
  const rootY = (totalHeight - rootItemBounds.height) / 2;
  if (leftRoot) {
    itemElements.push(jsx(RootItem, { indexes: [0], x: leftRootX, y: rootY, data, datum: leftRoot, positionH: flipRoot ? "normal" : "flipped" }));
  }
  if (rightRoot) {
    itemElements.push(jsx(RootItem, { indexes: [1], x: rightRootX, y: rootY, data, datum: rightRoot, positionH: flipRoot ? "flipped" : "normal" }));
  }
  const addDecoElement = (side, pos, indexes) => {
    if (decoration === "none")
      return;
    const [x6, y6] = pos;
    const currentColor = getPaletteColor2(options, indexes);
    const props2 = {
      x: x6,
      y: y6,
      width: itemBounds.width,
      height: itemBounds.height,
      side,
      color: currentColor || "#ccc",
      colorBg: options.themeConfig.colorBg || "#fff"
    };
    if (decoration === "split-line") {
      decoElements.push(jsx(SplitLine, Object.assign({}, props2)));
    } else if (decoration === "dot-line") {
      decoElements.push(jsx(DotLine3, Object.assign({}, props2)));
    }
  };
  if (surround) {
    const diameter = 2 * rootItemBounds.width + groupGap + itemBounds.width;
    const radius = diameter / 2 + decorationWidth;
    const circleCenterX = leftRootX + rootItemBounds.width + groupGap / 2;
    const circleCenterY = rootY + rootItemBounds.height / 2;
    leftItems.forEach((item, index2) => {
      const leftItemsHeight = leftItems.length * (itemBounds.height + gap) - gap;
      const leftStartY = (totalHeight - leftItemsHeight) / 2;
      const itemY = leftStartY + index2 * (itemBounds.height + gap);
      const itemCenterY = itemY + itemBounds.height / 2;
      const dy = itemCenterY - circleCenterY;
      const dxSq = Math.max(0, radius * radius - dy * dy);
      const xCenter = circleCenterX - Math.sqrt(dxSq);
      const leftX = xCenter - itemBounds.width / 2;
      itemElements.push(jsx(Item, { indexes: [0, index2], datum: item, data, x: leftX, y: itemY, positionH: flipLeaf ? "flipped" : "normal" }));
      addDecoElement("left", [leftX, itemY], [0, index2]);
    });
    rightItems.forEach((item, index2) => {
      const rightItemsHeight = rightItems.length * (itemBounds.height + gap) - gap;
      const rightStartY = (totalHeight - rightItemsHeight) / 2;
      const itemY = rightStartY + index2 * (itemBounds.height + gap);
      const itemCenterY = itemY + itemBounds.height / 2;
      const dy = itemCenterY - circleCenterY;
      const dxSq = Math.max(0, radius * radius - dy * dy);
      const xCenter = circleCenterX + Math.sqrt(dxSq);
      const rightX = xCenter - itemBounds.width / 2;
      itemElements.push(jsx(Item, { indexes: [1, index2], datum: item, data, x: rightX, y: itemY, positionH: flipLeaf ? "normal" : "flipped" }));
      addDecoElement("right", [rightX, itemY], [1, index2]);
    });
  } else {
    leftItems.forEach((item, index2) => {
      const leftItemsHeight = leftItems.length * (itemBounds.height + gap) - gap;
      const leftStartY = (totalHeight - leftItemsHeight) / 2;
      const itemY = leftStartY + index2 * (itemBounds.height + gap);
      const indexes = [0, index2];
      const leftX = 0;
      itemElements.push(jsx(Item, { indexes, datum: item, data, x: leftX, y: itemY, positionH: flipLeaf ? "flipped" : "normal" }));
      addDecoElement("left", [leftX, itemY], indexes);
    });
    rightItems.forEach((item, index2) => {
      const rightItemsHeight = rightItems.length * (itemBounds.height + gap) - gap;
      const rightStartY = (totalHeight - rightItemsHeight) / 2;
      const itemY = rightStartY + index2 * (itemBounds.height + gap);
      const indexes = [1, index2];
      const rightX = rightRootX + rootItemBounds.width + decorationWidth;
      itemElements.push(jsx(Item, { indexes, datum: item, data, x: rightX, y: itemY, positionH: flipLeaf ? "normal" : "flipped" }));
      addDecoElement("right", [rightX, itemY], indexes);
    });
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(ItemsGroup, { children: itemElements }), jsx(Group, { width: 0, height: 0, children: decoElements })] })] });
};
var SplitLine = (props) => {
  const { x: x6, y: y6, width, height, color: color3, colorBg, side } = props;
  const lineY = y6 + height;
  const linearGradientId = `split-line-linear-gradient-${side}`;
  return jsxs(Fragment, { children: [jsx(Defs, { children: jsx(LinearGradient, { id: linearGradientId, startColor: color3, stopColor: colorBg, direction: side === "left" ? "left-right" : "right-left" }) }), jsx(Rect, { x: x6, y: lineY, width, height: 1, fill: `url(#${linearGradientId})` })] });
};
var DotLine3 = (props) => {
  const { x: x6, y: y6, side, width, height, color: color3, colorBg } = props;
  const radius = 6;
  const innerRadius = radius / 3;
  const d3 = radius * 2;
  const innerD = innerRadius * 2;
  const gap = 5;
  const cx = side === "left" ? x6 + width + radius + gap : x6 - radius - gap;
  const cy = y6 + height / 2;
  const innerX = cx - innerRadius;
  const innerY = cy - innerRadius;
  const lineLength = 80;
  const dx = side === "left" ? lineLength : -lineLength;
  const linearGradientId = `dot-line-linear-gradient-${side}`;
  return jsxs(Group, { children: [jsx(Defs, { children: jsx(LinearGradient, { id: linearGradientId, startColor: color3, stopColor: colorBg, direction: side === "left" ? "left-right" : "right-left" }) }), jsxs(ShapesGroup, { children: [jsx(Ellipse, { x: cx - radius, y: cy - radius, width: d3, height: d3, fill: "none", strokeWidth: 1, stroke: color3 }), jsx(Ellipse, { x: innerX, y: innerY, width: innerD, height: innerD, fill: color3 })] }), jsx(Rect, { x: side === "left" ? cx : cx + dx, y: cy - 0.5, width: lineLength, height: 1, fill: `url(#${linearGradientId})` })] });
};
registerStructure("compare-hierarchy-left-right", {
  component: CompareHierarchyLeftRight,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/compare-hierarchy-row.js
var CompareHierarchyRow = (props) => {
  var _a, _b;
  const { Title: Title2, Items, data, gap = 0, itemGap = 20, columnWidth = 280, itemPadding = 5, showColumnBackground = true, columnBackgroundAlpha = 0.08, options } = props;
  const [RootItem, Item] = Items;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const palette2 = getPaletteColors(options);
  const itemElements = [];
  const btnElements = [];
  const childItemWidth = columnWidth - itemPadding * 2;
  const rootItemBounds = getElementBounds(jsx(RootItem, { indexes: [0], data, datum: items3[0], width: columnWidth }));
  const childItemBounds = getElementBounds(jsx(Item, { indexes: [0, 0], data, datum: ((_b = (_a = items3[0]) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b[0]) || {}, width: childItemWidth }));
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const maxChildrenCount = Math.max(...items3.map((item) => {
    var _a2;
    return ((_a2 = item.children) === null || _a2 === void 0 ? void 0 : _a2.length) || 0;
  }), 0);
  const columnHeight = rootItemBounds.height + itemGap + maxChildrenCount * (childItemBounds.height + itemGap);
  items3.forEach((rootItem, rootIndex) => {
    const { children: children2 = [] } = rootItem;
    const columnX = rootIndex * (columnWidth + gap);
    const rootX = columnX;
    const rootY = 0;
    if (showColumnBackground) {
      const baseColor = palette2[rootIndex % palette2.length];
      const bgColor = `${baseColor}${Math.round(columnBackgroundAlpha * 255).toString(16).padStart(2, "0")}`;
      itemElements.push(jsx(Rect, { x: columnX, y: rootY, width: columnWidth, height: columnHeight, fill: bgColor, rx: 0, ry: 0, "data-element-type": "shape" }));
    }
    itemElements.push(jsx(RootItem, { indexes: [rootIndex], datum: rootItem, data, x: rootX, y: rootY, width: columnWidth }));
    btnElements.push(jsx(BtnRemove, { indexes: [rootIndex], x: rootX + rootItemBounds.width - btnBounds.width - 10, y: rootY + 10 }));
    if (rootIndex === 0) {
      btnElements.push(jsx(BtnAdd, { indexes: [rootIndex], x: rootX + rootItemBounds.width / 2 - btnBounds.width / 2, y: rootY - btnBounds.height - 5 }));
    }
    const childStartY = rootY + rootItemBounds.height + itemGap;
    children2.forEach((child, childIndex) => {
      const childY = childStartY + childIndex * (childItemBounds.height + itemGap);
      const childX2 = rootX + itemPadding;
      const indexes = [rootIndex, childIndex];
      itemElements.push(jsx(Item, { indexes, datum: child, data, x: childX2, y: childY, width: childItemWidth }));
      btnElements.push(jsx(BtnRemove, { indexes, x: childX2 + childItemBounds.width - btnBounds.width - 10, y: childY + (childItemBounds.height - btnBounds.height) / 2 }));
      if (childIndex < children2.length - 1) {
        btnElements.push(jsx(BtnAdd, { indexes: [rootIndex, childIndex + 1], x: childX2 + childItemBounds.width / 2 - btnBounds.width / 2, y: childY + childItemBounds.height - btnBounds.height / 2 }));
      }
    });
    const childX = rootX + itemPadding;
    if (children2.length > 0) {
      const lastChildY = childStartY + children2.length * (childItemBounds.height + itemGap);
      btnElements.push(jsx(BtnAdd, { indexes: [rootIndex, children2.length], x: childX + childItemBounds.width / 2 - btnBounds.width / 2, y: lastChildY - childItemBounds.height / 2 - btnBounds.height / 2 }));
    } else {
      btnElements.push(jsx(BtnAdd, { indexes: [rootIndex, 0], x: childX + childItemBounds.width / 2 - btnBounds.width / 2, y: childStartY - itemGap / 2 - btnBounds.height / 2 }));
    }
  });
  if (items3.length > 0) {
    const lastColumnX = items3.length * (columnWidth + gap);
    btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: lastColumnX - gap / 2 - btnBounds.width / 2, y: -btnBounds.height - 5 }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("compare-hierarchy-row", {
  component: CompareHierarchyRow,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/compare-quadrant.js
var QUADRANT_CONFIG = {
  axisColor: "#D9D9D9",
  axisArrowSize: 5,
  strokeWidth: 1,
  dashArray: "4,2",
  // 4px2px
  defaultExtraSpacing: 20
  // 
};
var Quadrant = (props) => {
  const { Title: Title2, Item, data, quadrantWidth: userQuadrantWidth, quadrantHeight: userQuadrantHeight, showAxis = true, dashedAxis = true } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const quadrantItems = Array.from({ length: 4 }, (_2, i4) => items3[i4]);
  const itemBounds = quadrantItems[0] ? getElementBounds(jsx(Item, { indexes: [0], data, datum: quadrantItems[0] })) : { width: 0, height: 0 };
  const quadrantWidth = userQuadrantWidth !== null && userQuadrantWidth !== void 0 ? userQuadrantWidth : itemBounds.width + QUADRANT_CONFIG.defaultExtraSpacing;
  const quadrantHeight = userQuadrantHeight !== null && userQuadrantHeight !== void 0 ? userQuadrantHeight : itemBounds.height + QUADRANT_CONFIG.defaultExtraSpacing;
  const quadrantPositions = calculateQuadrantPositions(quadrantWidth, quadrantHeight, itemBounds);
  const itemElements = quadrantItems.map((item, index2) => {
    if (!item)
      return null;
    const position = quadrantPositions[index2];
    return jsx(Item, { indexes: [index2], datum: item, data, x: position.x, y: position.y, positionH: index2 % 2 ? "flipped" : "normal", positionV: index2 < 2 ? "normal" : "flipped" });
  }).filter(Boolean);
  const axisElements = createAxisElements(quadrantWidth, quadrantHeight, showAxis, dashedAxis);
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { width: quadrantWidth * 2, height: quadrantHeight * 2, children: [axisElements, jsx(ItemsGroup, { children: itemElements })] })] });
};
function createAxisElements(quadrantWidth, quadrantHeight, showAxis, dashedAxis) {
  if (!showAxis)
    return [];
  const { axisColor, axisArrowSize, strokeWidth, dashArray } = QUADRANT_CONFIG;
  const centerX = quadrantWidth;
  const centerY = quadrantHeight;
  const maxX = quadrantWidth * 2;
  const maxY = quadrantHeight * 2;
  const strokeDasharray = dashedAxis ? dashArray : void 0;
  return [
    // X 
    jsx(Path, { d: `M 0 ${centerY} L ${maxX} ${centerY}`, stroke: axisColor, strokeWidth, strokeDasharray, fill: "none", "data-element-type": "shape" }),
    // X 
    jsxs(ShapesGroup, { transform: `translate(${maxX}, ${centerY})`, children: [jsx(Path, { d: `M 0 0 L ${-axisArrowSize} ${-axisArrowSize / 2}`, stroke: axisColor, strokeWidth, fill: "none" }), jsx(Path, { d: `M 0 0 L ${-axisArrowSize} ${axisArrowSize / 2}`, stroke: axisColor, strokeWidth, fill: "none" })] }),
    // X 
    jsxs(ShapesGroup, { transform: `translate(0, ${centerY})`, children: [jsx(Path, { d: `M 0 0 L ${axisArrowSize} ${-axisArrowSize / 2}`, stroke: axisColor, strokeWidth, fill: "none" }), jsx(Path, { d: `M 0 0 L ${axisArrowSize} ${axisArrowSize / 2}`, stroke: axisColor, strokeWidth, fill: "none" })] }),
    // Y 
    jsx(Path, { d: `M ${centerX} 0 L ${centerX} ${maxY}`, stroke: axisColor, strokeWidth, strokeDasharray, fill: "none", "data-element-type": "shape" }),
    // Y 
    jsxs(ShapesGroup, { transform: `translate(${centerX}, 0)`, children: [jsx(Path, { d: `M 0 0 L ${-axisArrowSize / 2} ${axisArrowSize}`, stroke: axisColor, strokeWidth, fill: "none" }), jsx(Path, { d: `M 0 0 L ${axisArrowSize / 2} ${axisArrowSize}`, stroke: axisColor, strokeWidth, fill: "none" })] }),
    // Y 
    jsxs(ShapesGroup, { transform: `translate(${centerX}, ${maxY})`, children: [jsx(Path, { d: `M 0 0 L ${-axisArrowSize / 2} ${-axisArrowSize}`, stroke: axisColor, strokeWidth, fill: "none" }), jsx(Path, { d: `M 0 0 L ${axisArrowSize / 2} ${-axisArrowSize}`, stroke: axisColor, strokeWidth, fill: "none" })] })
  ];
}
function calculateQuadrantPositions(quadrantWidth, quadrantHeight, itemBounds) {
  const centerX = quadrantWidth / 2;
  const centerY = quadrantHeight / 2;
  return [
    {
      x: centerX - itemBounds.width / 2,
      y: centerY - itemBounds.height / 2
    },
    //  ()
    {
      x: quadrantWidth + centerX - itemBounds.width / 2,
      y: centerY - itemBounds.height / 2
    },
    //  ()
    {
      x: centerX - itemBounds.width / 2,
      y: quadrantHeight + centerY - itemBounds.height / 2
    },
    //  ()
    {
      x: quadrantWidth + centerX - itemBounds.width / 2,
      y: quadrantHeight + centerY - itemBounds.height / 2
    }
    //  ()
  ];
}
registerStructure("quadrant", {
  component: Quadrant,
  composites: ["title", "item"]
});

// node_modules/@antv/hierarchy/dist/hierarchy.es.js
var e6 = Object.assign;
var i2 = { getId: (t2) => t2.id || t2.name, getPreH: (t2) => t2.preH || 0, getPreV: (t2) => t2.preV || 0, getHGap: (t2) => t2.hgap || 18, getVGap: (t2) => t2.vgap || 18, getChildren: (t2) => t2.children, getHeight: (t2) => t2.height || 36, getWidth(t2) {
  const e8 = t2.label || " ";
  return t2.width || 18 * e8.split("").length;
} };
var n2 = class {
  constructor(t2, e8) {
    if (this.x = 0, this.y = 0, this.depth = 0, this.children = [], this.hgap = 0, this.vgap = 0, t2 instanceof n2 || "x" in t2 && "y" in t2 && "children" in t2) {
      const e9 = t2;
      return this.data = e9.data, this.id = e9.id, this.x = e9.x, this.y = e9.y, this.width = e9.width, this.height = e9.height, this.depth = e9.depth, this.children = e9.children, this.parent = e9.parent, this.hgap = e9.hgap, this.vgap = e9.vgap, this.preH = e9.preH, void (this.preV = e9.preV);
    }
    this.data = t2;
    const i4 = e8.getHGap(t2), h4 = e8.getVGap(t2);
    this.preH = e8.getPreH(t2), this.preV = e8.getPreV(t2), this.width = e8.getWidth(t2), this.height = e8.getHeight(t2), this.width += this.preH, this.height += this.preV, this.id = e8.getId(t2), this.addGap(i4, h4);
  }
  isRoot() {
    return 0 === this.depth;
  }
  isLeaf() {
    return 0 === this.children.length;
  }
  addGap(t2, e8) {
    this.hgap += t2, this.vgap += e8, this.width += 2 * t2, this.height += 2 * e8;
  }
  eachNode(t2) {
    let e8, i4 = [this];
    for (; e8 = i4.shift(); )
      t2(e8), i4 = e8.children.concat(i4);
  }
  DFTraverse(t2) {
    this.eachNode(t2);
  }
  BFTraverse(t2) {
    let e8, i4 = [this];
    for (; e8 = i4.shift(); )
      t2(e8), i4 = i4.concat(e8.children);
  }
  getBoundingBox() {
    const t2 = { left: Number.MAX_VALUE, top: Number.MAX_VALUE, width: 0, height: 0 };
    return this.eachNode((e8) => {
      t2.left = Math.min(t2.left, e8.x), t2.top = Math.min(t2.top, e8.y), t2.width = Math.max(t2.width, e8.x + e8.width), t2.height = Math.max(t2.height, e8.y + e8.height);
    }), t2;
  }
  translate(t2 = 0, e8 = 0) {
    this.eachNode((i4) => {
      i4.x += t2, i4.y += e8, i4.x += i4.preH, i4.y += i4.preV;
    });
  }
  right2left() {
    const t2 = this.getBoundingBox();
    this.eachNode((e8) => {
      e8.x = e8.x - 2 * (e8.x - t2.left) - e8.width;
    }), this.translate(t2.width, 0);
  }
  bottom2top() {
    const t2 = this.getBoundingBox();
    this.eachNode((e8) => {
      e8.y = e8.y - 2 * (e8.y - t2.top) - e8.height;
    }), this.translate(0, t2.height);
  }
};
function h2(t2, h4 = {}, r5) {
  h4 = e6({}, i2, h4);
  const o3 = new n2(t2, h4), s3 = [o3];
  let c4;
  if (!r5 && !t2.collapsed) {
    for (; c4 = s3.shift(); )
      if (!c4.data.collapsed) {
        const t3 = h4.getChildren(c4.data), e8 = t3 ? t3.length : 0;
        if (c4.children = new Array(e8), t3 && e8)
          for (let i4 = 0; i4 < e8; i4++) {
            const e9 = new n2(t3[i4], h4);
            c4.children[i4] = e9, s3.push(e9), e9.parent = c4, e9.depth = c4.depth + 1;
          }
      }
  }
  return o3;
}
var r3 = class {
  constructor(t2, e8 = {}) {
    this.options = e8, this.rootNode = h2(t2, e8);
  }
  execute() {
    throw new Error("please override this method");
  }
};
function g2(t2, e8) {
  const i4 = h2(t2.data, e8, true), n4 = h2(t2.data, e8, true), r5 = t2.children.length, o3 = Math.round(r5 / 2), s3 = e8.getSide || function(t3, e9) {
    return e9 < o3 ? "right" : "left";
  };
  for (let h4 = 0; h4 < r5; h4++) {
    const e9 = t2.children[h4];
    "right" === s3(e9, h4) ? n4.children.push(e9) : i4.children.push(e9);
  }
  return i4.eachNode((t3) => {
    t3.isRoot() || (t3.side = "left");
  }), n4.eachNode((t3) => {
    t3.isRoot() || (t3.side = "right");
  }), { left: i4, right: n4 };
}
var u2 = ["LR", "RL", "TB", "BT", "H", "V"];
var p5 = ["LR", "RL", "H"];
var x5 = u2[0];
function y5(t2, e8, i4) {
  const n4 = e8.direction || x5;
  if (e8.isHorizontal = ((t3) => p5.indexOf(t3) > -1)(n4), n4 && -1 === u2.indexOf(n4))
    throw new TypeError(`Invalid direction: ${n4}`);
  if (n4 === u2[0])
    i4(t2, e8);
  else if (n4 === u2[1])
    i4(t2, e8), t2.right2left();
  else if (n4 === u2[2])
    i4(t2, e8);
  else if (n4 === u2[3])
    i4(t2, e8), t2.bottom2top();
  else if (n4 === u2[4] || n4 === u2[5]) {
    const { left: n5, right: h5 } = g2(t2, e8);
    i4(n5, e8), i4(h5, e8), e8.isHorizontal ? n5.right2left() : n5.bottom2top(), h5.translate(n5.x - h5.x, n5.y - h5.y), t2.x = n5.x, t2.y = h5.y;
    const r5 = t2.getBoundingBox();
    e8.isHorizontal ? r5.top < 0 && t2.translate(0, -r5.top) : r5.left < 0 && t2.translate(-r5.left, 0);
  }
  let h4 = e8.fixedRoot;
  return void 0 === h4 && (h4 = true), h4 && t2.translate(-(t2.x + t2.width / 2 + t2.hgap), -(t2.y + t2.height / 2 + t2.vgap)), function(t3, e9) {
    if (e9.radial) {
      const [i5, n5] = e9.isHorizontal ? ["x", "y"] : ["y", "x"], h5 = { x: 1 / 0, y: 1 / 0 }, r5 = { x: -1 / 0, y: -1 / 0 };
      let o3 = 0;
      t3.DFTraverse((t4) => {
        o3++;
        const { x: e11, y: i6 } = t4;
        h5.x = Math.min(h5.x, e11), h5.y = Math.min(h5.y, i6), r5.x = Math.max(r5.x, e11), r5.y = Math.max(r5.y, i6);
      });
      const s3 = r5[n5] - h5[n5];
      if (0 === s3)
        return;
      const c4 = 2 * Math.PI / o3;
      t3.DFTraverse((e11) => {
        const r6 = e11[n5], o4 = h5[n5], l3 = e11[i5], a3 = t3[i5], d3 = (r6 - o4) / s3 * (2 * Math.PI - c4) + c4, f5 = l3 - a3;
        e11.x = Math.cos(d3) * f5, e11.y = Math.sin(d3) * f5;
      });
    }
  }(t2, e8), t2;
}
var L2 = ["LR", "RL", "H"];
var V2 = L2[0];
function D2(t2, e8) {
  let i4 = 0;
  return t2.children.length ? t2.children.forEach((t3) => {
    i4 += D2(t3, e8);
  }) : i4 = t2.height, t2._subTreeSep = e8.getSubTreeSep(t2.data), t2.totalHeight = Math.max(t2.height, i4) + 2 * t2._subTreeSep, t2.totalHeight;
}
function Y3(t2) {
  const e8 = t2.children, i4 = e8.length;
  if (i4) {
    e8.forEach((t3) => {
      Y3(t3);
    });
    const n4 = e8[0], h4 = e8[i4 - 1], r5 = h4.y - n4.y + h4.height;
    let o3 = 0;
    if (e8.forEach((t3) => {
      o3 += t3.totalHeight;
    }), r5 > t2.height)
      t2.y = n4.y + r5 / 2 - t2.height / 2;
    else if (1 !== e8.length || t2.height > o3) {
      const i5 = t2.y + (t2.height - r5) / 2 - n4.y;
      e8.forEach((t3) => {
        t3.translate(0, i5);
      });
    } else
      t2.y = (n4.y + n4.height / 2 + h4.y + h4.height / 2) / 2 - t2.height / 2;
  }
}
var G2 = { getSubTreeSep: () => 0 };
function I2(t2, i4 = {}) {
  return i4 = e6({}, G2, i4), t2.parent = { x: 0, width: 0, height: 0, y: 0 }, t2.BFTraverse((t3) => {
    t3.x = t3.parent.x + t3.parent.width;
  }), t2.parent = void 0, D2(t2, i4), t2.startY = 0, t2.y = t2.totalHeight / 2 - t2.height / 2, t2.eachNode((t3) => {
    const e8 = t3.children, i5 = e8.length;
    if (i5) {
      const n4 = e8[0];
      if (n4.startY = t3.startY + t3._subTreeSep, 1 === i5)
        n4.y = t3.y + t3.height / 2 - n4.height / 2;
      else {
        n4.y = n4.startY + n4.totalHeight / 2 - n4.height / 2;
        for (let t4 = 1; t4 < i5; t4++) {
          const i6 = e8[t4];
          i6.startY = e8[t4 - 1].startY + e8[t4 - 1].totalHeight, i6.y = i6.startY + i6.totalHeight / 2 - i6.height / 2;
        }
      }
    }
  }), Y3(t2), t2;
}
var P2 = class extends r3 {
  execute() {
    return y5(this.rootNode, this.options, I2);
  }
};
var A2 = {};
function F2(t2, i4) {
  const n4 = e6({}, A2, i4);
  return new P2(t2, n4).execute();
}

// node_modules/@antv/infographic/esm/designs/structures/hierarchy-mindmap.js
var DEFAULT_LEVEL_GAP = 60;
var DEFAULT_NODE_GAP = 14;
var LAYOUT_PADDING = 30;
var DEFAULT_EDGE_ALIGN = "center";
var DEFAULT_EDGE_TYPE = "curved";
var DEFAULT_EDGE_WIDTH = 2;
var DEFAULT_COLOR_MODE = "node";
var DEFAULT_EDGE_COLOR_MODE = "solid";
var annotateTree = (node, parentIndexes = [], index2 = 0) => {
  var _a, _b;
  const indexes = [...parentIndexes, index2];
  return Object.assign(Object.assign({}, node), { _indexes: indexes, children: (_b = (_a = node.children) === null || _a === void 0 ? void 0 : _a.map((child, childIndex) => annotateTree(child, indexes, childIndex))) !== null && _b !== void 0 ? _b : [] });
};
var collectNodes = (node, nodes, links, parent) => {
  var _a;
  var _b;
  nodes.push(node);
  (_a = (_b = node.data)._flatIndex) !== null && _a !== void 0 ? _a : _b._flatIndex = nodes.length - 1;
  if (parent)
    links.push({ parent, child: node });
  const children2 = node.children;
  children2 === null || children2 === void 0 ? void 0 : children2.forEach((child) => collectNodes(child, nodes, links, node));
};
var createCurvePath = (sx, sy, tx, ty) => {
  const offsetX = Math.abs(tx - sx) / 2;
  const ctrlX1 = tx > sx ? sx + offsetX : sx - offsetX;
  const ctrlX2 = tx > sx ? tx - offsetX : tx + offsetX;
  return `M ${sx} ${sy} C ${ctrlX1} ${sy} ${ctrlX2} ${ty} ${tx} ${ty}`;
};
var createStraightPath = (sx, sy, tx, ty) => `M ${sx} ${sy} L ${tx} ${ty}`;
var getEdgeAnchors = (parentLayout, childLayout, childSide, align = DEFAULT_EDGE_ALIGN) => {
  const clampRatio = (val) => Math.max(0, Math.min(1, val));
  const toRatio = (value) => {
    if (value === "top")
      return 0;
    if (value === "bottom")
      return 1;
    if (value === "center")
      return 0.5;
    return clampRatio(value);
  };
  const ratio = toRatio(align);
  const parentCy = parentLayout.y + parentLayout.height * ratio;
  const childCy = childLayout.y + childLayout.height * ratio;
  if (childSide === "left") {
    return {
      sx: parentLayout.x,
      sy: parentCy,
      tx: childLayout.x + childLayout.width,
      ty: childCy
    };
  }
  return {
    sx: parentLayout.x + parentLayout.width,
    sy: parentCy,
    tx: childLayout.x,
    ty: childCy
  };
};
var HierarchyMindmap = (props) => {
  var _a, _b;
  const { Title: Title2, Items, data, levelGap = DEFAULT_LEVEL_GAP, nodeGap = DEFAULT_NODE_GAP, edgeAlign = DEFAULT_EDGE_ALIGN, colorMode = DEFAULT_COLOR_MODE, edgeColorMode = DEFAULT_EDGE_COLOR_MODE, edgeType = DEFAULT_EDGE_TYPE, edgeWidth = DEFAULT_EDGE_WIDTH, options } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const colorPrimary = getColorPrimary(options);
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const groupColorIndexMap = /* @__PURE__ */ new Map();
  let nextGroupColorIndex = 0;
  if (!items3.length || !(Items === null || Items === void 0 ? void 0 : Items.length)) {
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { children: jsx(BtnAdd, { indexes: [0], x: 0, y: 0 }) })] });
  }
  const root4 = annotateTree(items3[0]);
  const nodeSizeCache = /* @__PURE__ */ new WeakMap();
  const colorCache = /* @__PURE__ */ new WeakMap();
  const themeCache = /* @__PURE__ */ new WeakMap();
  const getNodeColorIndexes = (datum2, depth) => {
    var _a2;
    if (colorMode === "group") {
      const groupKey = String((_a2 = datum2.group) !== null && _a2 !== void 0 ? _a2 : "");
      let groupIndex = groupColorIndexMap.get(groupKey);
      if (groupIndex == null) {
        groupIndex = nextGroupColorIndex;
        groupColorIndexMap.set(groupKey, groupIndex);
        nextGroupColorIndex += 1;
      }
      return [groupIndex];
    }
    return getHierarchyColorIndexes({
      depth,
      originalIndexes: datum2._indexes,
      flatIndex: datum2._flatIndex
    }, colorMode);
  };
  const getNodeThemeColors = (datum2, depth) => {
    const cachedTheme = themeCache.get(datum2);
    if (cachedTheme)
      return cachedTheme;
    const colorIndexes = getNodeColorIndexes(datum2, depth);
    const primary = getPaletteColor2(options, colorIndexes);
    const themeColors = getThemeColors({ colorPrimary: primary }, options);
    themeCache.set(datum2, themeColors);
    colorCache.set(datum2, primary);
    return themeColors;
  };
  const measureNode = (datum2) => {
    const cached = nodeSizeCache.get(datum2);
    if (cached)
      return cached;
    const depth = Math.max(datum2._indexes.length - 1, 0);
    const Component = getItemComponent(Items, depth);
    const bounds = getElementBounds(jsx(Component, { indexes: datum2._indexes, data, datum: datum2, positionH: "center", positionV: "middle", themeColors: getNodeThemeColors(datum2, depth) }));
    nodeSizeCache.set(datum2, bounds);
    return bounds;
  };
  const mindmapRoot = F2(root4, {
    direction: "H",
    getSide: (node, index2) => {
      if (!node.parent)
        return "right";
      const order = (node.parent.children || []).indexOf(node);
      const rank = order >= 0 ? order : index2;
      return rank % 2 === 0 ? "left" : "right";
    },
    getWidth: (datum2) => measureNode(datum2).width,
    getHeight: (datum2) => measureNode(datum2).height,
    getHGap: () => levelGap,
    getVGap: () => nodeGap
  });
  const layoutNodes = [];
  const nodeLinks = [];
  collectNodes(mindmapRoot, layoutNodes, nodeLinks);
  const minX = layoutNodes.length > 0 ? Math.min(...layoutNodes.map((node) => node.x)) : 0;
  const minY = layoutNodes.length > 0 ? Math.min(...layoutNodes.map((node) => node.y)) : 0;
  const shiftX = LAYOUT_PADDING - minX;
  const shiftY = LAYOUT_PADDING - minY;
  const defsElements = [];
  const decorElements = [];
  const itemElements = [];
  const btnElements = [];
  const layoutStore = /* @__PURE__ */ new WeakMap();
  layoutNodes.forEach((node) => {
    var _a2, _b2;
    const datum2 = node.data;
    const measured = measureNode(datum2);
    const displayX = node.x + shiftX + ((_a2 = node.hgap) !== null && _a2 !== void 0 ? _a2 : 0);
    const displayY = node.y + shiftY + ((_b2 = node.vgap) !== null && _b2 !== void 0 ? _b2 : 0);
    const Component = getItemComponent(Items, node.depth);
    const positionH = node.depth === 0 ? "center" : node.side === "left" ? "flipped" : "normal";
    const themeColors = getNodeThemeColors(datum2, node.depth);
    itemElements.push(jsx(Component, { indexes: datum2._indexes, data, datum: datum2, x: displayX, y: displayY, positionH, positionV: "middle", themeColors }));
    layoutStore.set(node, {
      x: displayX,
      y: displayY,
      width: measured.width,
      height: measured.height,
      centerX: displayX + measured.width / 2,
      centerY: displayY + measured.height / 2
    });
  });
  nodeLinks.forEach((link) => {
    var _a2, _b2, _c, _d;
    const { parent, child } = link;
    const childLayout = layoutStore.get(child);
    const parentLayout = layoutStore.get(parent);
    if (!childLayout || !parentLayout) {
      return;
    }
    const childDatum = child.data;
    const { sx, sy, tx, ty } = getEdgeAnchors(parentLayout, childLayout, child.side, edgeAlign);
    const childColor = (_a2 = colorCache.get(childDatum)) !== null && _a2 !== void 0 ? _a2 : getPaletteColor2(options, getNodeColorIndexes(childDatum, child.depth));
    const parentColor = (_b2 = colorCache.get(parent.data)) !== null && _b2 !== void 0 ? _b2 : getPaletteColor2(options, getNodeColorIndexes(parent.data, parent.depth));
    const pathD = edgeType === "straight" ? createStraightPath(sx, sy, tx, ty) : createCurvePath(sx, sy, tx, ty);
    const gradientId = `edge-gradient-${childDatum._indexes.join("-")}`;
    decorElements.push(jsx(Path, { d: pathD, stroke: edgeColorMode === "gradient" ? `url(#${gradientId})` : childColor !== null && childColor !== void 0 ? childColor : colorPrimary, strokeWidth: edgeWidth, fill: "none" }));
    if (edgeColorMode === "gradient") {
      defsElements.push(jsxs("linearGradient", { id: gradientId, gradientUnits: "userSpaceOnUse", x1: sx, y1: sy, x2: tx, y2: ty, children: [jsx("stop", { offset: "0%", stopColor: parentColor !== null && parentColor !== void 0 ? parentColor : colorPrimary }), jsx("stop", { offset: "100%", stopColor: childColor !== null && childColor !== void 0 ? childColor : colorPrimary })] }));
    }
    const appendIndex = (_d = (_c = childDatum.children) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
    const addIndexes = [...childDatum._indexes, appendIndex];
    const btnX = childLayout.x + (childLayout.width - btnBounds.width) / 2;
    const removeY = childLayout.y + childLayout.height + 8;
    const addY = removeY + btnBounds.height + 6;
    if (child.depth > 0) {
      btnElements.push(jsx(BtnRemove, { indexes: childDatum._indexes, x: btnX, y: removeY }));
    }
    btnElements.push(jsx(BtnAdd, { indexes: addIndexes, x: btnX, y: addY }));
  });
  const rootLayout = layoutStore.get(mindmapRoot);
  if (rootLayout) {
    const rootDatum = mindmapRoot.data;
    const appendIndex = (_b = (_a = rootDatum.children) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    const addIndexes = [...rootDatum._indexes, appendIndex];
    const btnX = rootLayout.x + (rootLayout.width - btnBounds.width) / 2;
    const addY = rootLayout.y + rootLayout.height + 8 + btnBounds.height + 6;
    btnElements.push(jsx(BtnAdd, { indexes: addIndexes, x: btnX, y: addY }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [defsElements.length > 0 ? jsx(Defs, { children: defsElements }) : null, jsx(Group, { children: decorElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("hierarchy-mindmap", {
  component: HierarchyMindmap,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/hierarchy-structure.js
var applyAlpha = (color3, alpha) => {
  if (!color3 || color3[0] !== "#" || color3.length !== 7)
    return color3;
  const clamped = Math.max(0, Math.min(1, alpha));
  const alphaHex = Math.round(clamped * 255).toString(16).padStart(2, "0");
  return `${color3}${alphaHex}`;
};
var normalizeLabel = (label) => label == null ? "" : String(label);
var measureText3 = (text, fontSize, fontWeight) => getElementBounds(jsx(Text, { fontSize, fontWeight, children: text }));
var getMaxTextBounds = (labels, fontSize, fontWeight, fallbackText = " ") => {
  const sampleBounds = measureText3(fallbackText, fontSize, fontWeight);
  let maxWidth = sampleBounds.width;
  let maxHeight = sampleBounds.height;
  labels.forEach((label) => {
    const bounds = measureText3(label || " ", fontSize, fontWeight);
    maxWidth = Math.max(maxWidth, bounds.width);
    maxHeight = Math.max(maxHeight, bounds.height);
  });
  return { width: maxWidth, height: maxHeight };
};
var getPillDimensions = (labels, fontSize, paddingX, paddingY) => {
  const bounds = getMaxTextBounds(labels, fontSize, "normal", "Item");
  return {
    pillWidth: bounds.width + paddingX * 2,
    pillHeight: bounds.height + paddingY * 2
  };
};
var HierarchyStructure = (props) => {
  const { Title: Title2, data, options, rowGap = 20, labelGap = 20, groupGap = 20, pillGap = 14, pillColumns = 2, ungroupedColumns = 6, layerLabelPosition = "left", rowPadding = 20, groupPadding = 16, labelPaddingX = 28, labelPaddingY = 16, pillPaddingX = 18, pillPaddingY = 10, labelFontSize = 20, groupTitleFontSize = 18, pillFontSize = 16, groupTitleGap = 10, rowRadius = 12, groupRadius = 10, pillRadius = 12 } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  if (items3.length === 0) {
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { children: jsx(ItemsGroup, {}) })] });
  }
  const themeColors = getThemeColors(options.themeConfig);
  const decorElements = [];
  const itemElements = [];
  const isLabelOnRight = layerLabelPosition === "right";
  const rowBackgroundAlpha = 0.12;
  const rowBorderAlpha = 0.55;
  const groupBackgroundAlpha = 0.08;
  const groupBorderAlpha = 0.4;
  const pillBackgroundAlpha = 0.06;
  const pillBorderAlpha = 0.35;
  const rowInfos = items3.map((layer) => {
    const layerLabel = normalizeLabel(layer.label);
    const labelBounds = measureText3(layerLabel || " ", labelFontSize, "bold");
    const labelWidth = labelBounds.width + labelPaddingX * 2;
    const labelHeight = labelBounds.height + labelPaddingY * 2;
    const children2 = layer.children || [];
    const hasGroups = children2.some((child) => {
      var _a;
      return (((_a = child.children) === null || _a === void 0 ? void 0 : _a.length) || 0) > 0;
    });
    if (hasGroups) {
      const pillLabels2 = [];
      children2.forEach((child) => {
        (child.children || []).forEach((pill) => {
          pillLabels2.push(normalizeLabel(pill.label));
        });
      });
      const { pillWidth: pillWidth2, pillHeight: pillHeight2 } = getPillDimensions(pillLabels2, pillFontSize, pillPaddingX, pillPaddingY);
      const groupMetrics = children2.map((group) => {
        const groupLabel = normalizeLabel(group.label);
        const groupTitleBounds = measureText3(groupLabel || " ", groupTitleFontSize, "bold");
        const groupChildren = group.children || [];
        const groupColumns = groupChildren.length > 0 ? Math.min(pillColumns, groupChildren.length) : 0;
        const groupRows = groupColumns > 0 ? Math.ceil(groupChildren.length / groupColumns) : 0;
        const groupContentWidth = groupColumns > 0 ? groupColumns * pillWidth2 + (groupColumns - 1) * pillGap : 0;
        const groupContentHeight = groupRows > 0 ? groupRows * pillHeight2 + (groupRows - 1) * pillGap : 0;
        const innerWidth = Math.max(groupTitleBounds.width, groupContentWidth);
        const groupWidth = innerWidth + groupPadding * 2;
        const groupHeight = groupPadding * 2 + groupTitleBounds.height + (groupRows > 0 ? groupTitleGap + groupContentHeight : 0);
        return {
          label: groupLabel,
          children: groupChildren,
          width: groupWidth,
          height: groupHeight,
          titleHeight: groupTitleBounds.height,
          columns: groupColumns,
          contentWidth: groupContentWidth,
          pillWidth: pillWidth2,
          pillHeight: pillHeight2
        };
      });
      const contentInnerWidth2 = groupMetrics.reduce((sum, metric) => sum + metric.width, 0) + (groupMetrics.length > 1 ? (groupMetrics.length - 1) * groupGap : 0);
      const contentInnerHeight2 = groupMetrics.reduce((max3, metric) => Math.max(max3, metric.height), 0);
      return {
        label: layerLabel,
        labelWidth,
        labelHeight,
        hasGroups: true,
        children: children2,
        groupMetrics,
        contentInnerWidth: contentInnerWidth2,
        contentInnerHeight: contentInnerHeight2
      };
    }
    const pillLabels = children2.map((child) => normalizeLabel(child.label));
    const { pillWidth, pillHeight } = getPillDimensions(pillLabels, pillFontSize, pillPaddingX, pillPaddingY);
    const columns = children2.length > 0 ? Math.min(ungroupedColumns, children2.length) : 0;
    const rows = columns > 0 ? Math.ceil(children2.length / columns) : 0;
    const contentInnerWidth = columns > 0 ? columns * pillWidth + (columns - 1) * pillGap : 0;
    const contentInnerHeight = rows > 0 ? rows * pillHeight + (rows - 1) * pillGap : 0;
    return {
      label: layerLabel,
      labelWidth,
      labelHeight,
      hasGroups: false,
      children: children2,
      pillWidth,
      pillHeight,
      columns,
      contentInnerWidth,
      contentInnerHeight
    };
  });
  const maxLabelWidth = rowInfos.reduce((max3, row) => Math.max(max3, row.labelWidth), 0);
  const targetContentInnerWidth = rowInfos.reduce((max3, row) => Math.max(max3, row.contentInnerWidth), 0);
  const getRowColors = (layerIndex) => {
    const rowColor = getPaletteColor2(options, [layerIndex]) || themeColors.colorPrimary || "#6c7dff";
    return {
      rowFill: applyAlpha(rowColor, rowBackgroundAlpha),
      rowStroke: applyAlpha(rowColor, rowBorderAlpha),
      groupFill: applyAlpha(rowColor, groupBackgroundAlpha),
      groupStroke: applyAlpha(rowColor, groupBorderAlpha),
      pillFill: applyAlpha(rowColor, pillBackgroundAlpha),
      pillStroke: applyAlpha(rowColor, pillBorderAlpha)
    };
  };
  const renderRowFrame = (layerLabel, layerIndexes, labelX, labelY, labelWidth, labelHeight, rowY, rowHeight, contentX, contentY, contentWidth, contentHeight, rowFill, rowStroke) => {
    decorElements.push(jsx(Rect, { x: labelX, y: rowY, width: labelWidth, height: rowHeight, fill: rowFill, stroke: rowStroke, rx: rowRadius, ry: rowRadius, "data-element-type": "shape" }));
    decorElements.push(jsx(Rect, { x: contentX, y: contentY, width: contentWidth, height: contentHeight, fill: rowFill, stroke: rowStroke, rx: rowRadius, ry: rowRadius, "data-element-type": "shape" }));
    itemElements.push(jsx(Text, { x: labelX, y: labelY, width: labelWidth, height: labelHeight, fontSize: labelFontSize, fontWeight: "bold", alignHorizontal: "center", alignVertical: "middle", fill: themeColors.colorText, "data-element-type": "item-label", "data-indexes": layerIndexes, children: layerLabel }));
  };
  const renderGroupedRow = (rowInfo, layerIndex, rowY, rowColors) => {
    const groupMetrics = rowInfo.groupMetrics || [];
    const layerLabel = rowInfo.label;
    const layerIndexes = [layerIndex];
    const labelWidth = maxLabelWidth;
    const labelHeight = rowInfo.labelHeight;
    const contentInnerHeight = rowInfo.contentInnerHeight;
    const extraInnerWidth = Math.max(0, targetContentInnerWidth - rowInfo.contentInnerWidth);
    const extraPerGroup = groupMetrics.length > 0 ? extraInnerWidth / groupMetrics.length : 0;
    const contentInnerWidth = rowInfo.contentInnerWidth + (groupMetrics.length > 0 ? extraInnerWidth : 0);
    const contentWidth = contentInnerWidth + rowPadding * 2;
    const contentHeight = contentInnerHeight + rowPadding * 2;
    const rowHeight = Math.max(labelHeight, contentHeight);
    const contentX = isLabelOnRight ? 0 : labelWidth + labelGap;
    const labelX = isLabelOnRight ? contentX + contentWidth + labelGap : 0;
    const labelY = rowY + (rowHeight - labelHeight) / 2;
    const contentY = rowY + (rowHeight - contentHeight) / 2;
    renderRowFrame(layerLabel, layerIndexes, labelX, labelY, labelWidth, labelHeight, rowY, rowHeight, contentX, contentY, contentWidth, contentHeight, rowColors.rowFill, rowColors.rowStroke);
    let groupX = contentX + rowPadding;
    groupMetrics.forEach((metric, groupIndex) => {
      const groupIndexes = [...layerIndexes, groupIndex];
      const groupWidth = metric.width + extraPerGroup;
      const groupY = contentY + rowPadding + (contentInnerHeight - metric.height) / 2;
      decorElements.push(jsx(Rect, { x: groupX, y: groupY, width: groupWidth, height: metric.height, fill: rowColors.groupFill, stroke: rowColors.groupStroke, rx: groupRadius, ry: groupRadius, "data-element-type": "shape" }));
      const hasGroupChildren = metric.children.length > 0;
      const titleY = hasGroupChildren ? groupY + groupPadding : groupY;
      const titleHeight = hasGroupChildren ? metric.titleHeight : metric.height;
      const titleAlignV = hasGroupChildren ? "top" : "middle";
      itemElements.push(jsx(Text, { x: groupX + groupPadding, y: titleY, width: groupWidth - groupPadding * 2, height: titleHeight, fontSize: groupTitleFontSize, fontWeight: "bold", alignHorizontal: "center", alignVertical: titleAlignV, fill: themeColors.colorText, "data-element-type": "item-label", "data-indexes": groupIndexes, children: metric.label }));
      if (metric.columns > 0) {
        const innerWidth = groupWidth - groupPadding * 2;
        const extraWidth = innerWidth - metric.contentWidth;
        const columnExtra = extraWidth > 0 ? extraWidth / metric.columns : 0;
        const pillWidth = metric.pillWidth + columnExtra;
        const contentWidth2 = metric.columns * pillWidth + (metric.columns - 1) * pillGap;
        const contentOffsetX = (innerWidth - contentWidth2) / 2;
        const pillStartX = groupX + groupPadding + Math.max(0, contentOffsetX);
        const pillStartY = groupY + groupPadding + metric.titleHeight + groupTitleGap;
        metric.children.forEach((pill, pillIndex) => {
          const pillIndexes = [...groupIndexes, pillIndex];
          const rowIndex = Math.floor(pillIndex / metric.columns);
          const colIndex = pillIndex % metric.columns;
          const pillX = pillStartX + colIndex * (pillWidth + pillGap);
          const pillY = pillStartY + rowIndex * (metric.pillHeight + pillGap);
          const pillRx = Math.min(pillRadius, metric.pillHeight / 2);
          decorElements.push(jsx(Rect, { x: pillX, y: pillY, width: pillWidth, height: metric.pillHeight, fill: rowColors.pillFill, stroke: rowColors.pillStroke, rx: pillRx, ry: pillRx, "data-element-type": "shape" }));
          itemElements.push(jsx(Text, { x: pillX, y: pillY, width: pillWidth, height: metric.pillHeight, fontSize: pillFontSize, fontWeight: "normal", alignHorizontal: "center", alignVertical: "middle", fill: themeColors.colorText, "data-element-type": "item-label", "data-indexes": pillIndexes, children: normalizeLabel(pill.label) }));
        });
      }
      groupX += groupWidth + groupGap;
    });
    const rowWidth = isLabelOnRight ? labelX + labelWidth : contentX + contentWidth;
    return { rowWidth, rowHeight };
  };
  const renderUngroupedRow = (rowInfo, layerIndex, rowY, rowColors) => {
    const layerLabel = rowInfo.label;
    const layerIndexes = [layerIndex];
    const labelWidth = maxLabelWidth;
    const labelHeight = rowInfo.labelHeight;
    const contentInnerHeight = rowInfo.contentInnerHeight;
    const extraInnerWidth = Math.max(0, targetContentInnerWidth - rowInfo.contentInnerWidth);
    const columns = rowInfo.columns || 0;
    const pillWidthBase = rowInfo.pillWidth || 0;
    const pillHeight = rowInfo.pillHeight || 0;
    const extraPerColumn = columns > 0 ? extraInnerWidth / columns : 0;
    const pillWidth = pillWidthBase + extraPerColumn;
    const contentInnerWidth = columns > 0 ? columns * pillWidth + (columns - 1) * pillGap : 0;
    const contentWidth = contentInnerWidth + rowPadding * 2;
    const contentHeight = contentInnerHeight + rowPadding * 2;
    const rowHeight = Math.max(labelHeight, contentHeight);
    const contentX = isLabelOnRight ? 0 : labelWidth + labelGap;
    const labelX = isLabelOnRight ? contentX + contentWidth + labelGap : 0;
    const labelY = rowY + (rowHeight - labelHeight) / 2;
    const contentY = rowY + (rowHeight - contentHeight) / 2;
    renderRowFrame(layerLabel, layerIndexes, labelX, labelY, labelWidth, labelHeight, rowY, rowHeight, contentX, contentY, contentWidth, contentHeight, rowColors.rowFill, rowColors.rowStroke);
    if (columns > 0) {
      const pillStartX = contentX + rowPadding;
      const pillStartY = contentY + rowPadding;
      const flatChildren = rowInfo.children || [];
      flatChildren.forEach((child, pillIndex) => {
        const pillIndexes = [...layerIndexes, pillIndex];
        const rowIndex = Math.floor(pillIndex / columns);
        const colIndex = pillIndex % columns;
        const pillX = pillStartX + colIndex * (pillWidth + pillGap);
        const pillY = pillStartY + rowIndex * (pillHeight + pillGap);
        const pillRx = Math.min(pillRadius, pillHeight / 2);
        decorElements.push(jsx(Rect, { x: pillX, y: pillY, width: pillWidth, height: pillHeight, fill: rowColors.pillFill, stroke: rowColors.pillStroke, rx: pillRx, ry: pillRx, "data-element-type": "shape" }));
        itemElements.push(jsx(Text, { x: pillX, y: pillY, width: pillWidth, height: pillHeight, fontSize: pillFontSize, fontWeight: "normal", alignHorizontal: "center", alignVertical: "middle", fill: themeColors.colorText, "data-element-type": "item-label", "data-indexes": pillIndexes, children: normalizeLabel(child.label) }));
      });
    }
    const rowWidth = isLabelOnRight ? labelX + labelWidth : contentX + contentWidth;
    return { rowWidth, rowHeight };
  };
  let currentY = 0;
  let maxWidth = 0;
  rowInfos.forEach((rowInfo, layerIndex) => {
    const rowColors = getRowColors(layerIndex);
    const { rowWidth, rowHeight } = rowInfo.hasGroups ? renderGroupedRow(rowInfo, layerIndex, currentY, rowColors) : renderUngroupedRow(rowInfo, layerIndex, currentY, rowColors);
    maxWidth = Math.max(maxWidth, rowWidth);
    currentY += rowHeight + rowGap;
  });
  const totalHeight = Math.max(currentY - rowGap, 0);
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { width: maxWidth, height: totalHeight, children: [jsx(Group, { children: decorElements }), jsx(ItemsGroup, { children: itemElements })] })] });
};
registerStructure("hierarchy-structure", {
  component: HierarchyStructure,
  composites: ["title"]
});

// node_modules/@antv/infographic/esm/designs/structures/hierarchy-tree.js
var distributedPadding = (rawPadding, size) => {
  const maxPadding = Math.max(0, size / 2 - 1);
  return Math.min(rawPadding, maxPadding);
};
var HierarchyTree = (props) => {
  const {
    Title: Title2,
    Items,
    data,
    // 
    levelGap = 80,
    nodeGap = 60,
    // 
    edgeType = "straight",
    edgeColorMode = "gradient",
    edgeWidth = 3,
    edgeStyle = "solid",
    edgeDashPattern = "5,5",
    edgeCornerRadius = 0,
    // 
    edgeOffset = 0,
    edgeOrigin = "center",
    edgeOriginPadding = 20,
    // 
    edgeMarker = "none",
    markerSize = 12,
    // 
    colorMode = "branch",
    // 
    orientation = "top-bottom",
    options
  } = props;
  const isHorizontal = orientation === "left-right" || orientation === "right-left";
  const mainSign = orientation === "bottom-top" || orientation === "right-left" ? -1 : 1;
  const { title, desc } = data;
  const colorPrimary = getColorPrimary(options);
  const groupColorIndexMap = /* @__PURE__ */ new Map();
  let nextGroupColorIndex = 0;
  const normalizeItems2 = (items4) => {
    var _a;
    const list3 = [...items4];
    if (!((_a = list3[0]) === null || _a === void 0 ? void 0 : _a.children)) {
      list3[0] = Object.assign(Object.assign({}, list3[0]), { children: list3.slice(1) });
      list3.splice(1);
    }
    return list3;
  };
  const createRoundedPath = (x1, y1, x22, y22, radius, direction = "vertical") => {
    const isVertical = direction === "vertical";
    const deltaMain = isVertical ? y22 - y1 : x22 - x1;
    const deltaCross = isVertical ? x22 - x1 : y22 - y1;
    const signMain = deltaMain === 0 ? 1 : Math.sign(deltaMain);
    const signCross = deltaCross === 0 ? 1 : Math.sign(deltaCross);
    const midMain = isVertical ? y1 + deltaMain / 2 : x1 + deltaMain / 2;
    const effectiveRadius = Math.min(radius, Math.abs(deltaMain) / 2, Math.abs(deltaCross) / 2);
    if (effectiveRadius === 0) {
      return isVertical ? `M ${x1} ${y1} L ${x1} ${midMain} L ${x22} ${midMain} L ${x22} ${y22}` : `M ${x1} ${y1} L ${midMain} ${y1} L ${midMain} ${y22} L ${x22} ${y22}`;
    }
    if (isVertical) {
      return `M ${x1} ${y1}
              L ${x1} ${midMain - signMain * effectiveRadius}
              Q ${x1} ${midMain} ${x1 + signCross * effectiveRadius} ${midMain}
              L ${x22 - signCross * effectiveRadius} ${midMain}
              Q ${x22} ${midMain} ${x22} ${midMain + signMain * effectiveRadius}
              L ${x22} ${y22}`;
    }
    return `M ${x1} ${y1}
            L ${midMain - signMain * effectiveRadius} ${y1}
            Q ${midMain} ${y1} ${midMain} ${y1 + signCross * effectiveRadius}
            L ${midMain} ${y22 - signCross * effectiveRadius}
            Q ${midMain} ${y22} ${midMain + signMain * effectiveRadius} ${y22}
            L ${x22} ${y22}`;
  };
  const getLayoutPoint = (node) => {
    const { x: x6, y: y6 } = node;
    return isHorizontal ? { x: y6 * mainSign, y: x6 } : { x: x6, y: y6 * mainSign };
  };
  const getNodeRect = (node, bounds, offsets2) => {
    const { x: x6, y: y6 } = getLayoutPoint(node);
    const centerX = x6 + offsets2.x;
    const top = y6 + offsets2.y;
    const centerY = top + bounds.height / 2;
    return {
      centerX,
      centerY,
      left: centerX - bounds.width / 2,
      right: centerX + bounds.width / 2,
      top,
      bottom: top + bounds.height
    };
  };
  const buildHierarchyData = (list3) => {
    var _a;
    if (!list3.length)
      return null;
    const rootItem = list3[0];
    const buildNode = (node, parentIndexes = [], idx = 0) => {
      var _a2, _b;
      const indexes = [...parentIndexes, idx];
      return Object.assign(Object.assign({}, node), { _originalIndex: indexes, _depth: indexes.length - 1, children: (_b = (_a2 = node.children) === null || _a2 === void 0 ? void 0 : _a2.map((c4, i4) => buildNode(c4, indexes, i4))) !== null && _b !== void 0 ? _b : [] });
    };
    return ((_a = rootItem.children) === null || _a === void 0 ? void 0 : _a.length) ? buildNode(rootItem) : Object.assign(Object.assign({}, rootItem), { _originalIndex: [0], _depth: 0, children: list3.slice(1).map((child, i4) => Object.assign(Object.assign({}, child), { _originalIndex: [i4 + 1], _depth: 1 })) });
  };
  const computeLevelBounds = (rootNode) => {
    var _a, _b;
    let maxWidth2 = 0, maxHeight2 = 0;
    const levelBounds2 = /* @__PURE__ */ new Map();
    const sampleDatumByLevel = /* @__PURE__ */ new Map();
    rootNode.each((node) => {
      if (!sampleDatumByLevel.has(node.depth)) {
        sampleDatumByLevel.set(node.depth, node.data);
      }
    });
    for (let level = 0; level < rootNode.height + 1; level++) {
      const ItemComponent = getItemComponent(Items, level);
      const sampleDatum = (_a = sampleDatumByLevel.get(level)) !== null && _a !== void 0 ? _a : {};
      const indexes = (_b = sampleDatum._originalIndex) !== null && _b !== void 0 ? _b : Array(level + 1).fill(0);
      const bounds = getElementBounds(jsx(ItemComponent, { indexes, data, datum: sampleDatum, positionH: "center" }));
      levelBounds2.set(level, bounds);
      maxWidth2 = Math.max(maxWidth2, bounds.width);
      maxHeight2 = Math.max(maxHeight2, bounds.height);
    }
    return { levelBounds: levelBounds2, maxWidth: maxWidth2, maxHeight: maxHeight2 };
  };
  const getNodeColorIndexes = (nodeData, depth) => {
    var _a;
    if (colorMode === "group") {
      const groupKey = String((_a = nodeData === null || nodeData === void 0 ? void 0 : nodeData.group) !== null && _a !== void 0 ? _a : "");
      let groupIndex = groupColorIndexMap.get(groupKey);
      if (groupIndex == null) {
        groupIndex = nextGroupColorIndex;
        groupColorIndexMap.set(groupKey, groupIndex);
        nextGroupColorIndex += 1;
      }
      return [groupIndex];
    }
    return getHierarchyColorIndexes({
      depth,
      originalIndexes: nodeData._originalIndex,
      flatIndex: nodeData._flatIndex
    }, colorMode);
  };
  const renderNode = (node, levelBounds2, btnBounds2, offsets2, gradientDefs2, allNodes) => {
    const { depth, data: nodeData, parent } = node;
    const indexes = nodeData._originalIndex;
    const NodeComponent = getItemComponent(Items, depth);
    const bounds = levelBounds2.get(depth);
    const nodeRect = getNodeRect(node, bounds, offsets2);
    const nodeX = nodeRect.left;
    const nodeY = nodeRect.top;
    const elements = {
      items: [],
      btns: [],
      deco: []
    };
    const colorIndexes = getNodeColorIndexes(nodeData, depth);
    const nodeColor = getPaletteColor2(options, colorIndexes);
    const nodeThemeColors = getThemeColors({
      colorPrimary: nodeColor
    }, options);
    elements.items.push(jsx(NodeComponent, { indexes, datum: nodeData, data, x: nodeX, y: nodeY, positionH: "center", themeColors: nodeThemeColors }));
    elements.btns.push(jsx(BtnRemove, { indexes, x: nodeX + (bounds.width - btnBounds2.width) / 2, y: nodeY + bounds.height + 5 }), jsx(BtnAdd, { indexes: [...indexes, 0], x: nodeX + (bounds.width - btnBounds2.width) / 2, y: nodeY + bounds.height + btnBounds2.height + 10 }));
    if (parent) {
      const parentBounds = levelBounds2.get(parent.depth);
      const parentRect = getNodeRect(parent, parentBounds, offsets2);
      const siblings = allNodes.filter((n4) => n4.parent === parent);
      const siblingIndex = siblings.findIndex((s3) => s3 === node);
      const siblingCount = siblings.length;
      let parentX;
      let parentY;
      if (edgeOrigin === "distributed" && siblingCount > 1) {
        if (isHorizontal) {
          const padding = distributedPadding(edgeOriginPadding, parentBounds.height);
          const startY = parentRect.top + padding;
          const endY = parentRect.bottom - padding;
          const segmentHeight = (endY - startY) / siblingCount;
          parentY = startY + segmentHeight * siblingIndex + segmentHeight / 2;
          parentX = (mainSign > 0 ? parentRect.right : parentRect.left) + edgeOffset * mainSign;
        } else {
          const padding = distributedPadding(edgeOriginPadding, parentBounds.width);
          const startX = parentRect.left + padding;
          const endX = parentRect.right - padding;
          const segmentWidth = (endX - startX) / siblingCount;
          parentX = startX + segmentWidth * siblingIndex + segmentWidth / 2;
          parentY = (mainSign > 0 ? parentRect.bottom : parentRect.top) + edgeOffset * mainSign;
        }
      } else {
        parentX = isHorizontal ? (mainSign > 0 ? parentRect.right : parentRect.left) + edgeOffset * mainSign : parentRect.centerX;
        parentY = isHorizontal ? parentRect.centerY : (mainSign > 0 ? parentRect.bottom : parentRect.top) + edgeOffset * mainSign;
      }
      const baseChildX = isHorizontal ? (mainSign > 0 ? nodeRect.left : nodeRect.right) - edgeOffset * mainSign : nodeRect.centerX;
      const baseChildY = isHorizontal ? nodeRect.centerY : (mainSign > 0 ? nodeRect.top : nodeRect.bottom) - edgeOffset * mainSign;
      let childX = baseChildX;
      let childY = baseChildY;
      if (edgeMarker === "arrow") {
        if (isHorizontal) {
          childX -= markerSize * mainSign;
        } else {
          childY -= markerSize * mainSign;
        }
      }
      let pathD;
      if (edgeType === "curved") {
        if (isHorizontal) {
          const midX = parentX + (childX - parentX) / 2;
          pathD = `M ${parentX} ${parentY} C ${midX} ${parentY}, ${midX} ${childY}, ${childX} ${childY}`;
        } else {
          const midY = parentY + (childY - parentY) / 2;
          pathD = `M ${parentX} ${parentY} C ${parentX} ${midY}, ${childX} ${midY}, ${childX} ${childY}`;
        }
      } else if (edgeCornerRadius > 0) {
        pathD = createRoundedPath(parentX, parentY, childX, childY, edgeCornerRadius, isHorizontal ? "horizontal" : "vertical");
      } else {
        if (isHorizontal) {
          const midX = parentX + (childX - parentX) / 2;
          pathD = `M ${parentX} ${parentY} L ${midX} ${parentY} L ${midX} ${childY} L ${childX} ${childY}`;
        } else {
          const midY = parentY + (childY - parentY) / 2;
          pathD = `M ${parentX} ${parentY} L ${parentX} ${midY} L ${childX} ${midY} L ${childX} ${childY}`;
        }
      }
      let strokeColor = colorPrimary;
      if (edgeColorMode === "gradient") {
        const parentColorIndexes = getNodeColorIndexes(parent.data, parent.depth);
        const childColorIndexes = getNodeColorIndexes(nodeData, depth);
        const parentColor = getPaletteColor2(options, parentColorIndexes);
        const childColor = getPaletteColor2(options, childColorIndexes);
        const gradientId = `gradient-${parent.data._originalIndex.join("-")}-${indexes.join("-")}`;
        gradientDefs2.push(jsxs("linearGradient", { id: gradientId, x1: parentX, y1: parentY, x2: childX, y2: childY, gradientUnits: "userSpaceOnUse", children: [jsx("stop", { offset: "0%", stopColor: parentColor }), jsx("stop", { offset: "100%", stopColor: childColor })] }));
        strokeColor = `url(#${gradientId})`;
      }
      const dashArray = edgeStyle === "dashed" ? edgeDashPattern : "";
      elements.deco.push(jsx(Path, { d: pathD, stroke: strokeColor, strokeWidth: edgeWidth, strokeDasharray: dashArray, fill: "none" }));
      if (edgeMarker === "arrow") {
        const arrowColor = edgeColorMode === "gradient" ? getPaletteColor2(options, colorIndexes) : getColorPrimary(options);
        const arrowPoints = isHorizontal ? [
          { x: baseChildX, y: baseChildY },
          {
            x: baseChildX - markerSize * mainSign,
            y: baseChildY - markerSize / 2
          },
          {
            x: baseChildX - markerSize * mainSign,
            y: baseChildY + markerSize / 2
          }
        ] : [
          { x: baseChildX, y: baseChildY },
          {
            x: baseChildX - markerSize / 2,
            y: baseChildY - markerSize * mainSign
          },
          {
            x: baseChildX + markerSize / 2,
            y: baseChildY - markerSize * mainSign
          }
        ];
        elements.deco.push(jsx(Polygon, { points: arrowPoints, fill: arrowColor, width: markerSize, height: markerSize }));
      }
      if (edgeMarker === "dot") {
        const parentColorIndexes = getNodeColorIndexes(parent.data, parent.depth);
        const parentDotColor = edgeColorMode === "gradient" ? getPaletteColor2(options, parentColorIndexes) : getColorPrimary(options);
        elements.deco.push(jsx(Ellipse, { x: (isHorizontal ? mainSign > 0 ? parentRect.right + edgeOffset : parentRect.left - edgeOffset : parentX) - markerSize, y: (isHorizontal ? parentY : mainSign > 0 ? parentRect.bottom + edgeOffset : parentRect.top - edgeOffset) - markerSize, width: markerSize * 2, height: markerSize * 2, fill: parentDotColor }));
        const childDotColor = edgeColorMode === "gradient" ? getPaletteColor2(options, colorIndexes) : getColorPrimary(options);
        elements.deco.push(jsx(Ellipse, { x: baseChildX - markerSize, y: baseChildY - markerSize, width: markerSize * 2, height: markerSize * 2, fill: childDotColor }));
      }
    }
    return elements;
  };
  const renderSiblingBtns = (nodes2, btnBounds2, offsets2) => {
    const nodesByParent = /* @__PURE__ */ new Map();
    nodes2.forEach((node) => {
      var _a;
      const key = node.parent ? node.parent.data._originalIndex.join("-") : "root";
      ((_a = nodesByParent.get(key)) !== null && _a !== void 0 ? _a : nodesByParent.set(key, []).get(key)).push(node);
    });
    const btns = [];
    nodesByParent.forEach((siblings) => {
      if (siblings.length <= 1)
        return;
      const sorted = siblings.slice().sort((a3, b2) => isHorizontal ? getLayoutPoint(a3).y - getLayoutPoint(b2).y : getLayoutPoint(a3).x - getLayoutPoint(b2).x);
      if (sorted.length === 0)
        return;
      for (let i4 = 0; i4 < sorted.length - 1; i4++) {
        const current = getLayoutPoint(sorted[i4]);
        const next = getLayoutPoint(sorted[i4 + 1]);
        const parentIndexes = sorted[i4].data._originalIndex.slice(0, -1);
        const insertIndex = sorted[i4].data._originalIndex.at(-1) + 1;
        if (isHorizontal) {
          const btnX = current.x + offsets2.x + (mainSign > 0 ? -btnBounds2.width - 5 : btnBounds2.width + 5);
          const btnY = (current.y + next.y) / 2 + offsets2.y - btnBounds2.height / 2;
          btns.push(jsx(BtnAdd, { indexes: [...parentIndexes, insertIndex], x: btnX, y: btnY }));
        } else {
          const siblingY = current.y + offsets2.y - btnBounds2.height - 5;
          const btnX = (current.x + next.x) / 2 + offsets2.x - btnBounds2.width / 2;
          btns.push(jsx(BtnAdd, { indexes: [...parentIndexes, insertIndex], x: btnX, y: siblingY }));
        }
      }
    });
    return btns;
  };
  const items3 = normalizeItems2(data.items);
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  if (!items3.length) {
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { children: jsx(BtnsGroup, { children: jsx(BtnAdd, { indexes: [0], x: -btnBounds.width / 2, y: -btnBounds.height / 2 }) }) })] });
  }
  const hierarchyData = buildHierarchyData(items3);
  const root4 = hierarchy(hierarchyData);
  const { levelBounds, maxWidth, maxHeight } = computeLevelBounds(root4);
  const treeLayout = tree_default().nodeSize(isHorizontal ? [maxHeight + nodeGap, maxWidth + levelGap] : [maxWidth + nodeGap, maxHeight + levelGap]).separation(() => 1);
  const nodes = treeLayout(root4).descendants();
  const layoutPoints = nodes.map((d3) => getLayoutPoint(d3));
  const minX = Math.min(...layoutPoints.map((d3) => d3.x));
  const minY = Math.min(...layoutPoints.map((d3) => d3.y));
  const offsets = {
    x: Math.max(0, -minX + maxWidth / 2),
    y: Math.max(0, -minY + btnBounds.height + 10)
  };
  const itemElements = [];
  const btnElements = [];
  const decoElements = [];
  const gradientDefs = [];
  nodes.forEach((node, index2) => {
    node.data._flatIndex = index2;
    const { x: x6, y: y6 } = getLayoutPoint(node);
    node.__layout = { x: x6, y: y6 };
  });
  nodes.forEach((node) => {
    const { items: items4, btns, deco } = renderNode(node, levelBounds, btnBounds, offsets, gradientDefs, nodes);
    itemElements.push(...items4);
    btnElements.push(...btns);
    decoElements.push(...deco);
  });
  btnElements.push(...renderSiblingBtns(nodes, btnBounds, offsets));
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [gradientDefs.length > 0 && jsx(Defs, { children: gradientDefs }), jsx(ShapesGroup, { children: decoElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("hierarchy-tree", {
  component: HierarchyTree,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/list-column.js
var ListColumn = (props) => {
  const { Title: Title2, Item, data, gap = 20, width: contentWidth, zigzag } = props;
  const { title, desc, items: items3 = [] } = data;
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0] }));
  const width = contentWidth || itemBounds.width;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const btnElements = [];
  const itemElements = [];
  const btnAddX = (width - btnBounds.width) / 2;
  items3.forEach((item, index2) => {
    const itemY = (itemBounds.height + gap) * index2;
    const indexes = [index2];
    itemElements.push(jsx(Item, { indexes, datum: item, data, y: itemY, width, positionV: "middle", positionH: zigzag ? index2 % 2 === 0 ? "normal" : "flipped" : "normal" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: -btnBounds.width - 10, y: itemY + (itemBounds.height - btnBounds.height) / 2 }));
    const btnAddY = index2 === 0 ? -btnBounds.height : itemY - gap / 2 - btnBounds.height / 2;
    btnElements.push(jsx(BtnAdd, { indexes, x: btnAddX, y: btnAddY }));
  });
  if (items3.length > 0) {
    const lastItemY = (itemBounds.height + gap) * (items3.length - 1);
    const extraAddBtnY = lastItemY + itemBounds.height;
    btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: btnAddX, y: extraAddBtnY }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("list-column", {
  component: ListColumn,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/list-grid.js
var ListGrid = (props) => {
  const { Title: Title2, Item, data, columns = 3, gap = 24, zigzag } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const btnElements = [];
  const itemElements = [];
  const rowHeight = itemBounds.height + gap;
  const colWidth = itemBounds.width + gap;
  const processedRows = /* @__PURE__ */ new Set();
  items3.forEach((item, index2) => {
    const row = Math.floor(index2 / columns);
    const col = index2 % columns;
    const itemX = col * colWidth;
    const itemY = row * rowHeight;
    const indexes = [index2];
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, positionH: "center", positionV: zigzag && index2 % 2 === 0 ? "normal" : "flipped" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: itemY + itemBounds.height }));
    if (col < columns - 1) {
      btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: itemX + itemBounds.width + (gap - btnBounds.width) / 2, y: itemY + (itemBounds.height - btnBounds.height) / 2 }));
    }
    if (col === 0 && !processedRows.has(row)) {
      btnElements.push(jsx(BtnAdd, { indexes: [index2], x: itemX - gap / 2 - btnBounds.width / 2, y: itemY + (itemBounds.height - btnBounds.height) / 2 }));
      processedRows.add(row);
    }
    const isLastInRow = col === columns - 1 || index2 === items3.length - 1;
    if (isLastInRow) {
      btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: itemX + itemBounds.width + gap / 2 - btnBounds.width / 2, y: itemY + (itemBounds.height - btnBounds.height) / 2 }));
    }
  });
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("list-grid", {
  component: ListGrid,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/list-pyramid.js
var ListPyramid = (props) => {
  const { Title: Title2, Item, data, gap = 20, levelGap = 20 } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const btnElements = [];
  const itemElements = [];
  const levels = Math.ceil(Math.sqrt(items3.length));
  const levelSizes = [];
  let remainingItems = items3.length;
  for (let level = 0; level < levels; level++) {
    const itemsInLevel = Math.min(level + 1, remainingItems);
    levelSizes.push(itemsInLevel);
    remainingItems -= itemsInLevel;
    if (remainingItems <= 0)
      break;
  }
  let itemIndex = 0;
  const maxLevelSize = Math.max(...levelSizes);
  const maxLevelWidth = maxLevelSize * itemBounds.width + (maxLevelSize - 1) * gap;
  const baseOffset = maxLevelWidth / 2;
  levelSizes.forEach((levelSize, level) => {
    const levelY = level * (itemBounds.height + levelGap);
    const totalLevelWidth = levelSize * itemBounds.width + (levelSize - 1) * gap;
    const startX = baseOffset - totalLevelWidth / 2;
    for (let i4 = 0; i4 < levelSize && itemIndex < items3.length; i4++) {
      const itemX = startX + i4 * (itemBounds.width + gap);
      const item = items3[itemIndex];
      const indexes = [itemIndex];
      itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: levelY, positionH: "center" }));
      btnElements.push(jsx(BtnRemove, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: levelY + itemBounds.height }));
      if (i4 < levelSize - 1) {
        btnElements.push(jsx(BtnAdd, { indexes: [itemIndex + 1], x: itemX + itemBounds.width + (gap - btnBounds.width) / 2, y: levelY + (itemBounds.height - btnBounds.height) / 2 }));
      }
      if (i4 === 0) {
        btnElements.push(jsx(BtnAdd, { indexes: [itemIndex], x: itemX - gap / 2 - btnBounds.width / 2, y: levelY + (itemBounds.height - btnBounds.height) / 2 }));
      }
      if (i4 === levelSize - 1) {
        btnElements.push(jsx(BtnAdd, { indexes: [itemIndex + 1], x: itemX + itemBounds.width + gap / 2 - btnBounds.width / 2, y: levelY + (itemBounds.height - btnBounds.height) / 2 }));
      }
      itemIndex++;
    }
  });
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("list-pyramid", {
  component: ListPyramid,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/list-row.js
var ListRow = (props) => {
  const { Title: Title2, Item, data, gap = 20, zigzag } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const btnElements = [];
  const itemElements = [];
  const btnAddY = (itemBounds.height - btnBounds.height) / 2;
  const btnRemoveY = itemBounds.height;
  items3.forEach((item, index2) => {
    const itemX = (itemBounds.width + gap) * index2;
    const indexes = [index2];
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, positionH: "center", positionV: zigzag && index2 % 2 === 0 ? "normal" : "flipped" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: btnRemoveY }));
    const btnAddX = index2 === 0 ? -(gap + btnBounds.width) / 2 : itemX - (gap + btnBounds.width) / 2;
    btnElements.push(jsx(BtnAdd, { indexes, x: btnAddX, y: btnAddY }));
  });
  if (items3.length > 0) {
    const lastItemX = (itemBounds.width + gap) * (items3.length - 1);
    const extraAddBtnX = lastItemX + itemBounds.width + (gap - btnBounds.width) / 2;
    btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: extraAddBtnX, y: btnAddY }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("list-row", {
  component: ListRow,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/list-sector.js
var ListSector = (props) => {
  const { Item, data, outerRadius = 250, innerRadius = 120, startAngle = -90, endAngle = 270, gapAngle = 1, options } = props;
  const { title, items: items3 = [] } = data;
  const themeColors = getThemeColors(options.themeConfig);
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const btnElements = [];
  const itemElements = [];
  const sectorElements = [];
  const centerX = outerRadius + 100;
  const centerY = outerRadius + 100;
  const totalAngle = endAngle - startAngle;
  const isFullCircle = Math.abs(totalAngle - 360) < 0.01;
  const totalGapAngle = items3.length > 0 ? gapAngle * (isFullCircle ? items3.length : items3.length - 1) : 0;
  const totalUsableAngle = totalAngle - totalGapAngle;
  const anglePerSector = items3.length > 0 ? totalUsableAngle / items3.length : 0;
  items3.forEach((item, index2) => {
    var _a;
    const indexes = [index2];
    const currentStartAngle = startAngle + (anglePerSector + gapAngle) * index2;
    const currentEndAngle = currentStartAngle + anglePerSector;
    const gapArcLength = gapAngle * Math.PI * outerRadius / 180;
    const innerGapAngle = gapArcLength / innerRadius * (180 / Math.PI);
    const outerGapAngle = gapAngle;
    const outerStartAngleRad = (currentStartAngle + outerGapAngle / 2) * Math.PI / 180;
    const outerEndAngleRad = (currentEndAngle - outerGapAngle / 2) * Math.PI / 180;
    const innerStartAngleRad = (currentStartAngle + innerGapAngle / 2) * Math.PI / 180;
    const innerEndAngleRad = (currentEndAngle - innerGapAngle / 2) * Math.PI / 180;
    const outerStartX = centerX + outerRadius * Math.cos(outerStartAngleRad);
    const outerStartY = centerY + outerRadius * Math.sin(outerStartAngleRad);
    const outerEndX = centerX + outerRadius * Math.cos(outerEndAngleRad);
    const outerEndY = centerY + outerRadius * Math.sin(outerEndAngleRad);
    const innerStartX = centerX + innerRadius * Math.cos(innerStartAngleRad);
    const innerStartY = centerY + innerRadius * Math.sin(innerStartAngleRad);
    const innerEndX = centerX + innerRadius * Math.cos(innerEndAngleRad);
    const innerEndY = centerY + innerRadius * Math.sin(innerEndAngleRad);
    const largeArcFlag = anglePerSector > 180 ? 1 : 0;
    const arcPath = `
      M ${outerStartX} ${outerStartY}
      A ${outerRadius} ${outerRadius} 0 ${largeArcFlag} 1 ${outerEndX} ${outerEndY}
      L ${innerEndX} ${innerEndY}
      A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${innerStartX} ${innerStartY}
      Z
    `.trim();
    const color3 = getPaletteColor2(options, indexes);
    sectorElements.push(jsx(Path, { id: "shape-sector", d: arcPath, fill: color3, width: outerRadius * 2 + 200, height: outerRadius * 2 + 200, "data-element-type": "shape" }));
    const midAngle = currentStartAngle + anglePerSector / 2;
    const midAngleRad = midAngle * Math.PI / 180;
    const midRadius = (outerRadius + innerRadius) / 2;
    const arcThickness = outerRadius - innerRadius;
    const midAngleRadian = anglePerSector * Math.PI / 180;
    const arcLength = midRadius * midAngleRadian;
    const maxWidth = Math.min(arcLength * 0.8, arcThickness * 0.9);
    const maxHeight = Math.min(arcThickness * 0.9, arcLength * 0.8);
    const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center", width: maxWidth, height: maxHeight }));
    const itemX = centerX + midRadius * Math.cos(midAngleRad) - itemBounds.width / 2;
    const itemY = centerY + midRadius * Math.sin(midAngleRad) - itemBounds.height / 2;
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, positionH: "center", width: maxWidth, height: maxHeight, themeColors: Object.assign({}, getThemeColors({
      colorBg: getPaletteColor2(options, indexes),
      colorPrimary: ((_a = options.themeConfig) === null || _a === void 0 ? void 0 : _a.colorBg) || "white"
    })) }));
    const btnRemoveRadius = outerRadius + 10;
    const btnRemoveX = centerX + btnRemoveRadius * Math.cos(midAngleRad) - btnBounds.width / 2;
    const btnRemoveY = centerY + btnRemoveRadius * Math.sin(midAngleRad) - btnBounds.height / 2;
    btnElements.push(jsx(BtnRemove, { indexes, x: btnRemoveX, y: btnRemoveY }));
    if (isFullCircle || index2 < items3.length - 1) {
      const gapMidAngle = currentEndAngle + gapAngle / 2;
      const gapMidAngleRad = gapMidAngle * Math.PI / 180;
      const btnAddRadius = midRadius;
      const btnAddX = centerX + btnAddRadius * Math.cos(gapMidAngleRad) - btnBounds.width / 2;
      const btnAddY = centerY + btnAddRadius * Math.sin(gapMidAngleRad) - btnBounds.height / 2;
      btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: btnAddX, y: btnAddY }));
    }
  });
  if (items3.length > 0) {
    const firstGapMidAngle = startAngle - gapAngle / 2;
    const firstGapMidAngleRad = firstGapMidAngle * Math.PI / 180;
    const midRadius = (outerRadius + innerRadius) / 2;
    const btnAddX = centerX + midRadius * Math.cos(firstGapMidAngleRad) - btnBounds.width / 2;
    const btnAddY = centerY + midRadius * Math.sin(firstGapMidAngleRad) - btnBounds.height / 2;
    btnElements.push(jsx(BtnAdd, { indexes: [0], x: btnAddX, y: btnAddY }));
  }
  const centerRadius = innerRadius * 0.9;
  let titleCenterX = centerX;
  let titleCenterY = centerY;
  let titleWidth = centerRadius * 1.4;
  let titleHeight = centerRadius * 1.4;
  if (!isFullCircle) {
    const midAngle = (startAngle + endAngle) / 2;
    const midAngleRad = midAngle * Math.PI / 180;
    const titleRadius = centerRadius * 0.5;
    titleCenterX = centerX + titleRadius * Math.cos(midAngleRad);
    titleCenterY = centerY + titleRadius * Math.sin(midAngleRad);
    const arcLength = totalAngle * Math.PI * titleRadius / 180;
    titleWidth = Math.min(arcLength * 0.8, centerRadius * 1.4);
    titleHeight = Math.min(titleRadius * 1.5, centerRadius * 1.4);
  }
  let centerSectorPath = "";
  if (isFullCircle) {
    centerSectorPath = "";
  } else {
    const centerStartAngleRad = startAngle * Math.PI / 180;
    const centerEndAngleRad = endAngle * Math.PI / 180;
    const centerStartX = centerX + centerRadius * Math.cos(centerStartAngleRad);
    const centerStartY = centerY + centerRadius * Math.sin(centerStartAngleRad);
    const centerEndX = centerX + centerRadius * Math.cos(centerEndAngleRad);
    const centerEndY = centerY + centerRadius * Math.sin(centerEndAngleRad);
    const centerLargeArcFlag = totalAngle > 180 ? 1 : 0;
    centerSectorPath = `
      M ${centerX} ${centerY}
      L ${centerStartX} ${centerStartY}
      A ${centerRadius} ${centerRadius} 0 ${centerLargeArcFlag} 1 ${centerEndX} ${centerEndY}
      Z
    `.trim();
  }
  return jsxs(Group, { id: "infographic-container", children: [jsx(Group, { children: sectorElements }), isFullCircle ? jsx(Ellipse, { id: "shape-center-circle", x: centerX - centerRadius, y: centerY - centerRadius, width: centerRadius * 2, height: centerRadius * 2, fill: themeColors.colorPrimaryBg, fillOpacity: 0.5, "data-element-type": "shape" }) : jsx(Path, { id: "shape-center-sector", d: centerSectorPath, fill: themeColors.colorPrimaryBg, fillOpacity: 0.5, width: outerRadius * 2 + 200, height: outerRadius * 2 + 200, "data-element-type": "shape" }), jsx(Text, { x: titleCenterX - titleWidth / 2, y: titleCenterY - titleHeight / 2, width: titleWidth, height: titleHeight, alignHorizontal: "center", alignVertical: "middle", fontSize: 24, fontWeight: "bold", fill: themeColors.colorText, "data-element-type": "title", children: title }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] });
};
registerStructure("list-sector", {
  component: ListSector,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/list-waterfall.js
var ListWaterfall = (props) => {
  const { Title: Title2, Item, data, columns = 4, gap = 20, stepOffset = 40 } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const btnElements = [];
  const itemElements = [];
  const colWidth = itemBounds.width + gap;
  items3.forEach((item, index2) => {
    const col = index2 % columns;
    const row = Math.floor(index2 / columns);
    const itemX = col * colWidth;
    const baseY = row * (itemBounds.height + gap);
    const columnStepOffset = col * stepOffset;
    const itemY = baseY + columnStepOffset;
    const indexes = [index2];
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, positionH: "center" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: itemY + itemBounds.height + 5 }));
  });
  items3.forEach((item, index2) => {
    const col = index2 % columns;
    const row = Math.floor(index2 / columns);
    const itemX = col * colWidth;
    const baseY = row * (itemBounds.height + gap);
    const columnStepOffset = col * stepOffset;
    const itemY = baseY + columnStepOffset;
    if (index2 === 0) {
      btnElements.push(jsx(BtnAdd, { indexes: [0], x: itemX - gap / 2 - btnBounds.width / 2, y: itemY + (itemBounds.height - btnBounds.height) / 2 }));
    }
    if (col < columns - 1 && index2 < items3.length - 1) {
      const nextRow = Math.floor((index2 + 1) / columns);
      if (row === nextRow) {
        btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: itemX + itemBounds.width + (gap - btnBounds.width) / 2, y: itemY + (itemBounds.height - btnBounds.height) / 2 }));
      }
    }
    if (col === columns - 1 || index2 === items3.length - 1) {
      btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: itemX + itemBounds.width + (gap - btnBounds.width) / 2, y: itemY + (itemBounds.height - btnBounds.height) / 2 }));
    }
  });
  if (items3.length === 0) {
    btnElements.push(jsx(BtnAdd, { indexes: [0], x: (columns - 1) * colWidth / 2 + (itemBounds.width - btnBounds.width) / 2, y: 0 }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("list-waterfall", {
  component: ListWaterfall,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/list-zigzag.js
var MAX_ITEMS = 6;
var ARROW_WIDTH = 700;
var ARROW_HEIGHT_DOWN = 330;
var ARROW_HEIGHT_UP = 333;
var PRESET_RATIOS_DOWN = {
  1: [{ x: 0.5, y: 0.6, anchor: "top-right" }],
  2: [
    { x: 0.42, y: 0.5, anchor: "top-right" },
    { x: 0.72, y: 0.4, anchor: "bottom" }
  ],
  3: [
    { x: 0.3, y: 0.5, anchor: "top-right" },
    { x: 0.48, y: 0.3, anchor: "bottom-left" },
    { x: 0.8, y: 0.75, anchor: "top-right" }
  ],
  4: [
    { x: 0.3, y: 0.5, anchor: "top-right" },
    { x: 0.35, y: 0.2, anchor: "bottom-left" },
    { x: 0.65, y: 0.73, anchor: "top-right" },
    { x: 0.8, y: 0.52, anchor: "bottom-left" }
  ],
  5: [
    { x: 0.19, y: 0.4, anchor: "top-right" },
    { x: 0.38, y: 0.2, anchor: "bottom" },
    { x: 0.52, y: 0.62, anchor: "top-right" },
    { x: 0.7, y: 0.43, anchor: "bottom" },
    { x: 0.82, y: 0.8, anchor: "top-right" }
  ],
  6: [
    { x: 0.16, y: 0.35, anchor: "top-right" },
    { x: 0.38, y: 0.2, anchor: "bottom" },
    { x: 0.48, y: 0.54, anchor: "top-right" },
    { x: 0.55, y: 0.43, anchor: "bottom-left" },
    { x: 0.8, y: 0.75, anchor: "top-right" },
    { x: 0.86, y: 0.65, anchor: "bottom-left" }
  ]
};
var PRESET_RATIOS_UP = {
  1: [{ x: 0.5, y: 0.4, anchor: "bottom-right" }],
  2: [
    { x: 0.42, y: 0.5, anchor: "bottom-right" },
    { x: 0.72, y: 0.6, anchor: "top" }
  ],
  3: [
    { x: 0.3, y: 0.5, anchor: "bottom-right" },
    { x: 0.48, y: 0.7, anchor: "top-left" },
    { x: 0.8, y: 0.25, anchor: "bottom-right" }
  ],
  4: [
    { x: 0.3, y: 0.5, anchor: "bottom-right" },
    { x: 0.35, y: 0.8, anchor: "top-left" },
    { x: 0.65, y: 0.27, anchor: "bottom-right" },
    { x: 0.8, y: 0.48, anchor: "top-left" }
  ],
  5: [
    { x: 0.19, y: 0.6, anchor: "bottom-right" },
    { x: 0.38, y: 0.8, anchor: "top" },
    { x: 0.52, y: 0.38, anchor: "bottom-right" },
    { x: 0.7, y: 0.57, anchor: "top" },
    { x: 0.82, y: 0.2, anchor: "bottom-right" }
  ],
  6: [
    { x: 0.16, y: 0.65, anchor: "bottom-right" },
    { x: 0.38, y: 0.8, anchor: "top" },
    { x: 0.48, y: 0.46, anchor: "bottom-right" },
    { x: 0.55, y: 0.57, anchor: "top-left" },
    { x: 0.8, y: 0.25, anchor: "bottom-right" },
    { x: 0.86, y: 0.35, anchor: "top-left" }
  ]
};
var getPresetPoints = (count2, presetRatios, arrowHeight) => {
  const ratios = presetRatios[count2];
  if (!ratios)
    return null;
  return ratios.map((point) => ({
    x: point.x * ARROW_WIDTH,
    y: point.y * arrowHeight,
    anchor: point.anchor
  }));
};
var getAnchoredPosition = (point, size) => {
  const anchor = point.anchor || "center";
  let x6 = point.x - size.width / 2;
  let y6 = point.y - size.height / 2;
  let centerY = point.y;
  switch (anchor) {
    case "top":
      x6 = point.x - size.width / 2;
      y6 = point.y;
      centerY = point.y + size.height / 2;
      break;
    case "bottom":
      x6 = point.x - size.width / 2;
      y6 = point.y - size.height;
      centerY = point.y - size.height / 2;
      break;
    case "top-left":
      x6 = point.x;
      y6 = point.y;
      centerY = point.y + size.height / 2;
      break;
    case "top-right":
      x6 = point.x - size.width;
      y6 = point.y;
      centerY = point.y + size.height / 2;
      break;
    case "bottom-left":
      x6 = point.x;
      y6 = point.y - size.height;
      centerY = point.y - size.height / 2;
      break;
    case "bottom-right":
      x6 = point.x - size.width;
      y6 = point.y - size.height;
      centerY = point.y - size.height / 2;
      break;
    default:
      break;
  }
  return { x: x6, y: y6, centerY };
};
var getUnitVector = (from, to) => {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const length = Math.hypot(dx, dy) || 1;
  return { x: dx / length, y: dy / length };
};
var createListZigzag = (config) => {
  const { presetRatios, arrowHeight, Arrow } = config;
  const ListZigzag = (props) => {
    var _a;
    const { Title: Title2, Item, data, options, itemGap = 24 } = props;
    const { title, desc, items: items3 = [] } = data;
    const layoutCount = Math.min(items3.length, MAX_ITEMS);
    const displayItems = items3.slice(0, layoutCount);
    const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
    const colorPrimary = getColorPrimary(options);
    const themeColors = getThemeColors({ colorPrimary }, options);
    const colorShadow = themeColors.colorTextSecondary || "#737373";
    const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
    if (items3.length === 0) {
      const anchor = (_a = getPresetPoints(1, presetRatios, arrowHeight)) === null || _a === void 0 ? void 0 : _a[0];
      if (!anchor) {
        return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { children: jsx(Arrow, { colorPrimary, colorShadow }) })] });
      }
      const btnX = anchor.x - btnBounds.width / 2;
      const btnY = anchor.y - btnBounds.height / 2;
      return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(Arrow, { colorPrimary, colorShadow }), jsx(ItemsGroup, {}), jsx(BtnsGroup, { children: jsx(BtnAdd, { indexes: [0], x: btnX, y: btnY }) })] })] });
    }
    const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
    const btnElements = [];
    const itemElements = [];
    const presetPoints = getPresetPoints(layoutCount, presetRatios, arrowHeight);
    if (!presetPoints) {
      return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(Arrow, { colorPrimary, colorShadow }), jsx(ItemsGroup, {})] })] });
    }
    const anchorPoints = presetPoints;
    const baseDirection = anchorPoints.length > 1 ? getUnitVector(anchorPoints[0], anchorPoints[anchorPoints.length - 1]) : { x: 1, y: 0 };
    const startDirection = anchorPoints.length > 1 ? getUnitVector(anchorPoints[0], anchorPoints[1]) : baseDirection;
    const endDirection = anchorPoints.length > 1 ? getUnitVector(anchorPoints[anchorPoints.length - 2], anchorPoints[anchorPoints.length - 1]) : baseDirection;
    const addOffset = Math.max(itemBounds.width, itemBounds.height) * 0.45 + itemGap;
    const toItemPosition = (point) => {
      const { x: x6, y: y6, centerY } = getAnchoredPosition(point, itemBounds);
      return { x: x6, y: y6, centerY };
    };
    anchorPoints.forEach((anchor, index2) => {
      const itemPosition = toItemPosition(anchor);
      const isTop = itemPosition.centerY < arrowHeight / 2;
      const indexes = [index2];
      const item = displayItems[index2];
      if (!item)
        return;
      itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemPosition.x, y: itemPosition.y, positionH: "center" }));
      const btnRemoveX = itemPosition.x + itemBounds.width - btnBounds.width / 2;
      const btnRemoveY = isTop ? itemPosition.y - btnBounds.height / 2 : itemPosition.y + itemBounds.height - btnBounds.height / 2;
      btnElements.push(jsx(BtnRemove, { indexes, x: btnRemoveX, y: btnRemoveY }));
    });
    if (anchorPoints.length > 0) {
      const firstAnchor = anchorPoints[0];
      const firstAddX = firstAnchor.x - startDirection.x * addOffset - btnBounds.width / 2;
      const firstAddY = firstAnchor.y - startDirection.y * addOffset - btnBounds.height / 2;
      btnElements.push(jsx(BtnAdd, { indexes: [0], x: firstAddX, y: firstAddY }));
      for (let index2 = 0; index2 < anchorPoints.length - 1; index2++) {
        const current = anchorPoints[index2];
        const next = anchorPoints[index2 + 1];
        const midX = (current.x + next.x) / 2;
        const midY = (current.y + next.y) / 2;
        const midAddX = midX - btnBounds.width / 2;
        const midAddY = midY - btnBounds.height / 2;
        btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: midAddX, y: midAddY }));
      }
      const lastAnchor = anchorPoints[anchorPoints.length - 1];
      const lastAddX = lastAnchor.x + endDirection.x * addOffset - btnBounds.width / 2;
      const lastAddY = lastAnchor.y + endDirection.y * addOffset - btnBounds.height / 2;
      btnElements.push(jsx(BtnAdd, { indexes: [layoutCount], x: lastAddX, y: lastAddY }));
    }
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(Arrow, { colorPrimary, colorShadow }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
  };
  return ListZigzag;
};
var ArrowDown = ({ colorPrimary = "#17CA2C", colorShadow = "#737373" }) => {
  const colorPrimaryDark = tinycolor(colorPrimary).darken(20).toHexString();
  return jsxs(Group, { width: ARROW_WIDTH, height: ARROW_HEIGHT_DOWN, children: [jsx("path", { d: "M228.864 159.446C230.266 159.446 231.623 158.768 232.689 157.535L274.263 110.162L265.717 102.923L227.311 148.082C225.977 149.623 224.281 150.47 222.529 150.47H175.404L182.03 158.367C182.795 159.445 182.795 159.446 183.734 159.446H228.864Z", fill: colorShadow }), jsx("path", { d: "M462.869 234.92C464.271 234.92 465.628 234.242 466.695 233.01L508.268 185.636L499.722 178.397L461.316 223.557C459.983 225.098 458.287 225.945 456.534 225.945H409.409L416.035 233.841C416.8 234.92 416.8 234.92 417.74 234.92H462.869Z", fill: colorShadow }), jsx("path", { d: "M697.005 330C698.783 330 700 328.82 700 327.001V256.638C700 254.857 697.848 253.965 696.591 255.225L693.409 258.411V320.402C693.409 322.058 692.069 323.401 690.414 323.401H630.718L627.536 326.587C626.278 327.847 627.169 330 628.947 330H697.005Z", fill: colorShadow }), jsx("path", { d: "M689.642 321.89C690.744 321.89 691.638 320.995 691.638 319.891V250.743C691.638 248.962 689.488 248.07 688.23 249.329L662.647 274.947L520.987 153.863C519.541 152.627 517.703 151.948 515.802 151.948H469.518C470.236 151.949 470.956 152.206 471.53 152.729L498.163 176.978L498.13 177.018L639.84 297.784L619.174 318.477C617.916 319.737 618.807 321.89 620.586 321.89H689.642Z", fill: colorPrimary }), jsx("path", { d: "M429.279 198.995L467.208 153.03C468.3 151.716 470.268 151.579 471.531 152.729L498.163 176.978L460.69 221.107C459.173 222.894 456.946 223.924 454.6 223.924H408.473C409.366 223.924 410.252 223.527 410.845 222.764L429.279 198.995Z", fill: colorPrimaryDark }), jsx("path", { d: "M408.473 223.924H408.314L408.318 223.92C408.369 223.922 408.421 223.924 408.473 223.924Z", fill: colorPrimaryDark }), jsx("path", { d: "M406.524 223.203C407.826 224.318 409.796 224.116 410.845 222.761L429.279 198.932L287.411 77.8866C285.964 76.6523 284.125 75.9742 282.223 75.9742H234.606L234.625 75.9907C235.429 75.9118 236.263 76.1557 236.915 76.7378L263.662 100.621L263.546 100.758L406.524 223.203Z", fill: colorPrimary }), jsx("path", { d: "M236.914 76.7386C235.651 75.6097 233.707 75.7513 232.621 77.0513L194.557 123.104L175.644 146.821C175.076 147.535 174.25 147.917 173.409 147.947L173.407 147.95H219.923C222.271 147.95 224.499 146.915 226.017 145.122L263.645 100.649L236.914 76.7386Z", fill: colorPrimaryDark }), jsx("path", { d: "M175.648 146.816C174.589 148.145 172.637 148.329 171.348 147.221L4.09334 3.51697C2.68586 2.30767 3.54106 0 5.39671 0H47.5805C49.4864 0 51.3297 0.680433 52.7785 1.91877L194.557 123.104L175.648 146.816Z", fill: colorPrimary })] });
};
var ArrowUp = ({ colorPrimary = "#17CA2C", colorShadow = "#737373" }) => {
  const colorPrimaryDark = tinycolor(colorPrimary).darken(20).toHexString();
  return jsxs(Group, { width: ARROW_WIDTH, height: ARROW_HEIGHT_UP, children: [jsx("path", { d: "M19.0526 324L12.6762 329.482C11.2703 330.691 12.1234 333 13.976 333H56.1578C58.058 333 59.896 332.321 61.3413 331.085L201.854 210.901L194.249 201.693L54.0527 321.606C52.246 323.151 49.9486 324 47.5732 324H19.0526Z", fill: colorShadow }), jsx("path", { d: "M234.587 248L241.131 255.922C241.656 256.552 242.382 256.909 243.134 256.983L243.115 257H290.716C292.618 257 294.457 256.322 295.903 255.087L437.091 134.536L429.305 125.5L288.613 245.609C286.805 247.153 284.507 248 282.132 248H234.587Z", fill: colorShadow }), jsx("path", { d: "M461.123 162.429L475.642 179.918C476.237 180.635 477.092 181.001 477.951 181H524.22C526.121 181 527.959 180.321 529.404 179.085L670.786 58.1578L662.326 49.6809L522.115 169.606C520.309 171.151 518.011 172 515.636 172H469.369L461.123 162.429Z", fill: colorShadow }), jsx("path", { d: "M687.912 74.8875C690.374 75.9052 693.412 74.1668 693.412 71.1716V11H698.004C699.106 11 700 11.8954 700 13V82.1716C700 83.9534 697.85 84.8457 696.593 83.5858L687.912 74.8875Z", fill: colorShadow }), jsx("path", { d: "M689.419 0C690.522 0 691.415 0.895432 691.415 2V71.1716C691.415 72.9534 689.265 73.8457 688.008 72.5858L662.433 46.9598L520.819 168.085C519.374 169.321 517.536 170 515.636 170H469.367C470.084 169.999 470.804 169.742 471.379 169.219L498.003 144.961L497.969 144.922L639.634 24.115L618.975 3.41421C617.717 2.15428 618.608 0 620.386 0H689.419Z", fill: colorPrimary }), jsx("path", { d: "M429.141 122.937L467.058 168.918C468.149 170.232 470.116 170.369 471.378 169.219L498.003 144.961L460.542 100.818C459.025 99.0305 456.798 98 454.453 98H408.341C409.234 98.0001 410.12 98.3968 410.712 99.1606L429.141 122.937Z", fill: colorPrimaryDark }), jsx("path", { d: "M408.341 98H408.183L408.186 98.004C408.237 98.0013 408.289 98 408.341 98Z", fill: colorPrimaryDark }), jsx("path", { d: "M406.393 98.721C407.695 97.606 409.664 97.8077 410.712 99.1633L429.141 123L287.318 244.087C285.872 245.322 284.033 246 282.132 246H234.53L234.55 245.983C235.353 246.062 236.187 245.818 236.839 245.236L263.577 221.345L263.461 221.208L406.393 98.721Z", fill: colorPrimary }), jsx("path", { d: "M236.837 245.235C235.575 246.365 233.631 246.223 232.546 244.922L194.494 198.854L175.588 175.129C175.019 174.415 174.194 174.032 173.353 174.002L173.351 174H219.852C222.199 174 224.427 175.035 225.944 176.829L263.56 221.317L236.837 245.235Z", fill: colorPrimaryDark }), jsx("path", { d: "M175.593 175.135C174.533 173.805 172.581 173.622 171.291 174.73L4.09013 318.484C2.68329 319.693 3.53868 322 5.394 322H47.5627C49.4695 322 51.3136 321.319 52.7627 320.08L194.494 198.854L175.593 175.135Z", fill: colorPrimary })] });
};
var ListZigzagDown = createListZigzag({
  arrowHeight: ARROW_HEIGHT_DOWN,
  presetRatios: PRESET_RATIOS_DOWN,
  Arrow: ArrowDown
});
var ListZigzagUp = createListZigzag({
  arrowHeight: ARROW_HEIGHT_UP,
  presetRatios: PRESET_RATIOS_UP,
  Arrow: ArrowUp
});
registerStructure("list-zigzag-down", {
  component: ListZigzagDown,
  composites: ["title", "item"]
});
registerStructure("list-zigzag-up", {
  component: ListZigzagUp,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/relation-circle.js
var RelationCircle = (props) => {
  const { Title: Title2, Item, data, radius = 150, startMode = "top" } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const btnElements = [];
  const itemElements = [];
  if (items3.length === 0) {
    btnElements.push(jsx(BtnAdd, { indexes: [0], x: -btnBounds.width / 2, y: -btnBounds.height / 2 }));
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { children: jsx(BtnsGroup, { children: btnElements }) })] });
  }
  const size = Math.max(itemBounds.width, itemBounds.height);
  const minRadius = Math.max(radius, size);
  const centerOffset = minRadius + size / 2;
  const itemArcWeights = items3.map(() => {
    const w3 = itemBounds.width;
    const h4 = itemBounds.height;
    return (w3 + h4) / 2;
  });
  const totalWeight = itemArcWeights.reduce((a3, b2) => a3 + b2, 0);
  let startAngle;
  if (startMode === "equal") {
    startAngle = -Math.PI / 2;
  } else {
    startAngle = -Math.PI / 2 + 2 * Math.PI / items3.length / 2;
  }
  let angleAcc = startAngle;
  items3.forEach((item, index2) => {
    const anglePortion = itemArcWeights[index2] / totalWeight * 2 * Math.PI;
    const angle = angleAcc + anglePortion / 2;
    angleAcc += anglePortion;
    const itemX = centerOffset + minRadius * Math.cos(angle) - itemBounds.width / 2;
    const itemY = centerOffset + minRadius * Math.sin(angle) - itemBounds.height / 2;
    itemElements.push(jsx(Item, { indexes: [index2], datum: item, data, x: itemX, y: itemY }));
    const removeRadius = minRadius - Math.max(itemBounds.width, itemBounds.height) / 2 - 20;
    const removeBtnX = centerOffset + removeRadius * Math.cos(angle) - btnBounds.width / 2;
    const removeBtnY = centerOffset + removeRadius * Math.sin(angle) - btnBounds.height / 2;
    btnElements.push(jsx(BtnRemove, { indexes: [index2], x: removeBtnX, y: removeBtnY }));
  });
  const buttonRadius = minRadius - Math.max(itemBounds.width, itemBounds.height) / 2 - 20;
  if (items3.length > 0) {
    for (let i4 = 0; i4 < items3.length; i4++) {
      const currentAngle = i4 * 2 * Math.PI / items3.length - Math.PI / 2;
      const nextAngle = (i4 + 1) % items3.length * 2 * Math.PI / items3.length - Math.PI / 2;
      let midAngle;
      if (i4 === items3.length - 1) {
        const angleDiff = nextAngle + 2 * Math.PI - currentAngle;
        midAngle = currentAngle + angleDiff / 2;
      } else {
        midAngle = (currentAngle + nextAngle) / 2;
      }
      const addX = centerOffset + buttonRadius * Math.cos(midAngle) - btnBounds.width / 2;
      const addY = centerOffset + buttonRadius * Math.sin(midAngle) - btnBounds.height / 2;
      btnElements.push(jsx(BtnAdd, { indexes: [i4 + 1], x: addX, y: addY }));
    }
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("relation-circle", {
  component: RelationCircle,
  composites: ["title", "item"]
});

// node_modules/@antv/layout/lib/node_modules/tslib/tslib.es6.js
function __awaiter7(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@antv/layout/lib/node_modules/@antv/expr/dist/index.esm.js
var e7 = { abs: Math.abs, ceil: Math.ceil, floor: Math.floor, max: Math.max, min: Math.min, round: Math.round, sqrt: Math.sqrt, pow: Math.pow };
var n3 = class extends Error {
  constructor(e8, t2, n4) {
    super(e8), this.position = t2, this.token = n4, this.name = "ExpressionError";
  }
};
var r4;
!function(e8) {
  e8[e8.STRING = 0] = "STRING", e8[e8.NUMBER = 1] = "NUMBER", e8[e8.BOOLEAN = 2] = "BOOLEAN", e8[e8.NULL = 3] = "NULL", e8[e8.IDENTIFIER = 4] = "IDENTIFIER", e8[e8.OPERATOR = 5] = "OPERATOR", e8[e8.FUNCTION = 6] = "FUNCTION", e8[e8.DOT = 7] = "DOT", e8[e8.BRACKET_LEFT = 8] = "BRACKET_LEFT", e8[e8.BRACKET_RIGHT = 9] = "BRACKET_RIGHT", e8[e8.PAREN_LEFT = 10] = "PAREN_LEFT", e8[e8.PAREN_RIGHT = 11] = "PAREN_RIGHT", e8[e8.COMMA = 12] = "COMMA", e8[e8.QUESTION = 13] = "QUESTION", e8[e8.COLON = 14] = "COLON", e8[e8.DOLLAR = 15] = "DOLLAR";
}(r4 || (r4 = {}));
var o2 = /* @__PURE__ */ new Set([32, 9, 10, 13]);
var a$2 = /* @__PURE__ */ new Set([43, 45, 42, 47, 37, 33, 38, 124, 61, 60, 62]);
var s2 = /* @__PURE__ */ new Map([["true", r4.BOOLEAN], ["false", r4.BOOLEAN], ["null", r4.NULL]]);
var i3 = /* @__PURE__ */ new Map([["===", true], ["!==", true], ["<=", true], [">=", true], ["&&", true], ["||", true], ["+", true], ["-", true], ["*", true], ["/", true], ["%", true], ["!", true], ["<", true], [">", true]]);
var u3 = /* @__PURE__ */ new Map([[46, r4.DOT], [91, r4.BRACKET_LEFT], [93, r4.BRACKET_RIGHT], [40, r4.PAREN_LEFT], [41, r4.PAREN_RIGHT], [44, r4.COMMA], [63, r4.QUESTION], [58, r4.COLON], [36, r4.DOLLAR]]);
var c$2 = /* @__PURE__ */ new Map();
for (const [e8, t2] of u3.entries())
  c$2.set(e8, { type: t2, value: String.fromCharCode(e8) });
function p6(e8) {
  return e8 >= 48 && e8 <= 57;
}
function l2(e8) {
  return e8 >= 97 && e8 <= 122 || e8 >= 65 && e8 <= 90 || 95 === e8;
}
function f4(e8) {
  return l2(e8) || p6(e8);
}
function E2(e8) {
  return a$2.has(e8);
}
var h3;
!function(e8) {
  e8[e8.Program = 0] = "Program", e8[e8.Literal = 1] = "Literal", e8[e8.Identifier = 2] = "Identifier", e8[e8.MemberExpression = 3] = "MemberExpression", e8[e8.CallExpression = 4] = "CallExpression", e8[e8.BinaryExpression = 5] = "BinaryExpression", e8[e8.UnaryExpression = 6] = "UnaryExpression", e8[e8.ConditionalExpression = 7] = "ConditionalExpression";
}(h3 || (h3 = {}));
var d2 = /* @__PURE__ */ new Map([["||", 2], ["&&", 3], ["===", 4], ["!==", 4], [">", 5], [">=", 5], ["<", 5], ["<=", 5], ["+", 6], ["-", 6], ["*", 7], ["/", 7], ["%", 7], ["!", 8]]);
var R2 = { type: h3.Literal, value: null };
var T2 = { type: h3.Literal, value: true };
var w2 = { type: h3.Literal, value: false };
var y$4 = (e8) => {
  let t2 = 0;
  const o3 = e8.length, a3 = () => t2 >= o3 ? null : e8[t2], s3 = () => e8[t2++], i4 = (e9) => {
    const t3 = a3();
    return null !== t3 && t3.type === e9;
  }, u4 = (e9) => e9.type === r4.OPERATOR ? d2.get(e9.value) || -1 : e9.type === r4.DOT || e9.type === r4.BRACKET_LEFT ? 9 : e9.type === r4.QUESTION ? 1 : -1, c4 = (e9) => {
    let o4, u5;
    if (s3().type === r4.DOT) {
      if (!i4(r4.IDENTIFIER)) {
        const e12 = a3();
        throw new n3("Expected property name", t2, e12 ? e12.value : "<end of input>");
      }
      const e11 = s3();
      o4 = { type: h3.Identifier, name: e11.value }, u5 = false;
    } else {
      if (o4 = l3(0), !i4(r4.BRACKET_RIGHT)) {
        const e11 = a3();
        throw new n3("Expected closing bracket", t2, e11 ? e11.value : "<end of input>");
      }
      s3(), u5 = true;
    }
    return { type: h3.MemberExpression, object: e9, property: o4, computed: u5 };
  }, p7 = () => {
    const e9 = a3();
    if (!e9)
      throw new n3("Unexpected end of input", t2, "<end of input>");
    if (e9.type === r4.OPERATOR && ("!" === e9.value || "-" === e9.value)) {
      s3();
      const t3 = p7();
      return { type: h3.UnaryExpression, operator: e9.value, argument: t3, prefix: true };
    }
    switch (e9.type) {
      case r4.NUMBER:
        return s3(), { type: h3.Literal, value: Number(e9.value) };
      case r4.STRING:
        return s3(), { type: h3.Literal, value: e9.value };
      case r4.BOOLEAN:
        return s3(), "true" === e9.value ? T2 : w2;
      case r4.NULL:
        return s3(), R2;
      case r4.IDENTIFIER:
        return s3(), { type: h3.Identifier, name: e9.value };
      case r4.FUNCTION:
        return (() => {
          const e11 = s3(), o4 = [];
          if (!i4(r4.PAREN_LEFT)) {
            const e12 = a3();
            throw new n3("Expected opening parenthesis after function name", t2, e12 ? e12.value : "<end of input>");
          }
          for (s3(); ; ) {
            if (i4(r4.PAREN_RIGHT)) {
              s3();
              break;
            }
            if (!a3()) {
              const e13 = a3();
              throw new n3("Expected closing parenthesis", t2, e13 ? e13.value : "<end of input>");
            }
            if (o4.length > 0) {
              if (!i4(r4.COMMA)) {
                const e13 = a3();
                throw new n3("Expected comma between function arguments", t2, e13 ? e13.value : "<end of input>");
              }
              s3();
            }
            const e12 = l3(0);
            o4.push(e12);
          }
          return { type: h3.CallExpression, callee: { type: h3.Identifier, name: e11.value }, arguments: o4 };
        })();
      case r4.PAREN_LEFT: {
        s3();
        const e11 = l3(0);
        if (!i4(r4.PAREN_RIGHT)) {
          const e12 = a3();
          throw new n3("Expected closing parenthesis", t2, e12 ? e12.value : "<end of input>");
        }
        return s3(), e11;
      }
      default:
        throw new n3(`Unexpected token: ${e9.type}`, t2, e9.value);
    }
  }, l3 = (f6 = 0) => {
    let E3 = p7();
    for (; t2 < o3; ) {
      const o4 = e8[t2], p8 = u4(o4);
      if (p8 <= f6)
        break;
      if (o4.type !== r4.QUESTION)
        if (o4.type !== r4.OPERATOR) {
          if (o4.type !== r4.DOT && o4.type !== r4.BRACKET_LEFT)
            break;
          E3 = c4(E3);
        } else {
          s3();
          const e9 = l3(p8);
          E3 = { type: h3.BinaryExpression, operator: o4.value, left: E3, right: e9 };
        }
      else {
        s3();
        const e9 = l3(0);
        if (!i4(r4.COLON)) {
          const e11 = a3();
          throw new n3("Expected : in conditional expression", t2, e11 ? e11.value : "<end of input>");
        }
        s3();
        const o5 = l3(0);
        E3 = { type: h3.ConditionalExpression, test: E3, consequent: e9, alternate: o5 };
      }
    }
    return E3;
  }, f5 = l3();
  return { type: h3.Program, body: f5 };
};
var O2 = (e8, t2, r5) => {
  let o3 = t2;
  r5 && (o3 = { ...t2, context: { ...t2.context, ...r5 } });
  const a3 = (e9) => {
    switch (e9.type) {
      case h3.Literal:
        return ((e11) => e11.value)(e9);
      case h3.Identifier:
        return ((e11) => {
          if (!(e11.name in o3.context))
            throw new n3(`Undefined variable: ${e11.name}`);
          return o3.context[e11.name];
        })(e9);
      case h3.MemberExpression:
        return ((e11) => {
          const t3 = a3(e11.object);
          if (null == t3)
            throw new n3("Cannot access property of null or undefined");
          return t3[e11.computed ? a3(e11.property) : e11.property.name];
        })(e9);
      case h3.CallExpression:
        return ((e11) => {
          const t3 = o3.functions[e11.callee.name];
          if (!t3)
            throw new n3(`Undefined function: ${e11.callee.name}`);
          return t3(...e11.arguments.map((e12) => a3(e12)));
        })(e9);
      case h3.BinaryExpression:
        return ((e11) => {
          if ("&&" === e11.operator) {
            const t4 = a3(e11.left);
            return t4 ? a3(e11.right) : t4;
          }
          if ("||" === e11.operator) {
            return a3(e11.left) || a3(e11.right);
          }
          const t3 = a3(e11.left), r6 = a3(e11.right);
          switch (e11.operator) {
            case "+":
              return t3 + r6;
            case "-":
              return t3 - r6;
            case "*":
              return t3 * r6;
            case "/":
              return t3 / r6;
            case "%":
              return t3 % r6;
            case "===":
              return t3 === r6;
            case "!==":
              return t3 !== r6;
            case ">":
              return t3 > r6;
            case ">=":
              return t3 >= r6;
            case "<":
              return t3 < r6;
            case "<=":
              return t3 <= r6;
            default:
              throw new n3(`Unknown operator: ${e11.operator}`);
          }
        })(e9);
      case h3.UnaryExpression:
        return ((e11) => {
          const t3 = a3(e11.argument);
          if (e11.prefix)
            switch (e11.operator) {
              case "!":
                return !t3;
              case "-":
                if ("number" != typeof t3)
                  throw new n3(`Cannot apply unary - to non-number: ${t3}`);
                return -t3;
              default:
                throw new n3(`Unknown operator: ${e11.operator}`);
            }
          throw new n3(`Postfix operators are not supported: ${e11.operator}`);
        })(e9);
      case h3.ConditionalExpression:
        return ((e11) => {
          const t3 = a3(e11.test);
          return a3(t3 ? e11.consequent : e11.alternate);
        })(e9);
      default:
        throw new n3(`Evaluation error: Unsupported node type: ${e9.type}`);
    }
  };
  return a3(e8.body);
};
function A3(t2) {
  const a3 = ((e8) => {
    const t3 = e8, a4 = t3.length, u5 = new Array(Math.ceil(a4 / 3));
    let h5 = 0, d3 = 0;
    function R3(e9) {
      const o3 = d3 + 1;
      d3++;
      let s3 = "", i4 = false;
      for (; d3 < a4; ) {
        const n4 = t3.charCodeAt(d3);
        if (n4 === e9)
          return i4 || (s3 = t3.substring(o3, d3)), d3++, { type: r4.STRING, value: s3 };
        92 === n4 ? (i4 || (s3 = t3.substring(o3, d3), i4 = true), d3++, s3 += t3[d3]) : i4 && (s3 += t3[d3]), d3++;
      }
      throw new n3(`Unterminated string starting with ${String.fromCharCode(e9)}`, d3, t3.substring(Math.max(0, d3 - 10), d3));
    }
    function T3() {
      const e9 = d3;
      for (45 === t3.charCodeAt(d3) && d3++; d3 < a4 && p6(t3.charCodeAt(d3)); )
        d3++;
      if (d3 < a4 && 46 === t3.charCodeAt(d3))
        for (d3++; d3 < a4 && p6(t3.charCodeAt(d3)); )
          d3++;
      const n4 = t3.slice(e9, d3);
      return { type: r4.NUMBER, value: n4 };
    }
    function w3() {
      d3++;
      const e9 = d3;
      if (d3 < a4 && l2(t3.charCodeAt(d3)))
        for (d3++; d3 < a4 && f4(t3.charCodeAt(d3)); )
          d3++;
      const n4 = t3.slice(e9, d3);
      return { type: r4.FUNCTION, value: n4 };
    }
    function y6() {
      const e9 = d3++;
      for (; d3 < a4 && f4(t3.charCodeAt(d3)); )
        d3++;
      const n4 = t3.slice(e9, d3), o3 = s2.get(n4);
      return o3 ? { type: o3, value: n4 } : { type: r4.IDENTIFIER, value: n4 };
    }
    function O3() {
      if (d3 + 2 < a4) {
        const e11 = t3.substring(d3, d3 + 3);
        if (i3.has(e11))
          return d3 += 3, { type: r4.OPERATOR, value: e11 };
      }
      if (d3 + 1 < a4) {
        const e11 = t3.substring(d3, d3 + 2);
        if (i3.has(e11))
          return d3 += 2, { type: r4.OPERATOR, value: e11 };
      }
      const e9 = t3[d3];
      if (i3.has(e9))
        return d3++, { type: r4.OPERATOR, value: e9 };
      throw new n3(`Unknown operator at position ${d3}: ${t3.substring(d3, d3 + 1)}`, d3, t3.substring(Math.max(0, d3 - 10), d3));
    }
    for (; d3 < a4; ) {
      const e9 = t3.charCodeAt(d3);
      if (A4 = e9, o2.has(A4)) {
        d3++;
        continue;
      }
      const r5 = c$2.get(e9);
      if (r5)
        u5[h5++] = r5, d3++;
      else if (34 !== e9 && 39 !== e9)
        if (p6(e9) || 45 === e9 && d3 + 1 < a4 && p6(t3.charCodeAt(d3 + 1)))
          u5[h5++] = T3();
        else if (64 !== e9)
          if (l2(e9))
            u5[h5++] = y6();
          else {
            if (!E2(e9))
              throw new n3(`Unexpected character: ${t3[d3]}`, d3, t3.substring(Math.max(0, d3 - 10), d3));
            u5[h5++] = O3();
          }
        else
          u5[h5++] = w3();
      else
        u5[h5++] = R3(e9);
    }
    var A4;
    return h5 === u5.length ? u5 : u5.slice(0, h5);
  })(t2), u4 = y$4(a3), h4 = ((e8 = {}, t3 = {}) => ({ context: e8, functions: t3 }))({}, e7);
  return (e8 = {}) => O2(u4, h4, e8);
}
function N2(e8, t2 = {}) {
  return A3(e8)(t2);
}

// node_modules/@antv/layout/lib/util/expr.js
function evaluateExpression(expression, context) {
  if (typeof expression !== "string")
    return void 0;
  const source = expression.trim();
  if (!source)
    return void 0;
  try {
    A3(source);
    return N2(source, context);
  } catch (_a) {
    return void 0;
  }
}

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/is-number.js
function isNumber2(value) {
  return typeof value === "number";
}

// node_modules/@antv/layout/lib/util/size.js
function parseSize(size) {
  if (!size)
    return [0, 0, 0];
  if (isNumber2(size))
    return [size, size, size];
  else if (Array.isArray(size) && size.length === 0)
    return [0, 0, 0];
  const [x6, y6 = x6, z2 = x6] = size;
  return [x6, y6, z2];
}
function isSize(value) {
  if (isNumber2(value))
    return true;
  if (Array.isArray(value)) {
    return value.every((item) => isNumber2(item));
  }
  return false;
}

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/is-nil.js
function isNil(value) {
  return value === null || value === void 0;
}

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/is-string.js
function isString(value) {
  return typeof value === "string";
}

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/is-function.js
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/@antv/layout/lib/util/format.js
function formatFn(value, argNames) {
  if (typeof value === "function")
    return value;
  if (typeof value === "string") {
    const expr = value;
    return (...argv) => {
      const ctx = {};
      for (let i4 = 0; i4 < argNames.length; i4++) {
        ctx[argNames[i4]] = argv[i4];
      }
      return evaluateExpression(expr, ctx);
    };
  }
  return () => value;
}
function formatNumberFn(value, defaultValue, type2 = "node") {
  if (isNil(value)) {
    return () => defaultValue;
  }
  if (isString(value)) {
    const numberFn = formatFn(value, [type2]);
    return (d3) => {
      const evaluated = numberFn(d3);
      if (isNumber2(evaluated))
        return evaluated;
      return defaultValue;
    };
  }
  if (isFunction2(value)) {
    return value;
  }
  if (isNumber2(value)) {
    return () => value;
  }
  return () => defaultValue;
}
function formatSizeFn(value, defaultValue = 10, type2 = "node") {
  if (isNil(value)) {
    return () => defaultValue;
  }
  if (isString(value)) {
    const sizeFn = formatFn(value, [type2]);
    return (d3) => {
      const evaluated = sizeFn(d3);
      if (isSize(evaluated))
        return evaluated;
      return defaultValue;
    };
  }
  if (isFunction2(value)) {
    return value;
  }
  if (isNumber2(value)) {
    return () => value;
  }
  if (Array.isArray(value)) {
    return () => value;
  }
  return () => defaultValue;
}

// node_modules/@antv/layout/lib/util/point.js
function parsePoint(point) {
  var _a;
  return [point.x, point.y, (_a = point.z) !== null && _a !== void 0 ? _a : 0];
}

// node_modules/@antv/layout/lib/model/data.js
var GraphLib = class {
  constructor(data, options = {}) {
    this.edgeIdCounter = /* @__PURE__ */ new Map();
    this.nodeMap = extractNodeData(data.nodes, options.node);
    this.edgeMap = extractEdgeData(data.edges || [], options.edge, this.getEdgeId.bind(this));
  }
  data() {
    return { nodes: this.nodeMap, edges: this.edgeMap };
  }
  replace(result) {
    this.nodeMap = result.nodes;
    this.edgeMap = result.edges;
    this.clearCache();
  }
  nodes() {
    return Array.from(this.nodeMap.values());
  }
  node(id2) {
    return this.nodeMap.get(id2);
  }
  nodeAt(index2) {
    if (!this.indexNodeCache) {
      this.buildNodeIndexCache();
    }
    const nodeId = this.indexNodeCache.get(index2);
    return nodeId ? this.nodeMap.get(nodeId) : void 0;
  }
  nodeIndexOf(id2) {
    var _a;
    if (!this.nodeIndexCache) {
      this.buildNodeIndexCache();
    }
    return (_a = this.nodeIndexCache.get(id2)) !== null && _a !== void 0 ? _a : -1;
  }
  firstNode() {
    return this.nodeMap.values().next().value;
  }
  forEachNode(callback) {
    let i4 = 0;
    this.nodeMap.forEach((node) => callback(node, i4++));
  }
  originalNode(id2) {
    const node = this.nodeMap.get(id2);
    return node === null || node === void 0 ? void 0 : node._original;
  }
  nodeCount() {
    return this.nodeMap.size;
  }
  edges() {
    return Array.from(this.edgeMap.values());
  }
  edge(id2) {
    return this.edgeMap.get(id2);
  }
  firstEdge() {
    return this.edgeMap.values().next().value;
  }
  forEachEdge(callback) {
    let i4 = 0;
    this.edgeMap.forEach((edge) => callback(edge, i4++));
  }
  originalEdge(id2) {
    const edge = this.edgeMap.get(id2);
    return edge === null || edge === void 0 ? void 0 : edge._original;
  }
  edgeCount() {
    return this.edgeMap.size;
  }
  getEdgeId(edge) {
    if (edge.id)
      return edge.id;
    const baseId = `${edge.source}-${edge.target}`;
    const count2 = this.edgeIdCounter.get(baseId) || 0;
    const id2 = count2 === 0 ? baseId : `${baseId}-${count2}`;
    this.edgeIdCounter.set(baseId, count2 + 1);
    return id2;
  }
  degree(nodeId, direction = "both") {
    if (!this.degreeCache) {
      this.buildDegreeCache();
    }
    const degree = this.degreeCache.get(nodeId);
    if (!degree)
      return 0;
    return degree[direction];
  }
  neighbors(nodeId, direction = "both") {
    if (!this.outAdjacencyCache || !this.inAdjacencyCache) {
      this.buildAdjacencyCache();
    }
    if (direction === "out") {
      return Array.from(this.outAdjacencyCache.get(nodeId) || []);
    }
    if (direction === "in") {
      return Array.from(this.inAdjacencyCache.get(nodeId) || []);
    }
    if (this.bothAdjacencyCache) {
      return Array.from(this.bothAdjacencyCache.get(nodeId) || []);
    }
    const inSet = this.inAdjacencyCache.get(nodeId);
    const outSet = this.outAdjacencyCache.get(nodeId);
    if (!inSet && !outSet)
      return [];
    if (!inSet)
      return Array.from(outSet);
    if (!outSet)
      return Array.from(inSet);
    const merged = /* @__PURE__ */ new Set();
    inSet.forEach((id2) => merged.add(id2));
    outSet.forEach((id2) => merged.add(id2));
    return Array.from(merged);
  }
  successors(nodeId) {
    return this.neighbors(nodeId, "out");
  }
  predecessors(nodeId) {
    return this.neighbors(nodeId, "in");
  }
  setNodeOrder(nodes) {
    const next = /* @__PURE__ */ new Map();
    for (const node of nodes)
      next.set(node.id, node);
    this.nodeMap = next;
    this.nodeIndexCache = void 0;
    this.indexNodeCache = void 0;
  }
  clearCache() {
    this.degreeCache = void 0;
    this.inAdjacencyCache = void 0;
    this.outAdjacencyCache = void 0;
    this.bothAdjacencyCache = void 0;
    this.nodeIndexCache = void 0;
    this.indexNodeCache = void 0;
  }
  buildDegreeCache() {
    this.degreeCache = /* @__PURE__ */ new Map();
    for (const edge of this.edges()) {
      const { source, target } = edge;
      if (edge.source === edge.target)
        continue;
      if (!this.degreeCache.has(source)) {
        this.degreeCache.set(source, { in: 0, out: 0, both: 0 });
      }
      const sourceDeg = this.degreeCache.get(edge.source);
      if (sourceDeg) {
        sourceDeg.out++;
        sourceDeg.both++;
      }
      if (!this.degreeCache.has(target)) {
        this.degreeCache.set(target, { in: 0, out: 0, both: 0 });
      }
      const targetDeg = this.degreeCache.get(edge.target);
      if (targetDeg) {
        targetDeg.in++;
        targetDeg.both++;
      }
    }
  }
  buildAdjacencyCache() {
    this.inAdjacencyCache = /* @__PURE__ */ new Map();
    this.outAdjacencyCache = /* @__PURE__ */ new Map();
    for (const edge of this.edges()) {
      if (!this.nodeMap.has(edge.source) || !this.nodeMap.has(edge.target))
        continue;
      if (!this.outAdjacencyCache.has(edge.source)) {
        this.outAdjacencyCache.set(edge.source, /* @__PURE__ */ new Set());
      }
      this.outAdjacencyCache.get(edge.source).add(edge.target);
      if (!this.inAdjacencyCache.has(edge.target)) {
        this.inAdjacencyCache.set(edge.target, /* @__PURE__ */ new Set());
      }
      this.inAdjacencyCache.get(edge.target).add(edge.source);
    }
  }
  buildNodeIndexCache() {
    this.nodeIndexCache = /* @__PURE__ */ new Map();
    this.indexNodeCache = /* @__PURE__ */ new Map();
    let index2 = 0;
    this.nodeMap.forEach((_node, nodeId) => {
      this.nodeIndexCache.set(nodeId, index2);
      this.indexNodeCache.set(index2, nodeId);
      index2++;
    });
  }
  destroy() {
    this.clearCache();
    this.nodeMap.clear();
    this.edgeMap.clear();
    this.edgeIdCounter.clear();
  }
};
var nodeFields = [
  "id",
  "x",
  "y",
  "z",
  "vx",
  "vy",
  "vz",
  "fx",
  "fy",
  "fz",
  "parentId"
];
var edgeFields = ["id", "source", "target", "points"];
function extractNodeData(nodes, node) {
  if (!nodes) {
    throw new Error("Data.nodes is required");
  }
  const result = /* @__PURE__ */ new Map();
  for (const datum2 of nodes) {
    const nodeData = { _original: datum2 };
    for (const field of nodeFields) {
      const value = datum2[field];
      if (isNil(value))
        continue;
      nodeData[field] = value;
    }
    if (node) {
      const customFields = node(datum2);
      for (const key in customFields) {
        const value = customFields[key];
        if (isNil(value))
          continue;
        nodeData[key] = value;
      }
    }
    if (isNil(nodeData.id)) {
      throw new Error(`Node is missing id field`);
    }
    result.set(nodeData.id, nodeData);
  }
  return result;
}
function extractEdgeData(edges, edge, getEdgeId) {
  const result = /* @__PURE__ */ new Map();
  for (const datum2 of edges) {
    const edgeData = { _original: datum2 };
    for (const field of edgeFields) {
      const value = datum2[field];
      if (isNil(value))
        continue;
      edgeData[field] = value;
    }
    if (edge) {
      const customFields = edge(datum2);
      for (const key in customFields) {
        const value = customFields[key];
        if (isNil(value))
          continue;
        edgeData[key] = value;
      }
    }
    if (isNil(edgeData.source) || isNil(edgeData.target)) {
      throw new Error(`Edge is missing source or target field`);
    }
    if (isNil(edgeData.id)) {
      edgeData.id = getEdgeId === null || getEdgeId === void 0 ? void 0 : getEdgeId(datum2);
    }
    result.set(edgeData.id, edgeData);
  }
  return result;
}

// node_modules/@antv/layout/lib/runtime/context.js
var RuntimeContext = class {
  constructor(data, options = {}) {
    this.graph = new GraphLib(data, options);
  }
  export() {
    return this.graph.data();
  }
  replace(result) {
    this.graph.replace(result);
  }
  forEachNode(callback) {
    this.graph.forEachNode(callback);
  }
  forEachEdge(callback) {
    this.graph.forEachEdge((edge, i4) => {
      edge.sourceNode = this.graph.node(edge.source);
      edge.targetNode = this.graph.node(edge.target);
      callback(edge, i4);
    });
  }
  destroy() {
    this.graph.destroy();
  }
};

// node_modules/@antv/layout/lib/node_modules/comlink/dist/esm/comlink.js
var proxyMarker = Symbol("Comlink.proxy");
var createEndpoint = Symbol("Comlink.endpoint");
var releaseProxy = Symbol("Comlink.releaseProxy");
var finalizer = Symbol("Comlink.finalizer");
var throwMarker = Symbol("Comlink.thrown");
var isObject2 = (val) => typeof val === "object" && val !== null || typeof val === "function";
var proxyTransferHandler = {
  canHandle: (val) => isObject2(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap(port);
  }
};
var throwTransferHandler = {
  canHandle: (value) => isObject2(value) && throwMarker in value,
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack
        }
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
var transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id: id2, type: type2, path: path2 } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path2.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
      const rawValue = path2.reduce((obj2, prop) => obj2[prop], obj);
      switch (type2) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path2.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer3(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value) => {
      return { value, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
      if (type2 === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
        if (finalizer in obj && typeof obj[finalizer] === "function") {
          obj[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap(ep, target) {
  const pendingListeners = /* @__PURE__ */ new Map();
  ep.addEventListener("message", function handleMessage(ev) {
    const { data } = ev;
    if (!data || !data.id) {
      return;
    }
    const resolver = pendingListeners.get(data.id);
    if (!resolver) {
      return;
    }
    try {
      resolver(data);
    } finally {
      pendingListeners.delete(data.id);
    }
  });
  return createProxy(ep, pendingListeners, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, /* @__PURE__ */ new Map(), {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep);
  });
}
var proxyCounter = /* @__PURE__ */ new WeakMap();
var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
  const newCount = (proxyCounter.get(ep) || 0) - 1;
  proxyCounter.set(ep, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep);
  }
});
function registerProxy(proxy2, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep, pendingListeners, path2 = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep);
          pendingListeners.clear();
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path2.length === 0) {
          return { then: () => proxy2 };
        }
        const r5 = requestResponseMessage(ep, pendingListeners, {
          type: "GET",
          path: path2.map((p7) => p7.toString())
        }).then(fromWireValue);
        return r5.then.bind(r5);
      }
      return createProxy(ep, pendingListeners, [...path2, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, pendingListeners, {
        type: "SET",
        path: [...path2, prop].map((p7) => p7.toString()),
        value
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path2[path2.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep, pendingListeners, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep, pendingListeners, path2.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "APPLY",
        path: path2.map((p7) => p7.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "CONSTRUCT",
        path: path2.map((p7) => p7.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v2) => v2[0]), myFlat(processed.map((v2) => v2[1]))];
}
var transferCache = /* @__PURE__ */ new WeakMap();
function transfer3(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value)) {
      const [serializedValue, transferables] = handler.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value
    },
    transferCache.get(value) || []
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, pendingListeners, msg, transfers) {
  return new Promise((resolve) => {
    const id2 = generateUUID();
    pendingListeners.set(id2, resolve);
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id: id2 }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}

// node_modules/@antv/layout/lib/runtime/supervisor.js
var Supervisor = class {
  constructor() {
    this.worker = null;
    this.workerApi = null;
  }
  /**
   * Execute layout in worker
   */
  execute(layoutId, data, options) {
    return __awaiter7(this, void 0, void 0, function* () {
      if (!this.worker) {
        yield this.initWorker();
      }
      if (!this.workerApi) {
        throw new Error("Worker API not initialized");
      }
      return yield this.workerApi.execute(layoutId, data, options);
    });
  }
  /**
   * Destroy worker
   */
  destroy() {
    if (this.workerApi) {
      this.workerApi.destroy();
    }
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
      this.workerApi = null;
    }
  }
  /**
   * Initialize worker
   */
  initWorker() {
    return __awaiter7(this, void 0, void 0, function* () {
      const workerPath = this.resolveWorkerPath();
      const isESM = workerPath.includes("/lib/") || workerPath.endsWith(".mjs");
      const type2 = isESM ? "module" : "classic";
      this.worker = new Worker(workerPath, { type: type2 });
      this.workerApi = wrap(this.worker);
    });
  }
  /**
   * Resolve worker script path which works in both ESM and UMD environments
   */
  resolveWorkerPath() {
    const scriptUrl = (() => {
      if (typeof document === "undefined")
        return null;
      const currentScript = document.currentScript;
      if (currentScript === null || currentScript === void 0 ? void 0 : currentScript.src)
        return currentScript.src;
      const scripts = document.getElementsByTagName("script");
      for (let i4 = scripts.length - 1; i4 >= 0; i4--) {
        const src = scripts[i4].src;
        if (!src)
          continue;
        if (src.includes("index.js") || src.includes("index.min.js")) {
          return src;
        }
      }
      return null;
    })();
    if (scriptUrl) {
      if (scriptUrl.includes("index.js") || scriptUrl.includes("index.min.js")) {
        const asIndex = scriptUrl.replace(/index(\.min)?\.(m?js)(\?.*)?$/, "worker.js");
        if (asIndex !== scriptUrl)
          return asIndex;
      }
      const asRoot = scriptUrl.replace(/\/runtime\/[^/]+\.(m?js)(\?.*)?$/, "/worker.js");
      if (asRoot !== scriptUrl)
        return asRoot;
      const asSibling = scriptUrl.replace(/\/[^/]+\.(m?js)(\?.*)?$/, "/worker.js");
      if (asSibling !== scriptUrl)
        return asSibling;
    }
    return "./worker.js";
  }
};

// node_modules/@antv/layout/lib/algorithm/base-layout.js
var BaseLayout = class {
  constructor(options) {
    this.supervisor = null;
    this.initialOptions = this.mergeOptions(this.getDefaultOptions(), options);
  }
  get options() {
    return this.runtimeOptions || this.initialOptions;
  }
  mergeOptions(base, patch) {
    return Object.assign({}, base, patch || {});
  }
  execute(data, userOptions) {
    return __awaiter7(this, void 0, void 0, function* () {
      this.runtimeOptions = this.mergeOptions(this.initialOptions, userOptions);
      const { node, edge, enableWorker } = this.runtimeOptions;
      this.context = new RuntimeContext(data, { node, edge });
      this.model = this.context.graph;
      const shouldUseWorker = enableWorker && typeof Worker !== "undefined";
      if (shouldUseWorker) {
        yield this.layoutInWorker(data, this.runtimeOptions);
      } else {
        yield this.layout(this.runtimeOptions);
      }
    });
  }
  layoutInWorker(data, options) {
    var _a;
    return __awaiter7(this, void 0, void 0, function* () {
      try {
        if (!this.supervisor) {
          this.supervisor = new Supervisor();
        }
        const result = yield this.supervisor.execute(this.id, data, options);
        (_a = this.context) === null || _a === void 0 ? void 0 : _a.replace(result);
      } catch (error) {
        console.error("Layout in worker failed, fallback to main thread layout.", error);
        yield this.layout(options);
      }
    });
  }
  forEachNode(callback) {
    this.context.forEachNode(callback);
  }
  forEachEdge(callback) {
    this.context.forEachEdge(callback);
  }
  destroy() {
    var _a;
    (_a = this.context) === null || _a === void 0 ? void 0 : _a.destroy();
    this.model = null;
    this.context = null;
    if (this.supervisor) {
      this.supervisor.destroy();
      this.supervisor = null;
    }
  }
};

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/is-array.js
function isArray$1(value) {
  return Array.isArray(value);
}

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/is-object.js
var isObject$1 = function(value) {
  var type2 = typeof value;
  return value !== null && type2 === "object" || type2 === "function";
};

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/is-object-like.js
var isObjectLike2 = function(value) {
  return typeof value === "object" && value !== null;
};

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/is-type.js
var toString$2 = {}.toString;
var isType = function(value, type2) {
  return toString$2.call(value) === "[object " + type2 + "]";
};

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/is-plain-object.js
var isPlainObject2 = function(value) {
  if (!isObjectLike2(value) || !isType(value, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  var proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
};

// node_modules/@antv/layout/lib/_virtual/_commonjsHelpers.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x6) {
  return x6 && x6.__esModule && Object.prototype.hasOwnProperty.call(x6, "default") ? x6["default"] : x6;
}

// node_modules/@antv/layout/lib/_virtual/_commonjs-dynamic-modules.js
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

// node_modules/@antv/layout/lib/node_modules/lodash/_listCacheClear.js
var _listCacheClear;
var hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear)
    return _listCacheClear;
  hasRequired_listCacheClear = 1;
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  _listCacheClear = listCacheClear2;
  return _listCacheClear;
}

// node_modules/@antv/layout/lib/node_modules/lodash/eq.js
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq)
    return eq_1;
  hasRequiredEq = 1;
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1 = eq2;
  return eq_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_assocIndexOf.js
var _assocIndexOf;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf)
    return _assocIndexOf;
  hasRequired_assocIndexOf = 1;
  var eq2 = requireEq();
  function assocIndexOf2(array3, key) {
    var length = array3.length;
    while (length--) {
      if (eq2(array3[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  _assocIndexOf = assocIndexOf2;
  return _assocIndexOf;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_listCacheDelete.js
var _listCacheDelete;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete)
    return _listCacheDelete;
  hasRequired_listCacheDelete = 1;
  var assocIndexOf2 = require_assocIndexOf();
  var arrayProto2 = Array.prototype;
  var splice2 = arrayProto2.splice;
  function listCacheDelete2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  _listCacheDelete = listCacheDelete2;
  return _listCacheDelete;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_listCacheGet.js
var _listCacheGet;
var hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet)
    return _listCacheGet;
  hasRequired_listCacheGet = 1;
  var assocIndexOf2 = require_assocIndexOf();
  function listCacheGet2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  _listCacheGet = listCacheGet2;
  return _listCacheGet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_listCacheHas.js
var _listCacheHas;
var hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas)
    return _listCacheHas;
  hasRequired_listCacheHas = 1;
  var assocIndexOf2 = require_assocIndexOf();
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  _listCacheHas = listCacheHas2;
  return _listCacheHas;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_listCacheSet.js
var _listCacheSet;
var hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet)
    return _listCacheSet;
  hasRequired_listCacheSet = 1;
  var assocIndexOf2 = require_assocIndexOf();
  function listCacheSet2(key, value) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  _listCacheSet = listCacheSet2;
  return _listCacheSet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_ListCache.js
var _ListCache;
var hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache)
    return _ListCache;
  hasRequired_ListCache = 1;
  var listCacheClear2 = require_listCacheClear(), listCacheDelete2 = require_listCacheDelete(), listCacheGet2 = require_listCacheGet(), listCacheHas2 = require_listCacheHas(), listCacheSet2 = require_listCacheSet();
  function ListCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  _ListCache = ListCache2;
  return _ListCache;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_stackClear.js
var _stackClear;
var hasRequired_stackClear;
function require_stackClear() {
  if (hasRequired_stackClear)
    return _stackClear;
  hasRequired_stackClear = 1;
  var ListCache2 = require_ListCache();
  function stackClear2() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  _stackClear = stackClear2;
  return _stackClear;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_stackDelete.js
var _stackDelete;
var hasRequired_stackDelete;
function require_stackDelete() {
  if (hasRequired_stackDelete)
    return _stackDelete;
  hasRequired_stackDelete = 1;
  function stackDelete2(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  _stackDelete = stackDelete2;
  return _stackDelete;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_stackGet.js
var _stackGet;
var hasRequired_stackGet;
function require_stackGet() {
  if (hasRequired_stackGet)
    return _stackGet;
  hasRequired_stackGet = 1;
  function stackGet2(key) {
    return this.__data__.get(key);
  }
  _stackGet = stackGet2;
  return _stackGet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_stackHas.js
var _stackHas;
var hasRequired_stackHas;
function require_stackHas() {
  if (hasRequired_stackHas)
    return _stackHas;
  hasRequired_stackHas = 1;
  function stackHas2(key) {
    return this.__data__.has(key);
  }
  _stackHas = stackHas2;
  return _stackHas;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_freeGlobal.js
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal)
    return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  _freeGlobal = freeGlobal2;
  return _freeGlobal;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_root.js
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root)
    return _root;
  hasRequired_root = 1;
  var freeGlobal2 = require_freeGlobal();
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root4 = freeGlobal2 || freeSelf2 || Function("return this")();
  _root = root4;
  return _root;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_Symbol.js
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol)
    return _Symbol;
  hasRequired_Symbol = 1;
  var root4 = require_root();
  var Symbol3 = root4.Symbol;
  _Symbol = Symbol3;
  return _Symbol;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_getRawTag.js
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag)
    return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol3 = require_Symbol();
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  var nativeObjectToString3 = objectProto15.toString;
  var symToStringTag3 = Symbol3 ? Symbol3.toStringTag : void 0;
  function getRawTag2(value) {
    var isOwn = hasOwnProperty13.call(value, symToStringTag3), tag = value[symToStringTag3];
    try {
      value[symToStringTag3] = void 0;
      var unmasked = true;
    } catch (e8) {
    }
    var result = nativeObjectToString3.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag3] = tag;
      } else {
        delete value[symToStringTag3];
      }
    }
    return result;
  }
  _getRawTag = getRawTag2;
  return _getRawTag;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_objectToString.js
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString)
    return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto15 = Object.prototype;
  var nativeObjectToString3 = objectProto15.toString;
  function objectToString2(value) {
    return nativeObjectToString3.call(value);
  }
  _objectToString = objectToString2;
  return _objectToString;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseGetTag.js
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag)
    return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol3 = require_Symbol(), getRawTag2 = require_getRawTag(), objectToString2 = require_objectToString();
  var nullTag2 = "[object Null]", undefinedTag2 = "[object Undefined]";
  var symToStringTag3 = Symbol3 ? Symbol3.toStringTag : void 0;
  function baseGetTag2(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag2 : nullTag2;
    }
    return symToStringTag3 && symToStringTag3 in Object(value) ? getRawTag2(value) : objectToString2(value);
  }
  _baseGetTag = baseGetTag2;
  return _baseGetTag;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isObject.js
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject)
    return isObject_1;
  hasRequiredIsObject = 1;
  function isObject3(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  isObject_1 = isObject3;
  return isObject_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isFunction.js
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction)
    return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag2 = require_baseGetTag(), isObject3 = requireIsObject();
  var asyncTag2 = "[object AsyncFunction]", funcTag4 = "[object Function]", genTag3 = "[object GeneratorFunction]", proxyTag2 = "[object Proxy]";
  function isFunction3(value) {
    if (!isObject3(value)) {
      return false;
    }
    var tag = baseGetTag2(value);
    return tag == funcTag4 || tag == genTag3 || tag == asyncTag2 || tag == proxyTag2;
  }
  isFunction_1 = isFunction3;
  return isFunction_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_coreJsData.js
var _coreJsData;
var hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData)
    return _coreJsData;
  hasRequired_coreJsData = 1;
  var root4 = require_root();
  var coreJsData2 = root4["__core-js_shared__"];
  _coreJsData = coreJsData2;
  return _coreJsData;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_isMasked.js
var _isMasked;
var hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked)
    return _isMasked;
  hasRequired_isMasked = 1;
  var coreJsData2 = require_coreJsData();
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  _isMasked = isMasked2;
  return _isMasked;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_toSource.js
var _toSource;
var hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource)
    return _toSource;
  hasRequired_toSource = 1;
  var funcProto4 = Function.prototype;
  var funcToString4 = funcProto4.toString;
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString4.call(func);
      } catch (e8) {
      }
      try {
        return func + "";
      } catch (e8) {
      }
    }
    return "";
  }
  _toSource = toSource2;
  return _toSource;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseIsNative.js
var _baseIsNative;
var hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative)
    return _baseIsNative;
  hasRequired_baseIsNative = 1;
  var isFunction3 = requireIsFunction(), isMasked2 = require_isMasked(), isObject3 = requireIsObject(), toSource2 = require_toSource();
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var funcProto4 = Function.prototype, objectProto15 = Object.prototype;
  var funcToString4 = funcProto4.toString;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  var reIsNative2 = RegExp(
    "^" + funcToString4.call(hasOwnProperty13).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative2(value) {
    if (!isObject3(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction3(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  _baseIsNative = baseIsNative2;
  return _baseIsNative;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_getValue.js
var _getValue;
var hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue)
    return _getValue;
  hasRequired_getValue = 1;
  function getValue2(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  _getValue = getValue2;
  return _getValue;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_getNative.js
var _getNative;
var hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative)
    return _getNative;
  hasRequired_getNative = 1;
  var baseIsNative2 = require_baseIsNative(), getValue2 = require_getValue();
  function getNative2(object2, key) {
    var value = getValue2(object2, key);
    return baseIsNative2(value) ? value : void 0;
  }
  _getNative = getNative2;
  return _getNative;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_Map.js
var _Map;
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map)
    return _Map;
  hasRequired_Map = 1;
  var getNative2 = require_getNative(), root4 = require_root();
  var Map3 = getNative2(root4, "Map");
  _Map = Map3;
  return _Map;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_nativeCreate.js
var _nativeCreate;
var hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate)
    return _nativeCreate;
  hasRequired_nativeCreate = 1;
  var getNative2 = require_getNative();
  var nativeCreate2 = getNative2(Object, "create");
  _nativeCreate = nativeCreate2;
  return _nativeCreate;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_hashClear.js
var _hashClear;
var hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear)
    return _hashClear;
  hasRequired_hashClear = 1;
  var nativeCreate2 = require_nativeCreate();
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  _hashClear = hashClear2;
  return _hashClear;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_hashDelete.js
var _hashDelete;
var hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete)
    return _hashDelete;
  hasRequired_hashDelete = 1;
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  _hashDelete = hashDelete2;
  return _hashDelete;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_hashGet.js
var _hashGet;
var hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet)
    return _hashGet;
  hasRequired_hashGet = 1;
  var nativeCreate2 = require_nativeCreate();
  var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED3 ? void 0 : result;
    }
    return hasOwnProperty13.call(data, key) ? data[key] : void 0;
  }
  _hashGet = hashGet2;
  return _hashGet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_hashHas.js
var _hashHas;
var hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas)
    return _hashHas;
  hasRequired_hashHas = 1;
  var nativeCreate2 = require_nativeCreate();
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty13.call(data, key);
  }
  _hashHas = hashHas2;
  return _hashHas;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_hashSet.js
var _hashSet;
var hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet)
    return _hashSet;
  hasRequired_hashSet = 1;
  var nativeCreate2 = require_nativeCreate();
  var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
  function hashSet2(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED3 : value;
    return this;
  }
  _hashSet = hashSet2;
  return _hashSet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_Hash.js
var _Hash;
var hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash)
    return _Hash;
  hasRequired_Hash = 1;
  var hashClear2 = require_hashClear(), hashDelete2 = require_hashDelete(), hashGet2 = require_hashGet(), hashHas2 = require_hashHas(), hashSet2 = require_hashSet();
  function Hash2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  _Hash = Hash2;
  return _Hash;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_mapCacheClear.js
var _mapCacheClear;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear)
    return _mapCacheClear;
  hasRequired_mapCacheClear = 1;
  var Hash2 = require_Hash(), ListCache2 = require_ListCache(), Map3 = require_Map();
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map3 || ListCache2)(),
      "string": new Hash2()
    };
  }
  _mapCacheClear = mapCacheClear2;
  return _mapCacheClear;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_isKeyable.js
var _isKeyable;
var hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable)
    return _isKeyable;
  hasRequired_isKeyable = 1;
  function isKeyable2(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  _isKeyable = isKeyable2;
  return _isKeyable;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_getMapData.js
var _getMapData;
var hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData)
    return _getMapData;
  hasRequired_getMapData = 1;
  var isKeyable2 = require_isKeyable();
  function getMapData2(map2, key) {
    var data = map2.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  _getMapData = getMapData2;
  return _getMapData;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_mapCacheDelete.js
var _mapCacheDelete;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete)
    return _mapCacheDelete;
  hasRequired_mapCacheDelete = 1;
  var getMapData2 = require_getMapData();
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  _mapCacheDelete = mapCacheDelete2;
  return _mapCacheDelete;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_mapCacheGet.js
var _mapCacheGet;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet)
    return _mapCacheGet;
  hasRequired_mapCacheGet = 1;
  var getMapData2 = require_getMapData();
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  _mapCacheGet = mapCacheGet2;
  return _mapCacheGet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_mapCacheHas.js
var _mapCacheHas;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas)
    return _mapCacheHas;
  hasRequired_mapCacheHas = 1;
  var getMapData2 = require_getMapData();
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  _mapCacheHas = mapCacheHas2;
  return _mapCacheHas;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_mapCacheSet.js
var _mapCacheSet;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet)
    return _mapCacheSet;
  hasRequired_mapCacheSet = 1;
  var getMapData2 = require_getMapData();
  function mapCacheSet2(key, value) {
    var data = getMapData2(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  _mapCacheSet = mapCacheSet2;
  return _mapCacheSet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_MapCache.js
var _MapCache;
var hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache)
    return _MapCache;
  hasRequired_MapCache = 1;
  var mapCacheClear2 = require_mapCacheClear(), mapCacheDelete2 = require_mapCacheDelete(), mapCacheGet2 = require_mapCacheGet(), mapCacheHas2 = require_mapCacheHas(), mapCacheSet2 = require_mapCacheSet();
  function MapCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  _MapCache = MapCache2;
  return _MapCache;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_stackSet.js
var _stackSet;
var hasRequired_stackSet;
function require_stackSet() {
  if (hasRequired_stackSet)
    return _stackSet;
  hasRequired_stackSet = 1;
  var ListCache2 = require_ListCache(), Map3 = require_Map(), MapCache2 = require_MapCache();
  var LARGE_ARRAY_SIZE2 = 200;
  function stackSet2(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache2) {
      var pairs = data.__data__;
      if (!Map3 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache2(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  _stackSet = stackSet2;
  return _stackSet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_Stack.js
var _Stack;
var hasRequired_Stack;
function require_Stack() {
  if (hasRequired_Stack)
    return _Stack;
  hasRequired_Stack = 1;
  var ListCache2 = require_ListCache(), stackClear2 = require_stackClear(), stackDelete2 = require_stackDelete(), stackGet2 = require_stackGet(), stackHas2 = require_stackHas(), stackSet2 = require_stackSet();
  function Stack2(entries) {
    var data = this.__data__ = new ListCache2(entries);
    this.size = data.size;
  }
  Stack2.prototype.clear = stackClear2;
  Stack2.prototype["delete"] = stackDelete2;
  Stack2.prototype.get = stackGet2;
  Stack2.prototype.has = stackHas2;
  Stack2.prototype.set = stackSet2;
  _Stack = Stack2;
  return _Stack;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_arrayEach.js
var _arrayEach;
var hasRequired_arrayEach;
function require_arrayEach() {
  if (hasRequired_arrayEach)
    return _arrayEach;
  hasRequired_arrayEach = 1;
  function arrayEach2(array3, iteratee) {
    var index2 = -1, length = array3 == null ? 0 : array3.length;
    while (++index2 < length) {
      if (iteratee(array3[index2], index2, array3) === false) {
        break;
      }
    }
    return array3;
  }
  _arrayEach = arrayEach2;
  return _arrayEach;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_defineProperty.js
var _defineProperty;
var hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty)
    return _defineProperty;
  hasRequired_defineProperty = 1;
  var getNative2 = require_getNative();
  var defineProperty2 = function() {
    try {
      var func = getNative2(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e8) {
    }
  }();
  _defineProperty = defineProperty2;
  return _defineProperty;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseAssignValue.js
var _baseAssignValue;
var hasRequired_baseAssignValue;
function require_baseAssignValue() {
  if (hasRequired_baseAssignValue)
    return _baseAssignValue;
  hasRequired_baseAssignValue = 1;
  var defineProperty2 = require_defineProperty();
  function baseAssignValue2(object2, key, value) {
    if (key == "__proto__" && defineProperty2) {
      defineProperty2(object2, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object2[key] = value;
    }
  }
  _baseAssignValue = baseAssignValue2;
  return _baseAssignValue;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_assignValue.js
var _assignValue;
var hasRequired_assignValue;
function require_assignValue() {
  if (hasRequired_assignValue)
    return _assignValue;
  hasRequired_assignValue = 1;
  var baseAssignValue2 = require_baseAssignValue(), eq2 = requireEq();
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  function assignValue2(object2, key, value) {
    var objValue = object2[key];
    if (!(hasOwnProperty13.call(object2, key) && eq2(objValue, value)) || value === void 0 && !(key in object2)) {
      baseAssignValue2(object2, key, value);
    }
  }
  _assignValue = assignValue2;
  return _assignValue;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_copyObject.js
var _copyObject;
var hasRequired_copyObject;
function require_copyObject() {
  if (hasRequired_copyObject)
    return _copyObject;
  hasRequired_copyObject = 1;
  var assignValue2 = require_assignValue(), baseAssignValue2 = require_baseAssignValue();
  function copyObject2(source, props, object2, customizer) {
    var isNew = !object2;
    object2 || (object2 = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key = props[index2];
      var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue2(object2, key, newValue);
      } else {
        assignValue2(object2, key, newValue);
      }
    }
    return object2;
  }
  _copyObject = copyObject2;
  return _copyObject;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseTimes.js
var _baseTimes;
var hasRequired_baseTimes;
function require_baseTimes() {
  if (hasRequired_baseTimes)
    return _baseTimes;
  hasRequired_baseTimes = 1;
  function baseTimes2(n4, iteratee) {
    var index2 = -1, result = Array(n4);
    while (++index2 < n4) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  _baseTimes = baseTimes2;
  return _baseTimes;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isObjectLike.js
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike)
    return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike3(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike3;
  return isObjectLike_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseIsArguments.js
var _baseIsArguments;
var hasRequired_baseIsArguments;
function require_baseIsArguments() {
  if (hasRequired_baseIsArguments)
    return _baseIsArguments;
  hasRequired_baseIsArguments = 1;
  var baseGetTag2 = require_baseGetTag(), isObjectLike3 = requireIsObjectLike();
  var argsTag4 = "[object Arguments]";
  function baseIsArguments2(value) {
    return isObjectLike3(value) && baseGetTag2(value) == argsTag4;
  }
  _baseIsArguments = baseIsArguments2;
  return _baseIsArguments;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isArguments.js
var isArguments_1;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments_1;
  hasRequiredIsArguments = 1;
  var baseIsArguments2 = require_baseIsArguments(), isObjectLike3 = requireIsObjectLike();
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  var propertyIsEnumerable3 = objectProto15.propertyIsEnumerable;
  var isArguments2 = baseIsArguments2(function() {
    return arguments;
  }()) ? baseIsArguments2 : function(value) {
    return isObjectLike3(value) && hasOwnProperty13.call(value, "callee") && !propertyIsEnumerable3.call(value, "callee");
  };
  isArguments_1 = isArguments2;
  return isArguments_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isArray.js
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray)
    return isArray_1;
  hasRequiredIsArray = 1;
  var isArray2 = Array.isArray;
  isArray_1 = isArray2;
  return isArray_1;
}

// node_modules/@antv/layout/lib/_virtual/isBuffer.js
var isBuffer2 = { exports: {} };

// node_modules/@antv/layout/lib/node_modules/lodash/stubFalse.js
var stubFalse_1;
var hasRequiredStubFalse;
function requireStubFalse() {
  if (hasRequiredStubFalse)
    return stubFalse_1;
  hasRequiredStubFalse = 1;
  function stubFalse2() {
    return false;
  }
  stubFalse_1 = stubFalse2;
  return stubFalse_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isBuffer.js
isBuffer2.exports;
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer)
    return isBuffer2.exports;
  hasRequiredIsBuffer = 1;
  (function(module2, exports$1) {
    var root4 = require_root(), stubFalse2 = requireStubFalse();
    var freeExports4 = exports$1 && !exports$1.nodeType && exports$1;
    var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
    var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
    var Buffer4 = moduleExports4 ? root4.Buffer : void 0;
    var nativeIsBuffer2 = Buffer4 ? Buffer4.isBuffer : void 0;
    var isBuffer3 = nativeIsBuffer2 || stubFalse2;
    module2.exports = isBuffer3;
  })(isBuffer2, isBuffer2.exports);
  return isBuffer2.exports;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_isIndex.js
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex)
    return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER3 = 9007199254740991;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  function isIndex2(value, length) {
    var type2 = typeof value;
    length = length == null ? MAX_SAFE_INTEGER3 : length;
    return !!length && (type2 == "number" || type2 != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  _isIndex = isIndex2;
  return _isIndex;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isLength.js
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength)
    return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER3 = 9007199254740991;
  function isLength2(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
  }
  isLength_1 = isLength2;
  return isLength_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseIsTypedArray.js
var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
  if (hasRequired_baseIsTypedArray)
    return _baseIsTypedArray;
  hasRequired_baseIsTypedArray = 1;
  var baseGetTag2 = require_baseGetTag(), isLength2 = requireIsLength(), isObjectLike3 = requireIsObjectLike();
  var argsTag4 = "[object Arguments]", arrayTag3 = "[object Array]", boolTag4 = "[object Boolean]", dateTag4 = "[object Date]", errorTag3 = "[object Error]", funcTag4 = "[object Function]", mapTag6 = "[object Map]", numberTag4 = "[object Number]", objectTag5 = "[object Object]", regexpTag4 = "[object RegExp]", setTag6 = "[object Set]", stringTag4 = "[object String]", weakMapTag4 = "[object WeakMap]";
  var arrayBufferTag4 = "[object ArrayBuffer]", dataViewTag5 = "[object DataView]", float32Tag4 = "[object Float32Array]", float64Tag4 = "[object Float64Array]", int8Tag4 = "[object Int8Array]", int16Tag4 = "[object Int16Array]", int32Tag4 = "[object Int32Array]", uint8Tag4 = "[object Uint8Array]", uint8ClampedTag4 = "[object Uint8ClampedArray]", uint16Tag4 = "[object Uint16Array]", uint32Tag4 = "[object Uint32Array]";
  var typedArrayTags2 = {};
  typedArrayTags2[float32Tag4] = typedArrayTags2[float64Tag4] = typedArrayTags2[int8Tag4] = typedArrayTags2[int16Tag4] = typedArrayTags2[int32Tag4] = typedArrayTags2[uint8Tag4] = typedArrayTags2[uint8ClampedTag4] = typedArrayTags2[uint16Tag4] = typedArrayTags2[uint32Tag4] = true;
  typedArrayTags2[argsTag4] = typedArrayTags2[arrayTag3] = typedArrayTags2[arrayBufferTag4] = typedArrayTags2[boolTag4] = typedArrayTags2[dataViewTag5] = typedArrayTags2[dateTag4] = typedArrayTags2[errorTag3] = typedArrayTags2[funcTag4] = typedArrayTags2[mapTag6] = typedArrayTags2[numberTag4] = typedArrayTags2[objectTag5] = typedArrayTags2[regexpTag4] = typedArrayTags2[setTag6] = typedArrayTags2[stringTag4] = typedArrayTags2[weakMapTag4] = false;
  function baseIsTypedArray2(value) {
    return isObjectLike3(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
  }
  _baseIsTypedArray = baseIsTypedArray2;
  return _baseIsTypedArray;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseUnary.js
var _baseUnary;
var hasRequired_baseUnary;
function require_baseUnary() {
  if (hasRequired_baseUnary)
    return _baseUnary;
  hasRequired_baseUnary = 1;
  function baseUnary2(func) {
    return function(value) {
      return func(value);
    };
  }
  _baseUnary = baseUnary2;
  return _baseUnary;
}

// node_modules/@antv/layout/lib/_virtual/_nodeUtil.js
var _nodeUtil = { exports: {} };

// node_modules/@antv/layout/lib/node_modules/lodash/_nodeUtil.js
_nodeUtil.exports;
var hasRequired_nodeUtil;
function require_nodeUtil() {
  if (hasRequired_nodeUtil)
    return _nodeUtil.exports;
  hasRequired_nodeUtil = 1;
  (function(module2, exports$1) {
    var freeGlobal2 = require_freeGlobal();
    var freeExports4 = exports$1 && !exports$1.nodeType && exports$1;
    var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
    var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
    var freeProcess2 = moduleExports4 && freeGlobal2.process;
    var nodeUtil2 = function() {
      try {
        var types = freeModule4 && freeModule4.require && freeModule4.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
      } catch (e8) {
      }
    }();
    module2.exports = nodeUtil2;
  })(_nodeUtil, _nodeUtil.exports);
  return _nodeUtil.exports;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isTypedArray.js
var isTypedArray_1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray_1;
  hasRequiredIsTypedArray = 1;
  var baseIsTypedArray2 = require_baseIsTypedArray(), baseUnary2 = require_baseUnary(), nodeUtil2 = require_nodeUtil();
  var nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
  var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
  isTypedArray_1 = isTypedArray2;
  return isTypedArray_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_arrayLikeKeys.js
var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
  if (hasRequired_arrayLikeKeys)
    return _arrayLikeKeys;
  hasRequired_arrayLikeKeys = 1;
  var baseTimes2 = require_baseTimes(), isArguments2 = requireIsArguments(), isArray2 = requireIsArray(), isBuffer3 = requireIsBuffer(), isIndex2 = require_isIndex(), isTypedArray2 = requireIsTypedArray();
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  function arrayLikeKeys2(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer3(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes2(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty13.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex2(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  _arrayLikeKeys = arrayLikeKeys2;
  return _arrayLikeKeys;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_isPrototype.js
var _isPrototype;
var hasRequired_isPrototype;
function require_isPrototype() {
  if (hasRequired_isPrototype)
    return _isPrototype;
  hasRequired_isPrototype = 1;
  var objectProto15 = Object.prototype;
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto15;
    return value === proto;
  }
  _isPrototype = isPrototype2;
  return _isPrototype;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_overArg.js
var _overArg;
var hasRequired_overArg;
function require_overArg() {
  if (hasRequired_overArg)
    return _overArg;
  hasRequired_overArg = 1;
  function overArg2(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  _overArg = overArg2;
  return _overArg;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_nativeKeys.js
var _nativeKeys;
var hasRequired_nativeKeys;
function require_nativeKeys() {
  if (hasRequired_nativeKeys)
    return _nativeKeys;
  hasRequired_nativeKeys = 1;
  var overArg2 = require_overArg();
  var nativeKeys2 = overArg2(Object.keys, Object);
  _nativeKeys = nativeKeys2;
  return _nativeKeys;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseKeys.js
var _baseKeys;
var hasRequired_baseKeys;
function require_baseKeys() {
  if (hasRequired_baseKeys)
    return _baseKeys;
  hasRequired_baseKeys = 1;
  var isPrototype2 = require_isPrototype(), nativeKeys2 = require_nativeKeys();
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  function baseKeys2(object2) {
    if (!isPrototype2(object2)) {
      return nativeKeys2(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty13.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeys = baseKeys2;
  return _baseKeys;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isArrayLike.js
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike)
    return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction3 = requireIsFunction(), isLength2 = requireIsLength();
  function isArrayLike2(value) {
    return value != null && isLength2(value.length) && !isFunction3(value);
  }
  isArrayLike_1 = isArrayLike2;
  return isArrayLike_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/keys.js
var keys_1;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys)
    return keys_1;
  hasRequiredKeys = 1;
  var arrayLikeKeys2 = require_arrayLikeKeys(), baseKeys2 = require_baseKeys(), isArrayLike2 = requireIsArrayLike();
  function keys2(object2) {
    return isArrayLike2(object2) ? arrayLikeKeys2(object2) : baseKeys2(object2);
  }
  keys_1 = keys2;
  return keys_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseAssign.js
var _baseAssign;
var hasRequired_baseAssign;
function require_baseAssign() {
  if (hasRequired_baseAssign)
    return _baseAssign;
  hasRequired_baseAssign = 1;
  var copyObject2 = require_copyObject(), keys2 = requireKeys();
  function baseAssign2(object2, source) {
    return object2 && copyObject2(source, keys2(source), object2);
  }
  _baseAssign = baseAssign2;
  return _baseAssign;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_nativeKeysIn.js
var _nativeKeysIn;
var hasRequired_nativeKeysIn;
function require_nativeKeysIn() {
  if (hasRequired_nativeKeysIn)
    return _nativeKeysIn;
  hasRequired_nativeKeysIn = 1;
  function nativeKeysIn2(object2) {
    var result = [];
    if (object2 != null) {
      for (var key in Object(object2)) {
        result.push(key);
      }
    }
    return result;
  }
  _nativeKeysIn = nativeKeysIn2;
  return _nativeKeysIn;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseKeysIn.js
var _baseKeysIn;
var hasRequired_baseKeysIn;
function require_baseKeysIn() {
  if (hasRequired_baseKeysIn)
    return _baseKeysIn;
  hasRequired_baseKeysIn = 1;
  var isObject3 = requireIsObject(), isPrototype2 = require_isPrototype(), nativeKeysIn2 = require_nativeKeysIn();
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  function baseKeysIn2(object2) {
    if (!isObject3(object2)) {
      return nativeKeysIn2(object2);
    }
    var isProto = isPrototype2(object2), result = [];
    for (var key in object2) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty13.call(object2, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeysIn = baseKeysIn2;
  return _baseKeysIn;
}

// node_modules/@antv/layout/lib/node_modules/lodash/keysIn.js
var keysIn_1;
var hasRequiredKeysIn;
function requireKeysIn() {
  if (hasRequiredKeysIn)
    return keysIn_1;
  hasRequiredKeysIn = 1;
  var arrayLikeKeys2 = require_arrayLikeKeys(), baseKeysIn2 = require_baseKeysIn(), isArrayLike2 = requireIsArrayLike();
  function keysIn2(object2) {
    return isArrayLike2(object2) ? arrayLikeKeys2(object2, true) : baseKeysIn2(object2);
  }
  keysIn_1 = keysIn2;
  return keysIn_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseAssignIn.js
var _baseAssignIn;
var hasRequired_baseAssignIn;
function require_baseAssignIn() {
  if (hasRequired_baseAssignIn)
    return _baseAssignIn;
  hasRequired_baseAssignIn = 1;
  var copyObject2 = require_copyObject(), keysIn2 = requireKeysIn();
  function baseAssignIn2(object2, source) {
    return object2 && copyObject2(source, keysIn2(source), object2);
  }
  _baseAssignIn = baseAssignIn2;
  return _baseAssignIn;
}

// node_modules/@antv/layout/lib/_virtual/_cloneBuffer.js
var _cloneBuffer = { exports: {} };

// node_modules/@antv/layout/lib/node_modules/lodash/_cloneBuffer.js
_cloneBuffer.exports;
var hasRequired_cloneBuffer;
function require_cloneBuffer() {
  if (hasRequired_cloneBuffer)
    return _cloneBuffer.exports;
  hasRequired_cloneBuffer = 1;
  (function(module2, exports$1) {
    var root4 = require_root();
    var freeExports4 = exports$1 && !exports$1.nodeType && exports$1;
    var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
    var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
    var Buffer4 = moduleExports4 ? root4.Buffer : void 0, allocUnsafe2 = Buffer4 ? Buffer4.allocUnsafe : void 0;
    function cloneBuffer2(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer2;
  })(_cloneBuffer, _cloneBuffer.exports);
  return _cloneBuffer.exports;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_copyArray.js
var _copyArray;
var hasRequired_copyArray;
function require_copyArray() {
  if (hasRequired_copyArray)
    return _copyArray;
  hasRequired_copyArray = 1;
  function copyArray2(source, array3) {
    var index2 = -1, length = source.length;
    array3 || (array3 = Array(length));
    while (++index2 < length) {
      array3[index2] = source[index2];
    }
    return array3;
  }
  _copyArray = copyArray2;
  return _copyArray;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_arrayFilter.js
var _arrayFilter;
var hasRequired_arrayFilter;
function require_arrayFilter() {
  if (hasRequired_arrayFilter)
    return _arrayFilter;
  hasRequired_arrayFilter = 1;
  function arrayFilter2(array3, predicate) {
    var index2 = -1, length = array3 == null ? 0 : array3.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array3[index2];
      if (predicate(value, index2, array3)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  _arrayFilter = arrayFilter2;
  return _arrayFilter;
}

// node_modules/@antv/layout/lib/node_modules/lodash/stubArray.js
var stubArray_1;
var hasRequiredStubArray;
function requireStubArray() {
  if (hasRequiredStubArray)
    return stubArray_1;
  hasRequiredStubArray = 1;
  function stubArray2() {
    return [];
  }
  stubArray_1 = stubArray2;
  return stubArray_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_getSymbols.js
var _getSymbols;
var hasRequired_getSymbols;
function require_getSymbols() {
  if (hasRequired_getSymbols)
    return _getSymbols;
  hasRequired_getSymbols = 1;
  var arrayFilter2 = require_arrayFilter(), stubArray2 = requireStubArray();
  var objectProto15 = Object.prototype;
  var propertyIsEnumerable3 = objectProto15.propertyIsEnumerable;
  var nativeGetSymbols3 = Object.getOwnPropertySymbols;
  var getSymbols2 = !nativeGetSymbols3 ? stubArray2 : function(object2) {
    if (object2 == null) {
      return [];
    }
    object2 = Object(object2);
    return arrayFilter2(nativeGetSymbols3(object2), function(symbol) {
      return propertyIsEnumerable3.call(object2, symbol);
    });
  };
  _getSymbols = getSymbols2;
  return _getSymbols;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_copySymbols.js
var _copySymbols;
var hasRequired_copySymbols;
function require_copySymbols() {
  if (hasRequired_copySymbols)
    return _copySymbols;
  hasRequired_copySymbols = 1;
  var copyObject2 = require_copyObject(), getSymbols2 = require_getSymbols();
  function copySymbols2(source, object2) {
    return copyObject2(source, getSymbols2(source), object2);
  }
  _copySymbols = copySymbols2;
  return _copySymbols;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_arrayPush.js
var _arrayPush;
var hasRequired_arrayPush;
function require_arrayPush() {
  if (hasRequired_arrayPush)
    return _arrayPush;
  hasRequired_arrayPush = 1;
  function arrayPush2(array3, values) {
    var index2 = -1, length = values.length, offset = array3.length;
    while (++index2 < length) {
      array3[offset + index2] = values[index2];
    }
    return array3;
  }
  _arrayPush = arrayPush2;
  return _arrayPush;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_getPrototype.js
var _getPrototype;
var hasRequired_getPrototype;
function require_getPrototype() {
  if (hasRequired_getPrototype)
    return _getPrototype;
  hasRequired_getPrototype = 1;
  var overArg2 = require_overArg();
  var getPrototype2 = overArg2(Object.getPrototypeOf, Object);
  _getPrototype = getPrototype2;
  return _getPrototype;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_getSymbolsIn.js
var _getSymbolsIn;
var hasRequired_getSymbolsIn;
function require_getSymbolsIn() {
  if (hasRequired_getSymbolsIn)
    return _getSymbolsIn;
  hasRequired_getSymbolsIn = 1;
  var arrayPush2 = require_arrayPush(), getPrototype2 = require_getPrototype(), getSymbols2 = require_getSymbols(), stubArray2 = requireStubArray();
  var nativeGetSymbols3 = Object.getOwnPropertySymbols;
  var getSymbolsIn2 = !nativeGetSymbols3 ? stubArray2 : function(object2) {
    var result = [];
    while (object2) {
      arrayPush2(result, getSymbols2(object2));
      object2 = getPrototype2(object2);
    }
    return result;
  };
  _getSymbolsIn = getSymbolsIn2;
  return _getSymbolsIn;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_copySymbolsIn.js
var _copySymbolsIn;
var hasRequired_copySymbolsIn;
function require_copySymbolsIn() {
  if (hasRequired_copySymbolsIn)
    return _copySymbolsIn;
  hasRequired_copySymbolsIn = 1;
  var copyObject2 = require_copyObject(), getSymbolsIn2 = require_getSymbolsIn();
  function copySymbolsIn2(source, object2) {
    return copyObject2(source, getSymbolsIn2(source), object2);
  }
  _copySymbolsIn = copySymbolsIn2;
  return _copySymbolsIn;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseGetAllKeys.js
var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
  if (hasRequired_baseGetAllKeys)
    return _baseGetAllKeys;
  hasRequired_baseGetAllKeys = 1;
  var arrayPush2 = require_arrayPush(), isArray2 = requireIsArray();
  function baseGetAllKeys2(object2, keysFunc, symbolsFunc) {
    var result = keysFunc(object2);
    return isArray2(object2) ? result : arrayPush2(result, symbolsFunc(object2));
  }
  _baseGetAllKeys = baseGetAllKeys2;
  return _baseGetAllKeys;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_getAllKeys.js
var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys)
    return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var baseGetAllKeys2 = require_baseGetAllKeys(), getSymbols2 = require_getSymbols(), keys2 = requireKeys();
  function getAllKeys2(object2) {
    return baseGetAllKeys2(object2, keys2, getSymbols2);
  }
  _getAllKeys = getAllKeys2;
  return _getAllKeys;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_getAllKeysIn.js
var _getAllKeysIn;
var hasRequired_getAllKeysIn;
function require_getAllKeysIn() {
  if (hasRequired_getAllKeysIn)
    return _getAllKeysIn;
  hasRequired_getAllKeysIn = 1;
  var baseGetAllKeys2 = require_baseGetAllKeys(), getSymbolsIn2 = require_getSymbolsIn(), keysIn2 = requireKeysIn();
  function getAllKeysIn2(object2) {
    return baseGetAllKeys2(object2, keysIn2, getSymbolsIn2);
  }
  _getAllKeysIn = getAllKeysIn2;
  return _getAllKeysIn;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_DataView.js
var _DataView;
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView)
    return _DataView;
  hasRequired_DataView = 1;
  var getNative2 = require_getNative(), root4 = require_root();
  var DataView3 = getNative2(root4, "DataView");
  _DataView = DataView3;
  return _DataView;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_Promise.js
var _Promise;
var hasRequired_Promise;
function require_Promise() {
  if (hasRequired_Promise)
    return _Promise;
  hasRequired_Promise = 1;
  var getNative2 = require_getNative(), root4 = require_root();
  var Promise3 = getNative2(root4, "Promise");
  _Promise = Promise3;
  return _Promise;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_Set.js
var _Set;
var hasRequired_Set;
function require_Set() {
  if (hasRequired_Set)
    return _Set;
  hasRequired_Set = 1;
  var getNative2 = require_getNative(), root4 = require_root();
  var Set3 = getNative2(root4, "Set");
  _Set = Set3;
  return _Set;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_WeakMap.js
var _WeakMap;
var hasRequired_WeakMap;
function require_WeakMap() {
  if (hasRequired_WeakMap)
    return _WeakMap;
  hasRequired_WeakMap = 1;
  var getNative2 = require_getNative(), root4 = require_root();
  var WeakMap3 = getNative2(root4, "WeakMap");
  _WeakMap = WeakMap3;
  return _WeakMap;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_getTag.js
var _getTag;
var hasRequired_getTag;
function require_getTag() {
  if (hasRequired_getTag)
    return _getTag;
  hasRequired_getTag = 1;
  var DataView3 = require_DataView(), Map3 = require_Map(), Promise3 = require_Promise(), Set3 = require_Set(), WeakMap3 = require_WeakMap(), baseGetTag2 = require_baseGetTag(), toSource2 = require_toSource();
  var mapTag6 = "[object Map]", objectTag5 = "[object Object]", promiseTag2 = "[object Promise]", setTag6 = "[object Set]", weakMapTag4 = "[object WeakMap]";
  var dataViewTag5 = "[object DataView]";
  var dataViewCtorString2 = toSource2(DataView3), mapCtorString2 = toSource2(Map3), promiseCtorString2 = toSource2(Promise3), setCtorString2 = toSource2(Set3), weakMapCtorString2 = toSource2(WeakMap3);
  var getTag2 = baseGetTag2;
  if (DataView3 && getTag2(new DataView3(new ArrayBuffer(1))) != dataViewTag5 || Map3 && getTag2(new Map3()) != mapTag6 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set3 && getTag2(new Set3()) != setTag6 || WeakMap3 && getTag2(new WeakMap3()) != weakMapTag4) {
    getTag2 = function(value) {
      var result = baseGetTag2(value), Ctor = result == objectTag5 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString2:
            return dataViewTag5;
          case mapCtorString2:
            return mapTag6;
          case promiseCtorString2:
            return promiseTag2;
          case setCtorString2:
            return setTag6;
          case weakMapCtorString2:
            return weakMapTag4;
        }
      }
      return result;
    };
  }
  _getTag = getTag2;
  return _getTag;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_initCloneArray.js
var _initCloneArray;
var hasRequired_initCloneArray;
function require_initCloneArray() {
  if (hasRequired_initCloneArray)
    return _initCloneArray;
  hasRequired_initCloneArray = 1;
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  function initCloneArray2(array3) {
    var length = array3.length, result = new array3.constructor(length);
    if (length && typeof array3[0] == "string" && hasOwnProperty13.call(array3, "index")) {
      result.index = array3.index;
      result.input = array3.input;
    }
    return result;
  }
  _initCloneArray = initCloneArray2;
  return _initCloneArray;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_Uint8Array.js
var _Uint8Array;
var hasRequired_Uint8Array;
function require_Uint8Array() {
  if (hasRequired_Uint8Array)
    return _Uint8Array;
  hasRequired_Uint8Array = 1;
  var root4 = require_root();
  var Uint8Array3 = root4.Uint8Array;
  _Uint8Array = Uint8Array3;
  return _Uint8Array;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_cloneArrayBuffer.js
var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;
function require_cloneArrayBuffer() {
  if (hasRequired_cloneArrayBuffer)
    return _cloneArrayBuffer;
  hasRequired_cloneArrayBuffer = 1;
  var Uint8Array3 = require_Uint8Array();
  function cloneArrayBuffer2(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
    return result;
  }
  _cloneArrayBuffer = cloneArrayBuffer2;
  return _cloneArrayBuffer;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_cloneDataView.js
var _cloneDataView;
var hasRequired_cloneDataView;
function require_cloneDataView() {
  if (hasRequired_cloneDataView)
    return _cloneDataView;
  hasRequired_cloneDataView = 1;
  var cloneArrayBuffer2 = require_cloneArrayBuffer();
  function cloneDataView2(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  _cloneDataView = cloneDataView2;
  return _cloneDataView;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_cloneRegExp.js
var _cloneRegExp;
var hasRequired_cloneRegExp;
function require_cloneRegExp() {
  if (hasRequired_cloneRegExp)
    return _cloneRegExp;
  hasRequired_cloneRegExp = 1;
  var reFlags2 = /\w*$/;
  function cloneRegExp2(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  _cloneRegExp = cloneRegExp2;
  return _cloneRegExp;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_cloneSymbol.js
var _cloneSymbol;
var hasRequired_cloneSymbol;
function require_cloneSymbol() {
  if (hasRequired_cloneSymbol)
    return _cloneSymbol;
  hasRequired_cloneSymbol = 1;
  var Symbol3 = require_Symbol();
  var symbolProto3 = Symbol3 ? Symbol3.prototype : void 0, symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
  function cloneSymbol2(symbol) {
    return symbolValueOf2 ? Object(symbolValueOf2.call(symbol)) : {};
  }
  _cloneSymbol = cloneSymbol2;
  return _cloneSymbol;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_cloneTypedArray.js
var _cloneTypedArray;
var hasRequired_cloneTypedArray;
function require_cloneTypedArray() {
  if (hasRequired_cloneTypedArray)
    return _cloneTypedArray;
  hasRequired_cloneTypedArray = 1;
  var cloneArrayBuffer2 = require_cloneArrayBuffer();
  function cloneTypedArray2(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  _cloneTypedArray = cloneTypedArray2;
  return _cloneTypedArray;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_initCloneByTag.js
var _initCloneByTag;
var hasRequired_initCloneByTag;
function require_initCloneByTag() {
  if (hasRequired_initCloneByTag)
    return _initCloneByTag;
  hasRequired_initCloneByTag = 1;
  var cloneArrayBuffer2 = require_cloneArrayBuffer(), cloneDataView2 = require_cloneDataView(), cloneRegExp2 = require_cloneRegExp(), cloneSymbol2 = require_cloneSymbol(), cloneTypedArray2 = require_cloneTypedArray();
  var boolTag4 = "[object Boolean]", dateTag4 = "[object Date]", mapTag6 = "[object Map]", numberTag4 = "[object Number]", regexpTag4 = "[object RegExp]", setTag6 = "[object Set]", stringTag4 = "[object String]", symbolTag4 = "[object Symbol]";
  var arrayBufferTag4 = "[object ArrayBuffer]", dataViewTag5 = "[object DataView]", float32Tag4 = "[object Float32Array]", float64Tag4 = "[object Float64Array]", int8Tag4 = "[object Int8Array]", int16Tag4 = "[object Int16Array]", int32Tag4 = "[object Int32Array]", uint8Tag4 = "[object Uint8Array]", uint8ClampedTag4 = "[object Uint8ClampedArray]", uint16Tag4 = "[object Uint16Array]", uint32Tag4 = "[object Uint32Array]";
  function initCloneByTag2(object2, tag, isDeep) {
    var Ctor = object2.constructor;
    switch (tag) {
      case arrayBufferTag4:
        return cloneArrayBuffer2(object2);
      case boolTag4:
      case dateTag4:
        return new Ctor(+object2);
      case dataViewTag5:
        return cloneDataView2(object2, isDeep);
      case float32Tag4:
      case float64Tag4:
      case int8Tag4:
      case int16Tag4:
      case int32Tag4:
      case uint8Tag4:
      case uint8ClampedTag4:
      case uint16Tag4:
      case uint32Tag4:
        return cloneTypedArray2(object2, isDeep);
      case mapTag6:
        return new Ctor();
      case numberTag4:
      case stringTag4:
        return new Ctor(object2);
      case regexpTag4:
        return cloneRegExp2(object2);
      case setTag6:
        return new Ctor();
      case symbolTag4:
        return cloneSymbol2(object2);
    }
  }
  _initCloneByTag = initCloneByTag2;
  return _initCloneByTag;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseCreate.js
var _baseCreate;
var hasRequired_baseCreate;
function require_baseCreate() {
  if (hasRequired_baseCreate)
    return _baseCreate;
  hasRequired_baseCreate = 1;
  var isObject3 = requireIsObject();
  var objectCreate2 = Object.create;
  var baseCreate2 = function() {
    function object2() {
    }
    return function(proto) {
      if (!isObject3(proto)) {
        return {};
      }
      if (objectCreate2) {
        return objectCreate2(proto);
      }
      object2.prototype = proto;
      var result = new object2();
      object2.prototype = void 0;
      return result;
    };
  }();
  _baseCreate = baseCreate2;
  return _baseCreate;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_initCloneObject.js
var _initCloneObject;
var hasRequired_initCloneObject;
function require_initCloneObject() {
  if (hasRequired_initCloneObject)
    return _initCloneObject;
  hasRequired_initCloneObject = 1;
  var baseCreate2 = require_baseCreate(), getPrototype2 = require_getPrototype(), isPrototype2 = require_isPrototype();
  function initCloneObject2(object2) {
    return typeof object2.constructor == "function" && !isPrototype2(object2) ? baseCreate2(getPrototype2(object2)) : {};
  }
  _initCloneObject = initCloneObject2;
  return _initCloneObject;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseIsMap.js
var _baseIsMap;
var hasRequired_baseIsMap;
function require_baseIsMap() {
  if (hasRequired_baseIsMap)
    return _baseIsMap;
  hasRequired_baseIsMap = 1;
  var getTag2 = require_getTag(), isObjectLike3 = requireIsObjectLike();
  var mapTag6 = "[object Map]";
  function baseIsMap2(value) {
    return isObjectLike3(value) && getTag2(value) == mapTag6;
  }
  _baseIsMap = baseIsMap2;
  return _baseIsMap;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isMap.js
var isMap_1;
var hasRequiredIsMap;
function requireIsMap() {
  if (hasRequiredIsMap)
    return isMap_1;
  hasRequiredIsMap = 1;
  var baseIsMap2 = require_baseIsMap(), baseUnary2 = require_baseUnary(), nodeUtil2 = require_nodeUtil();
  var nodeIsMap2 = nodeUtil2 && nodeUtil2.isMap;
  var isMap2 = nodeIsMap2 ? baseUnary2(nodeIsMap2) : baseIsMap2;
  isMap_1 = isMap2;
  return isMap_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseIsSet.js
var _baseIsSet;
var hasRequired_baseIsSet;
function require_baseIsSet() {
  if (hasRequired_baseIsSet)
    return _baseIsSet;
  hasRequired_baseIsSet = 1;
  var getTag2 = require_getTag(), isObjectLike3 = requireIsObjectLike();
  var setTag6 = "[object Set]";
  function baseIsSet2(value) {
    return isObjectLike3(value) && getTag2(value) == setTag6;
  }
  _baseIsSet = baseIsSet2;
  return _baseIsSet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isSet.js
var isSet_1;
var hasRequiredIsSet;
function requireIsSet() {
  if (hasRequiredIsSet)
    return isSet_1;
  hasRequiredIsSet = 1;
  var baseIsSet2 = require_baseIsSet(), baseUnary2 = require_baseUnary(), nodeUtil2 = require_nodeUtil();
  var nodeIsSet2 = nodeUtil2 && nodeUtil2.isSet;
  var isSet2 = nodeIsSet2 ? baseUnary2(nodeIsSet2) : baseIsSet2;
  isSet_1 = isSet2;
  return isSet_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseClone.js
var _baseClone;
var hasRequired_baseClone;
function require_baseClone() {
  if (hasRequired_baseClone)
    return _baseClone;
  hasRequired_baseClone = 1;
  var Stack2 = require_Stack(), arrayEach2 = require_arrayEach(), assignValue2 = require_assignValue(), baseAssign2 = require_baseAssign(), baseAssignIn2 = require_baseAssignIn(), cloneBuffer2 = require_cloneBuffer(), copyArray2 = require_copyArray(), copySymbols2 = require_copySymbols(), copySymbolsIn2 = require_copySymbolsIn(), getAllKeys2 = require_getAllKeys(), getAllKeysIn2 = require_getAllKeysIn(), getTag2 = require_getTag(), initCloneArray2 = require_initCloneArray(), initCloneByTag2 = require_initCloneByTag(), initCloneObject2 = require_initCloneObject(), isArray2 = requireIsArray(), isBuffer3 = requireIsBuffer(), isMap2 = requireIsMap(), isObject3 = requireIsObject(), isSet2 = requireIsSet(), keys2 = requireKeys(), keysIn2 = requireKeysIn();
  var CLONE_DEEP_FLAG3 = 1, CLONE_FLAT_FLAG2 = 2, CLONE_SYMBOLS_FLAG3 = 4;
  var argsTag4 = "[object Arguments]", arrayTag3 = "[object Array]", boolTag4 = "[object Boolean]", dateTag4 = "[object Date]", errorTag3 = "[object Error]", funcTag4 = "[object Function]", genTag3 = "[object GeneratorFunction]", mapTag6 = "[object Map]", numberTag4 = "[object Number]", objectTag5 = "[object Object]", regexpTag4 = "[object RegExp]", setTag6 = "[object Set]", stringTag4 = "[object String]", symbolTag4 = "[object Symbol]", weakMapTag4 = "[object WeakMap]";
  var arrayBufferTag4 = "[object ArrayBuffer]", dataViewTag5 = "[object DataView]", float32Tag4 = "[object Float32Array]", float64Tag4 = "[object Float64Array]", int8Tag4 = "[object Int8Array]", int16Tag4 = "[object Int16Array]", int32Tag4 = "[object Int32Array]", uint8Tag4 = "[object Uint8Array]", uint8ClampedTag4 = "[object Uint8ClampedArray]", uint16Tag4 = "[object Uint16Array]", uint32Tag4 = "[object Uint32Array]";
  var cloneableTags2 = {};
  cloneableTags2[argsTag4] = cloneableTags2[arrayTag3] = cloneableTags2[arrayBufferTag4] = cloneableTags2[dataViewTag5] = cloneableTags2[boolTag4] = cloneableTags2[dateTag4] = cloneableTags2[float32Tag4] = cloneableTags2[float64Tag4] = cloneableTags2[int8Tag4] = cloneableTags2[int16Tag4] = cloneableTags2[int32Tag4] = cloneableTags2[mapTag6] = cloneableTags2[numberTag4] = cloneableTags2[objectTag5] = cloneableTags2[regexpTag4] = cloneableTags2[setTag6] = cloneableTags2[stringTag4] = cloneableTags2[symbolTag4] = cloneableTags2[uint8Tag4] = cloneableTags2[uint8ClampedTag4] = cloneableTags2[uint16Tag4] = cloneableTags2[uint32Tag4] = true;
  cloneableTags2[errorTag3] = cloneableTags2[funcTag4] = cloneableTags2[weakMapTag4] = false;
  function baseClone2(value, bitmask, customizer, key, object2, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG3, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG3;
    if (customizer) {
      result = object2 ? customizer(value, key, object2, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject3(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result = initCloneArray2(value);
      if (!isDeep) {
        return copyArray2(value, result);
      }
    } else {
      var tag = getTag2(value), isFunc = tag == funcTag4 || tag == genTag3;
      if (isBuffer3(value)) {
        return cloneBuffer2(value, isDeep);
      }
      if (tag == objectTag5 || tag == argsTag4 || isFunc && !object2) {
        result = isFlat || isFunc ? {} : initCloneObject2(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn2(value, baseAssignIn2(result, value)) : copySymbols2(value, baseAssign2(result, value));
        }
      } else {
        if (!cloneableTags2[tag]) {
          return object2 ? value : {};
        }
        result = initCloneByTag2(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack2());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (isSet2(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone2(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap2(value)) {
      value.forEach(function(subValue, key2) {
        result.set(key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn2 : getAllKeys2 : isFlat ? keysIn2 : keys2;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach2(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue2(result, key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
    });
    return result;
  }
  _baseClone = baseClone2;
  return _baseClone;
}

// node_modules/@antv/layout/lib/node_modules/lodash/clone.js
var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone)
    return clone_1;
  hasRequiredClone = 1;
  var baseClone2 = require_baseClone();
  var CLONE_SYMBOLS_FLAG3 = 4;
  function clone2(value) {
    return baseClone2(value, CLONE_SYMBOLS_FLAG3);
  }
  clone_1 = clone2;
  return clone_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/constant.js
var constant_1;
var hasRequiredConstant;
function requireConstant() {
  if (hasRequiredConstant)
    return constant_1;
  hasRequiredConstant = 1;
  function constant2(value) {
    return function() {
      return value;
    };
  }
  constant_1 = constant2;
  return constant_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_createBaseFor.js
var _createBaseFor;
var hasRequired_createBaseFor;
function require_createBaseFor() {
  if (hasRequired_createBaseFor)
    return _createBaseFor;
  hasRequired_createBaseFor = 1;
  function createBaseFor2(fromRight) {
    return function(object2, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object2;
    };
  }
  _createBaseFor = createBaseFor2;
  return _createBaseFor;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseFor.js
var _baseFor;
var hasRequired_baseFor;
function require_baseFor() {
  if (hasRequired_baseFor)
    return _baseFor;
  hasRequired_baseFor = 1;
  var createBaseFor2 = require_createBaseFor();
  var baseFor2 = createBaseFor2();
  _baseFor = baseFor2;
  return _baseFor;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseForOwn.js
var _baseForOwn;
var hasRequired_baseForOwn;
function require_baseForOwn() {
  if (hasRequired_baseForOwn)
    return _baseForOwn;
  hasRequired_baseForOwn = 1;
  var baseFor2 = require_baseFor(), keys2 = requireKeys();
  function baseForOwn(object2, iteratee) {
    return object2 && baseFor2(object2, iteratee, keys2);
  }
  _baseForOwn = baseForOwn;
  return _baseForOwn;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_createBaseEach.js
var _createBaseEach;
var hasRequired_createBaseEach;
function require_createBaseEach() {
  if (hasRequired_createBaseEach)
    return _createBaseEach;
  hasRequired_createBaseEach = 1;
  var isArrayLike2 = requireIsArrayLike();
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike2(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index2-- : ++index2 < length) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  _createBaseEach = createBaseEach;
  return _createBaseEach;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseEach.js
var _baseEach;
var hasRequired_baseEach;
function require_baseEach() {
  if (hasRequired_baseEach)
    return _baseEach;
  hasRequired_baseEach = 1;
  var baseForOwn = require_baseForOwn(), createBaseEach = require_createBaseEach();
  var baseEach = createBaseEach(baseForOwn);
  _baseEach = baseEach;
  return _baseEach;
}

// node_modules/@antv/layout/lib/node_modules/lodash/identity.js
var identity_1;
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity)
    return identity_1;
  hasRequiredIdentity = 1;
  function identity6(value) {
    return value;
  }
  identity_1 = identity6;
  return identity_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_castFunction.js
var _castFunction;
var hasRequired_castFunction;
function require_castFunction() {
  if (hasRequired_castFunction)
    return _castFunction;
  hasRequired_castFunction = 1;
  var identity6 = requireIdentity();
  function castFunction(value) {
    return typeof value == "function" ? value : identity6;
  }
  _castFunction = castFunction;
  return _castFunction;
}

// node_modules/@antv/layout/lib/node_modules/lodash/forEach.js
var forEach_1;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var arrayEach2 = require_arrayEach(), baseEach = require_baseEach(), castFunction = require_castFunction(), isArray2 = requireIsArray();
  function forEach(collection, iteratee) {
    var func = isArray2(collection) ? arrayEach2 : baseEach;
    return func(collection, castFunction(iteratee));
  }
  forEach_1 = forEach;
  return forEach_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/each.js
var each;
var hasRequiredEach;
function requireEach() {
  if (hasRequiredEach)
    return each;
  hasRequiredEach = 1;
  each = requireForEach();
  return each;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseFilter.js
var _baseFilter;
var hasRequired_baseFilter;
function require_baseFilter() {
  if (hasRequired_baseFilter)
    return _baseFilter;
  hasRequired_baseFilter = 1;
  var baseEach = require_baseEach();
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value, index2, collection2) {
      if (predicate(value, index2, collection2)) {
        result.push(value);
      }
    });
    return result;
  }
  _baseFilter = baseFilter;
  return _baseFilter;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_setCacheAdd.js
var _setCacheAdd;
var hasRequired_setCacheAdd;
function require_setCacheAdd() {
  if (hasRequired_setCacheAdd)
    return _setCacheAdd;
  hasRequired_setCacheAdd = 1;
  var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED3);
    return this;
  }
  _setCacheAdd = setCacheAdd;
  return _setCacheAdd;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_setCacheHas.js
var _setCacheHas;
var hasRequired_setCacheHas;
function require_setCacheHas() {
  if (hasRequired_setCacheHas)
    return _setCacheHas;
  hasRequired_setCacheHas = 1;
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  _setCacheHas = setCacheHas;
  return _setCacheHas;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_SetCache.js
var _SetCache;
var hasRequired_SetCache;
function require_SetCache() {
  if (hasRequired_SetCache)
    return _SetCache;
  hasRequired_SetCache = 1;
  var MapCache2 = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
  function SetCache(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache2();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  _SetCache = SetCache;
  return _SetCache;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_arraySome.js
var _arraySome;
var hasRequired_arraySome;
function require_arraySome() {
  if (hasRequired_arraySome)
    return _arraySome;
  hasRequired_arraySome = 1;
  function arraySome(array3, predicate) {
    var index2 = -1, length = array3 == null ? 0 : array3.length;
    while (++index2 < length) {
      if (predicate(array3[index2], index2, array3)) {
        return true;
      }
    }
    return false;
  }
  _arraySome = arraySome;
  return _arraySome;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_cacheHas.js
var _cacheHas;
var hasRequired_cacheHas;
function require_cacheHas() {
  if (hasRequired_cacheHas)
    return _cacheHas;
  hasRequired_cacheHas = 1;
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  _cacheHas = cacheHas;
  return _cacheHas;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_equalArrays.js
var _equalArrays;
var hasRequired_equalArrays;
function require_equalArrays() {
  if (hasRequired_equalArrays)
    return _equalArrays;
  hasRequired_equalArrays = 1;
  var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array3, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array3.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array3);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array3;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array3, other);
    stack.set(other, array3);
    while (++index2 < arrLength) {
      var arrValue = array3[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array3, stack) : customizer(arrValue, othValue, index2, array3, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array3);
    stack["delete"](other);
    return result;
  }
  _equalArrays = equalArrays;
  return _equalArrays;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_mapToArray.js
var _mapToArray;
var hasRequired_mapToArray;
function require_mapToArray() {
  if (hasRequired_mapToArray)
    return _mapToArray;
  hasRequired_mapToArray = 1;
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  _mapToArray = mapToArray;
  return _mapToArray;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_setToArray.js
var _setToArray;
var hasRequired_setToArray;
function require_setToArray() {
  if (hasRequired_setToArray)
    return _setToArray;
  hasRequired_setToArray = 1;
  function setToArray(set3) {
    var index2 = -1, result = Array(set3.size);
    set3.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  _setToArray = setToArray;
  return _setToArray;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_equalByTag.js
var _equalByTag;
var hasRequired_equalByTag;
function require_equalByTag() {
  if (hasRequired_equalByTag)
    return _equalByTag;
  hasRequired_equalByTag = 1;
  var Symbol3 = require_Symbol(), Uint8Array3 = require_Uint8Array(), eq2 = requireEq(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var boolTag4 = "[object Boolean]", dateTag4 = "[object Date]", errorTag3 = "[object Error]", mapTag6 = "[object Map]", numberTag4 = "[object Number]", regexpTag4 = "[object RegExp]", setTag6 = "[object Set]", stringTag4 = "[object String]", symbolTag4 = "[object Symbol]";
  var arrayBufferTag4 = "[object ArrayBuffer]", dataViewTag5 = "[object DataView]";
  var symbolProto3 = Symbol3 ? Symbol3.prototype : void 0, symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
  function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag5:
        if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
          return false;
        }
        object2 = object2.buffer;
        other = other.buffer;
      case arrayBufferTag4:
        if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object2), new Uint8Array3(other))) {
          return false;
        }
        return true;
      case boolTag4:
      case dateTag4:
      case numberTag4:
        return eq2(+object2, +other);
      case errorTag3:
        return object2.name == other.name && object2.message == other.message;
      case regexpTag4:
      case stringTag4:
        return object2 == other + "";
      case mapTag6:
        var convert = mapToArray;
      case setTag6:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object2.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object2);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object2, other);
        var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object2);
        return result;
      case symbolTag4:
        if (symbolValueOf2) {
          return symbolValueOf2.call(object2) == symbolValueOf2.call(other);
        }
    }
    return false;
  }
  _equalByTag = equalByTag;
  return _equalByTag;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_equalObjects.js
var _equalObjects;
var hasRequired_equalObjects;
function require_equalObjects() {
  if (hasRequired_equalObjects)
    return _equalObjects;
  hasRequired_equalObjects = 1;
  var getAllKeys2 = require_getAllKeys();
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys2(object2), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty13.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object2);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object2;
    }
    var result = true;
    stack.set(object2, other);
    stack.set(other, object2);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object2[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object2.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object2);
    stack["delete"](other);
    return result;
  }
  _equalObjects = equalObjects;
  return _equalObjects;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseIsEqualDeep.js
var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;
function require_baseIsEqualDeep() {
  if (hasRequired_baseIsEqualDeep)
    return _baseIsEqualDeep;
  hasRequired_baseIsEqualDeep = 1;
  var Stack2 = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag2 = require_getTag(), isArray2 = requireIsArray(), isBuffer3 = requireIsBuffer(), isTypedArray2 = requireIsTypedArray();
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag4 = "[object Arguments]", arrayTag3 = "[object Array]", objectTag5 = "[object Object]";
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag3 : getTag2(object2), othTag = othIsArr ? arrayTag3 : getTag2(other);
    objTag = objTag == argsTag4 ? objectTag5 : objTag;
    othTag = othTag == argsTag4 ? objectTag5 : othTag;
    var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer3(object2)) {
      if (!isBuffer3(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack2());
      return objIsArr || isTypedArray2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty13.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty13.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack2());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack2());
    return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
  }
  _baseIsEqualDeep = baseIsEqualDeep;
  return _baseIsEqualDeep;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseIsEqual.js
var _baseIsEqual;
var hasRequired_baseIsEqual;
function require_baseIsEqual() {
  if (hasRequired_baseIsEqual)
    return _baseIsEqual;
  hasRequired_baseIsEqual = 1;
  var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike3 = requireIsObjectLike();
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike3(value) && !isObjectLike3(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  _baseIsEqual = baseIsEqual;
  return _baseIsEqual;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseIsMatch.js
var _baseIsMatch;
var hasRequired_baseIsMatch;
function require_baseIsMatch() {
  if (hasRequired_baseIsMatch)
    return _baseIsMatch;
  hasRequired_baseIsMatch = 1;
  var Stack2 = require_Stack(), baseIsEqual = require_baseIsEqual();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseIsMatch(object2, source, matchData, customizer) {
    var index2 = matchData.length, length = index2, noCustomizer = !customizer;
    if (object2 == null) {
      return !length;
    }
    object2 = Object(object2);
    while (index2--) {
      var data = matchData[index2];
      if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
        return false;
      }
    }
    while (++index2 < length) {
      data = matchData[index2];
      var key = data[0], objValue = object2[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key in object2)) {
          return false;
        }
      } else {
        var stack = new Stack2();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object2, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  _baseIsMatch = baseIsMatch;
  return _baseIsMatch;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_isStrictComparable.js
var _isStrictComparable;
var hasRequired_isStrictComparable;
function require_isStrictComparable() {
  if (hasRequired_isStrictComparable)
    return _isStrictComparable;
  hasRequired_isStrictComparable = 1;
  var isObject3 = requireIsObject();
  function isStrictComparable(value) {
    return value === value && !isObject3(value);
  }
  _isStrictComparable = isStrictComparable;
  return _isStrictComparable;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_getMatchData.js
var _getMatchData;
var hasRequired_getMatchData;
function require_getMatchData() {
  if (hasRequired_getMatchData)
    return _getMatchData;
  hasRequired_getMatchData = 1;
  var isStrictComparable = require_isStrictComparable(), keys2 = requireKeys();
  function getMatchData(object2) {
    var result = keys2(object2), length = result.length;
    while (length--) {
      var key = result[length], value = object2[key];
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  _getMatchData = getMatchData;
  return _getMatchData;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_matchesStrictComparable.js
var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;
function require_matchesStrictComparable() {
  if (hasRequired_matchesStrictComparable)
    return _matchesStrictComparable;
  hasRequired_matchesStrictComparable = 1;
  function matchesStrictComparable(key, srcValue) {
    return function(object2) {
      if (object2 == null) {
        return false;
      }
      return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
    };
  }
  _matchesStrictComparable = matchesStrictComparable;
  return _matchesStrictComparable;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseMatches.js
var _baseMatches;
var hasRequired_baseMatches;
function require_baseMatches() {
  if (hasRequired_baseMatches)
    return _baseMatches;
  hasRequired_baseMatches = 1;
  var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData(), matchesStrictComparable = require_matchesStrictComparable();
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object2) {
      return object2 === source || baseIsMatch(object2, source, matchData);
    };
  }
  _baseMatches = baseMatches;
  return _baseMatches;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isSymbol.js
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol)
    return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag2 = require_baseGetTag(), isObjectLike3 = requireIsObjectLike();
  var symbolTag4 = "[object Symbol]";
  function isSymbol2(value) {
    return typeof value == "symbol" || isObjectLike3(value) && baseGetTag2(value) == symbolTag4;
  }
  isSymbol_1 = isSymbol2;
  return isSymbol_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_isKey.js
var _isKey;
var hasRequired_isKey;
function require_isKey() {
  if (hasRequired_isKey)
    return _isKey;
  hasRequired_isKey = 1;
  var isArray2 = requireIsArray(), isSymbol2 = requireIsSymbol();
  var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/;
  function isKey2(value, object2) {
    if (isArray2(value)) {
      return false;
    }
    var type2 = typeof value;
    if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
      return true;
    }
    return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object2 != null && value in Object(object2);
  }
  _isKey = isKey2;
  return _isKey;
}

// node_modules/@antv/layout/lib/node_modules/lodash/memoize.js
var memoize_1;
var hasRequiredMemoize;
function requireMemoize() {
  if (hasRequiredMemoize)
    return memoize_1;
  hasRequiredMemoize = 1;
  var MapCache2 = require_MapCache();
  var FUNC_ERROR_TEXT2 = "Expected a function";
  function memoize2(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT2);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize2.Cache || MapCache2)();
    return memoized;
  }
  memoize2.Cache = MapCache2;
  memoize_1 = memoize2;
  return memoize_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_memoizeCapped.js
var _memoizeCapped;
var hasRequired_memoizeCapped;
function require_memoizeCapped() {
  if (hasRequired_memoizeCapped)
    return _memoizeCapped;
  hasRequired_memoizeCapped = 1;
  var memoize2 = requireMemoize();
  var MAX_MEMOIZE_SIZE2 = 500;
  function memoizeCapped2(func) {
    var result = memoize2(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE2) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  _memoizeCapped = memoizeCapped2;
  return _memoizeCapped;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_stringToPath.js
var _stringToPath;
var hasRequired_stringToPath;
function require_stringToPath() {
  if (hasRequired_stringToPath)
    return _stringToPath;
  hasRequired_stringToPath = 1;
  var memoizeCapped2 = require_memoizeCapped();
  var rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar2 = /\\(\\)?/g;
  var stringToPath2 = memoizeCapped2(function(string2) {
    var result = [];
    if (string2.charCodeAt(0) === 46) {
      result.push("");
    }
    string2.replace(rePropName2, function(match, number5, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar2, "$1") : number5 || match);
    });
    return result;
  });
  _stringToPath = stringToPath2;
  return _stringToPath;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_arrayMap.js
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap)
    return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap2(array3, iteratee) {
    var index2 = -1, length = array3 == null ? 0 : array3.length, result = Array(length);
    while (++index2 < length) {
      result[index2] = iteratee(array3[index2], index2, array3);
    }
    return result;
  }
  _arrayMap = arrayMap2;
  return _arrayMap;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseToString.js
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString)
    return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol3 = require_Symbol(), arrayMap2 = require_arrayMap(), isArray2 = requireIsArray(), isSymbol2 = requireIsSymbol();
  var symbolProto3 = Symbol3 ? Symbol3.prototype : void 0, symbolToString2 = symbolProto3 ? symbolProto3.toString : void 0;
  function baseToString2(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray2(value)) {
      return arrayMap2(value, baseToString2) + "";
    }
    if (isSymbol2(value)) {
      return symbolToString2 ? symbolToString2.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  _baseToString = baseToString2;
  return _baseToString;
}

// node_modules/@antv/layout/lib/node_modules/lodash/toString.js
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString)
    return toString_1;
  hasRequiredToString = 1;
  var baseToString2 = require_baseToString();
  function toString3(value) {
    return value == null ? "" : baseToString2(value);
  }
  toString_1 = toString3;
  return toString_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_castPath.js
var _castPath;
var hasRequired_castPath;
function require_castPath() {
  if (hasRequired_castPath)
    return _castPath;
  hasRequired_castPath = 1;
  var isArray2 = requireIsArray(), isKey2 = require_isKey(), stringToPath2 = require_stringToPath(), toString3 = requireToString();
  function castPath2(value, object2) {
    if (isArray2(value)) {
      return value;
    }
    return isKey2(value, object2) ? [value] : stringToPath2(toString3(value));
  }
  _castPath = castPath2;
  return _castPath;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_toKey.js
var _toKey;
var hasRequired_toKey;
function require_toKey() {
  if (hasRequired_toKey)
    return _toKey;
  hasRequired_toKey = 1;
  var isSymbol2 = requireIsSymbol();
  function toKey2(value) {
    if (typeof value == "string" || isSymbol2(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  _toKey = toKey2;
  return _toKey;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseGet.js
var _baseGet;
var hasRequired_baseGet;
function require_baseGet() {
  if (hasRequired_baseGet)
    return _baseGet;
  hasRequired_baseGet = 1;
  var castPath2 = require_castPath(), toKey2 = require_toKey();
  function baseGet2(object2, path2) {
    path2 = castPath2(path2, object2);
    var index2 = 0, length = path2.length;
    while (object2 != null && index2 < length) {
      object2 = object2[toKey2(path2[index2++])];
    }
    return index2 && index2 == length ? object2 : void 0;
  }
  _baseGet = baseGet2;
  return _baseGet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/get.js
var get_1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet)
    return get_1;
  hasRequiredGet = 1;
  var baseGet2 = require_baseGet();
  function get4(object2, path2, defaultValue) {
    var result = object2 == null ? void 0 : baseGet2(object2, path2);
    return result === void 0 ? defaultValue : result;
  }
  get_1 = get4;
  return get_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseHasIn.js
var _baseHasIn;
var hasRequired_baseHasIn;
function require_baseHasIn() {
  if (hasRequired_baseHasIn)
    return _baseHasIn;
  hasRequired_baseHasIn = 1;
  function baseHasIn(object2, key) {
    return object2 != null && key in Object(object2);
  }
  _baseHasIn = baseHasIn;
  return _baseHasIn;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_hasPath.js
var _hasPath;
var hasRequired_hasPath;
function require_hasPath() {
  if (hasRequired_hasPath)
    return _hasPath;
  hasRequired_hasPath = 1;
  var castPath2 = require_castPath(), isArguments2 = requireIsArguments(), isArray2 = requireIsArray(), isIndex2 = require_isIndex(), isLength2 = requireIsLength(), toKey2 = require_toKey();
  function hasPath(object2, path2, hasFunc) {
    path2 = castPath2(path2, object2);
    var index2 = -1, length = path2.length, result = false;
    while (++index2 < length) {
      var key = toKey2(path2[index2]);
      if (!(result = object2 != null && hasFunc(object2, key))) {
        break;
      }
      object2 = object2[key];
    }
    if (result || ++index2 != length) {
      return result;
    }
    length = object2 == null ? 0 : object2.length;
    return !!length && isLength2(length) && isIndex2(key, length) && (isArray2(object2) || isArguments2(object2));
  }
  _hasPath = hasPath;
  return _hasPath;
}

// node_modules/@antv/layout/lib/node_modules/lodash/hasIn.js
var hasIn_1;
var hasRequiredHasIn;
function requireHasIn() {
  if (hasRequiredHasIn)
    return hasIn_1;
  hasRequiredHasIn = 1;
  var baseHasIn = require_baseHasIn(), hasPath = require_hasPath();
  function hasIn(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHasIn);
  }
  hasIn_1 = hasIn;
  return hasIn_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseMatchesProperty.js
var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;
function require_baseMatchesProperty() {
  if (hasRequired_baseMatchesProperty)
    return _baseMatchesProperty;
  hasRequired_baseMatchesProperty = 1;
  var baseIsEqual = require_baseIsEqual(), get4 = requireGet(), hasIn = requireHasIn(), isKey2 = require_isKey(), isStrictComparable = require_isStrictComparable(), matchesStrictComparable = require_matchesStrictComparable(), toKey2 = require_toKey();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path2, srcValue) {
    if (isKey2(path2) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey2(path2), srcValue);
    }
    return function(object2) {
      var objValue = get4(object2, path2);
      return objValue === void 0 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  _baseMatchesProperty = baseMatchesProperty;
  return _baseMatchesProperty;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseProperty.js
var _baseProperty;
var hasRequired_baseProperty;
function require_baseProperty() {
  if (hasRequired_baseProperty)
    return _baseProperty;
  hasRequired_baseProperty = 1;
  function baseProperty(key) {
    return function(object2) {
      return object2 == null ? void 0 : object2[key];
    };
  }
  _baseProperty = baseProperty;
  return _baseProperty;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_basePropertyDeep.js
var _basePropertyDeep;
var hasRequired_basePropertyDeep;
function require_basePropertyDeep() {
  if (hasRequired_basePropertyDeep)
    return _basePropertyDeep;
  hasRequired_basePropertyDeep = 1;
  var baseGet2 = require_baseGet();
  function basePropertyDeep(path2) {
    return function(object2) {
      return baseGet2(object2, path2);
    };
  }
  _basePropertyDeep = basePropertyDeep;
  return _basePropertyDeep;
}

// node_modules/@antv/layout/lib/node_modules/lodash/property.js
var property_1;
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty)
    return property_1;
  hasRequiredProperty = 1;
  var baseProperty = require_baseProperty(), basePropertyDeep = require_basePropertyDeep(), isKey2 = require_isKey(), toKey2 = require_toKey();
  function property(path2) {
    return isKey2(path2) ? baseProperty(toKey2(path2)) : basePropertyDeep(path2);
  }
  property_1 = property;
  return property_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseIteratee.js
var _baseIteratee;
var hasRequired_baseIteratee;
function require_baseIteratee() {
  if (hasRequired_baseIteratee)
    return _baseIteratee;
  hasRequired_baseIteratee = 1;
  var baseMatches = require_baseMatches(), baseMatchesProperty = require_baseMatchesProperty(), identity6 = requireIdentity(), isArray2 = requireIsArray(), property = requireProperty();
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity6;
    }
    if (typeof value == "object") {
      return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  _baseIteratee = baseIteratee;
  return _baseIteratee;
}

// node_modules/@antv/layout/lib/node_modules/lodash/filter.js
var filter_1;
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter)
    return filter_1;
  hasRequiredFilter = 1;
  var arrayFilter2 = require_arrayFilter(), baseFilter = require_baseFilter(), baseIteratee = require_baseIteratee(), isArray2 = requireIsArray();
  function filter2(collection, predicate) {
    var func = isArray2(collection) ? arrayFilter2 : baseFilter;
    return func(collection, baseIteratee(predicate, 3));
  }
  filter_1 = filter2;
  return filter_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseHas.js
var _baseHas;
var hasRequired_baseHas;
function require_baseHas() {
  if (hasRequired_baseHas)
    return _baseHas;
  hasRequired_baseHas = 1;
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  function baseHas(object2, key) {
    return object2 != null && hasOwnProperty13.call(object2, key);
  }
  _baseHas = baseHas;
  return _baseHas;
}

// node_modules/@antv/layout/lib/node_modules/lodash/has.js
var has_1;
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas)
    return has_1;
  hasRequiredHas = 1;
  var baseHas = require_baseHas(), hasPath = require_hasPath();
  function has(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHas);
  }
  has_1 = has;
  return has_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isEmpty.js
var isEmpty_1;
var hasRequiredIsEmpty;
function requireIsEmpty() {
  if (hasRequiredIsEmpty)
    return isEmpty_1;
  hasRequiredIsEmpty = 1;
  var baseKeys2 = require_baseKeys(), getTag2 = require_getTag(), isArguments2 = requireIsArguments(), isArray2 = requireIsArray(), isArrayLike2 = requireIsArrayLike(), isBuffer3 = requireIsBuffer(), isPrototype2 = require_isPrototype(), isTypedArray2 = requireIsTypedArray();
  var mapTag6 = "[object Map]", setTag6 = "[object Set]";
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer3(value) || isTypedArray2(value) || isArguments2(value))) {
      return !value.length;
    }
    var tag = getTag2(value);
    if (tag == mapTag6 || tag == setTag6) {
      return !value.size;
    }
    if (isPrototype2(value)) {
      return !baseKeys2(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty13.call(value, key)) {
        return false;
      }
    }
    return true;
  }
  isEmpty_1 = isEmpty;
  return isEmpty_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isUndefined.js
var isUndefined_1;
var hasRequiredIsUndefined;
function requireIsUndefined() {
  if (hasRequiredIsUndefined)
    return isUndefined_1;
  hasRequiredIsUndefined = 1;
  function isUndefined(value) {
    return value === void 0;
  }
  isUndefined_1 = isUndefined;
  return isUndefined_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseMap.js
var _baseMap;
var hasRequired_baseMap;
function require_baseMap() {
  if (hasRequired_baseMap)
    return _baseMap;
  hasRequired_baseMap = 1;
  var baseEach = require_baseEach(), isArrayLike2 = requireIsArrayLike();
  function baseMap(collection, iteratee) {
    var index2 = -1, result = isArrayLike2(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index2] = iteratee(value, key, collection2);
    });
    return result;
  }
  _baseMap = baseMap;
  return _baseMap;
}

// node_modules/@antv/layout/lib/node_modules/lodash/map.js
var map_1;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap)
    return map_1;
  hasRequiredMap = 1;
  var arrayMap2 = require_arrayMap(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), isArray2 = requireIsArray();
  function map2(collection, iteratee) {
    var func = isArray2(collection) ? arrayMap2 : baseMap;
    return func(collection, baseIteratee(iteratee, 3));
  }
  map_1 = map2;
  return map_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_arrayReduce.js
var _arrayReduce;
var hasRequired_arrayReduce;
function require_arrayReduce() {
  if (hasRequired_arrayReduce)
    return _arrayReduce;
  hasRequired_arrayReduce = 1;
  function arrayReduce2(array3, iteratee, accumulator, initAccum) {
    var index2 = -1, length = array3 == null ? 0 : array3.length;
    if (initAccum && length) {
      accumulator = array3[++index2];
    }
    while (++index2 < length) {
      accumulator = iteratee(accumulator, array3[index2], index2, array3);
    }
    return accumulator;
  }
  _arrayReduce = arrayReduce2;
  return _arrayReduce;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseReduce.js
var _baseReduce;
var hasRequired_baseReduce;
function require_baseReduce() {
  if (hasRequired_baseReduce)
    return _baseReduce;
  hasRequired_baseReduce = 1;
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index2, collection2) {
      accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
    });
    return accumulator;
  }
  _baseReduce = baseReduce;
  return _baseReduce;
}

// node_modules/@antv/layout/lib/node_modules/lodash/reduce.js
var reduce_1;
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce)
    return reduce_1;
  hasRequiredReduce = 1;
  var arrayReduce2 = require_arrayReduce(), baseEach = require_baseEach(), baseIteratee = require_baseIteratee(), baseReduce = require_baseReduce(), isArray2 = requireIsArray();
  function reduce(collection, iteratee, accumulator) {
    var func = isArray2(collection) ? arrayReduce2 : baseReduce, initAccum = arguments.length < 3;
    return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
  }
  reduce_1 = reduce;
  return reduce_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isString.js
var isString_1;
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString)
    return isString_1;
  hasRequiredIsString = 1;
  var baseGetTag2 = require_baseGetTag(), isArray2 = requireIsArray(), isObjectLike3 = requireIsObjectLike();
  var stringTag4 = "[object String]";
  function isString2(value) {
    return typeof value == "string" || !isArray2(value) && isObjectLike3(value) && baseGetTag2(value) == stringTag4;
  }
  isString_1 = isString2;
  return isString_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_asciiSize.js
var _asciiSize;
var hasRequired_asciiSize;
function require_asciiSize() {
  if (hasRequired_asciiSize)
    return _asciiSize;
  hasRequired_asciiSize = 1;
  var baseProperty = require_baseProperty();
  var asciiSize = baseProperty("length");
  _asciiSize = asciiSize;
  return _asciiSize;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_hasUnicode.js
var _hasUnicode;
var hasRequired_hasUnicode;
function require_hasUnicode() {
  if (hasRequired_hasUnicode)
    return _hasUnicode;
  hasRequired_hasUnicode = 1;
  var rsAstralRange4 = "\\ud800-\\udfff", rsComboMarksRange5 = "\\u0300-\\u036f", reComboHalfMarksRange5 = "\\ufe20-\\ufe2f", rsComboSymbolsRange5 = "\\u20d0-\\u20ff", rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5, rsVarRange4 = "\\ufe0e\\ufe0f";
  var rsZWJ4 = "\\u200d";
  var reHasUnicode2 = RegExp("[" + rsZWJ4 + rsAstralRange4 + rsComboRange5 + rsVarRange4 + "]");
  function hasUnicode2(string2) {
    return reHasUnicode2.test(string2);
  }
  _hasUnicode = hasUnicode2;
  return _hasUnicode;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_unicodeSize.js
var _unicodeSize;
var hasRequired_unicodeSize;
function require_unicodeSize() {
  if (hasRequired_unicodeSize)
    return _unicodeSize;
  hasRequired_unicodeSize = 1;
  var rsAstralRange4 = "\\ud800-\\udfff", rsComboMarksRange5 = "\\u0300-\\u036f", reComboHalfMarksRange5 = "\\ufe20-\\ufe2f", rsComboSymbolsRange5 = "\\u20d0-\\u20ff", rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5, rsVarRange4 = "\\ufe0e\\ufe0f";
  var rsAstral2 = "[" + rsAstralRange4 + "]", rsCombo4 = "[" + rsComboRange5 + "]", rsFitz3 = "\\ud83c[\\udffb-\\udfff]", rsModifier3 = "(?:" + rsCombo4 + "|" + rsFitz3 + ")", rsNonAstral3 = "[^" + rsAstralRange4 + "]", rsRegional3 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair3 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ4 = "\\u200d";
  var reOptMod3 = rsModifier3 + "?", rsOptVar3 = "[" + rsVarRange4 + "]?", rsOptJoin3 = "(?:" + rsZWJ4 + "(?:" + [rsNonAstral3, rsRegional3, rsSurrPair3].join("|") + ")" + rsOptVar3 + reOptMod3 + ")*", rsSeq3 = rsOptVar3 + reOptMod3 + rsOptJoin3, rsSymbol2 = "(?:" + [rsNonAstral3 + rsCombo4 + "?", rsCombo4, rsRegional3, rsSurrPair3, rsAstral2].join("|") + ")";
  var reUnicode2 = RegExp(rsFitz3 + "(?=" + rsFitz3 + ")|" + rsSymbol2 + rsSeq3, "g");
  function unicodeSize(string2) {
    var result = reUnicode2.lastIndex = 0;
    while (reUnicode2.test(string2)) {
      ++result;
    }
    return result;
  }
  _unicodeSize = unicodeSize;
  return _unicodeSize;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_stringSize.js
var _stringSize;
var hasRequired_stringSize;
function require_stringSize() {
  if (hasRequired_stringSize)
    return _stringSize;
  hasRequired_stringSize = 1;
  var asciiSize = require_asciiSize(), hasUnicode2 = require_hasUnicode(), unicodeSize = require_unicodeSize();
  function stringSize(string2) {
    return hasUnicode2(string2) ? unicodeSize(string2) : asciiSize(string2);
  }
  _stringSize = stringSize;
  return _stringSize;
}

// node_modules/@antv/layout/lib/node_modules/lodash/size.js
var size_1;
var hasRequiredSize;
function requireSize() {
  if (hasRequiredSize)
    return size_1;
  hasRequiredSize = 1;
  var baseKeys2 = require_baseKeys(), getTag2 = require_getTag(), isArrayLike2 = requireIsArrayLike(), isString2 = requireIsString(), stringSize = require_stringSize();
  var mapTag6 = "[object Map]", setTag6 = "[object Set]";
  function size(collection) {
    if (collection == null) {
      return 0;
    }
    if (isArrayLike2(collection)) {
      return isString2(collection) ? stringSize(collection) : collection.length;
    }
    var tag = getTag2(collection);
    if (tag == mapTag6 || tag == setTag6) {
      return collection.size;
    }
    return baseKeys2(collection).length;
  }
  size_1 = size;
  return size_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/transform.js
var transform_1;
var hasRequiredTransform;
function requireTransform() {
  if (hasRequiredTransform)
    return transform_1;
  hasRequiredTransform = 1;
  var arrayEach2 = require_arrayEach(), baseCreate2 = require_baseCreate(), baseForOwn = require_baseForOwn(), baseIteratee = require_baseIteratee(), getPrototype2 = require_getPrototype(), isArray2 = requireIsArray(), isBuffer3 = requireIsBuffer(), isFunction3 = requireIsFunction(), isObject3 = requireIsObject(), isTypedArray2 = requireIsTypedArray();
  function transform2(object2, iteratee, accumulator) {
    var isArr = isArray2(object2), isArrLike = isArr || isBuffer3(object2) || isTypedArray2(object2);
    iteratee = baseIteratee(iteratee, 4);
    if (accumulator == null) {
      var Ctor = object2 && object2.constructor;
      if (isArrLike) {
        accumulator = isArr ? new Ctor() : [];
      } else if (isObject3(object2)) {
        accumulator = isFunction3(Ctor) ? baseCreate2(getPrototype2(object2)) : {};
      } else {
        accumulator = {};
      }
    }
    (isArrLike ? arrayEach2 : baseForOwn)(object2, function(value, index2, object3) {
      return iteratee(accumulator, value, index2, object3);
    });
    return accumulator;
  }
  transform_1 = transform2;
  return transform_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_isFlattenable.js
var _isFlattenable;
var hasRequired_isFlattenable;
function require_isFlattenable() {
  if (hasRequired_isFlattenable)
    return _isFlattenable;
  hasRequired_isFlattenable = 1;
  var Symbol3 = require_Symbol(), isArguments2 = requireIsArguments(), isArray2 = requireIsArray();
  var spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray2(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  _isFlattenable = isFlattenable;
  return _isFlattenable;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseFlatten.js
var _baseFlatten;
var hasRequired_baseFlatten;
function require_baseFlatten() {
  if (hasRequired_baseFlatten)
    return _baseFlatten;
  hasRequired_baseFlatten = 1;
  var arrayPush2 = require_arrayPush(), isFlattenable = require_isFlattenable();
  function baseFlatten(array3, depth, predicate, isStrict, result) {
    var index2 = -1, length = array3.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length) {
      var value = array3[index2];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush2(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  _baseFlatten = baseFlatten;
  return _baseFlatten;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_apply.js
var _apply;
var hasRequired_apply;
function require_apply() {
  if (hasRequired_apply)
    return _apply;
  hasRequired_apply = 1;
  function apply2(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  _apply = apply2;
  return _apply;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_overRest.js
var _overRest;
var hasRequired_overRest;
function require_overRest() {
  if (hasRequired_overRest)
    return _overRest;
  hasRequired_overRest = 1;
  var apply2 = require_apply();
  var nativeMax3 = Math.max;
  function overRest2(func, start2, transform2) {
    start2 = nativeMax3(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax3(args.length - start2, 0), array3 = Array(length);
      while (++index2 < length) {
        array3[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform2(array3);
      return apply2(func, this, otherArgs);
    };
  }
  _overRest = overRest2;
  return _overRest;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseSetToString.js
var _baseSetToString;
var hasRequired_baseSetToString;
function require_baseSetToString() {
  if (hasRequired_baseSetToString)
    return _baseSetToString;
  hasRequired_baseSetToString = 1;
  var constant2 = requireConstant(), defineProperty2 = require_defineProperty(), identity6 = requireIdentity();
  var baseSetToString2 = !defineProperty2 ? identity6 : function(func, string2) {
    return defineProperty2(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string2),
      "writable": true
    });
  };
  _baseSetToString = baseSetToString2;
  return _baseSetToString;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_shortOut.js
var _shortOut;
var hasRequired_shortOut;
function require_shortOut() {
  if (hasRequired_shortOut)
    return _shortOut;
  hasRequired_shortOut = 1;
  var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
  var nativeNow2 = Date.now;
  function shortOut2(func) {
    var count2 = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count2 >= HOT_COUNT2) {
          return arguments[0];
        }
      } else {
        count2 = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  _shortOut = shortOut2;
  return _shortOut;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_setToString.js
var _setToString;
var hasRequired_setToString;
function require_setToString() {
  if (hasRequired_setToString)
    return _setToString;
  hasRequired_setToString = 1;
  var baseSetToString2 = require_baseSetToString(), shortOut2 = require_shortOut();
  var setToString2 = shortOut2(baseSetToString2);
  _setToString = setToString2;
  return _setToString;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseRest.js
var _baseRest;
var hasRequired_baseRest;
function require_baseRest() {
  if (hasRequired_baseRest)
    return _baseRest;
  hasRequired_baseRest = 1;
  var identity6 = requireIdentity(), overRest2 = require_overRest(), setToString2 = require_setToString();
  function baseRest2(func, start2) {
    return setToString2(overRest2(func, start2, identity6), func + "");
  }
  _baseRest = baseRest2;
  return _baseRest;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseFindIndex.js
var _baseFindIndex;
var hasRequired_baseFindIndex;
function require_baseFindIndex() {
  if (hasRequired_baseFindIndex)
    return _baseFindIndex;
  hasRequired_baseFindIndex = 1;
  function baseFindIndex(array3, predicate, fromIndex, fromRight) {
    var length = array3.length, index2 = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index2-- : ++index2 < length) {
      if (predicate(array3[index2], index2, array3)) {
        return index2;
      }
    }
    return -1;
  }
  _baseFindIndex = baseFindIndex;
  return _baseFindIndex;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseIsNaN.js
var _baseIsNaN;
var hasRequired_baseIsNaN;
function require_baseIsNaN() {
  if (hasRequired_baseIsNaN)
    return _baseIsNaN;
  hasRequired_baseIsNaN = 1;
  function baseIsNaN(value) {
    return value !== value;
  }
  _baseIsNaN = baseIsNaN;
  return _baseIsNaN;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_strictIndexOf.js
var _strictIndexOf;
var hasRequired_strictIndexOf;
function require_strictIndexOf() {
  if (hasRequired_strictIndexOf)
    return _strictIndexOf;
  hasRequired_strictIndexOf = 1;
  function strictIndexOf(array3, value, fromIndex) {
    var index2 = fromIndex - 1, length = array3.length;
    while (++index2 < length) {
      if (array3[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  _strictIndexOf = strictIndexOf;
  return _strictIndexOf;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseIndexOf.js
var _baseIndexOf;
var hasRequired_baseIndexOf;
function require_baseIndexOf() {
  if (hasRequired_baseIndexOf)
    return _baseIndexOf;
  hasRequired_baseIndexOf = 1;
  var baseFindIndex = require_baseFindIndex(), baseIsNaN = require_baseIsNaN(), strictIndexOf = require_strictIndexOf();
  function baseIndexOf(array3, value, fromIndex) {
    return value === value ? strictIndexOf(array3, value, fromIndex) : baseFindIndex(array3, baseIsNaN, fromIndex);
  }
  _baseIndexOf = baseIndexOf;
  return _baseIndexOf;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_arrayIncludes.js
var _arrayIncludes;
var hasRequired_arrayIncludes;
function require_arrayIncludes() {
  if (hasRequired_arrayIncludes)
    return _arrayIncludes;
  hasRequired_arrayIncludes = 1;
  var baseIndexOf = require_baseIndexOf();
  function arrayIncludes(array3, value) {
    var length = array3 == null ? 0 : array3.length;
    return !!length && baseIndexOf(array3, value, 0) > -1;
  }
  _arrayIncludes = arrayIncludes;
  return _arrayIncludes;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_arrayIncludesWith.js
var _arrayIncludesWith;
var hasRequired_arrayIncludesWith;
function require_arrayIncludesWith() {
  if (hasRequired_arrayIncludesWith)
    return _arrayIncludesWith;
  hasRequired_arrayIncludesWith = 1;
  function arrayIncludesWith(array3, value, comparator) {
    var index2 = -1, length = array3 == null ? 0 : array3.length;
    while (++index2 < length) {
      if (comparator(value, array3[index2])) {
        return true;
      }
    }
    return false;
  }
  _arrayIncludesWith = arrayIncludesWith;
  return _arrayIncludesWith;
}

// node_modules/@antv/layout/lib/node_modules/lodash/noop.js
var noop_1;
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop)
    return noop_1;
  hasRequiredNoop = 1;
  function noop2() {
  }
  noop_1 = noop2;
  return noop_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_createSet.js
var _createSet;
var hasRequired_createSet;
function require_createSet() {
  if (hasRequired_createSet)
    return _createSet;
  hasRequired_createSet = 1;
  var Set3 = require_Set(), noop2 = requireNoop(), setToArray = require_setToArray();
  var INFINITY4 = 1 / 0;
  var createSet = !(Set3 && 1 / setToArray(new Set3([, -0]))[1] == INFINITY4) ? noop2 : function(values) {
    return new Set3(values);
  };
  _createSet = createSet;
  return _createSet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseUniq.js
var _baseUniq;
var hasRequired_baseUniq;
function require_baseUniq() {
  if (hasRequired_baseUniq)
    return _baseUniq;
  hasRequired_baseUniq = 1;
  var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), cacheHas = require_cacheHas(), createSet = require_createSet(), setToArray = require_setToArray();
  var LARGE_ARRAY_SIZE2 = 200;
  function baseUniq(array3, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes, length = array3.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE2) {
      var set3 = iteratee ? null : createSet(array3);
      if (set3) {
        return setToArray(set3);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index2 < length) {
        var value = array3[index2], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  _baseUniq = baseUniq;
  return _baseUniq;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isArrayLikeObject.js
var isArrayLikeObject_1;
var hasRequiredIsArrayLikeObject;
function requireIsArrayLikeObject() {
  if (hasRequiredIsArrayLikeObject)
    return isArrayLikeObject_1;
  hasRequiredIsArrayLikeObject = 1;
  var isArrayLike2 = requireIsArrayLike(), isObjectLike3 = requireIsObjectLike();
  function isArrayLikeObject2(value) {
    return isObjectLike3(value) && isArrayLike2(value);
  }
  isArrayLikeObject_1 = isArrayLikeObject2;
  return isArrayLikeObject_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/union.js
var union_1;
var hasRequiredUnion;
function requireUnion() {
  if (hasRequiredUnion)
    return union_1;
  hasRequiredUnion = 1;
  var baseFlatten = require_baseFlatten(), baseRest2 = require_baseRest(), baseUniq = require_baseUniq(), isArrayLikeObject2 = requireIsArrayLikeObject();
  var union2 = baseRest2(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true));
  });
  union_1 = union2;
  return union_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseValues.js
var _baseValues;
var hasRequired_baseValues;
function require_baseValues() {
  if (hasRequired_baseValues)
    return _baseValues;
  hasRequired_baseValues = 1;
  var arrayMap2 = require_arrayMap();
  function baseValues(object2, props) {
    return arrayMap2(props, function(key) {
      return object2[key];
    });
  }
  _baseValues = baseValues;
  return _baseValues;
}

// node_modules/@antv/layout/lib/node_modules/lodash/values.js
var values_1;
var hasRequiredValues;
function requireValues() {
  if (hasRequiredValues)
    return values_1;
  hasRequiredValues = 1;
  var baseValues = require_baseValues(), keys2 = requireKeys();
  function values(object2) {
    return object2 == null ? [] : baseValues(object2, keys2(object2));
  }
  values_1 = values;
  return values_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/lodash.js
var lodash_1$1;
var hasRequiredLodash$1;
function requireLodash$1() {
  if (hasRequiredLodash$1)
    return lodash_1$1;
  hasRequiredLodash$1 = 1;
  var lodash;
  if (typeof commonjsRequire === "function") {
    try {
      lodash = {
        clone: requireClone(),
        constant: requireConstant(),
        each: requireEach(),
        filter: requireFilter(),
        has: requireHas(),
        isArray: requireIsArray(),
        isEmpty: requireIsEmpty(),
        isFunction: requireIsFunction(),
        isUndefined: requireIsUndefined(),
        keys: requireKeys(),
        map: requireMap(),
        reduce: requireReduce(),
        size: requireSize(),
        transform: requireTransform(),
        union: requireUnion(),
        values: requireValues()
      };
    } catch (e8) {
    }
  }
  if (!lodash) {
    lodash = window._;
  }
  lodash_1$1 = lodash;
  return lodash_1$1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/graph.js
var graph;
var hasRequiredGraph;
function requireGraph() {
  if (hasRequiredGraph)
    return graph;
  hasRequiredGraph = 1;
  var _2 = requireLodash$1();
  graph = Graph;
  var DEFAULT_EDGE_NAME = "\0";
  var GRAPH_NODE = "\0";
  var EDGE_KEY_DELIM = "";
  function Graph(opts) {
    this._isDirected = _2.has(opts, "directed") ? opts.directed : true;
    this._isMultigraph = _2.has(opts, "multigraph") ? opts.multigraph : false;
    this._isCompound = _2.has(opts, "compound") ? opts.compound : false;
    this._label = void 0;
    this._defaultNodeLabelFn = _2.constant(void 0);
    this._defaultEdgeLabelFn = _2.constant(void 0);
    this._nodes = {};
    if (this._isCompound) {
      this._parent = {};
      this._children = {};
      this._children[GRAPH_NODE] = {};
    }
    this._in = {};
    this._preds = {};
    this._out = {};
    this._sucs = {};
    this._edgeObjs = {};
    this._edgeLabels = {};
  }
  Graph.prototype._nodeCount = 0;
  Graph.prototype._edgeCount = 0;
  Graph.prototype.isDirected = function() {
    return this._isDirected;
  };
  Graph.prototype.isMultigraph = function() {
    return this._isMultigraph;
  };
  Graph.prototype.isCompound = function() {
    return this._isCompound;
  };
  Graph.prototype.setGraph = function(label) {
    this._label = label;
    return this;
  };
  Graph.prototype.graph = function() {
    return this._label;
  };
  Graph.prototype.setDefaultNodeLabel = function(newDefault) {
    if (!_2.isFunction(newDefault)) {
      newDefault = _2.constant(newDefault);
    }
    this._defaultNodeLabelFn = newDefault;
    return this;
  };
  Graph.prototype.nodeCount = function() {
    return this._nodeCount;
  };
  Graph.prototype.nodes = function() {
    return _2.keys(this._nodes);
  };
  Graph.prototype.sources = function() {
    var self2 = this;
    return _2.filter(this.nodes(), function(v2) {
      return _2.isEmpty(self2._in[v2]);
    });
  };
  Graph.prototype.sinks = function() {
    var self2 = this;
    return _2.filter(this.nodes(), function(v2) {
      return _2.isEmpty(self2._out[v2]);
    });
  };
  Graph.prototype.setNodes = function(vs, value) {
    var args = arguments;
    var self2 = this;
    _2.each(vs, function(v2) {
      if (args.length > 1) {
        self2.setNode(v2, value);
      } else {
        self2.setNode(v2);
      }
    });
    return this;
  };
  Graph.prototype.setNode = function(v2, value) {
    if (_2.has(this._nodes, v2)) {
      if (arguments.length > 1) {
        this._nodes[v2] = value;
      }
      return this;
    }
    this._nodes[v2] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v2);
    if (this._isCompound) {
      this._parent[v2] = GRAPH_NODE;
      this._children[v2] = {};
      this._children[GRAPH_NODE][v2] = true;
    }
    this._in[v2] = {};
    this._preds[v2] = {};
    this._out[v2] = {};
    this._sucs[v2] = {};
    ++this._nodeCount;
    return this;
  };
  Graph.prototype.node = function(v2) {
    return this._nodes[v2];
  };
  Graph.prototype.hasNode = function(v2) {
    return _2.has(this._nodes, v2);
  };
  Graph.prototype.removeNode = function(v2) {
    var self2 = this;
    if (_2.has(this._nodes, v2)) {
      var removeEdge = function(e8) {
        self2.removeEdge(self2._edgeObjs[e8]);
      };
      delete this._nodes[v2];
      if (this._isCompound) {
        this._removeFromParentsChildList(v2);
        delete this._parent[v2];
        _2.each(this.children(v2), function(child) {
          self2.setParent(child);
        });
        delete this._children[v2];
      }
      _2.each(_2.keys(this._in[v2]), removeEdge);
      delete this._in[v2];
      delete this._preds[v2];
      _2.each(_2.keys(this._out[v2]), removeEdge);
      delete this._out[v2];
      delete this._sucs[v2];
      --this._nodeCount;
    }
    return this;
  };
  Graph.prototype.setParent = function(v2, parent) {
    if (!this._isCompound) {
      throw new Error("Cannot set parent in a non-compound graph");
    }
    if (_2.isUndefined(parent)) {
      parent = GRAPH_NODE;
    } else {
      parent += "";
      for (var ancestor = parent; !_2.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
        if (ancestor === v2) {
          throw new Error("Setting " + parent + " as parent of " + v2 + " would create a cycle");
        }
      }
      this.setNode(parent);
    }
    this.setNode(v2);
    this._removeFromParentsChildList(v2);
    this._parent[v2] = parent;
    this._children[parent][v2] = true;
    return this;
  };
  Graph.prototype._removeFromParentsChildList = function(v2) {
    delete this._children[this._parent[v2]][v2];
  };
  Graph.prototype.parent = function(v2) {
    if (this._isCompound) {
      var parent = this._parent[v2];
      if (parent !== GRAPH_NODE) {
        return parent;
      }
    }
  };
  Graph.prototype.children = function(v2) {
    if (_2.isUndefined(v2)) {
      v2 = GRAPH_NODE;
    }
    if (this._isCompound) {
      var children2 = this._children[v2];
      if (children2) {
        return _2.keys(children2);
      }
    } else if (v2 === GRAPH_NODE) {
      return this.nodes();
    } else if (this.hasNode(v2)) {
      return [];
    }
  };
  Graph.prototype.predecessors = function(v2) {
    var predsV = this._preds[v2];
    if (predsV) {
      return _2.keys(predsV);
    }
  };
  Graph.prototype.successors = function(v2) {
    var sucsV = this._sucs[v2];
    if (sucsV) {
      return _2.keys(sucsV);
    }
  };
  Graph.prototype.neighbors = function(v2) {
    var preds = this.predecessors(v2);
    if (preds) {
      return _2.union(preds, this.successors(v2));
    }
  };
  Graph.prototype.isLeaf = function(v2) {
    var neighbors;
    if (this.isDirected()) {
      neighbors = this.successors(v2);
    } else {
      neighbors = this.neighbors(v2);
    }
    return neighbors.length === 0;
  };
  Graph.prototype.filterNodes = function(filter2) {
    var copy2 = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    copy2.setGraph(this.graph());
    var self2 = this;
    _2.each(this._nodes, function(value, v2) {
      if (filter2(v2)) {
        copy2.setNode(v2, value);
      }
    });
    _2.each(this._edgeObjs, function(e8) {
      if (copy2.hasNode(e8.v) && copy2.hasNode(e8.w)) {
        copy2.setEdge(e8, self2.edge(e8));
      }
    });
    var parents = {};
    function findParent(v2) {
      var parent = self2.parent(v2);
      if (parent === void 0 || copy2.hasNode(parent)) {
        parents[v2] = parent;
        return parent;
      } else if (parent in parents) {
        return parents[parent];
      } else {
        return findParent(parent);
      }
    }
    if (this._isCompound) {
      _2.each(copy2.nodes(), function(v2) {
        copy2.setParent(v2, findParent(v2));
      });
    }
    return copy2;
  };
  Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
    if (!_2.isFunction(newDefault)) {
      newDefault = _2.constant(newDefault);
    }
    this._defaultEdgeLabelFn = newDefault;
    return this;
  };
  Graph.prototype.edgeCount = function() {
    return this._edgeCount;
  };
  Graph.prototype.edges = function() {
    return _2.values(this._edgeObjs);
  };
  Graph.prototype.setPath = function(vs, value) {
    var self2 = this;
    var args = arguments;
    _2.reduce(vs, function(v2, w3) {
      if (args.length > 1) {
        self2.setEdge(v2, w3, value);
      } else {
        self2.setEdge(v2, w3);
      }
      return w3;
    });
    return this;
  };
  Graph.prototype.setEdge = function() {
    var v2, w3, name, value;
    var valueSpecified = false;
    var arg0 = arguments[0];
    if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
      v2 = arg0.v;
      w3 = arg0.w;
      name = arg0.name;
      if (arguments.length === 2) {
        value = arguments[1];
        valueSpecified = true;
      }
    } else {
      v2 = arg0;
      w3 = arguments[1];
      name = arguments[3];
      if (arguments.length > 2) {
        value = arguments[2];
        valueSpecified = true;
      }
    }
    v2 = "" + v2;
    w3 = "" + w3;
    if (!_2.isUndefined(name)) {
      name = "" + name;
    }
    var e8 = edgeArgsToId(this._isDirected, v2, w3, name);
    if (_2.has(this._edgeLabels, e8)) {
      if (valueSpecified) {
        this._edgeLabels[e8] = value;
      }
      return this;
    }
    if (!_2.isUndefined(name) && !this._isMultigraph) {
      throw new Error("Cannot set a named edge when isMultigraph = false");
    }
    this.setNode(v2);
    this.setNode(w3);
    this._edgeLabels[e8] = valueSpecified ? value : this._defaultEdgeLabelFn(v2, w3, name);
    var edgeObj = edgeArgsToObj(this._isDirected, v2, w3, name);
    v2 = edgeObj.v;
    w3 = edgeObj.w;
    Object.freeze(edgeObj);
    this._edgeObjs[e8] = edgeObj;
    incrementOrInitEntry(this._preds[w3], v2);
    incrementOrInitEntry(this._sucs[v2], w3);
    this._in[w3][e8] = edgeObj;
    this._out[v2][e8] = edgeObj;
    this._edgeCount++;
    return this;
  };
  Graph.prototype.edge = function(v2, w3, name) {
    var e8 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w3, name);
    return this._edgeLabels[e8];
  };
  Graph.prototype.hasEdge = function(v2, w3, name) {
    var e8 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w3, name);
    return _2.has(this._edgeLabels, e8);
  };
  Graph.prototype.removeEdge = function(v2, w3, name) {
    var e8 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w3, name);
    var edge = this._edgeObjs[e8];
    if (edge) {
      v2 = edge.v;
      w3 = edge.w;
      delete this._edgeLabels[e8];
      delete this._edgeObjs[e8];
      decrementOrRemoveEntry(this._preds[w3], v2);
      decrementOrRemoveEntry(this._sucs[v2], w3);
      delete this._in[w3][e8];
      delete this._out[v2][e8];
      this._edgeCount--;
    }
    return this;
  };
  Graph.prototype.inEdges = function(v2, u4) {
    var inV = this._in[v2];
    if (inV) {
      var edges = _2.values(inV);
      if (!u4) {
        return edges;
      }
      return _2.filter(edges, function(edge) {
        return edge.v === u4;
      });
    }
  };
  Graph.prototype.outEdges = function(v2, w3) {
    var outV = this._out[v2];
    if (outV) {
      var edges = _2.values(outV);
      if (!w3) {
        return edges;
      }
      return _2.filter(edges, function(edge) {
        return edge.w === w3;
      });
    }
  };
  Graph.prototype.nodeEdges = function(v2, w3) {
    var inEdges = this.inEdges(v2, w3);
    if (inEdges) {
      return inEdges.concat(this.outEdges(v2, w3));
    }
  };
  function incrementOrInitEntry(map2, k5) {
    if (map2[k5]) {
      map2[k5]++;
    } else {
      map2[k5] = 1;
    }
  }
  function decrementOrRemoveEntry(map2, k5) {
    if (!--map2[k5]) {
      delete map2[k5];
    }
  }
  function edgeArgsToId(isDirected, v_, w_, name) {
    var v2 = "" + v_;
    var w3 = "" + w_;
    if (!isDirected && v2 > w3) {
      var tmp = v2;
      v2 = w3;
      w3 = tmp;
    }
    return v2 + EDGE_KEY_DELIM + w3 + EDGE_KEY_DELIM + (_2.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
  }
  function edgeArgsToObj(isDirected, v_, w_, name) {
    var v2 = "" + v_;
    var w3 = "" + w_;
    if (!isDirected && v2 > w3) {
      var tmp = v2;
      v2 = w3;
      w3 = tmp;
    }
    var edgeObj = { v: v2, w: w3 };
    if (name) {
      edgeObj.name = name;
    }
    return edgeObj;
  }
  function edgeObjToId(isDirected, edgeObj) {
    return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
  }
  return graph;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/version.js
var version$1;
var hasRequiredVersion$1;
function requireVersion$1() {
  if (hasRequiredVersion$1)
    return version$1;
  hasRequiredVersion$1 = 1;
  version$1 = "2.1.8";
  return version$1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/index.js
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib)
    return lib;
  hasRequiredLib = 1;
  lib = {
    Graph: requireGraph(),
    version: requireVersion$1()
  };
  return lib;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/json.js
var json;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson)
    return json;
  hasRequiredJson = 1;
  var _2 = requireLodash$1();
  var Graph = requireGraph();
  json = {
    write,
    read
  };
  function write(g3) {
    var json2 = {
      options: {
        directed: g3.isDirected(),
        multigraph: g3.isMultigraph(),
        compound: g3.isCompound()
      },
      nodes: writeNodes(g3),
      edges: writeEdges(g3)
    };
    if (!_2.isUndefined(g3.graph())) {
      json2.value = _2.clone(g3.graph());
    }
    return json2;
  }
  function writeNodes(g3) {
    return _2.map(g3.nodes(), function(v2) {
      var nodeValue = g3.node(v2);
      var parent = g3.parent(v2);
      var node = { v: v2 };
      if (!_2.isUndefined(nodeValue)) {
        node.value = nodeValue;
      }
      if (!_2.isUndefined(parent)) {
        node.parent = parent;
      }
      return node;
    });
  }
  function writeEdges(g3) {
    return _2.map(g3.edges(), function(e8) {
      var edgeValue = g3.edge(e8);
      var edge = { v: e8.v, w: e8.w };
      if (!_2.isUndefined(e8.name)) {
        edge.name = e8.name;
      }
      if (!_2.isUndefined(edgeValue)) {
        edge.value = edgeValue;
      }
      return edge;
    });
  }
  function read(json2) {
    var g3 = new Graph(json2.options).setGraph(json2.value);
    _2.each(json2.nodes, function(entry) {
      g3.setNode(entry.v, entry.value);
      if (entry.parent) {
        g3.setParent(entry.v, entry.parent);
      }
    });
    _2.each(json2.edges, function(entry) {
      g3.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
    });
    return g3;
  }
  return json;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/components.js
var components_1;
var hasRequiredComponents;
function requireComponents() {
  if (hasRequiredComponents)
    return components_1;
  hasRequiredComponents = 1;
  var _2 = requireLodash$1();
  components_1 = components;
  function components(g3) {
    var visited = {};
    var cmpts = [];
    var cmpt;
    function dfs(v2) {
      if (_2.has(visited, v2))
        return;
      visited[v2] = true;
      cmpt.push(v2);
      _2.each(g3.successors(v2), dfs);
      _2.each(g3.predecessors(v2), dfs);
    }
    _2.each(g3.nodes(), function(v2) {
      cmpt = [];
      dfs(v2);
      if (cmpt.length) {
        cmpts.push(cmpt);
      }
    });
    return cmpts;
  }
  return components_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/data/priority-queue.js
var priorityQueue;
var hasRequiredPriorityQueue;
function requirePriorityQueue() {
  if (hasRequiredPriorityQueue)
    return priorityQueue;
  hasRequiredPriorityQueue = 1;
  var _2 = requireLodash$1();
  priorityQueue = PriorityQueue;
  function PriorityQueue() {
    this._arr = [];
    this._keyIndices = {};
  }
  PriorityQueue.prototype.size = function() {
    return this._arr.length;
  };
  PriorityQueue.prototype.keys = function() {
    return this._arr.map(function(x6) {
      return x6.key;
    });
  };
  PriorityQueue.prototype.has = function(key) {
    return _2.has(this._keyIndices, key);
  };
  PriorityQueue.prototype.priority = function(key) {
    var index2 = this._keyIndices[key];
    if (index2 !== void 0) {
      return this._arr[index2].priority;
    }
  };
  PriorityQueue.prototype.min = function() {
    if (this.size() === 0) {
      throw new Error("Queue underflow");
    }
    return this._arr[0].key;
  };
  PriorityQueue.prototype.add = function(key, priority) {
    var keyIndices = this._keyIndices;
    key = String(key);
    if (!_2.has(keyIndices, key)) {
      var arr = this._arr;
      var index2 = arr.length;
      keyIndices[key] = index2;
      arr.push({ key, priority });
      this._decrease(index2);
      return true;
    }
    return false;
  };
  PriorityQueue.prototype.removeMin = function() {
    this._swap(0, this._arr.length - 1);
    var min3 = this._arr.pop();
    delete this._keyIndices[min3.key];
    this._heapify(0);
    return min3.key;
  };
  PriorityQueue.prototype.decrease = function(key, priority) {
    var index2 = this._keyIndices[key];
    if (priority > this._arr[index2].priority) {
      throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
    }
    this._arr[index2].priority = priority;
    this._decrease(index2);
  };
  PriorityQueue.prototype._heapify = function(i4) {
    var arr = this._arr;
    var l3 = 2 * i4;
    var r5 = l3 + 1;
    var largest = i4;
    if (l3 < arr.length) {
      largest = arr[l3].priority < arr[largest].priority ? l3 : largest;
      if (r5 < arr.length) {
        largest = arr[r5].priority < arr[largest].priority ? r5 : largest;
      }
      if (largest !== i4) {
        this._swap(i4, largest);
        this._heapify(largest);
      }
    }
  };
  PriorityQueue.prototype._decrease = function(index2) {
    var arr = this._arr;
    var priority = arr[index2].priority;
    var parent;
    while (index2 !== 0) {
      parent = index2 >> 1;
      if (arr[parent].priority < priority) {
        break;
      }
      this._swap(index2, parent);
      index2 = parent;
    }
  };
  PriorityQueue.prototype._swap = function(i4, j2) {
    var arr = this._arr;
    var keyIndices = this._keyIndices;
    var origArrI = arr[i4];
    var origArrJ = arr[j2];
    arr[i4] = origArrJ;
    arr[j2] = origArrI;
    keyIndices[origArrJ.key] = i4;
    keyIndices[origArrI.key] = j2;
  };
  return priorityQueue;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/dijkstra.js
var dijkstra_1;
var hasRequiredDijkstra;
function requireDijkstra() {
  if (hasRequiredDijkstra)
    return dijkstra_1;
  hasRequiredDijkstra = 1;
  var _2 = requireLodash$1();
  var PriorityQueue = requirePriorityQueue();
  dijkstra_1 = dijkstra;
  var DEFAULT_WEIGHT_FUNC = _2.constant(1);
  function dijkstra(g3, source, weightFn, edgeFn) {
    return runDijkstra(
      g3,
      String(source),
      weightFn || DEFAULT_WEIGHT_FUNC,
      edgeFn || function(v2) {
        return g3.outEdges(v2);
      }
    );
  }
  function runDijkstra(g3, source, weightFn, edgeFn) {
    var results = {};
    var pq = new PriorityQueue();
    var v2, vEntry;
    var updateNeighbors = function(edge) {
      var w3 = edge.v !== v2 ? edge.v : edge.w;
      var wEntry = results[w3];
      var weight = weightFn(edge);
      var distance = vEntry.distance + weight;
      if (weight < 0) {
        throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
      }
      if (distance < wEntry.distance) {
        wEntry.distance = distance;
        wEntry.predecessor = v2;
        pq.decrease(w3, distance);
      }
    };
    g3.nodes().forEach(function(v3) {
      var distance = v3 === source ? 0 : Number.POSITIVE_INFINITY;
      results[v3] = { distance };
      pq.add(v3, distance);
    });
    while (pq.size() > 0) {
      v2 = pq.removeMin();
      vEntry = results[v2];
      if (vEntry.distance === Number.POSITIVE_INFINITY) {
        break;
      }
      edgeFn(v2).forEach(updateNeighbors);
    }
    return results;
  }
  return dijkstra_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/dijkstra-all.js
var dijkstraAll_1;
var hasRequiredDijkstraAll;
function requireDijkstraAll() {
  if (hasRequiredDijkstraAll)
    return dijkstraAll_1;
  hasRequiredDijkstraAll = 1;
  var dijkstra = requireDijkstra();
  var _2 = requireLodash$1();
  dijkstraAll_1 = dijkstraAll;
  function dijkstraAll(g3, weightFunc, edgeFunc) {
    return _2.transform(g3.nodes(), function(acc, v2) {
      acc[v2] = dijkstra(g3, v2, weightFunc, edgeFunc);
    }, {});
  }
  return dijkstraAll_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/tarjan.js
var tarjan_1;
var hasRequiredTarjan;
function requireTarjan() {
  if (hasRequiredTarjan)
    return tarjan_1;
  hasRequiredTarjan = 1;
  var _2 = requireLodash$1();
  tarjan_1 = tarjan;
  function tarjan(g3) {
    var index2 = 0;
    var stack = [];
    var visited = {};
    var results = [];
    function dfs(v2) {
      var entry = visited[v2] = {
        onStack: true,
        lowlink: index2,
        index: index2++
      };
      stack.push(v2);
      g3.successors(v2).forEach(function(w4) {
        if (!_2.has(visited, w4)) {
          dfs(w4);
          entry.lowlink = Math.min(entry.lowlink, visited[w4].lowlink);
        } else if (visited[w4].onStack) {
          entry.lowlink = Math.min(entry.lowlink, visited[w4].index);
        }
      });
      if (entry.lowlink === entry.index) {
        var cmpt = [];
        var w3;
        do {
          w3 = stack.pop();
          visited[w3].onStack = false;
          cmpt.push(w3);
        } while (v2 !== w3);
        results.push(cmpt);
      }
    }
    g3.nodes().forEach(function(v2) {
      if (!_2.has(visited, v2)) {
        dfs(v2);
      }
    });
    return results;
  }
  return tarjan_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/find-cycles.js
var findCycles_1;
var hasRequiredFindCycles;
function requireFindCycles() {
  if (hasRequiredFindCycles)
    return findCycles_1;
  hasRequiredFindCycles = 1;
  var _2 = requireLodash$1();
  var tarjan = requireTarjan();
  findCycles_1 = findCycles;
  function findCycles(g3) {
    return _2.filter(tarjan(g3), function(cmpt) {
      return cmpt.length > 1 || cmpt.length === 1 && g3.hasEdge(cmpt[0], cmpt[0]);
    });
  }
  return findCycles_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/floyd-warshall.js
var floydWarshall_1;
var hasRequiredFloydWarshall;
function requireFloydWarshall() {
  if (hasRequiredFloydWarshall)
    return floydWarshall_1;
  hasRequiredFloydWarshall = 1;
  var _2 = requireLodash$1();
  floydWarshall_1 = floydWarshall;
  var DEFAULT_WEIGHT_FUNC = _2.constant(1);
  function floydWarshall(g3, weightFn, edgeFn) {
    return runFloydWarshall(
      g3,
      weightFn || DEFAULT_WEIGHT_FUNC,
      edgeFn || function(v2) {
        return g3.outEdges(v2);
      }
    );
  }
  function runFloydWarshall(g3, weightFn, edgeFn) {
    var results = {};
    var nodes = g3.nodes();
    nodes.forEach(function(v2) {
      results[v2] = {};
      results[v2][v2] = { distance: 0 };
      nodes.forEach(function(w3) {
        if (v2 !== w3) {
          results[v2][w3] = { distance: Number.POSITIVE_INFINITY };
        }
      });
      edgeFn(v2).forEach(function(edge) {
        var w3 = edge.v === v2 ? edge.w : edge.v;
        var d3 = weightFn(edge);
        results[v2][w3] = { distance: d3, predecessor: v2 };
      });
    });
    nodes.forEach(function(k5) {
      var rowK = results[k5];
      nodes.forEach(function(i4) {
        var rowI = results[i4];
        nodes.forEach(function(j2) {
          var ik = rowI[k5];
          var kj = rowK[j2];
          var ij = rowI[j2];
          var altDistance = ik.distance + kj.distance;
          if (altDistance < ij.distance) {
            ij.distance = altDistance;
            ij.predecessor = kj.predecessor;
          }
        });
      });
    });
    return results;
  }
  return floydWarshall_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/topsort.js
var topsort_1;
var hasRequiredTopsort;
function requireTopsort() {
  if (hasRequiredTopsort)
    return topsort_1;
  hasRequiredTopsort = 1;
  var _2 = requireLodash$1();
  topsort_1 = topsort;
  topsort.CycleException = CycleException;
  function topsort(g3) {
    var visited = {};
    var stack = {};
    var results = [];
    function visit(node) {
      if (_2.has(stack, node)) {
        throw new CycleException();
      }
      if (!_2.has(visited, node)) {
        stack[node] = true;
        visited[node] = true;
        _2.each(g3.predecessors(node), visit);
        delete stack[node];
        results.push(node);
      }
    }
    _2.each(g3.sinks(), visit);
    if (_2.size(visited) !== g3.nodeCount()) {
      throw new CycleException();
    }
    return results;
  }
  function CycleException() {
  }
  CycleException.prototype = new Error();
  return topsort_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/is-acyclic.js
var isAcyclic_1;
var hasRequiredIsAcyclic;
function requireIsAcyclic() {
  if (hasRequiredIsAcyclic)
    return isAcyclic_1;
  hasRequiredIsAcyclic = 1;
  var topsort = requireTopsort();
  isAcyclic_1 = isAcyclic;
  function isAcyclic(g3) {
    try {
      topsort(g3);
    } catch (e8) {
      if (e8 instanceof topsort.CycleException) {
        return false;
      }
      throw e8;
    }
    return true;
  }
  return isAcyclic_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/dfs.js
var dfs_1;
var hasRequiredDfs;
function requireDfs() {
  if (hasRequiredDfs)
    return dfs_1;
  hasRequiredDfs = 1;
  var _2 = requireLodash$1();
  dfs_1 = dfs;
  function dfs(g3, vs, order) {
    if (!_2.isArray(vs)) {
      vs = [vs];
    }
    var navigation = (g3.isDirected() ? g3.successors : g3.neighbors).bind(g3);
    var acc = [];
    var visited = {};
    _2.each(vs, function(v2) {
      if (!g3.hasNode(v2)) {
        throw new Error("Graph does not have node: " + v2);
      }
      doDfs(g3, v2, order === "post", visited, navigation, acc);
    });
    return acc;
  }
  function doDfs(g3, v2, postorder, visited, navigation, acc) {
    if (!_2.has(visited, v2)) {
      visited[v2] = true;
      if (!postorder) {
        acc.push(v2);
      }
      _2.each(navigation(v2), function(w3) {
        doDfs(g3, w3, postorder, visited, navigation, acc);
      });
      if (postorder) {
        acc.push(v2);
      }
    }
  }
  return dfs_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/postorder.js
var postorder_1;
var hasRequiredPostorder;
function requirePostorder() {
  if (hasRequiredPostorder)
    return postorder_1;
  hasRequiredPostorder = 1;
  var dfs = requireDfs();
  postorder_1 = postorder;
  function postorder(g3, vs) {
    return dfs(g3, vs, "post");
  }
  return postorder_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/preorder.js
var preorder_1;
var hasRequiredPreorder;
function requirePreorder() {
  if (hasRequiredPreorder)
    return preorder_1;
  hasRequiredPreorder = 1;
  var dfs = requireDfs();
  preorder_1 = preorder;
  function preorder(g3, vs) {
    return dfs(g3, vs, "pre");
  }
  return preorder_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/prim.js
var prim_1;
var hasRequiredPrim;
function requirePrim() {
  if (hasRequiredPrim)
    return prim_1;
  hasRequiredPrim = 1;
  var _2 = requireLodash$1();
  var Graph = requireGraph();
  var PriorityQueue = requirePriorityQueue();
  prim_1 = prim;
  function prim(g3, weightFunc) {
    var result = new Graph();
    var parents = {};
    var pq = new PriorityQueue();
    var v2;
    function updateNeighbors(edge) {
      var w3 = edge.v === v2 ? edge.w : edge.v;
      var pri = pq.priority(w3);
      if (pri !== void 0) {
        var edgeWeight = weightFunc(edge);
        if (edgeWeight < pri) {
          parents[w3] = v2;
          pq.decrease(w3, edgeWeight);
        }
      }
    }
    if (g3.nodeCount() === 0) {
      return result;
    }
    _2.each(g3.nodes(), function(v3) {
      pq.add(v3, Number.POSITIVE_INFINITY);
      result.setNode(v3);
    });
    pq.decrease(g3.nodes()[0], 0);
    var init2 = false;
    while (pq.size() > 0) {
      v2 = pq.removeMin();
      if (_2.has(parents, v2)) {
        result.setEdge(v2, parents[v2]);
      } else if (init2) {
        throw new Error("Input graph is not connected: " + g3);
      } else {
        init2 = true;
      }
      g3.nodeEdges(v2).forEach(updateNeighbors);
    }
    return result;
  }
  return prim_1;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/lib/alg/index.js
var alg;
var hasRequiredAlg;
function requireAlg() {
  if (hasRequiredAlg)
    return alg;
  hasRequiredAlg = 1;
  alg = {
    components: requireComponents(),
    dijkstra: requireDijkstra(),
    dijkstraAll: requireDijkstraAll(),
    findCycles: requireFindCycles(),
    floydWarshall: requireFloydWarshall(),
    isAcyclic: requireIsAcyclic(),
    postorder: requirePostorder(),
    preorder: requirePreorder(),
    prim: requirePrim(),
    tarjan: requireTarjan(),
    topsort: requireTopsort()
  };
  return alg;
}

// node_modules/@antv/layout/lib/node_modules/graphlib/index.js
var graphlib;
var hasRequiredGraphlib$1;
function requireGraphlib$1() {
  if (hasRequiredGraphlib$1)
    return graphlib;
  hasRequiredGraphlib$1 = 1;
  var lib2 = requireLib();
  graphlib = {
    Graph: lib2.Graph,
    json: requireJson(),
    alg: requireAlg(),
    version: lib2.version
  };
  return graphlib;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/graphlib.js
var graphlib_1;
var hasRequiredGraphlib;
function requireGraphlib() {
  if (hasRequiredGraphlib)
    return graphlib_1;
  hasRequiredGraphlib = 1;
  var graphlib2;
  if (typeof commonjsRequire === "function") {
    try {
      graphlib2 = requireGraphlib$1();
    } catch (e8) {
    }
  }
  if (!graphlib2) {
    graphlib2 = window.graphlib;
  }
  graphlib_1 = graphlib2;
  return graphlib_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/cloneDeep.js
var cloneDeep_1;
var hasRequiredCloneDeep;
function requireCloneDeep() {
  if (hasRequiredCloneDeep)
    return cloneDeep_1;
  hasRequiredCloneDeep = 1;
  var baseClone2 = require_baseClone();
  var CLONE_DEEP_FLAG3 = 1, CLONE_SYMBOLS_FLAG3 = 4;
  function cloneDeep2(value) {
    return baseClone2(value, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG3);
  }
  cloneDeep_1 = cloneDeep2;
  return cloneDeep_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_isIterateeCall.js
var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall)
    return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq2 = requireEq(), isArrayLike2 = requireIsArrayLike(), isIndex2 = require_isIndex(), isObject3 = requireIsObject();
  function isIterateeCall2(value, index2, object2) {
    if (!isObject3(object2)) {
      return false;
    }
    var type2 = typeof index2;
    if (type2 == "number" ? isArrayLike2(object2) && isIndex2(index2, object2.length) : type2 == "string" && index2 in object2) {
      return eq2(object2[index2], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall2;
  return _isIterateeCall;
}

// node_modules/@antv/layout/lib/node_modules/lodash/defaults.js
var defaults_1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults)
    return defaults_1;
  hasRequiredDefaults = 1;
  var baseRest2 = require_baseRest(), eq2 = requireEq(), isIterateeCall2 = require_isIterateeCall(), keysIn2 = requireKeysIn();
  var objectProto15 = Object.prototype;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  var defaults = baseRest2(function(object2, sources) {
    object2 = Object(object2);
    var index2 = -1;
    var length = sources.length;
    var guard = length > 2 ? sources[2] : void 0;
    if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
      length = 1;
    }
    while (++index2 < length) {
      var source = sources[index2];
      var props = keysIn2(source);
      var propsIndex = -1;
      var propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object2[key];
        if (value === void 0 || eq2(value, objectProto15[key]) && !hasOwnProperty13.call(object2, key)) {
          object2[key] = source[key];
        }
      }
    }
    return object2;
  });
  defaults_1 = defaults;
  return defaults_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_createFind.js
var _createFind;
var hasRequired_createFind;
function require_createFind() {
  if (hasRequired_createFind)
    return _createFind;
  hasRequired_createFind = 1;
  var baseIteratee = require_baseIteratee(), isArrayLike2 = requireIsArrayLike(), keys2 = requireKeys();
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike2(collection)) {
        var iteratee = baseIteratee(predicate, 3);
        collection = keys2(collection);
        predicate = function(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }
      var index2 = findIndexFunc(collection, predicate, fromIndex);
      return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
    };
  }
  _createFind = createFind;
  return _createFind;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_trimmedEndIndex.js
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex)
    return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace2 = /\s/;
  function trimmedEndIndex2(string2) {
    var index2 = string2.length;
    while (index2-- && reWhitespace2.test(string2.charAt(index2))) {
    }
    return index2;
  }
  _trimmedEndIndex = trimmedEndIndex2;
  return _trimmedEndIndex;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseTrim.js
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim)
    return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex2 = require_trimmedEndIndex();
  var reTrimStart2 = /^\s+/;
  function baseTrim2(string2) {
    return string2 ? string2.slice(0, trimmedEndIndex2(string2) + 1).replace(reTrimStart2, "") : string2;
  }
  _baseTrim = baseTrim2;
  return _baseTrim;
}

// node_modules/@antv/layout/lib/node_modules/lodash/toNumber.js
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber)
    return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim2 = require_baseTrim(), isObject3 = requireIsObject(), isSymbol2 = requireIsSymbol();
  var NAN2 = 0 / 0;
  var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary2 = /^0b[01]+$/i;
  var reIsOctal2 = /^0o[0-7]+$/i;
  var freeParseInt2 = parseInt;
  function toNumber2(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol2(value)) {
      return NAN2;
    }
    if (isObject3(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject3(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim2(value);
    var isBinary = reIsBinary2.test(value);
    return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
  }
  toNumber_1 = toNumber2;
  return toNumber_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/toFinite.js
var toFinite_1;
var hasRequiredToFinite;
function requireToFinite() {
  if (hasRequiredToFinite)
    return toFinite_1;
  hasRequiredToFinite = 1;
  var toNumber2 = requireToNumber();
  var INFINITY4 = 1 / 0, MAX_INTEGER2 = 17976931348623157e292;
  function toFinite2(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber2(value);
    if (value === INFINITY4 || value === -INFINITY4) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER2;
    }
    return value === value ? value : 0;
  }
  toFinite_1 = toFinite2;
  return toFinite_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/toInteger.js
var toInteger_1;
var hasRequiredToInteger;
function requireToInteger() {
  if (hasRequiredToInteger)
    return toInteger_1;
  hasRequiredToInteger = 1;
  var toFinite2 = requireToFinite();
  function toInteger(value) {
    var result = toFinite2(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  toInteger_1 = toInteger;
  return toInteger_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/findIndex.js
var findIndex_1;
var hasRequiredFindIndex;
function requireFindIndex() {
  if (hasRequiredFindIndex)
    return findIndex_1;
  hasRequiredFindIndex = 1;
  var baseFindIndex = require_baseFindIndex(), baseIteratee = require_baseIteratee(), toInteger = requireToInteger();
  var nativeMax3 = Math.max;
  function findIndex(array3, predicate, fromIndex) {
    var length = array3 == null ? 0 : array3.length;
    if (!length) {
      return -1;
    }
    var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index2 < 0) {
      index2 = nativeMax3(length + index2, 0);
    }
    return baseFindIndex(array3, baseIteratee(predicate, 3), index2);
  }
  findIndex_1 = findIndex;
  return findIndex_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/find.js
var find_1;
var hasRequiredFind;
function requireFind() {
  if (hasRequiredFind)
    return find_1;
  hasRequiredFind = 1;
  var createFind = require_createFind(), findIndex = requireFindIndex();
  var find3 = createFind(findIndex);
  find_1 = find3;
  return find_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/flatten.js
var flatten_1;
var hasRequiredFlatten;
function requireFlatten() {
  if (hasRequiredFlatten)
    return flatten_1;
  hasRequiredFlatten = 1;
  var baseFlatten = require_baseFlatten();
  function flatten(array3) {
    var length = array3 == null ? 0 : array3.length;
    return length ? baseFlatten(array3, 1) : [];
  }
  flatten_1 = flatten;
  return flatten_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/forIn.js
var forIn_1;
var hasRequiredForIn;
function requireForIn() {
  if (hasRequiredForIn)
    return forIn_1;
  hasRequiredForIn = 1;
  var baseFor2 = require_baseFor(), castFunction = require_castFunction(), keysIn2 = requireKeysIn();
  function forIn(object2, iteratee) {
    return object2 == null ? object2 : baseFor2(object2, castFunction(iteratee), keysIn2);
  }
  forIn_1 = forIn;
  return forIn_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/last.js
var last_1;
var hasRequiredLast;
function requireLast() {
  if (hasRequiredLast)
    return last_1;
  hasRequiredLast = 1;
  function last(array3) {
    var length = array3 == null ? 0 : array3.length;
    return length ? array3[length - 1] : void 0;
  }
  last_1 = last;
  return last_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/mapValues.js
var mapValues_1;
var hasRequiredMapValues;
function requireMapValues() {
  if (hasRequiredMapValues)
    return mapValues_1;
  hasRequiredMapValues = 1;
  var baseAssignValue2 = require_baseAssignValue(), baseForOwn = require_baseForOwn(), baseIteratee = require_baseIteratee();
  function mapValues(object2, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee, 3);
    baseForOwn(object2, function(value, key, object3) {
      baseAssignValue2(result, key, iteratee(value, key, object3));
    });
    return result;
  }
  mapValues_1 = mapValues;
  return mapValues_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseExtremum.js
var _baseExtremum;
var hasRequired_baseExtremum;
function require_baseExtremum() {
  if (hasRequired_baseExtremum)
    return _baseExtremum;
  hasRequired_baseExtremum = 1;
  var isSymbol2 = requireIsSymbol();
  function baseExtremum(array3, iteratee, comparator) {
    var index2 = -1, length = array3.length;
    while (++index2 < length) {
      var value = array3[index2], current = iteratee(value);
      if (current != null && (computed === void 0 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
        var computed = current, result = value;
      }
    }
    return result;
  }
  _baseExtremum = baseExtremum;
  return _baseExtremum;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseGt.js
var _baseGt;
var hasRequired_baseGt;
function require_baseGt() {
  if (hasRequired_baseGt)
    return _baseGt;
  hasRequired_baseGt = 1;
  function baseGt(value, other) {
    return value > other;
  }
  _baseGt = baseGt;
  return _baseGt;
}

// node_modules/@antv/layout/lib/node_modules/lodash/max.js
var max_1;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax)
    return max_1;
  hasRequiredMax = 1;
  var baseExtremum = require_baseExtremum(), baseGt = require_baseGt(), identity6 = requireIdentity();
  function max3(array3) {
    return array3 && array3.length ? baseExtremum(array3, identity6, baseGt) : void 0;
  }
  max_1 = max3;
  return max_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_assignMergeValue.js
var _assignMergeValue;
var hasRequired_assignMergeValue;
function require_assignMergeValue() {
  if (hasRequired_assignMergeValue)
    return _assignMergeValue;
  hasRequired_assignMergeValue = 1;
  var baseAssignValue2 = require_baseAssignValue(), eq2 = requireEq();
  function assignMergeValue2(object2, key, value) {
    if (value !== void 0 && !eq2(object2[key], value) || value === void 0 && !(key in object2)) {
      baseAssignValue2(object2, key, value);
    }
  }
  _assignMergeValue = assignMergeValue2;
  return _assignMergeValue;
}

// node_modules/@antv/layout/lib/node_modules/lodash/isPlainObject.js
var isPlainObject_1;
var hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject)
    return isPlainObject_1;
  hasRequiredIsPlainObject = 1;
  var baseGetTag2 = require_baseGetTag(), getPrototype2 = require_getPrototype(), isObjectLike3 = requireIsObjectLike();
  var objectTag5 = "[object Object]";
  var funcProto4 = Function.prototype, objectProto15 = Object.prototype;
  var funcToString4 = funcProto4.toString;
  var hasOwnProperty13 = objectProto15.hasOwnProperty;
  var objectCtorString2 = funcToString4.call(Object);
  function isPlainObject3(value) {
    if (!isObjectLike3(value) || baseGetTag2(value) != objectTag5) {
      return false;
    }
    var proto = getPrototype2(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty13.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString4.call(Ctor) == objectCtorString2;
  }
  isPlainObject_1 = isPlainObject3;
  return isPlainObject_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_safeGet.js
var _safeGet;
var hasRequired_safeGet;
function require_safeGet() {
  if (hasRequired_safeGet)
    return _safeGet;
  hasRequired_safeGet = 1;
  function safeGet2(object2, key) {
    if (key === "constructor" && typeof object2[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object2[key];
  }
  _safeGet = safeGet2;
  return _safeGet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/toPlainObject.js
var toPlainObject_1;
var hasRequiredToPlainObject;
function requireToPlainObject() {
  if (hasRequiredToPlainObject)
    return toPlainObject_1;
  hasRequiredToPlainObject = 1;
  var copyObject2 = require_copyObject(), keysIn2 = requireKeysIn();
  function toPlainObject2(value) {
    return copyObject2(value, keysIn2(value));
  }
  toPlainObject_1 = toPlainObject2;
  return toPlainObject_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseMergeDeep.js
var _baseMergeDeep;
var hasRequired_baseMergeDeep;
function require_baseMergeDeep() {
  if (hasRequired_baseMergeDeep)
    return _baseMergeDeep;
  hasRequired_baseMergeDeep = 1;
  var assignMergeValue2 = require_assignMergeValue(), cloneBuffer2 = require_cloneBuffer(), cloneTypedArray2 = require_cloneTypedArray(), copyArray2 = require_copyArray(), initCloneObject2 = require_initCloneObject(), isArguments2 = requireIsArguments(), isArray2 = requireIsArray(), isArrayLikeObject2 = requireIsArrayLikeObject(), isBuffer3 = requireIsBuffer(), isFunction3 = requireIsFunction(), isObject3 = requireIsObject(), isPlainObject3 = requireIsPlainObject(), isTypedArray2 = requireIsTypedArray(), safeGet2 = require_safeGet(), toPlainObject2 = requireToPlainObject();
  function baseMergeDeep2(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet2(object2, key), srcValue = safeGet2(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue2(object2, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer3(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray2(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject2(objValue)) {
          newValue = copyArray2(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer2(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray2(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject3(srcValue) || isArguments2(srcValue)) {
        newValue = objValue;
        if (isArguments2(objValue)) {
          newValue = toPlainObject2(objValue);
        } else if (!isObject3(objValue) || isFunction3(objValue)) {
          newValue = initCloneObject2(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue2(object2, key, newValue);
  }
  _baseMergeDeep = baseMergeDeep2;
  return _baseMergeDeep;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseMerge.js
var _baseMerge;
var hasRequired_baseMerge;
function require_baseMerge() {
  if (hasRequired_baseMerge)
    return _baseMerge;
  hasRequired_baseMerge = 1;
  var Stack2 = require_Stack(), assignMergeValue2 = require_assignMergeValue(), baseFor2 = require_baseFor(), baseMergeDeep2 = require_baseMergeDeep(), isObject3 = requireIsObject(), keysIn2 = requireKeysIn(), safeGet2 = require_safeGet();
  function baseMerge2(object2, source, srcIndex, customizer, stack) {
    if (object2 === source) {
      return;
    }
    baseFor2(source, function(srcValue, key) {
      stack || (stack = new Stack2());
      if (isObject3(srcValue)) {
        baseMergeDeep2(object2, source, key, srcIndex, baseMerge2, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet2(object2, key), srcValue, key + "", object2, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue2(object2, key, newValue);
      }
    }, keysIn2);
  }
  _baseMerge = baseMerge2;
  return _baseMerge;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_createAssigner.js
var _createAssigner;
var hasRequired_createAssigner;
function require_createAssigner() {
  if (hasRequired_createAssigner)
    return _createAssigner;
  hasRequired_createAssigner = 1;
  var baseRest2 = require_baseRest(), isIterateeCall2 = require_isIterateeCall();
  function createAssigner2(assigner) {
    return baseRest2(function(object2, sources) {
      var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object2 = Object(object2);
      while (++index2 < length) {
        var source = sources[index2];
        if (source) {
          assigner(object2, source, index2, customizer);
        }
      }
      return object2;
    });
  }
  _createAssigner = createAssigner2;
  return _createAssigner;
}

// node_modules/@antv/layout/lib/node_modules/lodash/merge.js
var merge_1;
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge)
    return merge_1;
  hasRequiredMerge = 1;
  var baseMerge2 = require_baseMerge(), createAssigner2 = require_createAssigner();
  var merge2 = createAssigner2(function(object2, source, srcIndex) {
    baseMerge2(object2, source, srcIndex);
  });
  merge_1 = merge2;
  return merge_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseLt.js
var _baseLt;
var hasRequired_baseLt;
function require_baseLt() {
  if (hasRequired_baseLt)
    return _baseLt;
  hasRequired_baseLt = 1;
  function baseLt(value, other) {
    return value < other;
  }
  _baseLt = baseLt;
  return _baseLt;
}

// node_modules/@antv/layout/lib/node_modules/lodash/min.js
var min_1;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin)
    return min_1;
  hasRequiredMin = 1;
  var baseExtremum = require_baseExtremum(), baseLt = require_baseLt(), identity6 = requireIdentity();
  function min3(array3) {
    return array3 && array3.length ? baseExtremum(array3, identity6, baseLt) : void 0;
  }
  min_1 = min3;
  return min_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/minBy.js
var minBy_1;
var hasRequiredMinBy;
function requireMinBy() {
  if (hasRequiredMinBy)
    return minBy_1;
  hasRequiredMinBy = 1;
  var baseExtremum = require_baseExtremum(), baseIteratee = require_baseIteratee(), baseLt = require_baseLt();
  function minBy(array3, iteratee) {
    return array3 && array3.length ? baseExtremum(array3, baseIteratee(iteratee, 2), baseLt) : void 0;
  }
  minBy_1 = minBy;
  return minBy_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/now.js
var now_1;
var hasRequiredNow;
function requireNow() {
  if (hasRequiredNow)
    return now_1;
  hasRequiredNow = 1;
  var root4 = require_root();
  var now2 = function() {
    return root4.Date.now();
  };
  now_1 = now2;
  return now_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseSet.js
var _baseSet;
var hasRequired_baseSet;
function require_baseSet() {
  if (hasRequired_baseSet)
    return _baseSet;
  hasRequired_baseSet = 1;
  var assignValue2 = require_assignValue(), castPath2 = require_castPath(), isIndex2 = require_isIndex(), isObject3 = requireIsObject(), toKey2 = require_toKey();
  function baseSet(object2, path2, value, customizer) {
    if (!isObject3(object2)) {
      return object2;
    }
    path2 = castPath2(path2, object2);
    var index2 = -1, length = path2.length, lastIndex = length - 1, nested = object2;
    while (nested != null && ++index2 < length) {
      var key = toKey2(path2[index2]), newValue = value;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object2;
      }
      if (index2 != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject3(objValue) ? objValue : isIndex2(path2[index2 + 1]) ? [] : {};
        }
      }
      assignValue2(nested, key, newValue);
      nested = nested[key];
    }
    return object2;
  }
  _baseSet = baseSet;
  return _baseSet;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_basePickBy.js
var _basePickBy;
var hasRequired_basePickBy;
function require_basePickBy() {
  if (hasRequired_basePickBy)
    return _basePickBy;
  hasRequired_basePickBy = 1;
  var baseGet2 = require_baseGet(), baseSet = require_baseSet(), castPath2 = require_castPath();
  function basePickBy(object2, paths, predicate) {
    var index2 = -1, length = paths.length, result = {};
    while (++index2 < length) {
      var path2 = paths[index2], value = baseGet2(object2, path2);
      if (predicate(value, path2)) {
        baseSet(result, castPath2(path2, object2), value);
      }
    }
    return result;
  }
  _basePickBy = basePickBy;
  return _basePickBy;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_basePick.js
var _basePick;
var hasRequired_basePick;
function require_basePick() {
  if (hasRequired_basePick)
    return _basePick;
  hasRequired_basePick = 1;
  var basePickBy = require_basePickBy(), hasIn = requireHasIn();
  function basePick(object2, paths) {
    return basePickBy(object2, paths, function(value, path2) {
      return hasIn(object2, path2);
    });
  }
  _basePick = basePick;
  return _basePick;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_flatRest.js
var _flatRest;
var hasRequired_flatRest;
function require_flatRest() {
  if (hasRequired_flatRest)
    return _flatRest;
  hasRequired_flatRest = 1;
  var flatten = requireFlatten(), overRest2 = require_overRest(), setToString2 = require_setToString();
  function flatRest(func) {
    return setToString2(overRest2(func, void 0, flatten), func + "");
  }
  _flatRest = flatRest;
  return _flatRest;
}

// node_modules/@antv/layout/lib/node_modules/lodash/pick.js
var pick_1;
var hasRequiredPick;
function requirePick() {
  if (hasRequiredPick)
    return pick_1;
  hasRequiredPick = 1;
  var basePick = require_basePick(), flatRest = require_flatRest();
  var pick2 = flatRest(function(object2, paths) {
    return object2 == null ? {} : basePick(object2, paths);
  });
  pick_1 = pick2;
  return pick_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseRange.js
var _baseRange;
var hasRequired_baseRange;
function require_baseRange() {
  if (hasRequired_baseRange)
    return _baseRange;
  hasRequired_baseRange = 1;
  var nativeCeil = Math.ceil, nativeMax3 = Math.max;
  function baseRange(start2, end, step, fromRight) {
    var index2 = -1, length = nativeMax3(nativeCeil((end - start2) / (step || 1)), 0), result = Array(length);
    while (length--) {
      result[fromRight ? length : ++index2] = start2;
      start2 += step;
    }
    return result;
  }
  _baseRange = baseRange;
  return _baseRange;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_createRange.js
var _createRange;
var hasRequired_createRange;
function require_createRange() {
  if (hasRequired_createRange)
    return _createRange;
  hasRequired_createRange = 1;
  var baseRange = require_baseRange(), isIterateeCall2 = require_isIterateeCall(), toFinite2 = requireToFinite();
  function createRange(fromRight) {
    return function(start2, end, step) {
      if (step && typeof step != "number" && isIterateeCall2(start2, end, step)) {
        end = step = void 0;
      }
      start2 = toFinite2(start2);
      if (end === void 0) {
        end = start2;
        start2 = 0;
      } else {
        end = toFinite2(end);
      }
      step = step === void 0 ? start2 < end ? 1 : -1 : toFinite2(step);
      return baseRange(start2, end, step, fromRight);
    };
  }
  _createRange = createRange;
  return _createRange;
}

// node_modules/@antv/layout/lib/node_modules/lodash/range.js
var range_1;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range_1;
  hasRequiredRange = 1;
  var createRange = require_createRange();
  var range = createRange();
  range_1 = range;
  return range_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseSortBy.js
var _baseSortBy;
var hasRequired_baseSortBy;
function require_baseSortBy() {
  if (hasRequired_baseSortBy)
    return _baseSortBy;
  hasRequired_baseSortBy = 1;
  function baseSortBy(array3, comparer) {
    var length = array3.length;
    array3.sort(comparer);
    while (length--) {
      array3[length] = array3[length].value;
    }
    return array3;
  }
  _baseSortBy = baseSortBy;
  return _baseSortBy;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_compareAscending.js
var _compareAscending;
var hasRequired_compareAscending;
function require_compareAscending() {
  if (hasRequired_compareAscending)
    return _compareAscending;
  hasRequired_compareAscending = 1;
  var isSymbol2 = requireIsSymbol();
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
      var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }
      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }
  _compareAscending = compareAscending;
  return _compareAscending;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_compareMultiple.js
var _compareMultiple;
var hasRequired_compareMultiple;
function require_compareMultiple() {
  if (hasRequired_compareMultiple)
    return _compareMultiple;
  hasRequired_compareMultiple = 1;
  var compareAscending = require_compareAscending();
  function compareMultiple(object2, other, orders) {
    var index2 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
    while (++index2 < length) {
      var result = compareAscending(objCriteria[index2], othCriteria[index2]);
      if (result) {
        if (index2 >= ordersLength) {
          return result;
        }
        var order = orders[index2];
        return result * (order == "desc" ? -1 : 1);
      }
    }
    return object2.index - other.index;
  }
  _compareMultiple = compareMultiple;
  return _compareMultiple;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseOrderBy.js
var _baseOrderBy;
var hasRequired_baseOrderBy;
function require_baseOrderBy() {
  if (hasRequired_baseOrderBy)
    return _baseOrderBy;
  hasRequired_baseOrderBy = 1;
  var arrayMap2 = require_arrayMap(), baseGet2 = require_baseGet(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), baseSortBy = require_baseSortBy(), baseUnary2 = require_baseUnary(), compareMultiple = require_compareMultiple(), identity6 = requireIdentity(), isArray2 = requireIsArray();
  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = arrayMap2(iteratees, function(iteratee) {
        if (isArray2(iteratee)) {
          return function(value) {
            return baseGet2(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          };
        }
        return iteratee;
      });
    } else {
      iteratees = [identity6];
    }
    var index2 = -1;
    iteratees = arrayMap2(iteratees, baseUnary2(baseIteratee));
    var result = baseMap(collection, function(value, key, collection2) {
      var criteria = arrayMap2(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { "criteria": criteria, "index": ++index2, "value": value };
    });
    return baseSortBy(result, function(object2, other) {
      return compareMultiple(object2, other, orders);
    });
  }
  _baseOrderBy = baseOrderBy;
  return _baseOrderBy;
}

// node_modules/@antv/layout/lib/node_modules/lodash/sortBy.js
var sortBy_1;
var hasRequiredSortBy;
function requireSortBy() {
  if (hasRequiredSortBy)
    return sortBy_1;
  hasRequiredSortBy = 1;
  var baseFlatten = require_baseFlatten(), baseOrderBy = require_baseOrderBy(), baseRest2 = require_baseRest(), isIterateeCall2 = require_isIterateeCall();
  var sortBy = baseRest2(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length = iteratees.length;
    if (length > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });
  sortBy_1 = sortBy;
  return sortBy_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/uniqueId.js
var uniqueId_1;
var hasRequiredUniqueId;
function requireUniqueId() {
  if (hasRequiredUniqueId)
    return uniqueId_1;
  hasRequiredUniqueId = 1;
  var toString3 = requireToString();
  var idCounter = 0;
  function uniqueId(prefix) {
    var id2 = ++idCounter;
    return toString3(prefix) + id2;
  }
  uniqueId_1 = uniqueId;
  return uniqueId_1;
}

// node_modules/@antv/layout/lib/node_modules/lodash/_baseZipObject.js
var _baseZipObject;
var hasRequired_baseZipObject;
function require_baseZipObject() {
  if (hasRequired_baseZipObject)
    return _baseZipObject;
  hasRequired_baseZipObject = 1;
  function baseZipObject(props, values, assignFunc) {
    var index2 = -1, length = props.length, valsLength = values.length, result = {};
    while (++index2 < length) {
      var value = index2 < valsLength ? values[index2] : void 0;
      assignFunc(result, props[index2], value);
    }
    return result;
  }
  _baseZipObject = baseZipObject;
  return _baseZipObject;
}

// node_modules/@antv/layout/lib/node_modules/lodash/zipObject.js
var zipObject_1;
var hasRequiredZipObject;
function requireZipObject() {
  if (hasRequiredZipObject)
    return zipObject_1;
  hasRequiredZipObject = 1;
  var assignValue2 = require_assignValue(), baseZipObject = require_baseZipObject();
  function zipObject(props, values) {
    return baseZipObject(props || [], values || [], assignValue2);
  }
  zipObject_1 = zipObject;
  return zipObject_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/lodash.js
var lodash_1;
var hasRequiredLodash;
function requireLodash() {
  if (hasRequiredLodash)
    return lodash_1;
  hasRequiredLodash = 1;
  var lodash;
  if (typeof commonjsRequire === "function") {
    try {
      lodash = {
        cloneDeep: requireCloneDeep(),
        constant: requireConstant(),
        defaults: requireDefaults(),
        each: requireEach(),
        filter: requireFilter(),
        find: requireFind(),
        flatten: requireFlatten(),
        forEach: requireForEach(),
        forIn: requireForIn(),
        has: requireHas(),
        isUndefined: requireIsUndefined(),
        last: requireLast(),
        map: requireMap(),
        mapValues: requireMapValues(),
        max: requireMax(),
        merge: requireMerge(),
        min: requireMin(),
        minBy: requireMinBy(),
        now: requireNow(),
        pick: requirePick(),
        range: requireRange(),
        reduce: requireReduce(),
        sortBy: requireSortBy(),
        uniqueId: requireUniqueId(),
        values: requireValues(),
        zipObject: requireZipObject()
      };
    } catch (e8) {
    }
  }
  if (!lodash) {
    lodash = window._;
  }
  lodash_1 = lodash;
  return lodash_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/data/list.js
var list;
var hasRequiredList;
function requireList() {
  if (hasRequiredList)
    return list;
  hasRequiredList = 1;
  list = List;
  function List() {
    var sentinel = {};
    sentinel._next = sentinel._prev = sentinel;
    this._sentinel = sentinel;
  }
  List.prototype.dequeue = function() {
    var sentinel = this._sentinel;
    var entry = sentinel._prev;
    if (entry !== sentinel) {
      unlink(entry);
      return entry;
    }
  };
  List.prototype.enqueue = function(entry) {
    var sentinel = this._sentinel;
    if (entry._prev && entry._next) {
      unlink(entry);
    }
    entry._next = sentinel._next;
    sentinel._next._prev = entry;
    sentinel._next = entry;
    entry._prev = sentinel;
  };
  List.prototype.toString = function() {
    var strs = [];
    var sentinel = this._sentinel;
    var curr = sentinel._prev;
    while (curr !== sentinel) {
      strs.push(JSON.stringify(curr, filterOutLinks));
      curr = curr._prev;
    }
    return "[" + strs.join(", ") + "]";
  };
  function unlink(entry) {
    entry._prev._next = entry._next;
    entry._next._prev = entry._prev;
    delete entry._next;
    delete entry._prev;
  }
  function filterOutLinks(k5, v2) {
    if (k5 !== "_next" && k5 !== "_prev") {
      return v2;
    }
  }
  return list;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/greedy-fas.js
var greedyFas;
var hasRequiredGreedyFas;
function requireGreedyFas() {
  if (hasRequiredGreedyFas)
    return greedyFas;
  hasRequiredGreedyFas = 1;
  var _2 = requireLodash();
  var Graph = requireGraphlib().Graph;
  var List = requireList();
  greedyFas = greedyFAS;
  var DEFAULT_WEIGHT_FN = _2.constant(1);
  function greedyFAS(g3, weightFn) {
    if (g3.nodeCount() <= 1) {
      return [];
    }
    var state = buildState(g3, weightFn || DEFAULT_WEIGHT_FN);
    var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
    return _2.flatten(_2.map(results, function(e8) {
      return g3.outEdges(e8.v, e8.w);
    }), true);
  }
  function doGreedyFAS(g3, buckets, zeroIdx) {
    var results = [];
    var sources = buckets[buckets.length - 1];
    var sinks = buckets[0];
    var entry;
    while (g3.nodeCount()) {
      while (entry = sinks.dequeue()) {
        removeNode(g3, buckets, zeroIdx, entry);
      }
      while (entry = sources.dequeue()) {
        removeNode(g3, buckets, zeroIdx, entry);
      }
      if (g3.nodeCount()) {
        for (var i4 = buckets.length - 2; i4 > 0; --i4) {
          entry = buckets[i4].dequeue();
          if (entry) {
            results = results.concat(removeNode(g3, buckets, zeroIdx, entry, true));
            break;
          }
        }
      }
    }
    return results;
  }
  function removeNode(g3, buckets, zeroIdx, entry, collectPredecessors) {
    var results = collectPredecessors ? [] : void 0;
    _2.forEach(g3.inEdges(entry.v), function(edge) {
      var weight = g3.edge(edge);
      var uEntry = g3.node(edge.v);
      if (collectPredecessors) {
        results.push({ v: edge.v, w: edge.w });
      }
      uEntry.out -= weight;
      assignBucket(buckets, zeroIdx, uEntry);
    });
    _2.forEach(g3.outEdges(entry.v), function(edge) {
      var weight = g3.edge(edge);
      var w3 = edge.w;
      var wEntry = g3.node(w3);
      wEntry["in"] -= weight;
      assignBucket(buckets, zeroIdx, wEntry);
    });
    g3.removeNode(entry.v);
    return results;
  }
  function buildState(g3, weightFn) {
    var fasGraph = new Graph();
    var maxIn = 0;
    var maxOut = 0;
    _2.forEach(g3.nodes(), function(v2) {
      fasGraph.setNode(v2, { v: v2, "in": 0, out: 0 });
    });
    _2.forEach(g3.edges(), function(e8) {
      var prevWeight = fasGraph.edge(e8.v, e8.w) || 0;
      var weight = weightFn(e8);
      var edgeWeight = prevWeight + weight;
      fasGraph.setEdge(e8.v, e8.w, edgeWeight);
      maxOut = Math.max(maxOut, fasGraph.node(e8.v).out += weight);
      maxIn = Math.max(maxIn, fasGraph.node(e8.w)["in"] += weight);
    });
    var buckets = _2.range(maxOut + maxIn + 3).map(function() {
      return new List();
    });
    var zeroIdx = maxIn + 1;
    _2.forEach(fasGraph.nodes(), function(v2) {
      assignBucket(buckets, zeroIdx, fasGraph.node(v2));
    });
    return { graph: fasGraph, buckets, zeroIdx };
  }
  function assignBucket(buckets, zeroIdx, entry) {
    if (!entry.out) {
      buckets[0].enqueue(entry);
    } else if (!entry["in"]) {
      buckets[buckets.length - 1].enqueue(entry);
    } else {
      buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
    }
  }
  return greedyFas;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/acyclic.js
var acyclic;
var hasRequiredAcyclic;
function requireAcyclic() {
  if (hasRequiredAcyclic)
    return acyclic;
  hasRequiredAcyclic = 1;
  var _2 = requireLodash();
  var greedyFAS = requireGreedyFas();
  acyclic = {
    run,
    undo
  };
  function run(g3) {
    var fas = g3.graph().acyclicer === "greedy" ? greedyFAS(g3, weightFn(g3)) : dfsFAS(g3);
    _2.forEach(fas, function(e8) {
      var label = g3.edge(e8);
      g3.removeEdge(e8);
      label.forwardName = e8.name;
      label.reversed = true;
      g3.setEdge(e8.w, e8.v, label, _2.uniqueId("rev"));
    });
    function weightFn(g4) {
      return function(e8) {
        return g4.edge(e8).weight;
      };
    }
  }
  function dfsFAS(g3) {
    var fas = [];
    var stack = {};
    var visited = {};
    function dfs(v2) {
      if (_2.has(visited, v2)) {
        return;
      }
      visited[v2] = true;
      stack[v2] = true;
      _2.forEach(g3.outEdges(v2), function(e8) {
        if (_2.has(stack, e8.w)) {
          fas.push(e8);
        } else {
          dfs(e8.w);
        }
      });
      delete stack[v2];
    }
    _2.forEach(g3.nodes(), dfs);
    return fas;
  }
  function undo(g3) {
    _2.forEach(g3.edges(), function(e8) {
      var label = g3.edge(e8);
      if (label.reversed) {
        g3.removeEdge(e8);
        var forwardName = label.forwardName;
        delete label.reversed;
        delete label.forwardName;
        g3.setEdge(e8.w, e8.v, label, forwardName);
      }
    });
  }
  return acyclic;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/util.js
var util$1;
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1)
    return util$1;
  hasRequiredUtil$1 = 1;
  var _2 = requireLodash();
  var Graph = requireGraphlib().Graph;
  util$1 = {
    addDummyNode,
    simplify,
    asNonCompoundGraph,
    successorWeights,
    predecessorWeights,
    intersectRect,
    buildLayerMatrix,
    normalizeRanks,
    removeEmptyRanks,
    addBorderNode,
    maxRank,
    partition,
    time,
    notime
  };
  function addDummyNode(g3, type2, attrs, name) {
    var v2;
    do {
      v2 = _2.uniqueId(name);
    } while (g3.hasNode(v2));
    attrs.dummy = type2;
    g3.setNode(v2, attrs);
    return v2;
  }
  function simplify(g3) {
    var simplified = new Graph().setGraph(g3.graph());
    _2.forEach(g3.nodes(), function(v2) {
      simplified.setNode(v2, g3.node(v2));
    });
    _2.forEach(g3.edges(), function(e8) {
      var simpleLabel = simplified.edge(e8.v, e8.w) || { weight: 0, minlen: 1 };
      var label = g3.edge(e8);
      simplified.setEdge(e8.v, e8.w, {
        weight: simpleLabel.weight + label.weight,
        minlen: Math.max(simpleLabel.minlen, label.minlen)
      });
    });
    return simplified;
  }
  function asNonCompoundGraph(g3) {
    var simplified = new Graph({ multigraph: g3.isMultigraph() }).setGraph(g3.graph());
    _2.forEach(g3.nodes(), function(v2) {
      if (!g3.children(v2).length) {
        simplified.setNode(v2, g3.node(v2));
      }
    });
    _2.forEach(g3.edges(), function(e8) {
      simplified.setEdge(e8, g3.edge(e8));
    });
    return simplified;
  }
  function successorWeights(g3) {
    var weightMap = _2.map(g3.nodes(), function(v2) {
      var sucs = {};
      _2.forEach(g3.outEdges(v2), function(e8) {
        sucs[e8.w] = (sucs[e8.w] || 0) + g3.edge(e8).weight;
      });
      return sucs;
    });
    return _2.zipObject(g3.nodes(), weightMap);
  }
  function predecessorWeights(g3) {
    var weightMap = _2.map(g3.nodes(), function(v2) {
      var preds = {};
      _2.forEach(g3.inEdges(v2), function(e8) {
        preds[e8.v] = (preds[e8.v] || 0) + g3.edge(e8).weight;
      });
      return preds;
    });
    return _2.zipObject(g3.nodes(), weightMap);
  }
  function intersectRect(rect, point) {
    var x6 = rect.x;
    var y6 = rect.y;
    var dx = point.x - x6;
    var dy = point.y - y6;
    var w3 = rect.width / 2;
    var h4 = rect.height / 2;
    if (!dx && !dy) {
      throw new Error("Not possible to find intersection inside of the rectangle");
    }
    var sx, sy;
    if (Math.abs(dy) * w3 > Math.abs(dx) * h4) {
      if (dy < 0) {
        h4 = -h4;
      }
      sx = h4 * dx / dy;
      sy = h4;
    } else {
      if (dx < 0) {
        w3 = -w3;
      }
      sx = w3;
      sy = w3 * dy / dx;
    }
    return { x: x6 + sx, y: y6 + sy };
  }
  function buildLayerMatrix(g3) {
    var layering = _2.map(_2.range(maxRank(g3) + 1), function() {
      return [];
    });
    _2.forEach(g3.nodes(), function(v2) {
      var node = g3.node(v2);
      var rank = node.rank;
      if (!_2.isUndefined(rank)) {
        layering[rank][node.order] = v2;
      }
    });
    return layering;
  }
  function normalizeRanks(g3) {
    var min3 = _2.min(_2.map(g3.nodes(), function(v2) {
      return g3.node(v2).rank;
    }));
    _2.forEach(g3.nodes(), function(v2) {
      var node = g3.node(v2);
      if (_2.has(node, "rank")) {
        node.rank -= min3;
      }
    });
  }
  function removeEmptyRanks(g3) {
    var offset = _2.min(_2.map(g3.nodes(), function(v2) {
      return g3.node(v2).rank;
    }));
    var layers = [];
    _2.forEach(g3.nodes(), function(v2) {
      var rank = g3.node(v2).rank - offset;
      if (!layers[rank]) {
        layers[rank] = [];
      }
      layers[rank].push(v2);
    });
    var delta = 0;
    var nodeRankFactor = g3.graph().nodeRankFactor;
    _2.forEach(layers, function(vs, i4) {
      if (_2.isUndefined(vs) && i4 % nodeRankFactor !== 0) {
        --delta;
      } else if (delta) {
        _2.forEach(vs, function(v2) {
          g3.node(v2).rank += delta;
        });
      }
    });
  }
  function addBorderNode(g3, prefix, rank, order) {
    var node = {
      width: 0,
      height: 0
    };
    if (arguments.length >= 4) {
      node.rank = rank;
      node.order = order;
    }
    return addDummyNode(g3, "border", node, prefix);
  }
  function maxRank(g3) {
    return _2.max(_2.map(g3.nodes(), function(v2) {
      var rank = g3.node(v2).rank;
      if (!_2.isUndefined(rank)) {
        return rank;
      }
    }));
  }
  function partition(collection, fn5) {
    var result = { lhs: [], rhs: [] };
    _2.forEach(collection, function(value) {
      if (fn5(value)) {
        result.lhs.push(value);
      } else {
        result.rhs.push(value);
      }
    });
    return result;
  }
  function time(name, fn5) {
    var start2 = _2.now();
    try {
      return fn5();
    } finally {
      console.log(name + " time: " + (_2.now() - start2) + "ms");
    }
  }
  function notime(name, fn5) {
    return fn5();
  }
  return util$1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/normalize.js
var normalize2;
var hasRequiredNormalize;
function requireNormalize() {
  if (hasRequiredNormalize)
    return normalize2;
  hasRequiredNormalize = 1;
  var _2 = requireLodash();
  var util2 = requireUtil$1();
  normalize2 = {
    run,
    undo
  };
  function run(g3) {
    g3.graph().dummyChains = [];
    _2.forEach(g3.edges(), function(edge) {
      normalizeEdge(g3, edge);
    });
  }
  function normalizeEdge(g3, e8) {
    var v2 = e8.v;
    var vRank = g3.node(v2).rank;
    var w3 = e8.w;
    var wRank = g3.node(w3).rank;
    var name = e8.name;
    var edgeLabel = g3.edge(e8);
    var labelRank = edgeLabel.labelRank;
    if (wRank === vRank + 1)
      return;
    g3.removeEdge(e8);
    var dummy, attrs, i4;
    for (i4 = 0, ++vRank; vRank < wRank; ++i4, ++vRank) {
      edgeLabel.points = [];
      attrs = {
        width: 0,
        height: 0,
        edgeLabel,
        edgeObj: e8,
        rank: vRank
      };
      dummy = util2.addDummyNode(g3, "edge", attrs, "_d");
      if (vRank === labelRank) {
        attrs.width = edgeLabel.width;
        attrs.height = edgeLabel.height;
        attrs.dummy = "edge-label";
        attrs.labelpos = edgeLabel.labelpos;
      }
      g3.setEdge(v2, dummy, { weight: edgeLabel.weight }, name);
      if (i4 === 0) {
        g3.graph().dummyChains.push(dummy);
      }
      v2 = dummy;
    }
    g3.setEdge(v2, w3, { weight: edgeLabel.weight }, name);
  }
  function undo(g3) {
    _2.forEach(g3.graph().dummyChains, function(v2) {
      var node = g3.node(v2);
      var origLabel = node.edgeLabel;
      var w3;
      g3.setEdge(node.edgeObj, origLabel);
      while (node.dummy) {
        w3 = g3.successors(v2)[0];
        g3.removeNode(v2);
        origLabel.points.push({ x: node.x, y: node.y });
        if (node.dummy === "edge-label") {
          origLabel.x = node.x;
          origLabel.y = node.y;
          origLabel.width = node.width;
          origLabel.height = node.height;
        }
        v2 = w3;
        node = g3.node(v2);
      }
    });
  }
  return normalize2;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/rank/util.js
var util;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util;
  hasRequiredUtil = 1;
  var _2 = requireLodash();
  util = {
    longestPath,
    slack
  };
  function longestPath(g3) {
    var visited = {};
    function dfs(v2) {
      var label = g3.node(v2);
      if (_2.has(visited, v2)) {
        return label.rank;
      }
      visited[v2] = true;
      var rank = _2.min(_2.map(g3.outEdges(v2), function(e8) {
        return dfs(e8.w) - g3.edge(e8).minlen;
      }));
      if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
      rank === void 0 || // return value of _.map([]) for Lodash 4
      rank === null) {
        rank = 0;
      }
      return label.rank = rank;
    }
    _2.forEach(g3.sources(), dfs);
  }
  function slack(g3, e8) {
    return g3.node(e8.w).rank - g3.node(e8.v).rank - g3.edge(e8).minlen;
  }
  return util;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/rank/feasible-tree.js
var feasibleTree_1;
var hasRequiredFeasibleTree;
function requireFeasibleTree() {
  if (hasRequiredFeasibleTree)
    return feasibleTree_1;
  hasRequiredFeasibleTree = 1;
  var _2 = requireLodash();
  var Graph = requireGraphlib().Graph;
  var slack = requireUtil().slack;
  feasibleTree_1 = feasibleTree;
  function feasibleTree(g3) {
    var t2 = new Graph({ directed: false });
    var start2 = g3.nodes()[0];
    var size = g3.nodeCount();
    t2.setNode(start2, {});
    var edge, delta;
    while (tightTree(t2, g3) < size) {
      edge = findMinSlackEdge(t2, g3);
      delta = t2.hasNode(edge.v) ? slack(g3, edge) : -slack(g3, edge);
      shiftRanks(t2, g3, delta);
    }
    return t2;
  }
  function tightTree(t2, g3) {
    function dfs(v2) {
      _2.forEach(g3.nodeEdges(v2), function(e8) {
        var edgeV = e8.v, w3 = v2 === edgeV ? e8.w : edgeV;
        if (!t2.hasNode(w3) && !slack(g3, e8)) {
          t2.setNode(w3, {});
          t2.setEdge(v2, w3, {});
          dfs(w3);
        }
      });
    }
    _2.forEach(t2.nodes(), dfs);
    return t2.nodeCount();
  }
  function findMinSlackEdge(t2, g3) {
    return _2.minBy(g3.edges(), function(e8) {
      if (t2.hasNode(e8.v) !== t2.hasNode(e8.w)) {
        return slack(g3, e8);
      }
    });
  }
  function shiftRanks(t2, g3, delta) {
    _2.forEach(t2.nodes(), function(v2) {
      g3.node(v2).rank += delta;
    });
  }
  return feasibleTree_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/rank/network-simplex.js
var networkSimplex_1;
var hasRequiredNetworkSimplex;
function requireNetworkSimplex() {
  if (hasRequiredNetworkSimplex)
    return networkSimplex_1;
  hasRequiredNetworkSimplex = 1;
  var _2 = requireLodash();
  var feasibleTree = requireFeasibleTree();
  var slack = requireUtil().slack;
  var initRank = requireUtil().longestPath;
  var preorder = requireGraphlib().alg.preorder;
  var postorder = requireGraphlib().alg.postorder;
  var simplify = requireUtil$1().simplify;
  networkSimplex_1 = networkSimplex;
  networkSimplex.initLowLimValues = initLowLimValues;
  networkSimplex.initCutValues = initCutValues;
  networkSimplex.calcCutValue = calcCutValue;
  networkSimplex.leaveEdge = leaveEdge;
  networkSimplex.enterEdge = enterEdge;
  networkSimplex.exchangeEdges = exchangeEdges;
  function networkSimplex(g3) {
    g3 = simplify(g3);
    initRank(g3);
    var t2 = feasibleTree(g3);
    initLowLimValues(t2);
    initCutValues(t2, g3);
    var e8, f5;
    while (e8 = leaveEdge(t2)) {
      f5 = enterEdge(t2, g3, e8);
      exchangeEdges(t2, g3, e8, f5);
    }
  }
  function initCutValues(t2, g3) {
    var vs = postorder(t2, t2.nodes());
    vs = vs.slice(0, vs.length - 1);
    _2.forEach(vs, function(v2) {
      assignCutValue(t2, g3, v2);
    });
  }
  function assignCutValue(t2, g3, child) {
    var childLab = t2.node(child);
    var parent = childLab.parent;
    t2.edge(child, parent).cutvalue = calcCutValue(t2, g3, child);
  }
  function calcCutValue(t2, g3, child) {
    var childLab = t2.node(child);
    var parent = childLab.parent;
    var childIsTail = true;
    var graphEdge = g3.edge(child, parent);
    var cutValue = 0;
    if (!graphEdge) {
      childIsTail = false;
      graphEdge = g3.edge(parent, child);
    }
    cutValue = graphEdge.weight;
    _2.forEach(g3.nodeEdges(child), function(e8) {
      var isOutEdge = e8.v === child, other = isOutEdge ? e8.w : e8.v;
      if (other !== parent) {
        var pointsToHead = isOutEdge === childIsTail, otherWeight = g3.edge(e8).weight;
        cutValue += pointsToHead ? otherWeight : -otherWeight;
        if (isTreeEdge(t2, child, other)) {
          var otherCutValue = t2.edge(child, other).cutvalue;
          cutValue += pointsToHead ? -otherCutValue : otherCutValue;
        }
      }
    });
    return cutValue;
  }
  function initLowLimValues(tree, root4) {
    if (arguments.length < 2) {
      root4 = tree.nodes()[0];
    }
    dfsAssignLowLim(tree, {}, 1, root4);
  }
  function dfsAssignLowLim(tree, visited, nextLim, v2, parent) {
    var low = nextLim;
    var label = tree.node(v2);
    visited[v2] = true;
    _2.forEach(tree.neighbors(v2), function(w3) {
      if (!_2.has(visited, w3)) {
        nextLim = dfsAssignLowLim(tree, visited, nextLim, w3, v2);
      }
    });
    label.low = low;
    label.lim = nextLim++;
    if (parent) {
      label.parent = parent;
    } else {
      delete label.parent;
    }
    return nextLim;
  }
  function leaveEdge(tree) {
    return _2.find(tree.edges(), function(e8) {
      return tree.edge(e8).cutvalue < 0;
    });
  }
  function enterEdge(t2, g3, edge) {
    var v2 = edge.v;
    var w3 = edge.w;
    if (!g3.hasEdge(v2, w3)) {
      v2 = edge.w;
      w3 = edge.v;
    }
    var vLabel = t2.node(v2);
    var wLabel = t2.node(w3);
    var tailLabel = vLabel;
    var flip2 = false;
    if (vLabel.lim > wLabel.lim) {
      tailLabel = wLabel;
      flip2 = true;
    }
    var candidates = _2.filter(g3.edges(), function(edge2) {
      return flip2 === isDescendant(t2, t2.node(edge2.v), tailLabel) && flip2 !== isDescendant(t2, t2.node(edge2.w), tailLabel);
    });
    return _2.minBy(candidates, function(edge2) {
      return slack(g3, edge2);
    });
  }
  function exchangeEdges(t2, g3, e8, f5) {
    var v2 = e8.v;
    var w3 = e8.w;
    t2.removeEdge(v2, w3);
    t2.setEdge(f5.v, f5.w, {});
    initLowLimValues(t2);
    initCutValues(t2, g3);
    updateRanks(t2, g3);
  }
  function updateRanks(t2, g3) {
    var root4 = _2.find(t2.nodes(), function(v2) {
      return !g3.node(v2).parent;
    });
    var vs = preorder(t2, root4);
    vs = vs.slice(1);
    _2.forEach(vs, function(v2) {
      var parent = t2.node(v2).parent, edge = g3.edge(v2, parent), flipped = false;
      if (!edge) {
        edge = g3.edge(parent, v2);
        flipped = true;
      }
      g3.node(v2).rank = g3.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
    });
  }
  function isTreeEdge(tree, u4, v2) {
    return tree.hasEdge(u4, v2);
  }
  function isDescendant(tree, vLabel, rootLabel) {
    return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
  }
  return networkSimplex_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/rank/index.js
var rank_1;
var hasRequiredRank;
function requireRank() {
  if (hasRequiredRank)
    return rank_1;
  hasRequiredRank = 1;
  var rankUtil = requireUtil();
  var longestPath = rankUtil.longestPath;
  var feasibleTree = requireFeasibleTree();
  var networkSimplex = requireNetworkSimplex();
  rank_1 = rank;
  function rank(g3) {
    switch (g3.graph().ranker) {
      case "network-simplex":
        networkSimplexRanker(g3);
        break;
      case "tight-tree":
        tightTreeRanker(g3);
        break;
      case "longest-path":
        longestPathRanker(g3);
        break;
      default:
        networkSimplexRanker(g3);
    }
  }
  var longestPathRanker = longestPath;
  function tightTreeRanker(g3) {
    longestPath(g3);
    feasibleTree(g3);
  }
  function networkSimplexRanker(g3) {
    networkSimplex(g3);
  }
  return rank_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/parent-dummy-chains.js
var parentDummyChains_1;
var hasRequiredParentDummyChains;
function requireParentDummyChains() {
  if (hasRequiredParentDummyChains)
    return parentDummyChains_1;
  hasRequiredParentDummyChains = 1;
  var _2 = requireLodash();
  parentDummyChains_1 = parentDummyChains;
  function parentDummyChains(g3) {
    var postorderNums = postorder(g3);
    _2.forEach(g3.graph().dummyChains, function(v2) {
      var node = g3.node(v2);
      var edgeObj = node.edgeObj;
      var pathData = findPath(g3, postorderNums, edgeObj.v, edgeObj.w);
      var path2 = pathData.path;
      var lca = pathData.lca;
      var pathIdx = 0;
      var pathV = path2[pathIdx];
      var ascending3 = true;
      while (v2 !== edgeObj.w) {
        node = g3.node(v2);
        if (ascending3) {
          while ((pathV = path2[pathIdx]) !== lca && g3.node(pathV).maxRank < node.rank) {
            pathIdx++;
          }
          if (pathV === lca) {
            ascending3 = false;
          }
        }
        if (!ascending3) {
          while (pathIdx < path2.length - 1 && g3.node(pathV = path2[pathIdx + 1]).minRank <= node.rank) {
            pathIdx++;
          }
          pathV = path2[pathIdx];
        }
        g3.setParent(v2, pathV);
        v2 = g3.successors(v2)[0];
      }
    });
  }
  function findPath(g3, postorderNums, v2, w3) {
    var vPath = [];
    var wPath = [];
    var low = Math.min(postorderNums[v2].low, postorderNums[w3].low);
    var lim = Math.max(postorderNums[v2].lim, postorderNums[w3].lim);
    var parent;
    var lca;
    parent = v2;
    do {
      parent = g3.parent(parent);
      vPath.push(parent);
    } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
    lca = parent;
    parent = w3;
    while ((parent = g3.parent(parent)) !== lca) {
      wPath.push(parent);
    }
    return { path: vPath.concat(wPath.reverse()), lca };
  }
  function postorder(g3) {
    var result = {};
    var lim = 0;
    function dfs(v2) {
      var low = lim;
      _2.forEach(g3.children(v2), dfs);
      result[v2] = { low, lim: lim++ };
    }
    _2.forEach(g3.children(), dfs);
    return result;
  }
  return parentDummyChains_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/nesting-graph.js
var nestingGraph;
var hasRequiredNestingGraph;
function requireNestingGraph() {
  if (hasRequiredNestingGraph)
    return nestingGraph;
  hasRequiredNestingGraph = 1;
  var _2 = requireLodash();
  var util2 = requireUtil$1();
  nestingGraph = {
    run,
    cleanup
  };
  function run(g3) {
    var root4 = util2.addDummyNode(g3, "root", {}, "_root");
    var depths = treeDepths(g3);
    var height = _2.max(_2.values(depths)) - 1;
    var nodeSep = 2 * height + 1;
    g3.graph().nestingRoot = root4;
    _2.forEach(g3.edges(), function(e8) {
      g3.edge(e8).minlen *= nodeSep;
    });
    var weight = sumWeights(g3) + 1;
    _2.forEach(g3.children(), function(child) {
      dfs(g3, root4, nodeSep, weight, height, depths, child);
    });
    g3.graph().nodeRankFactor = nodeSep;
  }
  function dfs(g3, root4, nodeSep, weight, height, depths, v2) {
    var children2 = g3.children(v2);
    if (!children2.length) {
      if (v2 !== root4) {
        g3.setEdge(root4, v2, { weight: 0, minlen: nodeSep });
      }
      return;
    }
    var top = util2.addBorderNode(g3, "_bt");
    var bottom = util2.addBorderNode(g3, "_bb");
    var label = g3.node(v2);
    g3.setParent(top, v2);
    label.borderTop = top;
    g3.setParent(bottom, v2);
    label.borderBottom = bottom;
    _2.forEach(children2, function(child) {
      dfs(g3, root4, nodeSep, weight, height, depths, child);
      var childNode = g3.node(child);
      var childTop = childNode.borderTop ? childNode.borderTop : child;
      var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
      var thisWeight = childNode.borderTop ? weight : 2 * weight;
      var minlen = childTop !== childBottom ? 1 : height - depths[v2] + 1;
      g3.setEdge(top, childTop, {
        weight: thisWeight,
        minlen,
        nestingEdge: true
      });
      g3.setEdge(childBottom, bottom, {
        weight: thisWeight,
        minlen,
        nestingEdge: true
      });
    });
    if (!g3.parent(v2)) {
      g3.setEdge(root4, top, { weight: 0, minlen: height + depths[v2] });
    }
  }
  function treeDepths(g3) {
    var depths = {};
    function dfs2(v2, depth) {
      var children2 = g3.children(v2);
      if (children2 && children2.length) {
        _2.forEach(children2, function(child) {
          dfs2(child, depth + 1);
        });
      }
      depths[v2] = depth;
    }
    _2.forEach(g3.children(), function(v2) {
      dfs2(v2, 1);
    });
    return depths;
  }
  function sumWeights(g3) {
    return _2.reduce(g3.edges(), function(acc, e8) {
      return acc + g3.edge(e8).weight;
    }, 0);
  }
  function cleanup(g3) {
    var graphLabel = g3.graph();
    g3.removeNode(graphLabel.nestingRoot);
    delete graphLabel.nestingRoot;
    _2.forEach(g3.edges(), function(e8) {
      var edge = g3.edge(e8);
      if (edge.nestingEdge) {
        g3.removeEdge(e8);
      }
    });
  }
  return nestingGraph;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/add-border-segments.js
var addBorderSegments_1;
var hasRequiredAddBorderSegments;
function requireAddBorderSegments() {
  if (hasRequiredAddBorderSegments)
    return addBorderSegments_1;
  hasRequiredAddBorderSegments = 1;
  var _2 = requireLodash();
  var util2 = requireUtil$1();
  addBorderSegments_1 = addBorderSegments;
  function addBorderSegments(g3) {
    function dfs(v2) {
      var children2 = g3.children(v2);
      var node = g3.node(v2);
      if (children2.length) {
        _2.forEach(children2, dfs);
      }
      if (_2.has(node, "minRank")) {
        node.borderLeft = [];
        node.borderRight = [];
        for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank) {
          addBorderNode(g3, "borderLeft", "_bl", v2, node, rank);
          addBorderNode(g3, "borderRight", "_br", v2, node, rank);
        }
      }
    }
    _2.forEach(g3.children(), dfs);
  }
  function addBorderNode(g3, prop, prefix, sg, sgNode, rank) {
    var label = { width: 0, height: 0, rank, borderType: prop };
    var prev = sgNode[prop][rank - 1];
    var curr = util2.addDummyNode(g3, "border", label, prefix);
    sgNode[prop][rank] = curr;
    g3.setParent(curr, sg);
    if (prev) {
      g3.setEdge(prev, curr, { weight: 1 });
    }
  }
  return addBorderSegments_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/coordinate-system.js
var coordinateSystem;
var hasRequiredCoordinateSystem;
function requireCoordinateSystem() {
  if (hasRequiredCoordinateSystem)
    return coordinateSystem;
  hasRequiredCoordinateSystem = 1;
  var _2 = requireLodash();
  coordinateSystem = {
    adjust,
    undo
  };
  function adjust(g3) {
    var rankDir = g3.graph().rankdir.toLowerCase();
    if (rankDir === "lr" || rankDir === "rl") {
      swapWidthHeight(g3);
    }
  }
  function undo(g3) {
    var rankDir = g3.graph().rankdir.toLowerCase();
    if (rankDir === "bt" || rankDir === "rl") {
      reverseY(g3);
    }
    if (rankDir === "lr" || rankDir === "rl") {
      swapXY(g3);
      swapWidthHeight(g3);
    }
  }
  function swapWidthHeight(g3) {
    _2.forEach(g3.nodes(), function(v2) {
      swapWidthHeightOne(g3.node(v2));
    });
    _2.forEach(g3.edges(), function(e8) {
      swapWidthHeightOne(g3.edge(e8));
    });
  }
  function swapWidthHeightOne(attrs) {
    var w3 = attrs.width;
    attrs.width = attrs.height;
    attrs.height = w3;
  }
  function reverseY(g3) {
    _2.forEach(g3.nodes(), function(v2) {
      reverseYOne(g3.node(v2));
    });
    _2.forEach(g3.edges(), function(e8) {
      var edge = g3.edge(e8);
      _2.forEach(edge.points, reverseYOne);
      if (_2.has(edge, "y")) {
        reverseYOne(edge);
      }
    });
  }
  function reverseYOne(attrs) {
    attrs.y = -attrs.y;
  }
  function swapXY(g3) {
    _2.forEach(g3.nodes(), function(v2) {
      swapXYOne(g3.node(v2));
    });
    _2.forEach(g3.edges(), function(e8) {
      var edge = g3.edge(e8);
      _2.forEach(edge.points, swapXYOne);
      if (_2.has(edge, "x")) {
        swapXYOne(edge);
      }
    });
  }
  function swapXYOne(attrs) {
    var x6 = attrs.x;
    attrs.x = attrs.y;
    attrs.y = x6;
  }
  return coordinateSystem;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/order/init-order.js
var initOrder_1;
var hasRequiredInitOrder;
function requireInitOrder() {
  if (hasRequiredInitOrder)
    return initOrder_1;
  hasRequiredInitOrder = 1;
  var _2 = requireLodash();
  initOrder_1 = initOrder;
  function initOrder(g3) {
    var visited = {};
    var simpleNodes = _2.filter(g3.nodes(), function(v2) {
      return !g3.children(v2).length;
    });
    var maxRank = _2.max(_2.map(simpleNodes, function(v2) {
      return g3.node(v2).rank;
    }));
    var layers = _2.map(_2.range(maxRank + 1), function() {
      return [];
    });
    function dfs(v2) {
      if (_2.has(visited, v2))
        return;
      visited[v2] = true;
      var node = g3.node(v2);
      layers[node.rank].push(v2);
      _2.forEach(g3.successors(v2), dfs);
    }
    var orderedVs = _2.sortBy(simpleNodes, function(v2) {
      return g3.node(v2).rank;
    });
    _2.forEach(orderedVs, dfs);
    return layers;
  }
  return initOrder_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/order/cross-count.js
var crossCount_1;
var hasRequiredCrossCount;
function requireCrossCount() {
  if (hasRequiredCrossCount)
    return crossCount_1;
  hasRequiredCrossCount = 1;
  var _2 = requireLodash();
  crossCount_1 = crossCount;
  function crossCount(g3, layering) {
    var cc = 0;
    for (var i4 = 1; i4 < layering.length; ++i4) {
      cc += twoLayerCrossCount(g3, layering[i4 - 1], layering[i4]);
    }
    return cc;
  }
  function twoLayerCrossCount(g3, northLayer, southLayer) {
    var southPos = _2.zipObject(
      southLayer,
      _2.map(southLayer, function(v2, i4) {
        return i4;
      })
    );
    var southEntries = _2.flatten(_2.map(northLayer, function(v2) {
      return _2.sortBy(_2.map(g3.outEdges(v2), function(e8) {
        return { pos: southPos[e8.w], weight: g3.edge(e8).weight };
      }), "pos");
    }), true);
    var firstIndex = 1;
    while (firstIndex < southLayer.length)
      firstIndex <<= 1;
    var treeSize = 2 * firstIndex - 1;
    firstIndex -= 1;
    var tree = _2.map(new Array(treeSize), function() {
      return 0;
    });
    var cc = 0;
    _2.forEach(southEntries.forEach(function(entry) {
      var index2 = entry.pos + firstIndex;
      tree[index2] += entry.weight;
      var weightSum = 0;
      while (index2 > 0) {
        if (index2 % 2) {
          weightSum += tree[index2 + 1];
        }
        index2 = index2 - 1 >> 1;
        tree[index2] += entry.weight;
      }
      cc += entry.weight * weightSum;
    }));
    return cc;
  }
  return crossCount_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/order/barycenter.js
var barycenter_1;
var hasRequiredBarycenter;
function requireBarycenter() {
  if (hasRequiredBarycenter)
    return barycenter_1;
  hasRequiredBarycenter = 1;
  var _2 = requireLodash();
  barycenter_1 = barycenter;
  function barycenter(g3, movable) {
    return _2.map(movable, function(v2) {
      var inV = g3.inEdges(v2);
      if (!inV.length) {
        return { v: v2 };
      } else {
        var result = _2.reduce(inV, function(acc, e8) {
          var edge = g3.edge(e8), nodeU = g3.node(e8.v);
          return {
            sum: acc.sum + edge.weight * nodeU.order,
            weight: acc.weight + edge.weight
          };
        }, { sum: 0, weight: 0 });
        return {
          v: v2,
          barycenter: result.sum / result.weight,
          weight: result.weight
        };
      }
    });
  }
  return barycenter_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/order/resolve-conflicts.js
var resolveConflicts_1;
var hasRequiredResolveConflicts;
function requireResolveConflicts() {
  if (hasRequiredResolveConflicts)
    return resolveConflicts_1;
  hasRequiredResolveConflicts = 1;
  var _2 = requireLodash();
  resolveConflicts_1 = resolveConflicts;
  function resolveConflicts(entries, cg) {
    var mappedEntries = {};
    _2.forEach(entries, function(entry, i4) {
      var tmp = mappedEntries[entry.v] = {
        indegree: 0,
        "in": [],
        out: [],
        vs: [entry.v],
        i: i4
      };
      if (!_2.isUndefined(entry.barycenter)) {
        tmp.barycenter = entry.barycenter;
        tmp.weight = entry.weight;
      }
    });
    _2.forEach(cg.edges(), function(e8) {
      var entryV = mappedEntries[e8.v];
      var entryW = mappedEntries[e8.w];
      if (!_2.isUndefined(entryV) && !_2.isUndefined(entryW)) {
        entryW.indegree++;
        entryV.out.push(mappedEntries[e8.w]);
      }
    });
    var sourceSet = _2.filter(mappedEntries, function(entry) {
      return !entry.indegree;
    });
    return doResolveConflicts(sourceSet);
  }
  function doResolveConflicts(sourceSet) {
    var entries = [];
    function handleIn(vEntry) {
      return function(uEntry) {
        if (uEntry.merged) {
          return;
        }
        if (_2.isUndefined(uEntry.barycenter) || _2.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
          mergeEntries(vEntry, uEntry);
        }
      };
    }
    function handleOut(vEntry) {
      return function(wEntry) {
        wEntry["in"].push(vEntry);
        if (--wEntry.indegree === 0) {
          sourceSet.push(wEntry);
        }
      };
    }
    while (sourceSet.length) {
      var entry = sourceSet.pop();
      entries.push(entry);
      _2.forEach(entry["in"].reverse(), handleIn(entry));
      _2.forEach(entry.out, handleOut(entry));
    }
    return _2.map(
      _2.filter(entries, function(entry2) {
        return !entry2.merged;
      }),
      function(entry2) {
        return _2.pick(entry2, ["vs", "i", "barycenter", "weight"]);
      }
    );
  }
  function mergeEntries(target, source) {
    var sum = 0;
    var weight = 0;
    if (target.weight) {
      sum += target.barycenter * target.weight;
      weight += target.weight;
    }
    if (source.weight) {
      sum += source.barycenter * source.weight;
      weight += source.weight;
    }
    target.vs = source.vs.concat(target.vs);
    target.barycenter = sum / weight;
    target.weight = weight;
    target.i = Math.min(source.i, target.i);
    source.merged = true;
  }
  return resolveConflicts_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/order/sort.js
var sort_1;
var hasRequiredSort;
function requireSort() {
  if (hasRequiredSort)
    return sort_1;
  hasRequiredSort = 1;
  var _2 = requireLodash();
  var util2 = requireUtil$1();
  sort_1 = sort;
  function sort(entries, biasRight) {
    var parts = util2.partition(entries, function(entry) {
      return _2.has(entry, "barycenter");
    });
    var sortable = parts.lhs, unsortable = _2.sortBy(parts.rhs, function(entry) {
      return -entry.i;
    }), vs = [], sum = 0, weight = 0, vsIndex = 0;
    sortable.sort(compareWithBias(!!biasRight));
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
    _2.forEach(sortable, function(entry) {
      vsIndex += entry.vs.length;
      vs.push(entry.vs);
      sum += entry.barycenter * entry.weight;
      weight += entry.weight;
      vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
    });
    var result = { vs: _2.flatten(vs, true) };
    if (weight) {
      result.barycenter = sum / weight;
      result.weight = weight;
    }
    return result;
  }
  function consumeUnsortable(vs, unsortable, index2) {
    var last;
    while (unsortable.length && (last = _2.last(unsortable)).i <= index2) {
      unsortable.pop();
      vs.push(last.vs);
      index2++;
    }
    return index2;
  }
  function compareWithBias(bias2) {
    return function(entryV, entryW) {
      if (entryV.barycenter < entryW.barycenter) {
        return -1;
      } else if (entryV.barycenter > entryW.barycenter) {
        return 1;
      }
      return !bias2 ? entryV.i - entryW.i : entryW.i - entryV.i;
    };
  }
  return sort_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/order/sort-subgraph.js
var sortSubgraph_1;
var hasRequiredSortSubgraph;
function requireSortSubgraph() {
  if (hasRequiredSortSubgraph)
    return sortSubgraph_1;
  hasRequiredSortSubgraph = 1;
  var _2 = requireLodash();
  var barycenter = requireBarycenter();
  var resolveConflicts = requireResolveConflicts();
  var sort = requireSort();
  sortSubgraph_1 = sortSubgraph;
  function sortSubgraph(g3, v2, cg, biasRight) {
    var movable = g3.children(v2);
    var node = g3.node(v2);
    var bl = node ? node.borderLeft : void 0;
    var br = node ? node.borderRight : void 0;
    var subgraphs = {};
    if (bl) {
      movable = _2.filter(movable, function(w3) {
        return w3 !== bl && w3 !== br;
      });
    }
    var barycenters = barycenter(g3, movable);
    _2.forEach(barycenters, function(entry) {
      if (g3.children(entry.v).length) {
        var subgraphResult = sortSubgraph(g3, entry.v, cg, biasRight);
        subgraphs[entry.v] = subgraphResult;
        if (_2.has(subgraphResult, "barycenter")) {
          mergeBarycenters(entry, subgraphResult);
        }
      }
    });
    var entries = resolveConflicts(barycenters, cg);
    expandSubgraphs(entries, subgraphs);
    var result = sort(entries, biasRight);
    if (bl) {
      result.vs = _2.flatten([bl, result.vs, br], true);
      if (g3.predecessors(bl).length) {
        var blPred = g3.node(g3.predecessors(bl)[0]), brPred = g3.node(g3.predecessors(br)[0]);
        if (!_2.has(result, "barycenter")) {
          result.barycenter = 0;
          result.weight = 0;
        }
        result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
        result.weight += 2;
      }
    }
    return result;
  }
  function expandSubgraphs(entries, subgraphs) {
    _2.forEach(entries, function(entry) {
      entry.vs = _2.flatten(entry.vs.map(function(v2) {
        if (subgraphs[v2]) {
          return subgraphs[v2].vs;
        }
        return v2;
      }), true);
    });
  }
  function mergeBarycenters(target, other) {
    if (!_2.isUndefined(target.barycenter)) {
      target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
      target.weight += other.weight;
    } else {
      target.barycenter = other.barycenter;
      target.weight = other.weight;
    }
  }
  return sortSubgraph_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/order/build-layer-graph.js
var buildLayerGraph_1;
var hasRequiredBuildLayerGraph;
function requireBuildLayerGraph() {
  if (hasRequiredBuildLayerGraph)
    return buildLayerGraph_1;
  hasRequiredBuildLayerGraph = 1;
  var _2 = requireLodash();
  var Graph = requireGraphlib().Graph;
  buildLayerGraph_1 = buildLayerGraph;
  function buildLayerGraph(g3, rank, relationship) {
    var root4 = createRootNode(g3), result = new Graph({ compound: true }).setGraph({ root: root4 }).setDefaultNodeLabel(function(v2) {
      return g3.node(v2);
    });
    _2.forEach(g3.nodes(), function(v2) {
      var node = g3.node(v2), parent = g3.parent(v2);
      if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
        result.setNode(v2);
        result.setParent(v2, parent || root4);
        _2.forEach(g3[relationship](v2), function(e8) {
          var u4 = e8.v === v2 ? e8.w : e8.v, edge = result.edge(u4, v2), weight = !_2.isUndefined(edge) ? edge.weight : 0;
          result.setEdge(u4, v2, { weight: g3.edge(e8).weight + weight });
        });
        if (_2.has(node, "minRank")) {
          result.setNode(v2, {
            borderLeft: node.borderLeft[rank],
            borderRight: node.borderRight[rank]
          });
        }
      }
    });
    return result;
  }
  function createRootNode(g3) {
    var v2;
    while (g3.hasNode(v2 = _2.uniqueId("_root")))
      ;
    return v2;
  }
  return buildLayerGraph_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/order/add-subgraph-constraints.js
var addSubgraphConstraints_1;
var hasRequiredAddSubgraphConstraints;
function requireAddSubgraphConstraints() {
  if (hasRequiredAddSubgraphConstraints)
    return addSubgraphConstraints_1;
  hasRequiredAddSubgraphConstraints = 1;
  var _2 = requireLodash();
  addSubgraphConstraints_1 = addSubgraphConstraints;
  function addSubgraphConstraints(g3, cg, vs) {
    var prev = {}, rootPrev;
    _2.forEach(vs, function(v2) {
      var child = g3.parent(v2), parent, prevChild;
      while (child) {
        parent = g3.parent(child);
        if (parent) {
          prevChild = prev[parent];
          prev[parent] = child;
        } else {
          prevChild = rootPrev;
          rootPrev = child;
        }
        if (prevChild && prevChild !== child) {
          cg.setEdge(prevChild, child);
          return;
        }
        child = parent;
      }
    });
  }
  return addSubgraphConstraints_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/order/index.js
var order_1;
var hasRequiredOrder;
function requireOrder() {
  if (hasRequiredOrder)
    return order_1;
  hasRequiredOrder = 1;
  var _2 = requireLodash();
  var initOrder = requireInitOrder();
  var crossCount = requireCrossCount();
  var sortSubgraph = requireSortSubgraph();
  var buildLayerGraph = requireBuildLayerGraph();
  var addSubgraphConstraints = requireAddSubgraphConstraints();
  var Graph = requireGraphlib().Graph;
  var util2 = requireUtil$1();
  order_1 = order;
  function order(g3) {
    var maxRank = util2.maxRank(g3), downLayerGraphs = buildLayerGraphs(g3, _2.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g3, _2.range(maxRank - 1, -1, -1), "outEdges");
    var layering = initOrder(g3);
    assignOrder(g3, layering);
    var bestCC = Number.POSITIVE_INFINITY, best;
    for (var i4 = 0, lastBest = 0; lastBest < 4; ++i4, ++lastBest) {
      sweepLayerGraphs(i4 % 2 ? downLayerGraphs : upLayerGraphs, i4 % 4 >= 2);
      layering = util2.buildLayerMatrix(g3);
      var cc = crossCount(g3, layering);
      if (cc < bestCC) {
        lastBest = 0;
        best = _2.cloneDeep(layering);
        bestCC = cc;
      }
    }
    assignOrder(g3, best);
  }
  function buildLayerGraphs(g3, ranks, relationship) {
    return _2.map(ranks, function(rank) {
      return buildLayerGraph(g3, rank, relationship);
    });
  }
  function sweepLayerGraphs(layerGraphs, biasRight) {
    var cg = new Graph();
    _2.forEach(layerGraphs, function(lg) {
      var root4 = lg.graph().root;
      var sorted = sortSubgraph(lg, root4, cg, biasRight);
      _2.forEach(sorted.vs, function(v2, i4) {
        lg.node(v2).order = i4;
      });
      addSubgraphConstraints(lg, cg, sorted.vs);
    });
  }
  function assignOrder(g3, layering) {
    _2.forEach(layering, function(layer) {
      _2.forEach(layer, function(v2, i4) {
        g3.node(v2).order = i4;
      });
    });
  }
  return order_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/position/bk.js
var bk;
var hasRequiredBk;
function requireBk() {
  if (hasRequiredBk)
    return bk;
  hasRequiredBk = 1;
  var _2 = requireLodash();
  var Graph = requireGraphlib().Graph;
  var util2 = requireUtil$1();
  bk = {
    positionX,
    findType1Conflicts,
    findType2Conflicts,
    addConflict,
    hasConflict,
    verticalAlignment,
    horizontalCompaction,
    alignCoordinates,
    findSmallestWidthAlignment,
    balance
  };
  function findType1Conflicts(g3, layering) {
    var conflicts = {};
    function visitLayer(prevLayer, layer) {
      var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _2.last(layer);
      _2.forEach(layer, function(v2, i4) {
        var w3 = findOtherInnerSegmentNode(g3, v2), k1 = w3 ? g3.node(w3).order : prevLayerLength;
        if (w3 || v2 === lastNode) {
          _2.forEach(layer.slice(scanPos, i4 + 1), function(scanNode) {
            _2.forEach(g3.predecessors(scanNode), function(u4) {
              var uLabel = g3.node(u4), uPos = uLabel.order;
              if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g3.node(scanNode).dummy)) {
                addConflict(conflicts, u4, scanNode);
              }
            });
          });
          scanPos = i4 + 1;
          k0 = k1;
        }
      });
      return layer;
    }
    _2.reduce(layering, visitLayer);
    return conflicts;
  }
  function findType2Conflicts(g3, layering) {
    var conflicts = {};
    function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
      var v2;
      _2.forEach(_2.range(southPos, southEnd), function(i4) {
        v2 = south[i4];
        if (g3.node(v2).dummy) {
          _2.forEach(g3.predecessors(v2), function(u4) {
            var uNode = g3.node(u4);
            if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
              addConflict(conflicts, u4, v2);
            }
          });
        }
      });
    }
    function visitLayer(north, south) {
      var prevNorthPos = -1, nextNorthPos, southPos = 0;
      _2.forEach(south, function(v2, southLookahead) {
        if (g3.node(v2).dummy === "border") {
          var predecessors = g3.predecessors(v2);
          if (predecessors.length) {
            nextNorthPos = g3.node(predecessors[0]).order;
            scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
            southPos = southLookahead;
            prevNorthPos = nextNorthPos;
          }
        }
        scan(south, southPos, south.length, nextNorthPos, north.length);
      });
      return south;
    }
    _2.reduce(layering, visitLayer);
    return conflicts;
  }
  function findOtherInnerSegmentNode(g3, v2) {
    if (g3.node(v2).dummy) {
      return _2.find(g3.predecessors(v2), function(u4) {
        return g3.node(u4).dummy;
      });
    }
  }
  function addConflict(conflicts, v2, w3) {
    if (v2 > w3) {
      var tmp = v2;
      v2 = w3;
      w3 = tmp;
    }
    var conflictsV = conflicts[v2];
    if (!conflictsV) {
      conflicts[v2] = conflictsV = {};
    }
    conflictsV[w3] = true;
  }
  function hasConflict(conflicts, v2, w3) {
    if (v2 > w3) {
      var tmp = v2;
      v2 = w3;
      w3 = tmp;
    }
    return _2.has(conflicts[v2], w3);
  }
  function verticalAlignment(g3, layering, conflicts, neighborFn) {
    var root4 = {}, align = {}, pos = {};
    _2.forEach(layering, function(layer) {
      _2.forEach(layer, function(v2, order) {
        root4[v2] = v2;
        align[v2] = v2;
        pos[v2] = order;
      });
    });
    _2.forEach(layering, function(layer) {
      var prevIdx = -1;
      _2.forEach(layer, function(v2) {
        var ws = neighborFn(v2);
        if (ws.length) {
          ws = _2.sortBy(ws, function(w4) {
            return pos[w4];
          });
          var mp = (ws.length - 1) / 2;
          for (var i4 = Math.floor(mp), il = Math.ceil(mp); i4 <= il; ++i4) {
            var w3 = ws[i4];
            if (align[v2] === v2 && prevIdx < pos[w3] && !hasConflict(conflicts, v2, w3)) {
              align[w3] = v2;
              align[v2] = root4[v2] = root4[w3];
              prevIdx = pos[w3];
            }
          }
        }
      });
    });
    return { root: root4, align };
  }
  function horizontalCompaction(g3, layering, root4, align, reverseSep) {
    var xs = {}, blockG = buildBlockGraph(g3, layering, root4, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
    function iterate(setXsFunc, nextNodesFunc) {
      var stack = blockG.nodes();
      var elem = stack.pop();
      var visited = {};
      while (elem) {
        if (visited[elem]) {
          setXsFunc(elem);
        } else {
          visited[elem] = true;
          stack.push(elem);
          stack = stack.concat(nextNodesFunc(elem));
        }
        elem = stack.pop();
      }
    }
    function pass1(elem) {
      xs[elem] = blockG.inEdges(elem).reduce(function(acc, e8) {
        return Math.max(acc, xs[e8.v] + blockG.edge(e8));
      }, 0);
    }
    function pass2(elem) {
      var min3 = blockG.outEdges(elem).reduce(function(acc, e8) {
        return Math.min(acc, xs[e8.w] - blockG.edge(e8));
      }, Number.POSITIVE_INFINITY);
      var node = g3.node(elem);
      if (min3 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
        xs[elem] = Math.max(xs[elem], min3);
      }
    }
    iterate(pass1, blockG.predecessors.bind(blockG));
    iterate(pass2, blockG.successors.bind(blockG));
    _2.forEach(align, function(v2) {
      xs[v2] = xs[root4[v2]];
    });
    return xs;
  }
  function buildBlockGraph(g3, layering, root4, reverseSep) {
    var blockGraph = new Graph(), graphLabel = g3.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
    _2.forEach(layering, function(layer) {
      var u4;
      _2.forEach(layer, function(v2) {
        var vRoot = root4[v2];
        blockGraph.setNode(vRoot);
        if (u4) {
          var uRoot = root4[u4], prevMax = blockGraph.edge(uRoot, vRoot);
          blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g3, v2, u4), prevMax || 0));
        }
        u4 = v2;
      });
    });
    return blockGraph;
  }
  function findSmallestWidthAlignment(g3, xss) {
    return _2.minBy(_2.values(xss), function(xs) {
      var max3 = Number.NEGATIVE_INFINITY;
      var min3 = Number.POSITIVE_INFINITY;
      _2.forIn(xs, function(x6, v2) {
        var halfWidth = width(g3, v2) / 2;
        max3 = Math.max(x6 + halfWidth, max3);
        min3 = Math.min(x6 - halfWidth, min3);
      });
      return max3 - min3;
    });
  }
  function alignCoordinates(xss, alignTo) {
    var alignToVals = _2.values(alignTo), alignToMin = _2.min(alignToVals), alignToMax = _2.max(alignToVals);
    _2.forEach(["u", "d"], function(vert) {
      _2.forEach(["l", "r"], function(horiz) {
        var alignment = vert + horiz, xs = xss[alignment], delta;
        if (xs === alignTo)
          return;
        var xsVals = _2.values(xs);
        delta = horiz === "l" ? alignToMin - _2.min(xsVals) : alignToMax - _2.max(xsVals);
        if (delta) {
          xss[alignment] = _2.mapValues(xs, function(x6) {
            return x6 + delta;
          });
        }
      });
    });
  }
  function balance(xss, align) {
    return _2.mapValues(xss.ul, function(ignore, v2) {
      if (align) {
        return xss[align.toLowerCase()][v2];
      } else {
        var xs = _2.sortBy(_2.map(xss, v2));
        return (xs[1] + xs[2]) / 2;
      }
    });
  }
  function positionX(g3) {
    var layering = util2.buildLayerMatrix(g3);
    var conflicts = _2.merge(
      findType1Conflicts(g3, layering),
      findType2Conflicts(g3, layering)
    );
    var xss = {};
    var adjustedLayering;
    _2.forEach(["u", "d"], function(vert) {
      adjustedLayering = vert === "u" ? layering : _2.values(layering).reverse();
      _2.forEach(["l", "r"], function(horiz) {
        if (horiz === "r") {
          adjustedLayering = _2.map(adjustedLayering, function(inner) {
            return _2.values(inner).reverse();
          });
        }
        var neighborFn = (vert === "u" ? g3.predecessors : g3.successors).bind(g3);
        var align = verticalAlignment(g3, adjustedLayering, conflicts, neighborFn);
        var xs = horizontalCompaction(
          g3,
          adjustedLayering,
          align.root,
          align.align,
          horiz === "r"
        );
        if (horiz === "r") {
          xs = _2.mapValues(xs, function(x6) {
            return -x6;
          });
        }
        xss[vert + horiz] = xs;
      });
    });
    var smallestWidth = findSmallestWidthAlignment(g3, xss);
    alignCoordinates(xss, smallestWidth);
    return balance(xss, g3.graph().align);
  }
  function sep(nodeSep, edgeSep, reverseSep) {
    return function(g3, v2, w3) {
      var vLabel = g3.node(v2);
      var wLabel = g3.node(w3);
      var sum = 0;
      var delta;
      sum += vLabel.width / 2;
      if (_2.has(vLabel, "labelpos")) {
        switch (vLabel.labelpos.toLowerCase()) {
          case "l":
            delta = -vLabel.width / 2;
            break;
          case "r":
            delta = vLabel.width / 2;
            break;
        }
      }
      if (delta) {
        sum += reverseSep ? delta : -delta;
      }
      delta = 0;
      sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
      sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
      sum += wLabel.width / 2;
      if (_2.has(wLabel, "labelpos")) {
        switch (wLabel.labelpos.toLowerCase()) {
          case "l":
            delta = wLabel.width / 2;
            break;
          case "r":
            delta = -wLabel.width / 2;
            break;
        }
      }
      if (delta) {
        sum += reverseSep ? delta : -delta;
      }
      delta = 0;
      return sum;
    };
  }
  function width(g3, v2) {
    return g3.node(v2).width;
  }
  return bk;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/position/index.js
var position_1;
var hasRequiredPosition;
function requirePosition() {
  if (hasRequiredPosition)
    return position_1;
  hasRequiredPosition = 1;
  var _2 = requireLodash();
  var util2 = requireUtil$1();
  var positionX = requireBk().positionX;
  position_1 = position;
  function position(g3) {
    g3 = util2.asNonCompoundGraph(g3);
    positionY(g3);
    _2.forEach(positionX(g3), function(x6, v2) {
      g3.node(v2).x = x6;
    });
  }
  function positionY(g3) {
    var layering = util2.buildLayerMatrix(g3);
    var rankSep = g3.graph().ranksep;
    var prevY = 0;
    _2.forEach(layering, function(layer) {
      var maxHeight = _2.max(_2.map(layer, function(v2) {
        return g3.node(v2).height;
      }));
      _2.forEach(layer, function(v2) {
        g3.node(v2).y = prevY + maxHeight / 2;
      });
      prevY += maxHeight + rankSep;
    });
  }
  return position_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/layout.js
var layout_1;
var hasRequiredLayout;
function requireLayout() {
  if (hasRequiredLayout)
    return layout_1;
  hasRequiredLayout = 1;
  var _2 = requireLodash();
  var acyclic2 = requireAcyclic();
  var normalize3 = requireNormalize();
  var rank = requireRank();
  var normalizeRanks = requireUtil$1().normalizeRanks;
  var parentDummyChains = requireParentDummyChains();
  var removeEmptyRanks = requireUtil$1().removeEmptyRanks;
  var nestingGraph2 = requireNestingGraph();
  var addBorderSegments = requireAddBorderSegments();
  var coordinateSystem2 = requireCoordinateSystem();
  var order = requireOrder();
  var position = requirePosition();
  var util2 = requireUtil$1();
  var Graph = requireGraphlib().Graph;
  layout_1 = layout;
  function layout(g3, opts) {
    var time = opts && opts.debugTiming ? util2.time : util2.notime;
    time("layout", function() {
      var layoutGraph = time("  buildLayoutGraph", function() {
        return buildLayoutGraph(g3);
      });
      time("  runLayout", function() {
        runLayout(layoutGraph, time);
      });
      time("  updateInputGraph", function() {
        updateInputGraph(g3, layoutGraph);
      });
    });
  }
  function runLayout(g3, time) {
    time("    makeSpaceForEdgeLabels", function() {
      makeSpaceForEdgeLabels(g3);
    });
    time("    removeSelfEdges", function() {
      removeSelfEdges(g3);
    });
    time("    acyclic", function() {
      acyclic2.run(g3);
    });
    time("    nestingGraph.run", function() {
      nestingGraph2.run(g3);
    });
    time("    rank", function() {
      rank(util2.asNonCompoundGraph(g3));
    });
    time("    injectEdgeLabelProxies", function() {
      injectEdgeLabelProxies(g3);
    });
    time("    removeEmptyRanks", function() {
      removeEmptyRanks(g3);
    });
    time("    nestingGraph.cleanup", function() {
      nestingGraph2.cleanup(g3);
    });
    time("    normalizeRanks", function() {
      normalizeRanks(g3);
    });
    time("    assignRankMinMax", function() {
      assignRankMinMax(g3);
    });
    time("    removeEdgeLabelProxies", function() {
      removeEdgeLabelProxies(g3);
    });
    time("    normalize.run", function() {
      normalize3.run(g3);
    });
    time("    parentDummyChains", function() {
      parentDummyChains(g3);
    });
    time("    addBorderSegments", function() {
      addBorderSegments(g3);
    });
    time("    order", function() {
      order(g3);
    });
    time("    insertSelfEdges", function() {
      insertSelfEdges(g3);
    });
    time("    adjustCoordinateSystem", function() {
      coordinateSystem2.adjust(g3);
    });
    time("    position", function() {
      position(g3);
    });
    time("    positionSelfEdges", function() {
      positionSelfEdges(g3);
    });
    time("    removeBorderNodes", function() {
      removeBorderNodes(g3);
    });
    time("    normalize.undo", function() {
      normalize3.undo(g3);
    });
    time("    fixupEdgeLabelCoords", function() {
      fixupEdgeLabelCoords(g3);
    });
    time("    undoCoordinateSystem", function() {
      coordinateSystem2.undo(g3);
    });
    time("    translateGraph", function() {
      translateGraph(g3);
    });
    time("    assignNodeIntersects", function() {
      assignNodeIntersects(g3);
    });
    time("    reversePoints", function() {
      reversePointsForReversedEdges(g3);
    });
    time("    acyclic.undo", function() {
      acyclic2.undo(g3);
    });
  }
  function updateInputGraph(inputGraph, layoutGraph) {
    _2.forEach(inputGraph.nodes(), function(v2) {
      var inputLabel = inputGraph.node(v2);
      var layoutLabel = layoutGraph.node(v2);
      if (inputLabel) {
        inputLabel.x = layoutLabel.x;
        inputLabel.y = layoutLabel.y;
        if (layoutGraph.children(v2).length) {
          inputLabel.width = layoutLabel.width;
          inputLabel.height = layoutLabel.height;
        }
      }
    });
    _2.forEach(inputGraph.edges(), function(e8) {
      var inputLabel = inputGraph.edge(e8);
      var layoutLabel = layoutGraph.edge(e8);
      inputLabel.points = layoutLabel.points;
      if (_2.has(layoutLabel, "x")) {
        inputLabel.x = layoutLabel.x;
        inputLabel.y = layoutLabel.y;
      }
    });
    inputGraph.graph().width = layoutGraph.graph().width;
    inputGraph.graph().height = layoutGraph.graph().height;
  }
  var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
  var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
  var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
  var nodeNumAttrs = ["width", "height"];
  var nodeDefaults = { width: 0, height: 0 };
  var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
  var edgeDefaults = {
    minlen: 1,
    weight: 1,
    width: 0,
    height: 0,
    labeloffset: 10,
    labelpos: "r"
  };
  var edgeAttrs = ["labelpos"];
  function buildLayoutGraph(inputGraph) {
    var g3 = new Graph({ multigraph: true, compound: true });
    var graph2 = canonicalize(inputGraph.graph());
    g3.setGraph(_2.merge(
      {},
      graphDefaults,
      selectNumberAttrs(graph2, graphNumAttrs),
      _2.pick(graph2, graphAttrs)
    ));
    _2.forEach(inputGraph.nodes(), function(v2) {
      var node = canonicalize(inputGraph.node(v2));
      g3.setNode(v2, _2.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
      g3.setParent(v2, inputGraph.parent(v2));
    });
    _2.forEach(inputGraph.edges(), function(e8) {
      var edge = canonicalize(inputGraph.edge(e8));
      g3.setEdge(e8, _2.merge(
        {},
        edgeDefaults,
        selectNumberAttrs(edge, edgeNumAttrs),
        _2.pick(edge, edgeAttrs)
      ));
    });
    return g3;
  }
  function makeSpaceForEdgeLabels(g3) {
    var graph2 = g3.graph();
    graph2.ranksep /= 2;
    _2.forEach(g3.edges(), function(e8) {
      var edge = g3.edge(e8);
      edge.minlen *= 2;
      if (edge.labelpos.toLowerCase() !== "c") {
        if (graph2.rankdir === "TB" || graph2.rankdir === "BT") {
          edge.width += edge.labeloffset;
        } else {
          edge.height += edge.labeloffset;
        }
      }
    });
  }
  function injectEdgeLabelProxies(g3) {
    _2.forEach(g3.edges(), function(e8) {
      var edge = g3.edge(e8);
      if (edge.width && edge.height) {
        var v2 = g3.node(e8.v);
        var w3 = g3.node(e8.w);
        var label = { rank: (w3.rank - v2.rank) / 2 + v2.rank, e: e8 };
        util2.addDummyNode(g3, "edge-proxy", label, "_ep");
      }
    });
  }
  function assignRankMinMax(g3) {
    var maxRank = 0;
    _2.forEach(g3.nodes(), function(v2) {
      var node = g3.node(v2);
      if (node.borderTop) {
        node.minRank = g3.node(node.borderTop).rank;
        node.maxRank = g3.node(node.borderBottom).rank;
        maxRank = _2.max(maxRank, node.maxRank);
      }
    });
    g3.graph().maxRank = maxRank;
  }
  function removeEdgeLabelProxies(g3) {
    _2.forEach(g3.nodes(), function(v2) {
      var node = g3.node(v2);
      if (node.dummy === "edge-proxy") {
        g3.edge(node.e).labelRank = node.rank;
        g3.removeNode(v2);
      }
    });
  }
  function translateGraph(g3) {
    var minX = Number.POSITIVE_INFINITY;
    var maxX = 0;
    var minY = Number.POSITIVE_INFINITY;
    var maxY = 0;
    var graphLabel = g3.graph();
    var marginX = graphLabel.marginx || 0;
    var marginY = graphLabel.marginy || 0;
    function getExtremes(attrs) {
      var x6 = attrs.x;
      var y6 = attrs.y;
      var w3 = attrs.width;
      var h4 = attrs.height;
      minX = Math.min(minX, x6 - w3 / 2);
      maxX = Math.max(maxX, x6 + w3 / 2);
      minY = Math.min(minY, y6 - h4 / 2);
      maxY = Math.max(maxY, y6 + h4 / 2);
    }
    _2.forEach(g3.nodes(), function(v2) {
      getExtremes(g3.node(v2));
    });
    _2.forEach(g3.edges(), function(e8) {
      var edge = g3.edge(e8);
      if (_2.has(edge, "x")) {
        getExtremes(edge);
      }
    });
    minX -= marginX;
    minY -= marginY;
    _2.forEach(g3.nodes(), function(v2) {
      var node = g3.node(v2);
      node.x -= minX;
      node.y -= minY;
    });
    _2.forEach(g3.edges(), function(e8) {
      var edge = g3.edge(e8);
      _2.forEach(edge.points, function(p7) {
        p7.x -= minX;
        p7.y -= minY;
      });
      if (_2.has(edge, "x")) {
        edge.x -= minX;
      }
      if (_2.has(edge, "y")) {
        edge.y -= minY;
      }
    });
    graphLabel.width = maxX - minX + marginX;
    graphLabel.height = maxY - minY + marginY;
  }
  function assignNodeIntersects(g3) {
    _2.forEach(g3.edges(), function(e8) {
      var edge = g3.edge(e8);
      var nodeV = g3.node(e8.v);
      var nodeW = g3.node(e8.w);
      var p1, p22;
      if (!edge.points) {
        edge.points = [];
        p1 = nodeW;
        p22 = nodeV;
      } else {
        p1 = edge.points[0];
        p22 = edge.points[edge.points.length - 1];
      }
      edge.points.unshift(util2.intersectRect(nodeV, p1));
      edge.points.push(util2.intersectRect(nodeW, p22));
    });
  }
  function fixupEdgeLabelCoords(g3) {
    _2.forEach(g3.edges(), function(e8) {
      var edge = g3.edge(e8);
      if (_2.has(edge, "x")) {
        if (edge.labelpos === "l" || edge.labelpos === "r") {
          edge.width -= edge.labeloffset;
        }
        switch (edge.labelpos) {
          case "l":
            edge.x -= edge.width / 2 + edge.labeloffset;
            break;
          case "r":
            edge.x += edge.width / 2 + edge.labeloffset;
            break;
        }
      }
    });
  }
  function reversePointsForReversedEdges(g3) {
    _2.forEach(g3.edges(), function(e8) {
      var edge = g3.edge(e8);
      if (edge.reversed) {
        edge.points.reverse();
      }
    });
  }
  function removeBorderNodes(g3) {
    _2.forEach(g3.nodes(), function(v2) {
      if (g3.children(v2).length) {
        var node = g3.node(v2);
        var t2 = g3.node(node.borderTop);
        var b2 = g3.node(node.borderBottom);
        var l3 = g3.node(_2.last(node.borderLeft));
        var r5 = g3.node(_2.last(node.borderRight));
        node.width = Math.abs(r5.x - l3.x);
        node.height = Math.abs(b2.y - t2.y);
        node.x = l3.x + node.width / 2;
        node.y = t2.y + node.height / 2;
      }
    });
    _2.forEach(g3.nodes(), function(v2) {
      if (g3.node(v2).dummy === "border") {
        g3.removeNode(v2);
      }
    });
  }
  function removeSelfEdges(g3) {
    _2.forEach(g3.edges(), function(e8) {
      if (e8.v === e8.w) {
        var node = g3.node(e8.v);
        if (!node.selfEdges) {
          node.selfEdges = [];
        }
        node.selfEdges.push({ e: e8, label: g3.edge(e8) });
        g3.removeEdge(e8);
      }
    });
  }
  function insertSelfEdges(g3) {
    var layers = util2.buildLayerMatrix(g3);
    _2.forEach(layers, function(layer) {
      var orderShift = 0;
      _2.forEach(layer, function(v2, i4) {
        var node = g3.node(v2);
        node.order = i4 + orderShift;
        _2.forEach(node.selfEdges, function(selfEdge) {
          util2.addDummyNode(g3, "selfedge", {
            width: selfEdge.label.width,
            height: selfEdge.label.height,
            rank: node.rank,
            order: i4 + ++orderShift,
            e: selfEdge.e,
            label: selfEdge.label
          }, "_se");
        });
        delete node.selfEdges;
      });
    });
  }
  function positionSelfEdges(g3) {
    _2.forEach(g3.nodes(), function(v2) {
      var node = g3.node(v2);
      if (node.dummy === "selfedge") {
        var selfNode = g3.node(node.e.v);
        var x6 = selfNode.x + selfNode.width / 2;
        var y6 = selfNode.y;
        var dx = node.x - x6;
        var dy = selfNode.height / 2;
        g3.setEdge(node.e, node.label);
        g3.removeNode(v2);
        node.label.points = [
          { x: x6 + 2 * dx / 3, y: y6 - dy },
          { x: x6 + 5 * dx / 6, y: y6 - dy },
          { x: x6 + dx, y: y6 },
          { x: x6 + 5 * dx / 6, y: y6 + dy },
          { x: x6 + 2 * dx / 3, y: y6 + dy }
        ];
        node.label.x = node.x;
        node.label.y = node.y;
      }
    });
  }
  function selectNumberAttrs(obj, attrs) {
    return _2.mapValues(_2.pick(obj, attrs), Number);
  }
  function canonicalize(attrs) {
    var newAttrs = {};
    _2.forEach(attrs, function(v2, k5) {
      newAttrs[k5.toLowerCase()] = v2;
    });
    return newAttrs;
  }
  return layout_1;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/debug.js
var debug;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug)
    return debug;
  hasRequiredDebug = 1;
  var _2 = requireLodash();
  var util2 = requireUtil$1();
  var Graph = requireGraphlib().Graph;
  debug = {
    debugOrdering
  };
  function debugOrdering(g3) {
    var layerMatrix = util2.buildLayerMatrix(g3);
    var h4 = new Graph({ compound: true, multigraph: true }).setGraph({});
    _2.forEach(g3.nodes(), function(v2) {
      h4.setNode(v2, { label: v2 });
      h4.setParent(v2, "layer" + g3.node(v2).rank);
    });
    _2.forEach(g3.edges(), function(e8) {
      h4.setEdge(e8.v, e8.w, {}, e8.name);
    });
    _2.forEach(layerMatrix, function(layer, i4) {
      var layerV = "layer" + i4;
      h4.setNode(layerV, { rank: "same" });
      _2.reduce(layer, function(u4, v2) {
        h4.setEdge(u4, v2, { style: "invis" });
        return v2;
      });
    });
    return h4;
  }
  return debug;
}

// node_modules/@antv/layout/lib/node_modules/dagre/lib/version.js
var version;
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion)
    return version;
  hasRequiredVersion = 1;
  version = "0.8.5";
  return version;
}

// node_modules/@antv/layout/lib/node_modules/dagre/index.js
var dagre$1;
var hasRequiredDagre;
function requireDagre() {
  if (hasRequiredDagre)
    return dagre$1;
  hasRequiredDagre = 1;
  dagre$1 = {
    graphlib: requireGraphlib(),
    layout: requireLayout(),
    debug: requireDebug(),
    util: {
      time: requireUtil$1().time,
      notime: requireUtil$1().notime
    },
    version: requireVersion()
  };
  return dagre$1;
}

// node_modules/@antv/layout/lib/_virtual/index.js
var dagreExports = requireDagre();
var dagre = /* @__PURE__ */ getDefaultExportFromCjs(dagreExports);

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/is-boolean.js
var isBoolean = function(value) {
  return isType(value, "Boolean");
};

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/each.js
function each$1(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (isArray$1(elements)) {
    for (var i4 = 0, len = elements.length; i4 < len; i4++) {
      rst = func(elements[i4], i4);
      if (rst === false) {
        break;
      }
    }
  } else if (isObject$1(elements)) {
    for (var k5 in elements) {
      if (elements.hasOwnProperty(k5)) {
        rst = func(elements[k5], k5);
        if (rst === false) {
          break;
        }
      }
    }
  }
}

// node_modules/@antv/layout/lib/node_modules/@antv/util/esm/lodash/pick.js
var hasOwnProperty12 = Object.prototype.hasOwnProperty;
var pick = function(object2, keys2) {
  if (object2 === null || !isPlainObject2(object2)) {
    return {};
  }
  var result = {};
  each$1(keys2, function(key) {
    if (hasOwnProperty12.call(object2, key)) {
      result[key] = object2[key];
    }
  });
  return result;
};

// node_modules/@antv/layout/lib/algorithm/dagre/index.js
var DagreLayout = class extends BaseLayout {
  constructor() {
    super(...arguments);
    this.id = "dagre";
    this.isCompoundGraph = null;
    this.config = {
      graphAttributes: [
        "rankdir",
        "align",
        "nodesep",
        "edgesep",
        "ranksep",
        "marginx",
        "marginy",
        "acyclicer",
        "ranker"
      ],
      nodeAttributes: ["width", "height"],
      edgeAttributes: [
        "minlen",
        "weight",
        "width",
        "height",
        "labelpos",
        "labeloffset"
      ]
    };
  }
  getDefaultOptions() {
    return {
      directed: true,
      multigraph: true,
      rankdir: "TB",
      align: void 0,
      nodesep: 50,
      edgesep: 10,
      ranksep: 50,
      marginx: 0,
      marginy: 0,
      acyclicer: void 0,
      ranker: "network-simplex",
      nodeSize: [0, 0],
      edgeMinLen: 1,
      edgeWeight: 1,
      edgeLabelSize: [0, 0],
      edgeLabelPos: "r",
      edgeLabelOffset: 10
    };
  }
  layout() {
    return __awaiter7(this, void 0, void 0, function* () {
      const g3 = new dagreExports.graphlib.Graph({
        directed: !!this.options.directed,
        multigraph: !!this.options.multigraph,
        compound: this.isCompound()
      });
      g3.setGraph(pick(this.options, this.config.graphAttributes));
      g3.setDefaultEdgeLabel(() => ({}));
      const nodeSizeFn = formatSizeFn(this.options.nodeSize, 0);
      this.model.forEachNode((node) => {
        const raw = node._original;
        const [width, height] = parseSize(nodeSizeFn(raw));
        const label = { width, height };
        g3.setNode(String(node.id), label);
        if (this.isCompound()) {
          if (isNil(node.parentId))
            return;
          g3.setParent(String(node.id), String(node.parentId));
        }
      });
      const { edgeLabelSize, edgeLabelOffset, edgeLabelPos, edgeMinLen, edgeWeight } = this.options;
      const edgeLabelSizeFn = formatSizeFn(edgeLabelSize, 0, "edge");
      const edgeLabelOffsetFn = formatNumberFn(edgeLabelOffset, 10, "edge");
      const edgeLabelPosFn = typeof edgeLabelPos === "string" ? () => edgeLabelPos : formatFn(edgeLabelPos, ["edge"]);
      const edgeMinLenFn = formatNumberFn(edgeMinLen, 1, "edge");
      const edgeWeightFn = formatNumberFn(edgeWeight, 1, "edge");
      this.model.forEachEdge((edge) => {
        const raw = edge._original;
        const [lw, lh] = parseSize(edgeLabelSizeFn(raw));
        const label = {
          width: lw,
          height: lh,
          labelpos: edgeLabelPosFn(raw),
          labeloffset: edgeLabelOffsetFn(raw),
          minlen: edgeMinLenFn(raw),
          weight: edgeWeightFn(raw)
        };
        g3.setEdge(String(edge.source), String(edge.target), label, String(edge.id));
      });
      dagre.layout(g3);
      this.model.forEachNode((node) => {
        const data = g3.node(String(node.id));
        if (!data)
          return;
        node.x = data.x;
        node.y = data.y;
        node.size = [data.width, data.height];
      });
      this.model.forEachEdge((edge) => {
        const data = g3.edge(String(edge.source), String(edge.target), String(edge.id));
        if (!data)
          return;
        const { width, height, weight, minlen, labelpos, labeloffset, points } = data;
        edge.labelSize = [width, height];
        edge.weight = weight;
        edge.minLen = minlen;
        edge.labelPos = labelpos;
        edge.labelOffset = labeloffset;
        edge.points = points.map(parsePoint);
      });
    });
  }
  isCompound() {
    if (this.isCompoundGraph !== null)
      return this.isCompoundGraph;
    if (isBoolean(this.options.compound)) {
      return this.isCompoundGraph = this.options.compound;
    }
    this.isCompoundGraph = this.model.nodes().some((node) => !isNil(node.parentId));
    return this.isCompoundGraph;
  }
};

// node_modules/@antv/infographic/esm/designs/structures/relation-dagre-flow.js
var DEFAULT_NODE_SEP = 50;
var DEFAULT_RANK_SEP = 70;
var DEFAULT_EDGE_SEP = 10;
var DEFAULT_EDGE_WIDTH2 = 2;
var DEFAULT_PADDING = 30;
var checkUndirectedCycle = (nodeIds, edges) => {
  var _a, _b;
  const adj = /* @__PURE__ */ new Map();
  nodeIds.forEach((id2) => adj.set(id2, []));
  for (const edge of edges) {
    if (edge.source === edge.target)
      return true;
    (_a = adj.get(edge.source)) === null || _a === void 0 ? void 0 : _a.push({ target: edge.target, edgeId: edge.id });
    (_b = adj.get(edge.target)) === null || _b === void 0 ? void 0 : _b.push({ target: edge.source, edgeId: edge.id });
  }
  const visited = /* @__PURE__ */ new Set();
  const dfs = (u4, parentEdgeId) => {
    visited.add(u4);
    const neighbors = adj.get(u4) || [];
    for (const { target: v2, edgeId } of neighbors) {
      if (edgeId === parentEdgeId)
        continue;
      if (visited.has(v2))
        return true;
      if (dfs(v2, edgeId))
        return true;
    }
    return false;
  };
  for (const node of nodeIds) {
    if (!visited.has(node)) {
      if (dfs(node, null))
        return true;
    }
  }
  return false;
};
var RelationDagreFlow = (props) => {
  var _a, _b;
  const { Title: Title2, Item, data, rankdir = "TB", nodesep = DEFAULT_NODE_SEP, ranksep = DEFAULT_RANK_SEP, edgesep = DEFAULT_EDGE_SEP, edgeWidth = DEFAULT_EDGE_WIDTH2, showConnections = true, edgeColorMode = "gradient", edgeStyle = "solid", edgeDashPattern = "5,5", edgeCornerRadius = 12, edgeRouting = "orth", showArrow = true, arrowType = "triangle", padding = DEFAULT_PADDING, edgeAnimation = "none", edgeAnimationSpeed = 1, options } = props;
  const { title, desc, items: items3 = [], relations = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  if (!Item || items3.length === 0) {
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { children: jsx(BtnAdd, { indexes: [0], x: 0, y: 0 }) })] });
  }
  const nodeMetaMap = /* @__PURE__ */ new Map();
  const nodeSizeMap = /* @__PURE__ */ new Map();
  const nodeColorMap = /* @__PURE__ */ new Map();
  const nodeIdsByIndex = /* @__PURE__ */ new Map();
  const nodeIdSet = /* @__PURE__ */ new Set();
  const colorGroupIndexMap = /* @__PURE__ */ new Map();
  let nextColorGroupIndex = 0;
  const nodes = items3.map((item, index2) => {
    var _a2, _b2;
    const datum2 = item;
    const id2 = String((_a2 = datum2.id) !== null && _a2 !== void 0 ? _a2 : index2);
    const indexes = [index2];
    let primary;
    const groupKey = String((_b2 = datum2.group) !== null && _b2 !== void 0 ? _b2 : "");
    if (groupKey) {
      let groupIndex = colorGroupIndexMap.get(groupKey);
      if (groupIndex == null) {
        groupIndex = nextColorGroupIndex;
        colorGroupIndexMap.set(groupKey, groupIndex);
        nextColorGroupIndex += 1;
      }
      primary = getPaletteColor2(options, [groupIndex]);
    } else {
      primary = getPaletteColor2(options, indexes);
    }
    const themeColors = primary ? getThemeColors({ colorPrimary: primary }, options) : void 0;
    if (primary) {
      nodeColorMap.set(id2, primary);
    }
    const bounds = getElementBounds(jsx(Item, { indexes, data, datum: datum2, positionH: "center", positionV: "middle", themeColors }));
    nodeSizeMap.set(id2, bounds);
    nodeMetaMap.set(id2, { id: id2, indexes, datum: datum2, themeColors });
    nodeIdsByIndex.set(index2, id2);
    nodeIdSet.add(id2);
    return { id: id2, parentId: datum2.parentId };
  });
  const resolveNodeId = (value) => {
    if (value == null)
      return null;
    const direct = String(value);
    if (nodeIdSet.has(direct))
      return direct;
    const asIndex = Number(value);
    if (!Number.isNaN(asIndex)) {
      const mapped = nodeIdsByIndex.get(asIndex);
      if (mapped)
        return mapped;
    }
    return null;
  };
  const edges = relations.map((relation, index2) => {
    const source = resolveNodeId(relation.from);
    const target = resolveNodeId(relation.to);
    if (!source || !target)
      return null;
    return {
      id: relation.id ? String(relation.id) : `edge-${index2}`,
      source,
      target,
      relation
    };
  }).filter(Boolean);
  const hasCycle = checkUndirectedCycle(Array.from(nodeIdSet), edges);
  const finalEdgeRouting = hasCycle ? "dagre" : edgeRouting;
  const layout = new DagreLayout({
    rankdir,
    nodesep,
    ranksep,
    edgesep,
    controlPoints: true,
    nodeSize: (node) => {
      var _a2;
      const id2 = String((_a2 = node.id) !== null && _a2 !== void 0 ? _a2 : "");
      const bounds = nodeSizeMap.get(id2);
      return bounds ? [bounds.width, bounds.height] : [0, 0];
    }
  });
  layout.execute({ nodes, edges });
  const nodeLayouts = [];
  layout.forEachNode((node) => {
    var _a2, _b2, _c, _d;
    const id2 = String(node.id);
    const meta = nodeMetaMap.get(id2);
    if (!meta)
      return;
    const bounds = nodeSizeMap.get(id2);
    const width = (_a2 = bounds === null || bounds === void 0 ? void 0 : bounds.width) !== null && _a2 !== void 0 ? _a2 : 0;
    const height = (_b2 = bounds === null || bounds === void 0 ? void 0 : bounds.height) !== null && _b2 !== void 0 ? _b2 : 0;
    const x6 = ((_c = node.x) !== null && _c !== void 0 ? _c : 0) - width / 2;
    const y6 = ((_d = node.y) !== null && _d !== void 0 ? _d : 0) - height / 2;
    nodeLayouts.push(Object.assign(Object.assign({}, meta), {
      x: x6,
      y: y6,
      width,
      height,
      centerX: x6 + width / 2,
      centerY: y6 + height / 2
    }));
  });
  if (nodeLayouts.length === 0) {
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { children: jsx(BtnAdd, { indexes: [0], x: 0, y: 0 }) })] });
  }
  const minX = Math.min(...nodeLayouts.map((node) => node.x));
  const minY = Math.min(...nodeLayouts.map((node) => node.y));
  const offsetX = padding - minX;
  const offsetY = padding - minY;
  const nodeLayoutById = /* @__PURE__ */ new Map();
  const itemElements = [];
  nodeLayouts.forEach((node) => {
    const displayX = node.x + offsetX;
    const displayY = node.y + offsetY;
    const positionH = rankdir === "LR" ? "normal" : rankdir === "RL" ? "flipped" : "center";
    const positionV = rankdir === "TB" ? "normal" : rankdir === "BT" ? "flipped" : "middle";
    itemElements.push(jsx(Item, { indexes: node.indexes, datum: node.datum, data, x: displayX, y: displayY, positionH, positionV, themeColors: node.themeColors }));
    nodeLayoutById.set(node.id, Object.assign(Object.assign({}, node), { x: displayX, y: displayY, centerX: displayX + node.width / 2, centerY: displayY + node.height / 2 }));
  });
  const defsElements = [];
  const decorElements = [];
  if (showConnections) {
    const defaultStroke = getColorPrimary(options);
    const themeColors = getThemeColors(options.themeConfig, options);
    const labelBackground = (_a = themeColors === null || themeColors === void 0 ? void 0 : themeColors.colorBg) !== null && _a !== void 0 ? _a : "#ffffff";
    const labelTextColor = (_b = themeColors === null || themeColors === void 0 ? void 0 : themeColors.colorText) !== null && _b !== void 0 ? _b : defaultStroke;
    const arrowSize = Math.max(10, edgeWidth * 4);
    const isVertical = rankdir === "TB" || rankdir === "BT";
    const enableAnimation = edgeAnimation === "ant-line";
    const animationDashArray = enableAnimation ? edgeDashPattern : "";
    const staticDashArray = !enableAnimation && edgeStyle === "dashed" ? edgeDashPattern : "";
    const actualDashArray = enableAnimation ? animationDashArray : staticDashArray;
    const dashPatternLength = enableAnimation ? animationDashArray.split(",").reduce((sum, val) => sum + parseFloat(val.trim() || "0"), 0) : 0;
    const animationDuration = enableAnimation && dashPatternLength > 0 ? `${dashPatternLength / (edgeAnimationSpeed * 10)}s` : "1s";
    const straightCornerRadius = edgeCornerRadius;
    const createStraightPath2 = (points, dx, dy) => points.map(([x6, y6], index2) => {
      const prefix = index2 === 0 ? "M" : "L";
      return `${prefix} ${x6 + dx} ${y6 + dy}`;
    }).join(" ");
    const createRoundedPath = (points, radius, dx, dy) => {
      if (points.length < 2)
        return "";
      const clamp2 = (value, min3, max3) => Math.min(max3, Math.max(min3, value));
      const toPoint = ([x6, y6]) => ({
        x: x6 + dx,
        y: y6 + dy
      });
      const output = [];
      const first = toPoint(points[0]);
      output.push(`M ${first.x} ${first.y}`);
      if (points.length === 2) {
        const last2 = toPoint(points[1]);
        output.push(`L ${last2.x} ${last2.y}`);
        return output.join(" ");
      }
      for (let i4 = 1; i4 < points.length - 1; i4 += 1) {
        const prev = points[i4 - 1];
        const curr = points[i4];
        const next = points[i4 + 1];
        const v0x = curr[0] - prev[0];
        const v0y = curr[1] - prev[1];
        const v1x = next[0] - curr[0];
        const v1y = next[1] - curr[1];
        const d03 = Math.hypot(v0x, v0y);
        const d1 = Math.hypot(v1x, v1y);
        if (d03 === 0 || d1 === 0) {
          const currPoint2 = toPoint(curr);
          output.push(`L ${currPoint2.x} ${currPoint2.y}`);
          continue;
        }
        const r5 = clamp2(radius, 0, Math.min(d03, d1) / 2);
        if (r5 === 0) {
          const currPoint2 = toPoint(curr);
          output.push(`L ${currPoint2.x} ${currPoint2.y}`);
          continue;
        }
        const u0x = v0x / d03;
        const u0y = v0y / d03;
        const u1x = v1x / d1;
        const u1y = v1y / d1;
        const start2 = toPoint([curr[0] - u0x * r5, curr[1] - u0y * r5]);
        const end = toPoint([curr[0] + u1x * r5, curr[1] + u1y * r5]);
        output.push(`L ${start2.x} ${start2.y}`);
        const currPoint = toPoint(curr);
        output.push(`Q ${currPoint.x} ${currPoint.y} ${end.x} ${end.y}`);
      }
      const last = toPoint(points[points.length - 1]);
      output.push(`L ${last.x} ${last.y}`);
      return output.join(" ");
    };
    const createArrowElements = (x6, y6, angle, type2, fillColor) => {
      const ux = Math.cos(angle);
      const uy = Math.sin(angle);
      const px = -uy;
      const py = ux;
      const length = arrowSize;
      const halfWidth = arrowSize * 0.55;
      if (type2 === "arrow") {
        const leftX = x6 - ux * length + px * halfWidth;
        const leftY = y6 - uy * length + py * halfWidth;
        const rightX = x6 - ux * length - px * halfWidth;
        const rightY = y6 - uy * length - py * halfWidth;
        return [
          jsx(Path, { d: `M ${leftX} ${leftY} L ${x6} ${y6} L ${rightX} ${rightY}`, stroke: fillColor, strokeWidth: Math.max(1.5, edgeWidth), strokeLinecap: "round", strokeLinejoin: "round", fill: "none" })
        ];
      }
      if (type2 === "diamond") {
        const diamondLength = length * 1.25;
        const diamondWidth = halfWidth * 0.75;
        const midX = x6 - ux * diamondLength * 0.5;
        const midY = y6 - uy * diamondLength * 0.5;
        const diamondPoints = [
          { x: x6, y: y6 },
          { x: midX + px * diamondWidth, y: midY + py * diamondWidth },
          { x: x6 - ux * diamondLength, y: y6 - uy * diamondLength },
          { x: midX - px * diamondWidth, y: midY - py * diamondWidth }
        ];
        return [
          jsx(Polygon, { points: diamondPoints, fill: fillColor, stroke: fillColor, strokeWidth: Math.max(1, edgeWidth * 0.8) })
        ];
      }
      const trianglePoints = [
        { x: x6, y: y6 },
        {
          x: x6 - ux * length + px * halfWidth,
          y: y6 - uy * length + py * halfWidth
        },
        {
          x: x6 - ux * length - px * halfWidth,
          y: y6 - uy * length - py * halfWidth
        }
      ];
      return [
        jsx(Polygon, { points: trianglePoints, fill: fillColor, stroke: fillColor, strokeWidth: Math.max(1, edgeWidth * 0.8) })
      ];
    };
    const getMidPoint = (points) => {
      if (points.length === 0)
        return null;
      if (points.length === 1)
        return points[0];
      let total = 0;
      const segments = [];
      for (let i4 = 0; i4 < points.length - 1; i4 += 1) {
        const start2 = points[i4];
        const end = points[i4 + 1];
        const length = Math.hypot(end[0] - start2[0], end[1] - start2[1]);
        segments.push({ length, start: start2, end });
        total += length;
      }
      if (total === 0)
        return points[0];
      let target = total / 2;
      for (let i4 = 0; i4 < segments.length; i4 += 1) {
        const segment = segments[i4];
        if (target <= segment.length || i4 === segments.length - 1) {
          const ratio = segment.length === 0 ? 0 : Math.max(0, Math.min(1, target / segment.length));
          return [
            segment.start[0] + (segment.end[0] - segment.start[0]) * ratio,
            segment.start[1] + (segment.end[1] - segment.start[1]) * ratio
          ];
        }
        target -= segment.length;
      }
      return points[Math.floor(points.length / 2)];
    };
    const getOrthEdgeEndpoints = (sourceId, targetId) => {
      const source = nodeLayoutById.get(sourceId);
      const target = nodeLayoutById.get(targetId);
      if (!source || !target)
        return null;
      if (rankdir === "TB") {
        return {
          start: [source.centerX, source.y + source.height],
          end: [target.centerX, target.y]
        };
      }
      if (rankdir === "BT") {
        return {
          start: [source.centerX, source.y],
          end: [target.centerX, target.y + target.height]
        };
      }
      if (rankdir === "LR") {
        return {
          start: [source.x + source.width, source.centerY],
          end: [target.x, target.centerY]
        };
      }
      return {
        start: [source.x, source.centerY],
        end: [target.x + target.width, target.centerY]
      };
    };
    const getOrthEdgePoints = (sourceId, targetId) => {
      const endpoints = getOrthEdgeEndpoints(sourceId, targetId);
      if (!endpoints)
        return null;
      const { start: start2, end } = endpoints;
      if (isVertical) {
        const midY = start2[1] + (end[1] - start2[1]) / 2;
        return {
          start: start2,
          end,
          points: [start2, [start2[0], midY], [end[0], midY], end]
        };
      }
      const midX = start2[0] + (end[0] - start2[0]) / 2;
      return {
        start: start2,
        end,
        points: [start2, [midX, start2[1]], [midX, end[1]], end]
      };
    };
    layout.forEachEdge((edge) => {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _j;
      const normalizePoints = (rawPoints) => {
        if (!Array.isArray(rawPoints))
          return [];
        return rawPoints.map((point) => {
          if (!point)
            return null;
          if (Array.isArray(point) && point.length >= 2) {
            return [Number(point[0]), Number(point[1])];
          }
          return null;
        }).filter((point) => !!point && Number.isFinite(point[0]) && Number.isFinite(point[1]));
      };
      const fallbackPoints = () => {
        const source = nodeLayoutById.get(String(edge.source));
        const target = nodeLayoutById.get(String(edge.target));
        if (!source || !target)
          return [];
        return [
          [source.centerX - offsetX, source.centerY - offsetY],
          [target.centerX - offsetX, target.centerY - offsetY]
        ];
      };
      const useOrthRouting = finalEdgeRouting === "orth";
      const orthEdge = useOrthRouting ? getOrthEdgePoints(String(edge.source), String(edge.target)) : null;
      const normalized = useOrthRouting ? [] : normalizePoints(edge.points);
      const points = useOrthRouting ? (_a2 = orthEdge === null || orthEdge === void 0 ? void 0 : orthEdge.points) !== null && _a2 !== void 0 ? _a2 : [] : normalized.length ? normalized : fallbackPoints();
      if (!points.length)
        return;
      const pointsOffsetX = useOrthRouting ? 0 : offsetX;
      const pointsOffsetY = useOrthRouting ? 0 : offsetY;
      const startPoint = useOrthRouting ? (_b2 = orthEdge === null || orthEdge === void 0 ? void 0 : orthEdge.start) !== null && _b2 !== void 0 ? _b2 : points[0] : points[0];
      const endPoint = useOrthRouting ? (_c = orthEdge === null || orthEdge === void 0 ? void 0 : orthEdge.end) !== null && _c !== void 0 ? _c : points[points.length - 1] : points[points.length - 1];
      const relation = (_d = edge._original) === null || _d === void 0 ? void 0 : _d.relation;
      const sourceColor = (_e = nodeColorMap.get(String(edge.source))) !== null && _e !== void 0 ? _e : defaultStroke;
      const targetColor = (_f = nodeColorMap.get(String(edge.target))) !== null && _f !== void 0 ? _f : defaultStroke;
      const gradientKey = `edge-gradient-${String(sourceColor)}-${String(targetColor)}`.replace(/[^a-zA-Z0-9_-]/g, "");
      const edgeStroke = edgeColorMode === "gradient" ? `url(#${gradientKey})` : defaultStroke;
      let pathD = "";
      if (straightCornerRadius > 0) {
        pathD = createRoundedPath(points, straightCornerRadius, pointsOffsetX, pointsOffsetY);
      } else {
        pathD = createStraightPath2(points, pointsOffsetX, pointsOffsetY);
      }
      if (!pathD)
        return;
      const pathElement = jsx(Path, { d: pathD, stroke: edgeStroke, strokeWidth: edgeWidth, strokeDasharray: actualDashArray, fill: "none", "data-element-type": "shape", children: enableAnimation && jsx("animate", { attributeName: "stroke-dashoffset", from: String(dashPatternLength), to: "0", dur: animationDuration, repeatCount: "indefinite" }) });
      decorElements.push(pathElement);
      if (edgeColorMode === "gradient") {
        const start2 = startPoint;
        const end = endPoint;
        defsElements.push(jsxs("linearGradient", { id: gradientKey, gradientUnits: "userSpaceOnUse", x1: start2[0] + pointsOffsetX, y1: start2[1] + pointsOffsetY, x2: end[0] + pointsOffsetX, y2: end[1] + pointsOffsetY, children: [jsx("stop", { offset: "0%", stopColor: sourceColor }), jsx("stop", { offset: "100%", stopColor: targetColor })] }));
      }
      if (relation === null || relation === void 0 ? void 0 : relation.label) {
        let labelPoint = null;
        const midPoint = getMidPoint(points);
        if (midPoint) {
          labelPoint = [
            midPoint[0] + pointsOffsetX,
            midPoint[1] + pointsOffsetY
          ];
        }
        if (labelPoint) {
          const labelText = String(relation.label);
          const labelBounds = getElementBounds(jsx(Text, { fontSize: 14, fontWeight: "normal", children: labelText }));
          const labelX = labelPoint[0] - labelBounds.width / 2;
          const labelY = labelPoint[1] - labelBounds.height / 2;
          decorElements.push(jsx(Text, { x: labelX, y: labelY, width: labelBounds.width, height: labelBounds.height, fontSize: 14, fontWeight: "normal", alignHorizontal: "center", alignVertical: "middle", fill: labelTextColor, backgroundColor: labelBackground, children: labelText }));
        }
      }
      const effectiveShowArrow = (_g = relation === null || relation === void 0 ? void 0 : relation.showArrow) !== null && _g !== void 0 ? _g : showArrow;
      const direction = (_h = relation === null || relation === void 0 ? void 0 : relation.direction) !== null && _h !== void 0 ? _h : "forward";
      const edgeArrowType = (_j = relation === null || relation === void 0 ? void 0 : relation.arrowType) !== null && _j !== void 0 ? _j : arrowType;
      const lastIndex = points.length - 1;
      if (effectiveShowArrow && points.length > 1) {
        if (direction === "forward" || direction === "both") {
          const head = points[lastIndex];
          const tail = points[lastIndex - 1];
          const angle = Math.atan2(head[1] - tail[1], head[0] - tail[0]);
          const arrowFill = edgeColorMode === "gradient" ? targetColor : defaultStroke;
          const arrowElements = createArrowElements(head[0] + pointsOffsetX, head[1] + pointsOffsetY, angle, edgeArrowType, arrowFill);
          decorElements.push(...arrowElements);
        }
        if (direction === "both") {
          const head = points[0];
          const tail = points[1];
          const angle = Math.atan2(head[1] - tail[1], head[0] - tail[0]);
          const arrowFill = edgeColorMode === "gradient" ? sourceColor : defaultStroke;
          const arrowElements = createArrowElements(head[0] + pointsOffsetX, head[1] + pointsOffsetY, angle, edgeArrowType, arrowFill);
          decorElements.push(...arrowElements);
        }
      }
    });
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(Defs, { children: defsElements }), jsx(Group, { width: 0, height: 0, children: decorElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, {})] })] });
};
registerStructure("relation-dagre-flow", {
  component: RelationDagreFlow,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/relation-network.js
var RelationNetwork = (props) => {
  const { Title: Title2, Item, data, spacing = 120, showConnections = true, options } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  if (items3.length === 0) {
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { children: jsx(ItemsGroup, {}) })] });
  }
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  function runForceLayout() {
    const nodes2 = items3.map((item, index2) => ({
      id: index2,
      data: item,
      isCenter: index2 === 0,
      _originalIndex: [index2]
    }));
    const links2 = items3.slice(1).map((_2, index2) => ({
      source: 0,
      target: index2 + 1
    }));
    const simulation = simulation_default(nodes2).force("link", link_default(links2).id((d3) => d3.id).distance(spacing)).force("charge", manyBody_default().strength(-50)).force("center", center_default(0, 0)).force("collision", collide_default().radius(Math.max(itemBounds.width, itemBounds.height) / 2 + 10));
    for (let i4 = 0; i4 < 300; ++i4)
      simulation.tick();
    return { nodes: nodes2, links: links2 };
  }
  const { nodes, links } = runForceLayout();
  const minX = Math.min(...nodes.map((d3) => {
    var _a;
    return (_a = d3.x) !== null && _a !== void 0 ? _a : 0;
  }));
  const minY = Math.min(...nodes.map((d3) => {
    var _a;
    return (_a = d3.y) !== null && _a !== void 0 ? _a : 0;
  }));
  const offsetX = Math.max(0, -minX + itemBounds.width / 2);
  const offsetY = Math.max(0, -minY + itemBounds.height / 2);
  const positionBy = (x6, y6) => ({
    positionH: x6 < -50 ? "flipped" : x6 > 50 ? "normal" : "center",
    positionV: y6 < -50 ? "flipped" : y6 > 50 ? "normal" : "middle"
  });
  const nodesEls = nodes.map((node) => {
    if (node.x == null || node.y == null)
      return null;
    const x6 = node.x + offsetX - itemBounds.width / 2;
    const y6 = node.y + offsetY - itemBounds.height / 2;
    const { positionH, positionV } = positionBy(node.x, node.y);
    return jsx(Item, { indexes: node._originalIndex, datum: node.data, data, x: x6, y: y6, positionH, positionV }, node.id);
  }).filter(Boolean);
  const linksMap = new Map(nodes.map((n4) => [n4.id, n4]));
  const linksEls = showConnections ? links.map((link) => {
    const src = typeof link.source === "object" ? link.source : linksMap.get(link.source);
    const tgt = typeof link.target === "object" ? link.target : linksMap.get(link.target);
    if (!src || !tgt || src.x == null || src.y == null || tgt.x == null || tgt.y == null)
      return null;
    const linePath = `M ${src.x + offsetX} ${src.y + offsetY} L ${tgt.x + offsetX} ${tgt.y + offsetY}`;
    return jsx(Path, { d: linePath, stroke: getColorPrimary(options), strokeWidth: 2, strokeOpacity: 0.6 });
  }).filter(Boolean) : [];
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(Group, { children: linksEls }), jsx(ItemsGroup, { children: nodesEls })] })] });
};
registerStructure("relation-network", {
  component: RelationNetwork,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/decorations/simple-arrow.js
var __rest17 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var SimpleArrow = (_a) => {
  var { width = 25, height = 25, colorPrimary = "#6699FF", rotation = 0 } = _a, rest = __rest17(_a, ["width", "height", "colorPrimary", "rotation"]);
  const strokeId = `gradient-arrow-stroke-${colorPrimary.replace("#", "")}`;
  const fillId = `gradient-arrow-fill-${colorPrimary.replace("#", "")}`;
  const shaftWidth = Math.round(width * 0.515);
  const shaftTop = Math.round(height * 0.275);
  const shaftBottom = Math.round(height * 0.875);
  const points = [
    { x: 0, y: shaftTop },
    { x: shaftWidth, y: shaftTop },
    { x: shaftWidth, y: height * 0.075 },
    { x: width, y: height * 0.575 },
    { x: shaftWidth, y: height * 1.075 },
    { x: shaftWidth, y: shaftBottom },
    { x: 0, y: shaftBottom }
  ];
  const centerX = width / 2;
  const centerY = height / 2;
  const transform2 = `rotate(${rotation} ${centerX} ${centerY})`;
  return jsxs(Fragment, { children: [jsx(Polygon, Object.assign({}, rest, { width, height, points, fill: `url(#${fillId})`, stroke: `url(#${strokeId})`, transform: transform2, "data-element-type": "shape" })), jsxs(Defs, { children: [jsxs("linearGradient", { id: fillId, x1: "100%", y1: "0%", x2: "0%", y2: "0%", children: [jsx("stop", { offset: "0%", "stop-color": colorPrimary, "stop-opacity": "0.36" }), jsx("stop", { offset: "100%", "stop-color": colorPrimary, "stop-opacity": "0" })] }), jsxs("linearGradient", { id: strokeId, x1: "100%", y1: "0%", x2: "0%", y2: "0%", children: [jsx("stop", { offset: "0%", "stop-color": colorPrimary }), jsx("stop", { offset: "58%", "stop-color": colorPrimary, "stop-opacity": "0" })] })] })] });
};

// node_modules/@antv/infographic/esm/designs/decorations/text-3d.js
var Text3d = ({ text, x: x6 = 0, y: y6 = 0, fontSize = 56, fontWeight = "bold", fill: fill2 = "#FFFFFF", textAnchor = "middle", dominantBaseline = "middle", shadowOffsetX = 2, shadowOffsetY = 4, midShadowOffsetX = 1, midShadowOffsetY = 2, deepShadowOpacity = 0.3, midShadowOpacity = 0.5 }) => {
  return jsxs(Group, { children: [jsx("text", { x: x6, y: y6, fontSize, fontWeight, fill: fill2, fillOpacity: deepShadowOpacity, textAnchor, dominantBaseline, transform: `translate(${shadowOffsetX}, ${shadowOffsetY})`, children: text }), jsx("text", { x: x6, y: y6, fontSize, fontWeight, fill: fill2, fillOpacity: midShadowOpacity, textAnchor, dominantBaseline, transform: `translate(${midShadowOffsetX}, ${midShadowOffsetY})`, children: text }), jsx("text", { x: x6, y: y6, fontSize, fontWeight, fill: fill2, textAnchor, dominantBaseline, children: text })] });
};

// node_modules/@antv/infographic/esm/designs/decorations/triangle.js
var __rest18 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
var Triangle = (_a) => {
  var { width = 25, height = 25, colorPrimary = "#6699FF", rotation = 0, strokeWidth = 4 } = _a, rest = __rest18(_a, ["width", "height", "colorPrimary", "rotation", "strokeWidth"]);
  const points = [
    { x: width / 2, y: 0 },
    // 
    { x: width, y: height },
    // 
    { x: 0, y: height }
    // 
  ];
  const centerX = width / 2;
  const centerY = height / 2;
  const transform2 = `rotate(${rotation} ${centerX} ${centerY})`;
  return jsx(Polygon, Object.assign({}, rest, { width, height, points, fill: colorPrimary, stroke: colorPrimary, strokeWidth, strokeLinecap: "round", strokeLinejoin: "round", transform: transform2 }));
};

// node_modules/@antv/infographic/esm/designs/structures/sequence-ascending-stairs-3d.js
var CUBE_GAP_X = -118;
var CUBE_GAP_Y = 118;
var CUBE_WIDTH = 240;
var CUBE_HEIGHT = 180;
var ITEM_GAP = 40;
var CUBE_PATH_BOTTOM = "M238.9 69.7a6 6 0 0 1-.1 1v.2l-.2.3v.3l-.1.3a6.2 6.2 0 0 1-.3.6l-.1.3-.2.3-.2.4-.3.5-.1.1a10.9 10.9 0 0 1-.8 1v.1l-.5.5h-.1l-.4.4-.3.3-.3.2-.3.3-.4.2a13 13 0 0 1-.7.5l-.4.3-.5.3-97.5 56.7-.7.4h-.2l-.6.4h-.1l-.8.4h-.2l-.6.4h-.2l-.8.3h-.2l-.5.3-.5.1-.5.1-.5.2h-.5a33.7 33.7 0 0 1-3.2.7h-.2l-1 .2h-1.6l-.7.1h-4.7l-.8-.1h-.2a38.2 38.2 0 0 1-2-.4h-.4l-.7-.2h-.4l-.7-.2-.4-.1a27.3 27.3 0 0 1-2.2-.7h-.2a44.2 44.2 0 0 1-.9-.3l-.5-.3-.4-.1-.5-.2-.3-.2-.5-.2-.3-.2-.8-.4L6.5 78C2.2 75.6 0 72.4 0 69v41.7c0 3.2 2.1 6.5 6.4 9l98.1 56.6a23.2 23.2 0 0 0 1 .6l.6.3.3.1.5.2.4.2.3.1h.2l.2.2a21.4 21.4 0 0 0 1.9.6l.3.1h.2l.7.2a77.6 77.6 0 0 1 1.1.3h.3l.7.2h.4a42.5 42.5 0 0 0 1 .2l1 .2h1.1l.4.1h2.1l.7.1h1.5a22 22 0 0 0 1.8-.2h.4l1.1-.1h.2l1.2-.2h.1l.3-.1.6-.1a12.5 12.5 0 0 0 1-.3h.5l.5-.2a29 29 0 0 0 1-.3h.2l.3-.2h.2a27 27 0 0 0 1.6-.7h.2l.8-.4a19.4 19.4 0 0 0 1.6-.9l97.5-56.7.3-.1.2-.2.4-.2.4-.3.3-.2.3-.3.4-.2.3-.3.3-.3h.1l.3-.3.5-.6h.1l.3-.5h.1v-.1l.4-.4v-.1l.4-.5v-.1l.1-.2.1-.2.2-.3.1-.3.1-.3.1-.1a6.9 6.9 0 0 0 .2-.8l.1-.3v-.4l.1-.3v-1l.2-41.4v.4Z";
var CUBE_PATH_TOP = "M232.5 60.4c8.5 4.9 8.5 12.8.1 17.7l-97.5 56.7c-8.4 4.9-22 4.9-30.5 0L6.5 78C-2 73-2 65.3 6.4 60.4l97.5-56.7c8.4-5 22-5 30.5 0l98.1 56.7Z";
var CUBE_PATH_STROKE = "M119.1 0A31 31 0 0 0 104 3.7L6.4 60.4C-2 65.3-2 73.2 6.4 78l98.2 56.7c4.2 2.4 9.8 3.7 15.3 3.7a31 31 0 0 0 15.2-3.7L232.6 78c8.4-5 8.4-12.8 0-17.7L134.3 3.7A31.2 31.2 0 0 0 119.1 0Zm0 2.5c5.4 0 10.3 1.2 14 3.3l98.2 56.7c3.3 2 5.1 4.3 5.1 6.8 0 2.4-1.8 4.7-5 6.6l-97.5 56.7a28.3 28.3 0 0 1-14 3.4c-5.3 0-10.3-1.2-14-3.4L7.7 76c-3.3-1.9-5-4.3-5-6.7 0-2.4 1.7-4.8 5-6.7L105 5.8a29 29 0 0 1 14-3.3Z";
var DropShadowFilter = jsxs("filter", { id: "sequence-ascending-stairs-3d-shadow-filter", x: "-50%", y: "-50%", width: "200%", height: "200%", filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB", children: [jsx("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }), jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), jsx("feOffset", { dx: "0", dy: "4" }), jsx("feGaussianBlur", { stdDeviation: "6" }), jsx("feComposite", { in2: "hardAlpha", operator: "out" }), jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0" }), jsx("feBlend", { mode: "normal", in2: "BackgroundImageFix", result: "effect1_dropShadow" }), jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "effect1_dropShadow", result: "shape" })] });
var SequenceAscendingStairs3d = (props) => {
  const { Title: Title2, Item, data, options, cubeWidth = CUBE_WIDTH } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  if (items3.length === 0) {
    const btnAddElement = jsx(BtnAdd, { indexes: [0], x: 0, y: 0 });
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [jsx(Defs, { children: DropShadowFilter }), titleContent, jsx(Group, { children: jsx(BtnsGroup, { children: btnAddElement }) })] });
  }
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const btnElements = [];
  const itemElements = [];
  const cubeElements = [];
  const cubeScale = cubeWidth / CUBE_WIDTH;
  const scaledCubeHeight = CUBE_HEIGHT * cubeScale;
  items3.forEach((item, index2) => {
    const indexes = [index2];
    const currentColor = getPaletteColor2(options, indexes);
    const cubeX = index2 * (cubeWidth + CUBE_GAP_X);
    const cubeY = (items3.length - 1 - index2) * CUBE_GAP_Y;
    const gradientIdBottom = `cube-gradient-bottom-${index2}`;
    const gradientIdTop = `cube-gradient-top-${index2}`;
    const gradientIdStroke = `cube-gradient-stroke-${index2}`;
    cubeElements.push(jsxs(Group, { x: cubeX, y: cubeY, id: `cube-${index2}`, width: cubeWidth, height: scaledCubeHeight, filter: "url(#sequence-ascending-stairs-3d-shadow-filter)", children: [jsxs(Defs, { children: [jsxs("linearGradient", { id: gradientIdBottom, x1: "0", y1: "124.5", x2: "238.9", y2: "124.5", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { offset: "0", stopColor: currentColor, stopOpacity: "0.8" }), jsx("stop", { offset: "1", stopColor: currentColor, stopOpacity: "0.4" })] }), jsxs("linearGradient", { id: gradientIdTop, x1: "119.5", y1: "0", x2: "119.5", y2: "138.5", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { offset: "0", stopColor: currentColor, stopOpacity: "0.9" }), jsx("stop", { offset: "1", stopColor: currentColor, stopOpacity: "0.5" })] }), jsxs("linearGradient", { id: gradientIdStroke, x1: "119.5", y1: "0", x2: "119.5", y2: "138.5", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { offset: "0", stopColor: currentColor }), jsx("stop", { offset: "1", stopColor: currentColor, stopOpacity: "0.7" })] })] }), jsxs(ShapesGroup, { transform: `scale(${cubeScale})`, children: [jsx(Path, { d: CUBE_PATH_BOTTOM, fill: `url(#${gradientIdBottom})` }), jsx(Path, { d: CUBE_PATH_TOP, fill: `url(#${gradientIdTop})` }), jsx(Path, { d: CUBE_PATH_STROKE, fill: `url(#${gradientIdStroke})` })] }), jsx(Text3d, { text: index2 + 1, x: 115, y: 65, fontSize: 56 })] }));
    const itemX = cubeX + cubeWidth + ITEM_GAP;
    const itemY = cubeY + scaledCubeHeight / 2;
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, positionH: "normal" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: cubeX + cubeWidth - btnBounds.width / 2, y: cubeY - btnBounds.height / 2 }));
    if (index2 === 0) {
      btnElements.push(jsx(BtnAdd, { indexes: [0], x: cubeX - 30 - btnBounds.width / 2, y: cubeY + scaledCubeHeight / 2 - btnBounds.height / 2 }));
    }
    if (index2 < items3.length - 1) {
      const nextCubeY = (items3.length - 1 - (index2 + 1)) * CUBE_GAP_Y;
      const btnAddX = cubeX + cubeWidth - btnBounds.width / 2;
      const btnAddY = (cubeY + scaledCubeHeight / 2 + nextCubeY + scaledCubeHeight / 2) / 2 - btnBounds.height / 2;
      btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: btnAddX, y: btnAddY }));
    } else {
      btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: cubeX + cubeWidth + 30 - btnBounds.width / 2, y: cubeY + scaledCubeHeight / 2 - btnBounds.height / 2 }));
    }
  });
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: 30, children: [jsx(Defs, { children: DropShadowFilter }), titleContent, jsxs(Group, { x: 0, y: 0, children: [jsx(Group, { children: cubeElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-ascending-stairs-3d", {
  component: SequenceAscendingStairs3d,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-ascending-steps.js
var SequenceAscendingSteps = (props) => {
  const { Title: Title2, Item, data, hGap = 0, vGap = 0 } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0] }));
  const itemElements = [];
  const btnElements = [];
  const n4 = items3.length;
  const stepX = itemBounds.width + hGap;
  const stepY = itemBounds.height / 2 + vGap;
  const startX = itemBounds.width / 2;
  const endY = 0;
  const startY = endY + (n4 - 1) * stepY;
  items3.forEach((datum2, index2) => {
    const x6 = startX + index2 * stepX;
    const y6 = startY - index2 * stepY;
    const indexes = [index2];
    itemElements.push(jsx(Item, { indexes, datum: datum2, data, x: x6, y: y6 }));
    btnElements.push(jsx(BtnRemove, { indexes, x: x6 + itemBounds.width - 30, y: y6 + itemBounds.height / 2 + 10 }));
    btnElements.push(jsx(BtnAdd, { indexes, x: x6 + itemBounds.width + hGap / 2, y: y6 - 30 }));
  });
  return jsxs(FlexLayout, { flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-ascending-steps", {
  component: SequenceAscendingSteps,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-circle-arrows.js
var ITEM_DISTANCE = 20;
var LINE_GAP = 5;
var SequenceCircleArrows = (props) => {
  const { Title: Title2, Item, data, options, radius = 150, arrowSize = 4, strokeWidth = 10 } = props;
  const { title, desc, items: items3 = [] } = data;
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const colorPrimary = getColorPrimary(options);
  if (!Item) {
    const titleContent2 = Title2 ? jsx(Title2, { title, desc }) : null;
    return jsxs(FlexLayout, { flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent2, jsx(Group, { children: jsx(BtnsGroup, { children: jsx(BtnAdd, { indexes: [0], x: 0, y: 0 }) }) })] });
  }
  const count2 = items3.length;
  if (count2 === 0) {
    const titleContent2 = Title2 ? jsx(Title2, { title, desc }) : null;
    return jsxs(FlexLayout, { flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent2, jsx(Group, { children: jsx(BtnsGroup, { children: jsx(BtnAdd, { indexes: [0], x: 0, y: 0 }) }) })] });
  }
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0] }));
  const centerX = 0;
  const centerY = 0;
  const angleStep = 2 * Math.PI / count2;
  const positions = [];
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (let i4 = 0; i4 < count2; i4++) {
    const angle = i4 * angleStep - Math.PI / 2;
    const x6 = centerX + radius * Math.cos(angle);
    const y6 = centerY + radius * Math.sin(angle);
    positions.push({ x: x6, y: y6 });
    minX = Math.min(minX, x6);
    minY = Math.min(minY, y6);
    maxX = Math.max(maxX, x6);
    maxY = Math.max(maxY, y6);
  }
  const lineData = [];
  for (let i4 = 0; i4 < count2; i4++) {
    const startPos = positions[i4];
    const endPos = positions[(i4 + 1) % count2];
    const lineLength = Math.sqrt(Math.pow(endPos.x - startPos.x, 2) + Math.pow(endPos.y - startPos.y, 2));
    const circleBigW = Math.min(lineLength * 0.5, 100);
    const midX = (startPos.x + endPos.x) / 2;
    const midY = (startPos.y + endPos.y) / 2;
    minX = Math.min(minX, midX - circleBigW / 2);
    minY = Math.min(minY, midY - circleBigW / 2);
    maxX = Math.max(maxX, midX + circleBigW / 2);
    maxY = Math.max(maxY, midY + circleBigW / 2);
    const midAngle = Math.atan2(midY - centerY, midX - centerX);
    const normalizedAngle = midAngle < 0 ? midAngle + 2 * Math.PI : midAngle;
    let itemX;
    let itemY;
    const deg = normalizedAngle * 180 / Math.PI;
    const distanceFromCenter = circleBigW / 2 + ITEM_DISTANCE;
    const itemCenterX = midX + Math.cos(midAngle) * distanceFromCenter;
    const itemCenterY = midY + Math.sin(midAngle) * distanceFromCenter;
    if (deg >= 337.5 || deg < 22.5) {
      itemX = itemCenterX;
      itemY = itemCenterY - itemBounds.height / 2;
    } else if (deg >= 22.5 && deg < 67.5) {
      itemX = itemCenterX;
      itemY = itemCenterY;
    } else if (deg >= 67.5 && deg < 112.5) {
      itemX = itemCenterX - itemBounds.width / 2;
      itemY = itemCenterY;
    } else if (deg >= 112.5 && deg < 157.5) {
      itemX = itemCenterX - itemBounds.width;
      itemY = itemCenterY;
    } else if (deg >= 157.5 && deg < 202.5) {
      itemX = itemCenterX - itemBounds.width;
      itemY = itemCenterY - itemBounds.height / 2;
    } else if (deg >= 202.5 && deg < 247.5) {
      itemX = itemCenterX - itemBounds.width;
      itemY = itemCenterY - itemBounds.height;
    } else if (deg >= 247.5 && deg < 292.5) {
      itemX = itemCenterX - itemBounds.width / 2;
      itemY = itemCenterY - itemBounds.height;
    } else {
      itemX = itemCenterX;
      itemY = itemCenterY - itemBounds.height;
    }
    lineData.push({ lineLength, circleBigW, midX, midY, itemX, itemY });
    minX = Math.min(minX, itemX);
    minY = Math.min(minY, itemY);
    maxX = Math.max(maxX, itemX + itemBounds.width + btnBounds.width + 5);
    maxY = Math.max(maxY, itemY + itemBounds.height);
  }
  const offsetX = Math.max(0, -minX);
  const offsetY = Math.max(0, -minY);
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const btnElements = [];
  const itemElements = [];
  const decorElements = [];
  const defsElements = [];
  const itemPositions = positions.map((pos) => ({
    x: pos.x + offsetX,
    y: pos.y + offsetY
  }));
  for (let i4 = 0; i4 < count2; i4++) {
    const startPos = itemPositions[i4];
    const endPos = itemPositions[(i4 + 1) % count2];
    const nextIndex = (i4 + 1) % count2;
    const indexes = [i4];
    const { lineLength, circleBigW, midX, midY } = lineData[i4];
    const CIRCLE_SMALL_W = Math.max(circleBigW - 20, 20);
    const ICON_SIZE2 = Math.max(CIRCLE_SMALL_W * 0.4, 16);
    const color3 = getPaletteColor2(options, indexes) || colorPrimary;
    const dx = endPos.x - startPos.x;
    const dy = endPos.y - startPos.y;
    const length = lineLength;
    const unitX = dx / length;
    const unitY = dy / length;
    const minLineLength = LINE_GAP * 2 + arrowSize;
    const actualGap = Math.min(LINE_GAP, (length - minLineLength) / 2);
    const adjustedStartX = Math.max(0, startPos.x + unitX * actualGap);
    const adjustedStartY = Math.max(0, startPos.y + unitY * actualGap);
    const adjustedEndX = Math.max(0, endPos.x - unitX * actualGap);
    const adjustedEndY = Math.max(0, endPos.y - unitY * actualGap);
    const line2 = line_default().x((d3) => Math.max(0, d3.x)).y((d3) => Math.max(0, d3.y)).curve(linear_default);
    const pathD = line2([
      { x: adjustedStartX, y: adjustedStartY },
      { x: adjustedEndX, y: adjustedEndY }
    ]) || "";
    const colorClean = color3.replace(/[^a-zA-Z0-9]/g, "");
    const arrowId = `fork-arrow-${colorClean}-${i4}`;
    const forkArrowPath = `
      M ${-arrowSize * 0.6} ${-arrowSize * 0.4}
      L 0 0
      L ${-arrowSize * 0.6} ${arrowSize * 0.4}
    `;
    defsElements.push(jsx("marker", { id: arrowId, viewBox: `${-arrowSize} ${-arrowSize * 0.6} ${arrowSize * 1.2} ${arrowSize * 1.2}`, refX: -arrowSize * 0.08, refY: 0, markerWidth: arrowSize, markerHeight: arrowSize, orient: "auto", markerUnits: "strokeWidth", children: jsx("path", { d: forkArrowPath, fill: "none", stroke: color3, strokeLinecap: "round", strokeLinejoin: "round", "data-element-type": "shape" }) }));
    decorElements.push(jsx(Path, { d: pathD, stroke: color3, strokeWidth, fill: "none", markerEnd: `url(#${arrowId})`, strokeLinecap: "round", "data-element-type": "shape" }));
    const adjustedMidX = midX + offsetX;
    const adjustedMidY = midY + offsetY;
    const themeColors = getThemeColors({
      colorPrimary: color3 || colorPrimary
    }, options);
    decorElements.push(jsx(Ellipse, { x: Math.max(0, adjustedMidX - circleBigW / 2), y: Math.max(0, adjustedMidY - circleBigW / 2), width: circleBigW, height: circleBigW, fill: themeColors.colorPrimaryBg, "data-element-type": "shape" }));
    decorElements.push(jsx(Ellipse, { x: Math.max(0, adjustedMidX - CIRCLE_SMALL_W / 2), y: Math.max(0, adjustedMidY - CIRCLE_SMALL_W / 2), width: CIRCLE_SMALL_W, height: CIRCLE_SMALL_W, fill: "#ffffff" }));
    decorElements.push(jsx(ItemIcon, { x: Math.max(0, adjustedMidX - ICON_SIZE2 / 2), y: Math.max(0, adjustedMidY - ICON_SIZE2 / 2), size: ICON_SIZE2, indexes, fill: color3 }));
    const btnAddX = Math.max(0, adjustedMidX - btnBounds.width / 2);
    const btnAddY = Math.max(0, adjustedMidY - btnBounds.height / 2);
    btnElements.push(jsx(BtnAdd, { indexes: [nextIndex], x: btnAddX, y: btnAddY }));
  }
  for (let i4 = 0; i4 < count2; i4++) {
    const indexes = [i4];
    const item = items3[i4];
    const { itemX: preItemX, itemY: preItemY } = lineData[i4];
    const itemX = Math.max(0, preItemX + offsetX);
    const itemY = Math.max(0, preItemY + offsetY);
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY }));
    const btnRemoveX = Math.max(0, itemX + itemBounds.width + 5);
    const btnRemoveY = Math.max(0, itemY + itemBounds.height / 2 - btnBounds.height / 2);
    btnElements.push(jsx(BtnRemove, { indexes, x: btnRemoveX, y: btnRemoveY }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: 30, children: [titleContent, jsxs(Group, { x: 0, y: 0, children: [jsx(Defs, { children: defsElements }), jsx(Group, { children: decorElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-circle-arrows", {
  component: SequenceCircleArrows,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-circular.js
var ITEM_AREA_HORIZONTAL_PADDING = 100;
var CIRCLE_AREA_HORIZONTAL_PADDING = 50;
var INNER_ARC_PADDING = 6;
var ARC_BACKGROUND_OPACITY_HEX = "40";
var SequenceCircular = (props) => {
  const { Title: Title2, Item, data, options, outerRadius = 180, innerRadius = 120, itemDistance = 310, gapAngle = 5, iconRadius = 34, iconBgRadius = 38, iconSize = 36 } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const centerX = Math.max(itemDistance + ITEM_AREA_HORIZONTAL_PADDING, outerRadius + CIRCLE_AREA_HORIZONTAL_PADDING);
  const centerY = Math.min(itemDistance, outerRadius);
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  if (items3.length === 0) {
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { children: jsx(BtnsGroup, { children: jsx(BtnAdd, { indexes: [0], x: centerX - 20, y: centerY - 20 }) }) })] });
  }
  const btnElements = [];
  const itemElements = [];
  const arcElements = [];
  const iconElements = [];
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0] }));
  const totalGapAngle = items3.length * gapAngle;
  const availableAngle = 360 - totalGapAngle;
  const arcAngle = availableAngle / items3.length;
  const createArcPath = (centerX2, centerY2, innerR, outerR, startAngle, endAngle) => {
    const startAngleRad = startAngle * Math.PI / 180;
    const endAngleRad = endAngle * Math.PI / 180;
    const x1 = centerX2 + innerR * Math.cos(startAngleRad);
    const y1 = centerY2 + innerR * Math.sin(startAngleRad);
    const x22 = centerX2 + outerR * Math.cos(startAngleRad);
    const y22 = centerY2 + outerR * Math.sin(startAngleRad);
    const x32 = centerX2 + outerR * Math.cos(endAngleRad);
    const y32 = centerY2 + outerR * Math.sin(endAngleRad);
    const x42 = centerX2 + innerR * Math.cos(endAngleRad);
    const y42 = centerY2 + innerR * Math.sin(endAngleRad);
    const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
    return [
      `M ${x1} ${y1}`,
      `L ${x22} ${y22}`,
      `A ${outerR} ${outerR} 0 ${largeArcFlag} 1 ${x32} ${y32}`,
      `L ${x42} ${y42}`,
      `A ${innerR} ${innerR} 0 ${largeArcFlag} 0 ${x1} ${y1}`,
      "Z"
    ].join(" ");
  };
  const computePosition = ({ centerX: centerX2, outerRadius: outerRadius2, angleRad, btnBounds: btnBounds2 }) => {
    const x6 = centerX2 + (outerRadius2 + 20) * Math.cos(angleRad) - btnBounds2.width / 2;
    const y6 = centerY + (outerRadius2 + 20) * Math.sin(angleRad) - btnBounds2.height / 2;
    return {
      x: x6,
      y: y6
    };
  };
  const padding = INNER_ARC_PADDING;
  const avgRadius = (innerRadius + outerRadius) / 2;
  const anglePadding = padding / avgRadius * (180 / Math.PI);
  items3.forEach((item, index2) => {
    const indexes = [index2];
    const startAngle = index2 * (arcAngle + gapAngle) + 270;
    const endAngle = startAngle + arcAngle;
    const midAngle = (startAngle + endAngle) / 2;
    const midAngleRad = midAngle * Math.PI / 180;
    const itemColor = getPaletteColor2(options, indexes);
    const lightColor = itemColor + ARC_BACKGROUND_OPACITY_HEX;
    const outerArcPath = createArcPath(centerX, centerY, innerRadius, outerRadius, startAngle, endAngle);
    arcElements.push(jsx(Path, { d: outerArcPath, fill: lightColor, width: outerRadius * 2, height: outerRadius * 2, "data-element-type": "shape" }));
    const innerArcPath = createArcPath(centerX, centerY, innerRadius + padding, outerRadius - padding, startAngle + anglePadding, endAngle - anglePadding);
    arcElements.push(jsx(Path, { d: innerArcPath, fill: itemColor, width: outerRadius * 2, height: outerRadius * 2, "data-element-type": "shape" }));
    const iconDistance = (innerRadius + outerRadius) / 2;
    const iconCenterX = centerX + iconDistance * Math.cos(midAngleRad);
    const iconCenterY = centerY + iconDistance * Math.sin(midAngleRad);
    iconElements.push(jsx(Ellipse, { x: iconCenterX - iconBgRadius, y: iconCenterY - iconBgRadius, width: iconBgRadius * 2, height: iconBgRadius * 2, fill: "#ffffff", "data-element-type": "shape" }));
    iconElements.push(jsx(Ellipse, { x: iconCenterX - iconRadius, y: iconCenterY - iconRadius, width: iconRadius * 2, height: iconRadius * 2, fill: itemColor, "data-element-type": "shape" }));
    if (item.icon) {
      iconElements.push(jsx(ItemIcon, { x: iconCenterX - iconSize / 2, y: iconCenterY - iconSize / 2, indexes, size: iconSize, fill: "#fff" }));
    }
    const normalizedAngle = (midAngle % 360 + 360) % 360;
    const isRightSide = normalizedAngle >= 270 || normalizedAngle <= 90;
    const isBottomArea = normalizedAngle >= 75 && normalizedAngle <= 105;
    let itemAngle;
    let positionH = "normal";
    let positionV = "normal";
    if (isBottomArea) {
      itemAngle = normalizedAngle;
      positionV = "normal";
      positionH = "center";
    } else if (isRightSide) {
      if (normalizedAngle >= 270) {
        itemAngle = -60 + (normalizedAngle - 270) / 90 * 60;
      } else {
        itemAngle = normalizedAngle / 90 * 60;
      }
      positionH = "normal";
    } else {
      itemAngle = 120 + (normalizedAngle - 90) / 180 * 120;
      positionH = "flipped";
    }
    const itemAngleRad = itemAngle * Math.PI / 180;
    const itemX = centerX + itemDistance * Math.cos(itemAngleRad) - itemBounds.width / 2;
    let itemY = centerY + itemDistance * Math.sin(itemAngleRad) - itemBounds.height / 2;
    if (isBottomArea) {
      itemY = centerY + outerRadius + itemBounds.height / 2;
    }
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, positionH, positionV }));
    const removeBtnDistance = itemDistance + 40;
    const removeBtnX = centerX + removeBtnDistance * Math.cos(itemAngleRad) - btnBounds.width / 2;
    const removeBtnY = centerY + removeBtnDistance * Math.sin(itemAngleRad) - btnBounds.height / 2;
    btnElements.push(jsx(BtnRemove, { indexes, x: removeBtnX, y: removeBtnY }));
    const nextGapAngle = startAngle + arcAngle + gapAngle / 2;
    const nextGapAngleRad = nextGapAngle * Math.PI / 180;
    const { x: addBtnX, y: addBtnY } = computePosition({
      centerX,
      outerRadius,
      angleRad: nextGapAngleRad,
      btnBounds
    });
    btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: addBtnX, y: addBtnY }));
  });
  const firstGapAngle = 270 - gapAngle / 2;
  const firstGapAngleRad = firstGapAngle * Math.PI / 180;
  const { x: firstAddBtnX, y: firstAddBtnY } = computePosition({
    centerX,
    outerRadius,
    angleRad: firstGapAngleRad,
    btnBounds
  });
  btnElements.unshift(jsx(BtnAdd, { indexes: [0], x: firstAddBtnX, y: firstAddBtnY }));
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: 70, children: [titleContent, jsxs(Group, { children: [jsx(Group, { children: arcElements }), jsx(Group, { children: iconElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-circular", {
  component: SequenceCircular,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-color-snake-steps.js
var SequenceColorSnakeSteps = (props) => {
  const { Title: Title2, Item, data, gap = 0, rowGap = 0, itemsPerRow = 3, circleStrokeWidth = 18, options } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const colorPrimary = getColorPrimary(options);
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const btnElements = [];
  const itemElements = [];
  const decorElements = [];
  const arcRadius = (rowGap + itemBounds.height) / 2;
  const arcWidth = arcRadius;
  items3.forEach((item, index2) => {
    const rowIndex = Math.floor(index2 / itemsPerRow);
    const colIndex = index2 % itemsPerRow;
    const isReversedRow = rowIndex % 2 === 1;
    const actualColIndex = isReversedRow ? itemsPerRow - 1 - colIndex : colIndex;
    const itemX = actualColIndex * (itemBounds.width + gap) + arcWidth;
    const itemY = rowIndex * (itemBounds.height + rowGap);
    const indexes = [index2];
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, positionH: "center", positionV: index2 % 2 === 1 ? "flipped" : "normal" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: itemY + itemBounds.height + 10 }));
    if (index2 === 0) {
      btnElements.push(jsx(BtnAdd, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: itemY - btnBounds.height - 10 }));
    }
    if (index2 < items3.length - 1) {
      const nextRowIndex = Math.floor((index2 + 1) / itemsPerRow);
      const isSameRow = rowIndex === nextRowIndex;
      if (isSameRow) {
        btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: itemX + (itemBounds.width - btnBounds.width) / 2, y: itemY - btnBounds.height - 10 }));
      } else {
        const currentItemY = itemY + itemBounds.height / 2;
        const nextItemY = itemY + itemBounds.height + rowGap + itemBounds.height / 2;
        let arcX, pathD, sweepFlag;
        if (isReversedRow) {
          arcX = itemX;
          sweepFlag = 0;
          pathD = `M ${arcX} ${currentItemY} A ${arcRadius} ${arcRadius} 0 0 ${sweepFlag} ${arcX} ${nextItemY}`;
        } else {
          arcX = itemX + itemBounds.width;
          sweepFlag = 1;
          pathD = `M ${arcX} ${currentItemY} A ${arcRadius} ${arcRadius} 0 0 ${sweepFlag} ${arcX} ${nextItemY}`;
        }
        const arcHeight = nextItemY - currentItemY;
        const currentColor = getPaletteColor2(options, indexes);
        const nextColor = getPaletteColor2(options, [index2 + 1]);
        const linearGradientId = `gradient-arc-${index2}`;
        decorElements.push(jsxs(Fragment, { children: [jsx(Defs, { children: jsxs("linearGradient", { id: linearGradientId, x1: "0%", y1: "0%", x2: "0%", y2: "100%", children: [jsx("stop", { offset: "0%", stopColor: currentColor || colorPrimary }), jsx("stop", { offset: "100%", stopColor: nextColor || colorPrimary })] }) }), jsx(Path, { d: pathD, stroke: `url(#${linearGradientId})`, strokeWidth: circleStrokeWidth, fill: "none", width: arcWidth, height: arcHeight, "data-element-type": "shape" })] }));
        const btnX = isReversedRow ? arcX - arcRadius - btnBounds.width / 2 : arcX + arcRadius - btnBounds.width / 2;
        const btnY = itemY + itemBounds.height + rowGap / 2 - btnBounds.height / 2;
        btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: btnX, y: btnY }));
      }
    }
  });
  if (items3.length > 0) {
    const lastIndex = items3.length - 1;
    const lastRowIndex = Math.floor(lastIndex / itemsPerRow);
    const lastColIndex = lastIndex % itemsPerRow;
    const isLastReversedRow = lastRowIndex % 2 === 1;
    const lastActualColIndex = isLastReversedRow ? itemsPerRow - 1 - lastColIndex : lastColIndex;
    const lastItemX = lastActualColIndex * (itemBounds.width + gap);
    const lastItemY = lastRowIndex * (itemBounds.height + rowGap);
    btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: lastItemX + (itemBounds.width - btnBounds.width) / 2, y: lastItemY + itemBounds.height + btnBounds.height + 20 }));
  }
  if (items3.length / itemsPerRow > 2) {
    const arcRadius2 = (rowGap + itemBounds.height) / 2;
    const firstItemColor = getPaletteColor2(options, [0]);
    decorElements.push(jsx(Rect, { x: 0, y: itemBounds.height / 2 - circleStrokeWidth / 2, width: arcRadius2, height: circleStrokeWidth, fill: firstItemColor || colorPrimary, "data-element-type": "shape" }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { width: itemsPerRow * itemBounds.width + (itemsPerRow - 1) * gap + arcRadius * 2, height: Math.ceil(items3.length / itemsPerRow) * (itemBounds.height + rowGap), children: [jsx(Group, { children: decorElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-color-snake-steps", {
  component: SequenceColorSnakeSteps,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-cylinders-3d.js
var calculateDepthOffset = (pairIndex, cylinderRx) => {
  if (pairIndex === 0)
    return 0;
  if (pairIndex === 1)
    return cylinderRx / 2;
  return cylinderRx / 2 + (pairIndex - 1) * (cylinderRx / 2 * 3);
};
var calculateLateralOffset = (isLeft, pairIndex, cylinderRx) => {
  if (isLeft)
    return 0;
  const firstPairGap = 2;
  const normalGap = cylinderRx;
  const gap = pairIndex === 0 ? firstPairGap : normalGap;
  return cylinderRx * 2 + gap;
};
var calculateLayoutMetrics = (itemsCount, itemBounds, cylinderRx, baseHeight, heightIncrement, depthSpacing, firstDecorationWidth, gapFromCylinder) => {
  const planeStepY = Math.max(6, depthSpacing * 0.15);
  const lastCylinderHeight = baseHeight + (itemsCount - 1) * heightIncrement;
  const totalPlaneOffset = itemsCount * planeStepY;
  const bottomMargin = 100;
  const topMargin = 50;
  const canvasHeight = lastCylinderHeight + totalPlaneOffset + bottomMargin + topMargin;
  const startY = canvasHeight - bottomMargin;
  let leftItemAlignedX = 0;
  let rightItemAlignedX = 0;
  let cylindersCenterX = 0;
  let cylinderAreaStartX = 0;
  if (itemsCount > 0) {
    const tempCylinderStart = 0;
    let minCylinderX = Infinity;
    let maxCylinderX = -Infinity;
    for (let index2 = 0; index2 < itemsCount; index2++) {
      const isLeft = index2 % 2 === 0;
      const pairIndex = Math.floor(index2 / 2);
      const depthOffset = calculateDepthOffset(pairIndex, cylinderRx);
      const lateralOffset = calculateLateralOffset(isLeft, pairIndex, cylinderRx);
      const x6 = tempCylinderStart + lateralOffset + depthOffset;
      minCylinderX = Math.min(minCylinderX, x6 - cylinderRx);
      maxCylinderX = Math.max(maxCylinderX, x6 + cylinderRx);
    }
    const relativeCylindersCenterX = (minCylinderX + maxCylinderX) / 2;
    const firstCylinderRelativeX = tempCylinderStart;
    leftItemAlignedX = 0;
    const leftLineEndX = leftItemAlignedX + itemBounds.width + gapFromCylinder;
    const firstCylinderLeftEdge = leftLineEndX + firstDecorationWidth;
    const requiredFirstCylinderX = firstCylinderLeftEdge + cylinderRx;
    cylinderAreaStartX = requiredFirstCylinderX;
    cylindersCenterX = cylinderAreaStartX - firstCylinderRelativeX + relativeCylindersCenterX;
    const firstItemCenterX = leftItemAlignedX + itemBounds.width / 2;
    const distanceToCenter = cylindersCenterX - firstItemCenterX;
    const rightItemCenterX = cylindersCenterX + distanceToCenter;
    rightItemAlignedX = rightItemCenterX - itemBounds.width / 2;
  }
  return {
    canvasHeight,
    startY,
    leftItemAlignedX,
    rightItemAlignedX,
    cylinderAreaStartX
  };
};
var calculateCylinderPosition = (index2, cylinderRx, baseHeight, heightIncrement, planeStepY, startY, cylinderAreaStartX) => {
  const isLeft = index2 % 2 === 0;
  const pairIndex = Math.floor(index2 / 2);
  const depthOffset = calculateDepthOffset(pairIndex, cylinderRx);
  const lateralOffset = calculateLateralOffset(isLeft, pairIndex, cylinderRx);
  const x6 = cylinderAreaStartX + lateralOffset + depthOffset;
  const bottomY = startY - index2 * planeStepY;
  const height = baseHeight + index2 * heightIncrement;
  const topY = bottomY - height;
  return { x: x6, y: topY, height, bottomY, topY };
};
var calculateItemPosition = (index2, cylinderPos, itemBounds, cylinderRx, leftItemAlignedX, rightItemAlignedX, itemVerticalAlign, itemVerticalOffset, gapFromCylinder) => {
  const isLeft = index2 % 2 === 0;
  const lineY = cylinderPos.topY + cylinderPos.height * 0.05;
  let itemX;
  let lineEndX;
  if (isLeft) {
    itemX = leftItemAlignedX;
    lineEndX = itemX + itemBounds.width + gapFromCylinder;
  } else {
    itemX = rightItemAlignedX;
    lineEndX = itemX - gapFromCylinder;
  }
  let itemY;
  if (itemVerticalAlign === "top") {
    itemY = lineY;
  } else if (itemVerticalAlign === "bottom") {
    itemY = lineY - itemBounds.height;
  } else {
    itemY = lineY - itemBounds.height / 2;
  }
  itemY += itemVerticalOffset;
  const cylinderEdgeX = isLeft ? cylinderPos.x - cylinderRx : cylinderPos.x + cylinderRx;
  const lineStartX = isLeft ? cylinderEdgeX - gapFromCylinder : cylinderEdgeX + gapFromCylinder;
  return { itemPos: { x: itemX, y: itemY }, lineStartX, lineEndX, lineY };
};
var createGradientDefs = (index2, color3) => {
  const baseColor = tinycolor(color3);
  const defs = [];
  defs.push(jsxs("linearGradient", { id: `cylinderGradient${index2}`, x1: "0%", y1: "0%", x2: "0%", y2: "100%", children: [jsx("stop", { offset: "0%", stopColor: baseColor.toRgbString(), stopOpacity: 0.7 }), jsx("stop", { offset: "40%", stopColor: baseColor.clone().lighten(5).toRgbString(), stopOpacity: 0.65 }), jsx("stop", { offset: "70%", stopColor: baseColor.clone().lighten(15).toRgbString(), stopOpacity: 0.6 }), jsx("stop", { offset: "100%", stopColor: baseColor.clone().lighten(20).toRgbString(), stopOpacity: 0.55 })] }));
  defs.push(jsxs("linearGradient", { id: `topGradient${index2}`, x1: "0%", y1: "0%", x2: "0%", y2: "100%", children: [jsx("stop", { offset: "0%", stopColor: baseColor.clone().lighten(15).toRgbString(), stopOpacity: 1 }), jsx("stop", { offset: "100%", stopColor: "#fafafa", stopOpacity: 1 })] }));
  defs.push(jsxs("linearGradient", { id: `bottomGradient${index2}`, x1: "0%", y1: "0%", x2: "0%", y2: "100%", children: [jsx("stop", { offset: "0%", stopColor: baseColor.clone().darken(8).toRgbString(), stopOpacity: 0.75 }), jsx("stop", { offset: "50%", stopColor: baseColor.clone().darken(5).toRgbString(), stopOpacity: 0.7 }), jsx("stop", { offset: "100%", stopColor: baseColor.clone().darken(12).toRgbString(), stopOpacity: 0.65 })] }));
  defs.push(jsxs("linearGradient", { id: `numberGradient${index2}`, x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [jsx("stop", { offset: "0%", stopColor: baseColor.clone().darken(0).toRgbString(), stopOpacity: 0.9 }), jsx("stop", { offset: "50%", stopColor: baseColor.clone().lighten(5).toRgbString(), stopOpacity: 0.85 }), jsx("stop", { offset: "100%", stopColor: baseColor.clone().lighten(10).toRgbString(), stopOpacity: 0.8 })] }));
  defs.push(jsxs("linearGradient", { id: `glowGradient${index2}`, x1: "0%", y1: "100%", x2: "0%", y2: "0%", children: [jsx("stop", { offset: "0%", stopColor: "#FFFFFF", stopOpacity: 0.2 }), jsx("stop", { offset: "90%", stopColor: "#FFFFFF", stopOpacity: 0 })] }));
  return defs;
};
var createCylinderElements = (index2, cylinderPos, cylinderRx, cylinderRy) => {
  const { x: x6, topY, bottomY } = cylinderPos;
  const elements = [];
  elements.push(jsx("ellipse", { id: `cylinder-bottom-${index2}`, cx: x6, cy: bottomY, rx: cylinderRx, ry: cylinderRy, fill: `url(#bottomGradient${index2})`, opacity: 0.7 }));
  elements.push(jsx(Path, { id: `cylinder-body-${index2}`, d: `
        M ${x6 - cylinderRx} ${topY}
        A ${cylinderRx} ${cylinderRy} 0 0 0 ${x6} ${topY + cylinderRy}
        A ${cylinderRx} ${cylinderRy} 0 0 0 ${x6 + cylinderRx} ${topY}
        L ${x6 + cylinderRx} ${bottomY}
        A ${cylinderRx} ${cylinderRy} 0 0 1 ${x6} ${bottomY + cylinderRy}
        A ${cylinderRx} ${cylinderRy} 0 0 1 ${x6 - cylinderRx} ${bottomY}
        Z
      `, fill: `url(#cylinderGradient${index2})`, stroke: "none" }));
  elements.push(jsx(Rect, { id: `cylinder-glow-${index2}`, x: x6 - cylinderRx, y: topY - cylinderRy * 3, width: cylinderRx * 2, height: cylinderRy * 3, fill: `url(#glowGradient${index2})` }));
  elements.push(jsx("ellipse", { id: `cylinder-top-${index2}`, cx: x6, cy: topY, rx: cylinderRx, ry: cylinderRy, fill: `url(#topGradient${index2})` }));
  const numberX = x6 - 10;
  const numberY = topY - 15;
  const scaleY = 0.6;
  const skewX = -0.6;
  const transformValue = `translate(${numberX}, ${numberY}) matrix(1, 0, ${skewX}, ${scaleY}, 0, 0)`;
  elements.push(jsx(Text, { id: `cylinder-number-${index2}`, width: 50, height: 50, fontFamily: "Arial Black, sans-serif", fontSize: 32, fontWeight: 900, fill: `url(#numberGradient${index2})`, alignHorizontal: "center", alignVertical: "middle", transform: transformValue, children: index2 + 1 }));
  return elements;
};
var createDecorationElements = (index2, lineStartX, lineEndX, lineY, color3) => {
  const dotRadius = 2;
  const elements = [];
  elements.push(jsx("circle", { id: `decoration-dot-start-${index2}`, cx: lineStartX, cy: lineY, r: dotRadius, fill: color3 }));
  elements.push(jsx("line", { id: `decoration-line-${index2}`, x1: lineStartX, y1: lineY, x2: lineEndX, y2: lineY, stroke: color3, strokeWidth: 1, opacity: 0.8 }));
  elements.push(jsx("circle", { id: `decoration-dot-end-${index2}`, cx: lineEndX, cy: lineY, r: dotRadius, fill: color3, opacity: 0.9 }));
  return elements;
};
var createBasePlate = (itemsCount, cylinderRx, cylinderAreaStartX, startY, planeStepY) => {
  if (itemsCount === 0)
    return null;
  const positions = [];
  for (let index2 = 0; index2 < itemsCount; index2++) {
    const isLeft = index2 % 2 === 0;
    const pairIndex = Math.floor(index2 / 2);
    const depthOffset = calculateDepthOffset(pairIndex, cylinderRx);
    const lateralOffset = calculateLateralOffset(isLeft, pairIndex, cylinderRx);
    const x6 = cylinderAreaStartX + lateralOffset + depthOffset;
    const bottomY = startY - index2 * planeStepY;
    positions.push({ x: x6, y: bottomY });
  }
  const leftmostPos = positions[0];
  const rightmostPos = positions[positions.length - 1];
  const plateThickness = 6;
  const plateMargin = itemsCount > 5 ? itemsCount * 16 : 100;
  const frontLeftX = leftmostPos.x - cylinderRx - plateMargin;
  const frontRightX = leftmostPos.x + cylinderRx + plateMargin;
  const frontY = leftmostPos.y + plateThickness + plateMargin / 6;
  const backLeftX = rightmostPos.x - cylinderRx - plateMargin;
  const backRightX = rightmostPos.x + cylinderRx + plateMargin;
  const backY = rightmostPos.y + plateThickness - plateMargin / 6;
  const platePath = `
    M ${frontLeftX} ${frontY}
    L ${frontRightX} ${frontY}
    L ${backRightX} ${backY}
    L ${backLeftX} ${backY}
    Z
  `;
  const sidePath = `
    M ${frontRightX} ${frontY}
    L ${frontRightX} ${frontY + plateThickness}
    L ${backRightX} ${backY + plateThickness}
    L ${backRightX} ${backY}
    Z
  `;
  const frontPath = `
    M ${frontLeftX} ${frontY}
    L ${frontRightX} ${frontY}
    L ${frontRightX} ${frontY + plateThickness}
    L ${frontLeftX} ${frontY + plateThickness}
    Z
  `;
  const plateGradients = jsxs(Fragment, { children: [jsxs("linearGradient", { id: "basePlateTopGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [jsx("stop", { offset: "0%", stopColor: "#fafafa", stopOpacity: 1 }), jsx("stop", { offset: "50%", stopColor: "#ffffff", stopOpacity: 0.98 }), jsx("stop", { offset: "100%", stopColor: "#ececec", stopOpacity: 0.95 })] }), jsxs("linearGradient", { id: "basePlateFrontGradient", x1: "0%", y1: "0%", x2: "0%", y2: "100%", children: [jsx("stop", { offset: "0%", stopColor: "#e0e0e0", stopOpacity: 0.95 }), jsx("stop", { offset: "50%", stopColor: "#d2d2d2", stopOpacity: 0.93 }), jsx("stop", { offset: "100%", stopColor: "#c5c5c5", stopOpacity: 0.9 })] }), jsxs("linearGradient", { id: "basePlateSideGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [jsx("stop", { offset: "0%", stopColor: "#b8b8b8", stopOpacity: 0.92 }), jsx("stop", { offset: "50%", stopColor: "#c0c0c0", stopOpacity: 0.88 }), jsx("stop", { offset: "100%", stopColor: "#adadad", stopOpacity: 0.85 })] })] });
  return jsxs(Group, { children: [jsx(Defs, { children: plateGradients }), jsx(Path, { id: "base-plate-front", d: frontPath, fill: "url(#basePlateFrontGradient)", stroke: "#c5c5c5", strokeWidth: 0.3, opacity: 0.92 }), jsx(Path, { id: "base-plate-side", d: sidePath, fill: "url(#basePlateSideGradient)", stroke: "#aaaaaa", strokeWidth: 0.3, opacity: 0.88 }), jsx(Path, { id: "base-plate-top", d: platePath, fill: "url(#basePlateTopGradient)", stroke: "#e5e5e5", strokeWidth: 0.5, opacity: 0.93 })] });
};
var sequenceCylinders3d = (props) => {
  const { Title: Title2, Item, data, options, cylinderRx = 28, cylinderRy = 18, baseHeight = 120, heightIncrement = 40, depthSpacing = 60, itemVerticalAlign = "top", itemVerticalOffset = -12, firstDecorationWidth = 90 } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const colorPrimary = getColorPrimary(options);
  const gapFromCylinder = 10;
  const planeStepY = Math.max(6, depthSpacing * 0.15);
  const layoutMetrics = calculateLayoutMetrics(items3.length, itemBounds, cylinderRx, baseHeight, heightIncrement, depthSpacing, firstDecorationWidth, gapFromCylinder);
  const { startY, leftItemAlignedX, rightItemAlignedX, cylinderAreaStartX } = layoutMetrics;
  const defsElements = [];
  const perItemGroups = [];
  items3.forEach((item, index2) => {
    const color3 = getPaletteColor2(options, [index2]) || colorPrimary;
    defsElements.push(...createGradientDefs(index2, color3));
    const cylinderPos = calculateCylinderPosition(index2, cylinderRx, baseHeight, heightIncrement, planeStepY, startY, cylinderAreaStartX);
    const cylinderNodes = createCylinderElements(index2, cylinderPos, cylinderRx, cylinderRy);
    const { itemPos, lineStartX, lineEndX, lineY } = calculateItemPosition(index2, cylinderPos, itemBounds, cylinderRx, leftItemAlignedX, rightItemAlignedX, itemVerticalAlign, itemVerticalOffset, gapFromCylinder);
    const decorationNodes = createDecorationElements(index2, lineStartX, lineEndX, lineY, color3);
    cylinderNodes.push(...decorationNodes);
    const itemNode = jsx(Item, { indexes: [index2], datum: item, data, x: itemPos.x, y: itemPos.y, positionH: index2 % 2 === 0 ? "flipped" : "normal" });
    const btnNodes = [
      jsx(BtnRemove, { indexes: [index2], x: itemPos.x + itemBounds.width / 2 - btnBounds.width / 2, y: itemPos.y + itemBounds.height + 10 }),
      jsx(BtnAdd, { indexes: [index2], x: itemPos.x + itemBounds.width / 2 - btnBounds.width / 2, y: itemPos.y - btnBounds.height - 10 })
    ];
    perItemGroups[index2] = {
      cylinderNodes,
      itemNode,
      btnNodes,
      itemX: itemPos.x,
      itemY: itemPos.y
    };
  });
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  perItemGroups.forEach((group) => {
    const { itemX, itemY } = group;
    minX = Math.min(minX, itemX);
    minY = Math.min(minY, itemY);
    maxX = Math.max(maxX, itemX + itemBounds.width);
    maxY = Math.max(maxY, itemY + itemBounds.height);
  });
  const itemsBoundsWidth = maxX - minX;
  const itemsBoundsHeight = maxY - minY;
  const itemElements = [jsx(Defs, { children: defsElements })];
  const btnElements = [];
  const basePlate = createBasePlate(items3.length, cylinderRx, cylinderAreaStartX, startY, planeStepY);
  if (basePlate) {
    itemElements.push(basePlate);
  }
  for (let i4 = items3.length - 1; i4 >= 0; i4--) {
    const g3 = perItemGroups[i4];
    if (!g3)
      continue;
    itemElements.push(jsxs(Group, { children: [jsx(Group, { children: g3.cylinderNodes }), g3.itemNode] }));
    btnElements.push(...g3.btnNodes);
  }
  if (items3.length > 0) {
    const isNextLeft = items3.length % 2 === 0;
    const nextPairIndex = Math.floor(items3.length / 2);
    const nextDepthOffset = calculateDepthOffset(nextPairIndex, cylinderRx);
    const nextLateralOffset = calculateLateralOffset(isNextLeft, nextPairIndex, cylinderRx);
    const nextX = cylinderAreaStartX + nextLateralOffset + nextDepthOffset;
    const nextY = startY - items3.length * planeStepY;
    btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: nextX, y: nextY - 100 }));
  }
  return jsxs(FlexLayout, { flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { width: itemsBoundsWidth, height: itemsBoundsHeight, children: [jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-cylinders-3d", {
  component: sequenceCylinders3d,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-filter-mesh.js
var SHAPE_CONFIG = {
  WIDTH: 160,
  HEIGHT: 260,
  ARROW_HEIGHT: 148,
  ARROW_WIDTH: 100,
  LINE_X: 100,
  RECT_X: 0,
  RECT_Y: 80,
  RECT_WIDTH: 100,
  RECT_HEIGHT: 130
};
var PARTICLE_CONFIG = {
  SIZE: 8,
  MAX_COUNT: 40,
  MIN_COUNT: 5,
  ARROW_RATIO: 0.6,
  MIN_ARROW_COUNT: 3
};
function pseudoRandom(seed, row, col) {
  return (seed + row * 7 + col * 13) % 100;
}
function calculateGridLayout(count2) {
  const cols = Math.ceil(Math.sqrt(count2 * 1.5));
  const rows = Math.ceil(count2 / cols);
  return { cols, rows };
}
function calculateParticlePosition(baseX, baseY, offsetX, offsetY, minX, maxX, minY, maxY) {
  const x6 = Math.max(minX, Math.min(baseX + offsetX, maxX));
  const y6 = Math.max(minY, Math.min(baseY + offsetY, maxY));
  return { x: x6, y: y6 };
}
function generateParticles({ count: count2, rectX, rectY, rectWidth, rectHeight, seed }) {
  const particles = [];
  const padding = PARTICLE_CONFIG.SIZE / 2;
  const { cols, rows } = calculateGridLayout(count2);
  const cellWidth = (rectWidth - padding * 2) / (cols + 1);
  const cellHeight = (rectHeight - padding * 2) / (rows + 1);
  let particleCount = 0;
  for (let row = 0; row < rows && particleCount < count2; row++) {
    for (let col = 0; col < cols && particleCount < count2; col++) {
      const random = pseudoRandom(seed, row, col);
      const offsetX = random % 16 - 8;
      const offsetY = random * 3 % 12 - 6;
      const rowOffset = row % 2 === 1 ? cellWidth / 2 : 0;
      const baseX = rectX + padding + (col + 1) * cellWidth + rowOffset;
      const baseY = rectY + padding + (row + 1) * cellHeight;
      const { x: x6, y: y6 } = calculateParticlePosition(baseX, baseY, offsetX, offsetY, rectX + padding, rectX + rectWidth - padding, rectY + padding, rectY + rectHeight - padding);
      particles.push({ x: x6, y: y6, colorIndex: particleCount });
      particleCount++;
    }
  }
  return particles;
}
function calculateParticleCount(index2, totalItems) {
  if (totalItems <= 1)
    return PARTICLE_CONFIG.MAX_COUNT;
  const progress = index2 / (totalItems - 1);
  const range = PARTICLE_CONFIG.MAX_COUNT - PARTICLE_CONFIG.MIN_COUNT;
  return Math.round(PARTICLE_CONFIG.MAX_COUNT - range * progress);
}
function createMeshPath() {
  const GRID_COUNT = 12;
  const MESH_WIDTH = 120;
  const MESH_HEIGHT = 180;
  const START_X = 40;
  const START_Y = 25;
  const PERSPECTIVE_OFFSET = 50;
  const corners = {
    topLeft: { x: START_X, y: START_Y },
    topRight: { x: START_X + MESH_WIDTH, y: START_Y + PERSPECTIVE_OFFSET },
    bottomLeft: { x: START_X, y: START_Y + MESH_HEIGHT },
    bottomRight: {
      x: START_X + MESH_WIDTH,
      y: START_Y + MESH_HEIGHT + PERSPECTIVE_OFFSET
    }
  };
  const lines = [];
  for (let i4 = 0; i4 <= GRID_COUNT; i4++) {
    const t2 = i4 / GRID_COUNT;
    const horizontalStart = {
      x: corners.topLeft.x + (corners.bottomLeft.x - corners.topLeft.x) * t2,
      y: corners.topLeft.y + (corners.bottomLeft.y - corners.topLeft.y) * t2
    };
    const horizontalEnd = {
      x: corners.topRight.x + (corners.bottomRight.x - corners.topRight.x) * t2,
      y: corners.topRight.y + (corners.bottomRight.y - corners.topRight.y) * t2
    };
    lines.push(`M${horizontalStart.x} ${horizontalStart.y}L${horizontalEnd.x} ${horizontalEnd.y}`);
    const verticalStart = {
      x: corners.topLeft.x + (corners.topRight.x - corners.topLeft.x) * t2,
      y: corners.topLeft.y + (corners.topRight.y - corners.topLeft.y) * t2
    };
    const verticalEnd = {
      x: corners.bottomLeft.x + (corners.bottomRight.x - corners.bottomLeft.x) * t2,
      y: corners.bottomLeft.y + (corners.bottomRight.y - corners.bottomLeft.y) * t2
    };
    lines.push(`M${verticalStart.x} ${verticalStart.y}L${verticalEnd.x} ${verticalEnd.y}`);
  }
  return lines.join("");
}
function renderParticles(particles, options) {
  return particles.map((particle) => {
    const color3 = getPaletteColor2(options, [particle.colorIndex]);
    return jsx(Path, { d: "M4 0L8 4L4 8L0 4Z", fill: color3, x: particle.x, y: particle.y, width: PARTICLE_CONFIG.SIZE, height: PARTICLE_CONFIG.SIZE, "data-element-type": "shape" });
  });
}
function createDecorElement(index2, itemX, color3, particles, options) {
  return jsxs(Group, { x: itemX, y: 0, width: SHAPE_CONFIG.WIDTH, height: SHAPE_CONFIG.HEIGHT, children: [jsxs(ShapesGroup, { children: [jsx(Path, { d: createMeshPath(), stroke: "#D9D9D9", strokeWidth: 2 }), jsx(Path, { d: `M${SHAPE_CONFIG.LINE_X} 25V260`, stroke: "#BFBFBF", strokeWidth: 2, strokeLinecap: "round" }), jsx(Rect, { x: SHAPE_CONFIG.RECT_X, y: SHAPE_CONFIG.RECT_Y, width: SHAPE_CONFIG.RECT_WIDTH, height: SHAPE_CONFIG.RECT_HEIGHT, fill: "#FFCB0E", fillOpacity: 0.2 })] }), jsx(Fragment, { children: renderParticles(particles, options) }), jsx(Text, { x: SHAPE_CONFIG.LINE_X - 25, y: 0, width: 50, height: 20, fontSize: 20, fontWeight: "bold", alignHorizontal: "center", alignVertical: "top", fill: color3, children: String(index2 + 1).padStart(2, "0") })] });
}
function createArrowElement(itemX, options) {
  const arrowY = SHAPE_CONFIG.RECT_Y + SHAPE_CONFIG.RECT_HEIGHT / 2 - SHAPE_CONFIG.ARROW_HEIGHT / 2;
  const arrowParticleCount = Math.max(Math.round(PARTICLE_CONFIG.MIN_COUNT * PARTICLE_CONFIG.ARROW_RATIO), PARTICLE_CONFIG.MIN_ARROW_COUNT);
  const arrowParticles = generateParticles({
    count: arrowParticleCount,
    rectX: 0,
    rectY: 14,
    rectWidth: 57,
    rectHeight: 120,
    seed: 999
  });
  return jsxs(Group, { x: itemX + SHAPE_CONFIG.WIDTH, y: arrowY, children: [jsx(Path, { d: "M0 13.9679H57.1429V0L100 74L57.1429 148V134.032H0V13.9679Z", width: SHAPE_CONFIG.ARROW_WIDTH, height: SHAPE_CONFIG.ARROW_HEIGHT, fill: "#FFCB0E", fillOpacity: 0.2, "data-element-type": "shape" }), jsx(Fragment, { children: renderParticles(arrowParticles, options) })] });
}
var SequenceFilterMesh = (props) => {
  const { Title: Title2, Item, data, gap = 20, options } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], width: SHAPE_CONFIG.WIDTH, positionH: "center" }));
  const decorElements = [];
  const itemElements = [];
  const btnElements = [];
  const itemYPos = SHAPE_CONFIG.HEIGHT + gap;
  const btnY = itemYPos + itemBounds.height + 10;
  items3.forEach((item, index2) => {
    const itemX = index2 * SHAPE_CONFIG.WIDTH;
    const indexes = [index2];
    const color3 = getPaletteColor2(options, indexes);
    const particleCount = calculateParticleCount(index2, items3.length);
    const particles = generateParticles({
      count: particleCount,
      rectX: SHAPE_CONFIG.RECT_X,
      rectY: SHAPE_CONFIG.RECT_Y,
      rectWidth: SHAPE_CONFIG.RECT_WIDTH,
      rectHeight: SHAPE_CONFIG.RECT_HEIGHT,
      seed: index2 * 100
    });
    decorElements.push(createDecorElement(index2, itemX, color3, particles, options));
    if (index2 === items3.length - 1) {
      decorElements.push(createArrowElement(itemX, options));
    }
    itemElements.push(jsx(Item, { indexes, datum: item, data, width: SHAPE_CONFIG.WIDTH, x: itemX + SHAPE_CONFIG.LINE_X - SHAPE_CONFIG.WIDTH / 2, y: itemYPos, positionH: "center" }, `item-${index2}`));
    btnElements.push(jsx(BtnRemove, { indexes, x: itemX + SHAPE_CONFIG.LINE_X - btnBounds.width / 2, y: btnY }));
    if (index2 < items3.length - 1) {
      btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: itemX + SHAPE_CONFIG.WIDTH - btnBounds.width / 2, y: btnY }));
    }
  });
  if (items3.length > 0) {
    btnElements.unshift(jsx(BtnAdd, { indexes: [0], x: -btnBounds.width / 2, y: btnY }));
    const lastItemX = (items3.length - 1) * SHAPE_CONFIG.WIDTH;
    btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: lastItemX + SHAPE_CONFIG.WIDTH - btnBounds.width / 2, y: btnY }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { width: SHAPE_CONFIG.WIDTH * items3.length + SHAPE_CONFIG.ARROW_WIDTH, height: SHAPE_CONFIG.HEIGHT + gap + itemBounds.height, children: [jsx(Group, { children: decorElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-filter-mesh", {
  component: SequenceFilterMesh,
  composites: ["title", "item"]
});

// node_modules/round-polygon/dist/round-polygon.es.js
var round2 = (n4) => Math.round(n4 * 1e10) / 1e10;
var getLength = (A4, B2) => round2(Math.sqrt((B2.x - A4.x) * (B2.x - A4.x) + (B2.y - A4.y) * (B2.y - A4.y)));
var PI$1 = Math.PI;
var TAU = PI$1 * 2;
var getClockDir = (angle1, angle2) => {
  const diff = angle2 - angle1;
  return diff > PI$1 && diff < TAU || diff < 0 && diff > -PI$1 ? -1 : 1;
};
var getAngles = (prevpoint, currpoint, nextpoint, prevlen, mainlen, nextlen) => {
  const prev = Math.atan2(prevpoint.y - currpoint.y, prevpoint.x - currpoint.x), next = Math.atan2(nextpoint.y - currpoint.y, nextpoint.x - currpoint.x), main = Math.acos((prevlen * prevlen + nextlen * nextlen - mainlen * mainlen) / (2 * prevlen * nextlen)), vel = 1 / Math.tan(main / 2), dir = getClockDir(prev, next), bis = prev + dir * main / 2;
  return { prev, next, main, vel, dir, bis };
};
var PI = Math.PI;
var getSegments = (points, type2, opt) => points.reduce((segmented, point) => {
  const { x: x6, y: y6, angle: { prev, next }, arc: { x: rx, y: ry, radius } } = point, dir = point.angle.dir * -1, startangle = prev + dir * PI / 2, angle = (dir * PI + next - prev) % PI, amount = type2 === "LENGTH" ? Math.round(dir * angle * radius / opt) : (opt || 1) - 1, unitangle = angle / amount, vertices = [];
  if (!amount || !unitangle)
    return segmented.concat({ x: x6, y: y6 });
  for (let i4 = 0; i4 <= amount; i4++)
    vertices.push({
      x: rx + Math.cos(startangle + unitangle * i4) * radius,
      y: ry + Math.sin(startangle + unitangle * i4) * radius
    });
  return segmented.concat(vertices);
}, []);
var roundPolygon = (points, radius = 0) => {
  const len = points.length, preRoundedPoints = [], limPoints = [], zeroLimPoints = [];
  points.forEach((curr, id2) => {
    const prev = points[(id2 - 1 + len) % len], next = points[(id2 + 1) % len], prevlen = getLength(prev, curr), mainlen = getLength(prev, next), nextlen = getLength(curr, next), angle = getAngles(prev, curr, next, prevlen, mainlen, nextlen);
    if (angle.main === 0) {
      angle.main = Number.EPSILON;
      angle.vel = Number.MAX_SAFE_INTEGER;
    }
    if (angle.main === PI$1)
      angle.vel = 0;
    const preRoundedPoint = {
      x: curr.x,
      y: curr.y,
      angle,
      offset: 0,
      arc: {
        radius,
        hit: radius,
        lim: Math.min(nextlen / angle.vel, prevlen / angle.vel, curr.r || 0)
      },
      in: { length: prevlen, rest: prevlen },
      out: { length: nextlen, rest: nextlen },
      locked: false,
      id: id2,
      get prev() {
        return preRoundedPoints[(id2 - 1 + len) % len];
      },
      get next() {
        return preRoundedPoints[(id2 + 1) % len];
      }
    };
    if (isNaN(angle.main)) {
      angle.main = 0;
      angle.bis = angle.prev || angle.next;
      zeroLimPoints.push(preRoundedPoint);
    }
    if (typeof curr.r === "number")
      if (curr.r === 0)
        zeroLimPoints.push(preRoundedPoint);
      else
        limPoints.push(preRoundedPoint);
    preRoundedPoints.push(preRoundedPoint);
  });
  zeroLimPoints.forEach((p7) => {
    p7.angle.vel = 0;
    p7.arc.radius = 0;
    lockPoint(p7);
  });
  preRoundedPoints.forEach((p7) => {
    p7.arc.hit = Math.min(p7.out.rest / (p7.angle.vel + p7.next.angle.vel), p7.in.rest / (p7.angle.vel + p7.prev.angle.vel));
  });
  let minHitPoint = getMinHit(limPoints);
  while (minHitPoint) {
    calcLimitRadius(minHitPoint);
    minHitPoint = getMinHit(limPoints);
  }
  minHitPoint = getMinHit(preRoundedPoints);
  while (minHitPoint) {
    calcCommonRadius(minHitPoint, radius);
    minHitPoint = getMinHit(preRoundedPoints);
  }
  const roundedPoints = preRoundedPoints.map((p7) => {
    const bislen = p7.arc.radius / Math.sin(p7.angle.main / 2);
    return {
      id: p7.id,
      x: p7.x,
      y: p7.y,
      angle: {
        main: round2(p7.angle.main),
        prev: p7.angle.prev,
        next: p7.angle.next,
        bis: p7.angle.bis,
        dir: p7.angle.dir
      },
      offset: round2(p7.offset),
      arc: {
        radius: round2(p7.arc.radius),
        x: p7.x + (Math.cos(p7.angle.bis) * bislen || 0),
        y: p7.y + (Math.sin(p7.angle.bis) * bislen || 0)
      },
      in: {
        length: p7.in.length,
        x: p7.x + Math.cos(p7.angle.prev) * p7.offset,
        y: p7.y + Math.sin(p7.angle.prev) * p7.offset
      },
      out: {
        length: p7.out.length,
        x: p7.x + Math.cos(p7.angle.next) * p7.offset,
        y: p7.y + Math.sin(p7.angle.next) * p7.offset
      },
      get prev() {
        return roundedPoints[(p7.id - 1 + len) % len];
      },
      get next() {
        return roundedPoints[(p7.id + 1) % len];
      }
    };
  });
  return roundedPoints;
};
var calcLimitRadius = (curr) => {
  const { prev, next } = curr;
  if (prev.locked && !next.locked)
    curr.arc.radius = Math.min(Math.max((curr.out.length - next.arc.lim * next.angle.vel) / curr.angle.vel, curr.out.length / (curr.angle.vel + next.angle.vel)), curr.in.rest / curr.angle.vel, curr.arc.lim);
  else if (next.locked && !prev.locked)
    curr.arc.radius = Math.min(Math.max((curr.in.length - prev.arc.lim * prev.angle.vel) / curr.angle.vel, curr.in.length / (curr.angle.vel + prev.angle.vel)), curr.out.rest / curr.angle.vel, curr.arc.lim);
  else if (next.locked && prev.locked)
    curr.arc.radius = Math.min(curr.in.rest / curr.angle.vel, curr.out.rest / curr.angle.vel, curr.arc.lim);
  else
    curr.arc.radius = Math.min(Math.max((curr.in.length - prev.arc.lim * prev.angle.vel) / curr.angle.vel, curr.in.length / (curr.angle.vel + prev.angle.vel)), Math.max((curr.out.length - next.arc.lim * next.angle.vel) / curr.angle.vel, curr.out.length / (curr.angle.vel + next.angle.vel)), curr.arc.lim);
  lockPoint(curr);
};
var calcCommonRadius = (curr, radius) => {
  if (radius > curr.arc.hit) {
    const { prev, next } = curr;
    if (prev.locked && !next.locked)
      curr.arc.radius = Math.max(Math.min(curr.in.rest / curr.angle.vel, curr.out.length / (curr.angle.vel + next.angle.vel), curr.arc.radius), 0);
    else if (next.locked && !prev.locked)
      curr.arc.radius = Math.max(Math.min(curr.out.rest / curr.angle.vel, curr.in.length / (curr.angle.vel + prev.angle.vel), curr.arc.radius), 0);
    else if (next.locked && prev.locked)
      curr.arc.radius = Math.max(Math.min(curr.in.rest / curr.angle.vel, curr.out.rest / curr.angle.vel, curr.arc.radius), 0);
    else
      curr.arc.radius = curr.arc.hit;
  }
  lockPoint(curr);
};
var lockPoint = (curr) => {
  const { prev, next } = curr;
  curr.offset = curr.arc.radius * curr.angle.vel;
  prev.out.rest -= curr.offset;
  curr.in.rest -= curr.offset;
  curr.out.rest -= curr.offset;
  next.in.rest -= curr.offset;
  curr.locked = true;
  prev.arc.hit = Math.min(prev.in.length / (prev.angle.vel + prev.prev.angle.vel), prev.in.rest / prev.angle.vel, prev.out.rest / prev.angle.vel);
  next.arc.hit = Math.min(next.out.length / (next.angle.vel + next.next.angle.vel), next.out.rest / next.angle.vel, next.in.rest / next.angle.vel);
};
var getMinHit = (arr) => arr.reduce((min3, p7) => p7.locked ? min3 : !min3 ? p7 : p7.arc.hit < min3.arc.hit ? p7 : min3, null);

// node_modules/@antv/infographic/esm/designs/structures/sequence-funnel.js
var FUNNEL_CORNER_RADIUS = 6;
var ICON_SIZE = 32;
var FUNNEL_LAYER_HEIGHT_RATIO = 1.25;
var OVERLAP_DIST = 25;
var TEXT_GAP2 = 15;
var SequenceFunnel = (props) => {
  const {
    Title: Title2,
    Item,
    data,
    gap = 10,
    width = 700,
    funnelWidth,
    itemHeight = 60,
    minBottomRatio = 0.25,
    //  25% 
    options
  } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  if (items3.length === 0) {
    return jsx(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: titleContent });
  }
  const themeColors = getThemeColors(options.themeConfig);
  const actualFunnelWidth = funnelWidth !== null && funnelWidth !== void 0 ? funnelWidth : width * 0.55;
  const itemAreaWidth = width - actualFunnelWidth;
  const funnelLayerHeight = itemHeight * FUNNEL_LAYER_HEIGHT_RATIO;
  const totalHeight = items3.length * funnelLayerHeight + (items3.length - 1) * gap;
  const minFunnelPixelWidth = actualFunnelWidth * minBottomRatio;
  const elements = items3.map((item, index2) => {
    const indexes = [index2];
    const color3 = getPaletteColor2(options, [index2]) || themeColors.colorPrimary;
    const { points, topWidth } = calculateTrapezoidSegment(actualFunnelWidth, minFunnelPixelWidth, funnelLayerHeight, gap, totalHeight, index2);
    const rounded = roundPolygon(points, FUNNEL_CORNER_RADIUS);
    const segments = getSegments(rounded, "AMOUNT", 10);
    const funnelCenterX = actualFunnelWidth / 2;
    const funnelY = index2 * (funnelLayerHeight + gap);
    const rightTopX = funnelCenterX + topWidth / 2;
    const backgroundX = rightTopX - OVERLAP_DIST;
    const backgroundWidth = itemAreaWidth + OVERLAP_DIST - 10;
    const backgroundYOffset = (funnelLayerHeight - itemHeight) / 2;
    const backgroundY = funnelY + backgroundYOffset;
    const itemX = rightTopX + TEXT_GAP2;
    const itemWidth = backgroundWidth - OVERLAP_DIST - TEXT_GAP2;
    const itemY = backgroundY;
    const iconX = funnelCenterX - ICON_SIZE / 2;
    const iconY = funnelY + funnelLayerHeight / 2 - ICON_SIZE / 2;
    const funnelColorId = `${color3.replace("#", "")}-funnel-${index2}`;
    return {
      background: jsx(Rect, {
        x: backgroundX,
        y: backgroundY,
        width: backgroundWidth,
        height: itemHeight,
        ry: "8",
        fill: tinycolor(color3).setAlpha(0.1).toRgbString(),
        "data-element-type": "shape"
      }),
      funnel: [
        jsx(Defs, { children: jsxs("linearGradient", { id: funnelColorId, x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [jsx("stop", { offset: "0%", stopColor: tinycolor(color3).lighten(10).toString() }), jsx("stop", { offset: "100%", stopColor: color3 })] }) }),
        jsx(Polygon, {
          points: segments,
          fill: `url(#${funnelColorId})`,
          y: funnelY,
          "data-element-type": "shape",
          //  filter
          style: { filter: "drop-shadow(0px 2px 3px rgba(0,0,0,0.15))" }
        })
      ],
      icon: jsx(ItemIcon, { indexes, x: iconX, y: iconY, size: ICON_SIZE, fill: "#fff" }),
      item: jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, width: itemWidth, height: itemHeight, positionV: "middle" }),
      btnRemove: jsx(BtnRemove, { indexes, x: backgroundX + backgroundWidth, y: backgroundY })
    };
  });
  const btnAdd = jsx(BtnAdd, { indexes: [items3.length], x: width / 2, y: totalHeight + 10 });
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { width, height: totalHeight + 40, children: [jsx(Group, { children: elements.map((element) => element.background) }), jsx(Group, { children: elements.flatMap((element) => element.funnel) }), jsx(Group, { children: elements.map((element) => element.icon) }), jsx(ItemsGroup, { children: elements.map((element) => element.item) }), jsxs(BtnsGroup, { children: [elements.map((element) => element.btnRemove), btnAdd] })] })] });
};
function calculateTrapezoidSegment(maxWidth, minWidth, layerHeight, gap, totalHeight, index2) {
  const centerX = maxWidth / 2;
  const currentTopY = index2 * (layerHeight + gap);
  const currentBottomY = currentTopY + layerHeight;
  const widthDiff = maxWidth - minWidth;
  const topWidth = maxWidth - widthDiff * (currentTopY / totalHeight);
  const bottomWidth = maxWidth - widthDiff * (currentBottomY / totalHeight);
  const p1 = { x: centerX - topWidth / 2, y: 0 };
  const p22 = { x: centerX + topWidth / 2, y: 0 };
  const p32 = { x: centerX + bottomWidth / 2, y: layerHeight };
  const p42 = { x: centerX - bottomWidth / 2, y: layerHeight };
  return { points: [p1, p22, p32, p42], topWidth, bottomWidth };
}
registerStructure("sequence-funnel", {
  component: SequenceFunnel,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-horizontal-zigzag.js
var SequenceHorizontalZigzag = (props) => {
  const { Title: Title2, Item, data, gap = 30, cardPadding = 10, options } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const colorPrimary = getColorPrimary(options);
  const themeColors = getThemeColors({ colorPrimary }, options);
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const btnElements = [];
  const itemElements = [];
  const decoElements = [];
  const cardWidth = itemBounds.width + cardPadding * 2;
  const cardHeight = itemBounds.height + cardPadding * 2 + 30;
  const dotSize = 8;
  const dotGap = 6;
  const topMargin = Math.max(btnBounds.height + 20, 40);
  const levelOffset = 40;
  items3.forEach((item, index2) => {
    const isEven = index2 % 2 === 0;
    const cardX = index2 * (cardWidth + gap);
    let cardY;
    if (isEven) {
      if (index2 % 4 === 2) {
        cardY = topMargin;
      } else {
        cardY = topMargin + levelOffset;
      }
    } else {
      cardY = topMargin + levelOffset + 60;
    }
    const indexes = [index2];
    const itemColor = getPaletteColor2(options, indexes) || colorPrimary;
    if (isEven) {
      const backgroundColor = itemColor === colorPrimary ? themeColors.colorPrimaryBg || "#E8F3FF" : `${itemColor}20`;
      const cardBackground = jsx(Rect, { x: cardX, y: cardY, width: cardWidth, height: cardHeight, fill: backgroundColor, rx: 20, ry: 20 });
      decoElements.push(cardBackground);
    }
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: cardX + cardPadding, y: cardY + cardPadding, positionH: "center", positionV: "normal" }));
    const totalDotsWidth = items3.length * dotSize + (items3.length - 1) * dotGap;
    const dotsStartX = cardX + (cardWidth - totalDotsWidth) / 2;
    const dotsY = cardY + itemBounds.height + 20;
    for (let i4 = 0; i4 < items3.length; i4++) {
      const dotX = dotsStartX + i4 * (dotSize + dotGap);
      const isCurrent = i4 === index2;
      decoElements.push(jsx(Ellipse, { x: dotX, y: dotsY, width: dotSize, height: dotSize, fill: isCurrent ? itemColor : "transparent", stroke: itemColor, strokeWidth: 2 }));
    }
    btnElements.push(jsx(BtnRemove, { indexes, x: cardX + (cardWidth - btnBounds.width) / 2, y: cardY + cardHeight + 10 }));
    if (index2 === 0) {
      btnElements.push(jsx(BtnAdd, { indexes, x: cardX + (cardWidth - btnBounds.width) / 2, y: cardY - btnBounds.height - 10 }));
    } else {
      btnElements.push(jsx(BtnAdd, { indexes, x: cardX - gap / 2 - btnBounds.width / 2, y: topMargin - btnBounds.height - 10 }));
    }
  });
  if (items3.length > 0) {
    const pathSegments = [];
    const radius = 35;
    const padding = gap / 2;
    const circleRadius = 6;
    const firstCardY = topMargin + levelOffset;
    const startX = 0 - padding;
    const startY = firstCardY + cardHeight / 2;
    pathSegments.push(`M ${startX} ${startY - circleRadius}`);
    items3.forEach((_2, index2) => {
      const isEven = index2 % 2 === 0;
      const cardX = index2 * (cardWidth + gap);
      let cardY;
      if (isEven) {
        if (index2 % 4 === 2) {
          cardY = topMargin;
        } else {
          cardY = topMargin + levelOffset;
        }
      } else {
        cardY = topMargin + levelOffset + 60;
      }
      const left = cardX - padding;
      const right = cardX + cardWidth + padding;
      const top = cardY - padding;
      const bottom = cardY + cardHeight + padding;
      const middleY = cardY + cardHeight / 2;
      if (isEven) {
        pathSegments.push(`L ${left} ${top + radius}`);
        pathSegments.push(`Q ${left} ${top} ${left + radius} ${top}`);
        pathSegments.push(`L ${right - radius} ${top}`);
        pathSegments.push(`Q ${right} ${top} ${right} ${top + radius}`);
        pathSegments.push(`L ${right} ${middleY - circleRadius}`);
      } else {
        pathSegments.push(`L ${left} ${middleY}`);
        pathSegments.push(`L ${left} ${bottom - radius}`);
        pathSegments.push(`Q ${left} ${bottom} ${left + radius} ${bottom}`);
        pathSegments.push(`L ${right - radius} ${bottom}`);
        pathSegments.push(`Q ${right} ${bottom} ${right} ${bottom - radius}`);
        pathSegments.push(`L ${right} ${middleY + circleRadius}`);
      }
    });
    const lastIndex = items3.length - 1;
    const lastIsEven = lastIndex % 2 === 0;
    const lastCardX = lastIndex * (cardWidth + gap);
    let lastCardY;
    if (lastIsEven) {
      if (lastIndex % 4 === 2) {
        lastCardY = topMargin;
      } else {
        lastCardY = topMargin + levelOffset;
      }
    } else {
      lastCardY = topMargin + levelOffset + 60;
    }
    const endX = lastCardX + cardWidth + padding;
    const endY = lastCardY + cardHeight / 2;
    const pathD = pathSegments.join(" ");
    const linearGradientId = "gradient-zigzag-path";
    const firstColor = getPaletteColor2(options, [0]) || colorPrimary;
    const lastColor = getPaletteColor2(options, [items3.length - 1]) || colorPrimary;
    const gradientStops = items3.map((_2, index2) => {
      const offset = index2 / (items3.length - 1) * 100;
      const color3 = getPaletteColor2(options, [index2]) || colorPrimary;
      return jsx("stop", { offset: `${offset}%`, stopColor: color3 });
    });
    decoElements.unshift(jsxs(Fragment, { children: [jsx(Defs, { children: jsx("linearGradient", { id: linearGradientId, x1: startX, y1: startY, x2: endX, y2: endY, gradientUnits: "userSpaceOnUse", children: gradientStops }) }), jsx(Path, { d: pathD, stroke: `url(#${linearGradientId})`, strokeWidth: 2, fill: "none", width: (items3.length - 1) * (cardWidth + gap) + cardWidth + padding * 2, height: cardHeight + 120 })] }));
    decoElements.unshift(jsx(Ellipse, { x: startX - circleRadius, y: startY - circleRadius, width: circleRadius * 2, height: circleRadius * 2, fill: "transparent", stroke: firstColor, strokeWidth: 2 }));
    decoElements.unshift(jsx(Ellipse, { x: endX - circleRadius, y: endY - circleRadius, width: circleRadius * 2, height: circleRadius * 2, fill: "transparent", stroke: lastColor, strokeWidth: 2 }));
  }
  if (items3.length > 0) {
    const lastIndex = items3.length - 1;
    const lastCardX = lastIndex * (cardWidth + gap);
    btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: lastCardX + cardWidth + (gap - btnBounds.width) / 2, y: topMargin - btnBounds.height - 10 }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(ShapesGroup, { children: decoElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-horizontal-zigzag", {
  component: SequenceHorizontalZigzag,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-mountain.js
function Mountain(props) {
  const { width, height, colorPrimary } = props;
  const leftBottomColor = colorPrimary;
  const rightBottomColor = tinycolor.mix(colorPrimary, "#000", 20).toHexString();
  const leftTopColor = tinycolor.mix(colorPrimary, "#fff", 50).toHexString();
  const rightTopColor = tinycolor.mix(leftTopColor, "#000", 15).toHexString();
  function calculateMountainPoints(width2, height2) {
    const snowLine = 0.35;
    const ripples = [
      { position: 0.25, offset: 0.1 },
      // 
      { position: 0.45, offset: -0.02 },
      // 
      { position: 0.6, offset: 0.04 },
      // 
      { position: 0.75, offset: -0.1 }
      // 
    ];
    const leftBottom2 = { x: 0, y: height2 };
    const rightBottom2 = { x: width2, y: height2 };
    const peak2 = { x: width2 / 2, y: 0 };
    const centerBottom2 = { x: width2 / 2, y: height2 };
    const snowLineY = height2 * snowLine;
    const t2 = snowLineY / height2;
    const leftEdge2 = {
      x: peak2.x * (1 - t2) + leftBottom2.x * t2,
      y: snowLineY
    };
    const centerSnow2 = {
      x: peak2.x,
      y: snowLineY
    };
    const rightEdge2 = {
      x: peak2.x * (1 - t2) + rightBottom2.x * t2,
      y: snowLineY
    };
    const allRipples = ripples.map((ripple) => {
      const baseX = leftEdge2.x + (rightEdge2.x - leftEdge2.x) * ripple.position;
      const baseY = snowLineY;
      const offsetY = height2 * ripple.offset;
      return {
        x: baseX,
        y: baseY + offsetY,
        position: ripple.position,
        offset: ripple.offset
      };
    });
    allRipples.sort((a3, b2) => a3.position - b2.position);
    const leftRipples2 = allRipples.filter((p7) => p7.x <= centerSnow2.x);
    const rightRipples2 = allRipples.filter((p7) => p7.x > centerSnow2.x);
    return {
      // 
      leftBottom: leftBottom2,
      rightBottom: rightBottom2,
      peak: peak2,
      centerBottom: centerBottom2,
      // 
      snowLineY,
      leftEdge: leftEdge2,
      centerSnow: centerSnow2,
      rightEdge: rightEdge2,
      // 
      leftRipples: leftRipples2,
      rightRipples: rightRipples2
    };
  }
  const { leftRipples, rightRipples, leftBottom, rightBottom, peak, centerBottom, leftEdge, centerSnow, rightEdge } = calculateMountainPoints(width, height);
  const leftTopShape = [peak, leftEdge, ...leftRipples, centerSnow];
  const rightTopShape = [peak, centerSnow, ...rightRipples, rightEdge];
  const leftBottomShape = [
    leftEdge,
    ...leftRipples,
    centerSnow,
    centerBottom,
    leftBottom
  ];
  const rightBottomShape = [
    centerSnow,
    ...rightRipples,
    rightEdge,
    rightBottom,
    centerBottom
  ];
  const toPointsString = (points) => points.map((p7) => `${p7.x},${p7.y}`).join(" ");
  return jsxs(ShapesGroup, Object.assign({}, props, { children: [jsx("polygon", { points: toPointsString(leftTopShape), fill: leftTopColor }), jsx("polygon", { points: toPointsString(rightTopShape), fill: rightTopColor }), jsx("polygon", { points: toPointsString(leftBottomShape), fill: leftBottomColor }), jsx("polygon", { points: toPointsString(rightBottomShape), fill: rightBottomColor })] }));
}
function Tree(size) {
  const heightMap = {
    tiny: 27,
    small: 48,
    medium: 54,
    large: 72
  };
  const height = heightMap[size] || 54;
  const leftLeafColor = "#17C76F";
  const rightLeafColor = "#139B57";
  const trunkColor = "#737373";
  const leafHeight = height * 0.7;
  const trunkHeight = height - leafHeight;
  const leafWidth = leafHeight * 0.8;
  const width = leafWidth;
  const trunkWidth = width / 6;
  const trunkX = (width - trunkWidth) / 2;
  const trunkY = leafHeight;
  return jsxs(ShapesGroup, { width, height, children: [jsx("ellipse", { cx: leafWidth / 2, cy: leafHeight / 2, rx: leafWidth / 2, ry: leafHeight / 2, fill: leftLeafColor, clipPath: `inset(0 50% 0 0)` }), jsx("ellipse", { cx: leafWidth / 2, cy: leafHeight / 2, rx: leafWidth / 2, ry: leafHeight / 2, fill: rightLeafColor, clipPath: `inset(0 0 0 50%)` }), jsx("rect", { x: trunkX, y: trunkY, width: trunkWidth, height: trunkHeight, fill: trunkColor })] });
}
function Sun(props) {
  const { width, height } = props;
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(width, height) * 0.28;
  const rayWidth = Math.min(width, height) * 0.14;
  const rayHeight = Math.min(width, height) * 0.07;
  const rayX = 0;
  const rayY = centerY - rayHeight / 2;
  const cornerRadius = rayHeight * 0.4;
  const rayCount = 8;
  const rays = Array.from({ length: rayCount }, (_2, i4) => {
    const angle = 360 / rayCount * i4;
    return jsx("rect", { x: rayX, y: rayY, width: rayWidth, height: rayHeight, rx: cornerRadius, ry: cornerRadius, fill: "#FFCB0E", transform: `rotate(${angle}, ${centerX}, ${centerY})` });
  });
  return jsxs(ShapesGroup, Object.assign({}, props, { children: [jsx("circle", { cx: centerX, cy: centerY, r: radius, fill: "#FFCB0E" }), ...rays] }));
}
function Cloud(props) {
  if (props.type === "single") {
    return jsx(ShapesGroup, Object.assign({}, props, { width: 54, height: 36, children: jsx("path", { d: "M10.2635 13.3806C11.0019 9.99045 12.7381 6.91002 15.2405 4.55004C17.743 2.19007 20.8929 0.662716 24.2701 0.171643C27.6473 -0.31943 31.0914 0.24912 34.143 1.80148C37.1946 3.35385 39.7087 5.81625 41.3501 8.86031C44.8835 9.0468 48.1994 10.6544 50.5684 13.3294C52.9373 16.0044 54.1653 19.5277 53.9821 23.1242C53.7989 26.7207 52.2195 30.0959 49.5914 32.5071C46.9634 34.9184 43.5019 36.1683 39.9684 35.9818H11.1517C4.93436 35.9818 0 30.9593 0 24.6309C0.0598447 21.8016 1.13799 19.093 3.02989 17.0192C4.9218 14.9454 7.49584 13.6506 10.2635 13.3806Z", fill: "#70CAF8" }) }));
  }
  return jsxs(ShapesGroup, Object.assign({}, props, { width: 73, height: 40, children: [jsx("path", { d: "M61.6461 14.9716C60.8681 11.1875 58.9581 7.73823 56.1763 5.09315C53.3944 2.44806 49.8758 0.735682 46.0992 0.189041C42.3226 -0.357601 38.4714 0.288046 35.0699 2.03812C31.6683 3.7882 28.8815 6.5577 27.0889 9.96971C23.161 10.1687 19.4719 11.9405 16.8333 14.8953C14.1947 17.8502 12.8227 21.746 13.0191 25.7258C13.2155 29.7055 14.9642 33.4433 17.8806 36.1167C20.7969 38.7901 24.642 40.1802 28.5699 39.9812H60.6588C67.5702 39.9812 73.0006 34.4791 73.0006 27.4764C73.0006 20.9739 67.8664 15.4718 61.6461 14.9716Z", fill: "#70CAF8" }), jsx("path", { d: "M21.9691 6.47136e-09C25.9369 6.47136e-09 29.5264 1.62125 32.0003 4.21094C30.0604 5.7917 28.4423 7.75571 27.2581 10C23.3149 10.1989 19.6111 11.9702 16.9622 14.9238C14.3136 17.8774 12.936 21.772 13.1331 25.75C13.2057 27.2131 13.4902 28.6432 13.9652 30H10.7689C7.96116 29.8907 5.29664 28.7203 3.30402 26.7217C1.31144 24.7231 0.135825 22.0419 0.0110544 19.21C-0.113702 16.378 0.821178 13.6017 2.63019 11.4326C4.43921 9.26356 6.99065 7.8602 9.77766 7.5C11.9582 3.00012 16.6168 8.76701e-05 21.9691 6.47136e-09Z", fill: "#5BA2C6" })] }));
}
var SequenceMountain = (props) => {
  const { Title: Title2, Item, data, gap = 20, minHeight = 100, maxHeight = 200, minWidth = 260, maxWidth = 300, options } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const itemElements = [];
  const btnElements = [];
  const decorElements = [];
  const labelElements = [];
  const n4 = items3.length;
  const themeColors = getThemeColors(options.themeConfig);
  const sunSize = 60;
  const cloudSizes = {
    single: { width: 54, height: 36 },
    double: { width: 73, height: 40 }
  };
  const mountainWidths = [];
  const mountainXPositions = [];
  let totalWidth = 0;
  let nextMountainX = 0;
  items3.forEach((datum2, index2) => {
    const progress = n4 > 1 ? index2 / (n4 - 1) : 0;
    const mountainHeight = minHeight + (maxHeight - minHeight) * progress;
    const calculatedWidth = mountainHeight * 1.6;
    const mountainWidth = Math.max(minWidth, Math.min(maxWidth, calculatedWidth));
    mountainWidths.push(mountainWidth);
    const mountainX = nextMountainX;
    mountainXPositions.push(mountainX);
    nextMountainX += mountainWidth / 2;
    if (index2 === n4 - 1) {
      totalWidth = mountainX + mountainWidth;
    }
  });
  const firstMountainLeft = mountainXPositions[0];
  const lastMountainRight = mountainXPositions[n4 - 1] + mountainWidths[n4 - 1];
  const itemAreaWidth = lastMountainRight - firstMountainLeft;
  const itemWidth = n4 > 1 ? (itemAreaWidth - gap * (n4 - 1)) / n4 : itemAreaWidth;
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], width: itemWidth }));
  const labelHeight = 32;
  const labelYPos = maxHeight + gap;
  const itemYPos = labelYPos + labelHeight + 10;
  items3.forEach((datum2, index2) => {
    const indexes = [index2];
    const mountainHeight = minHeight + (maxHeight - minHeight) * (n4 > 1 ? index2 / (n4 - 1) : 0);
    const mountainWidth = mountainWidths[index2];
    const mountainX = mountainXPositions[index2];
    const mountainY = maxHeight - mountainHeight;
    const color3 = getPaletteColor2(options, [index2]) || themeColors.colorPrimary;
    decorElements.push(jsx(Mountain, { colorPrimary: color3, x: mountainX, y: mountainY, width: mountainWidth, height: mountainHeight }));
    const itemX = firstMountainLeft + index2 * (itemWidth + gap);
    labelElements.push(jsx(Text, { x: itemX, y: labelYPos, width: itemWidth, height: labelHeight, fontSize: 16, fontWeight: "bold", alignHorizontal: "center", alignVertical: "middle", fill: color3, backgroundColor: color3, backgroundOpacity: 0.5, backgroundRadius: 4, children: String(index2 + 1).padStart(2, "0") }));
    itemElements.push(jsx(Item, { indexes, datum: datum2, data, x: itemX, y: itemYPos, width: itemWidth }));
  });
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const btnY = itemYPos + itemBounds.height + 10;
  items3.forEach((datum2, index2) => {
    const indexes = [index2];
    const itemX = firstMountainLeft + index2 * (itemWidth + gap);
    btnElements.push(jsx(BtnRemove, { indexes, x: itemX + itemWidth / 2 - btnBounds.width / 2, y: btnY }));
    if (index2 < items3.length - 1) {
      btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: itemX + itemWidth + gap / 2 - btnBounds.width / 2, y: btnY }));
    }
  });
  if (n4 > 0) {
    const firstItemX = firstMountainLeft;
    btnElements.unshift(jsx(BtnAdd, { indexes: [0], x: firstItemX - gap / 2 - btnBounds.width / 2, y: btnY }));
    const lastItemX = firstMountainLeft + (n4 - 1) * (itemWidth + gap);
    btnElements.push(jsx(BtnAdd, { indexes: [n4], x: lastItemX + itemWidth + gap / 2 - btnBounds.width / 2, y: btnY }));
    decorElements.push(jsx(Sun, { x: totalWidth - sunSize - 20, y: -35, width: sunSize, height: sunSize }));
    const treeSizes = [
      "tiny",
      "small",
      "medium",
      "large"
    ];
    const treeHeightMap = { tiny: 27, small: 48, medium: 54, large: 72 };
    const treeWidthMap = {
      tiny: 14.85,
      small: 26.4,
      medium: 29.7,
      large: 39.6
    };
    const placedTrees = [];
    const isTreeOverlapping = (treeX, treeWidth, padding = 5) => {
      return placedTrees.some((placed) => {
        return !(treeX + treeWidth + padding < placed.x || treeX > placed.x + placed.width + padding);
      });
    };
    items3.forEach((datum2, index2) => {
      const mountainX = mountainXPositions[index2];
      const mountainWidth = mountainWidths[index2];
      const isLastMountain = index2 === n4 - 1;
      const treesOnThisMountain = isLastMountain ? 3 : index2 === 0 ? 1 : 2;
      for (let t2 = 0; t2 < treesOnThisMountain; t2++) {
        const seed = index2 * 100 + t2 * 37;
        const sizeIndex = seed * 17 % treeSizes.length;
        const treeSize = treeSizes[sizeIndex];
        const treeHeight = treeHeightMap[treeSize];
        const treeWidth = treeWidthMap[treeSize];
        let attempts = 0;
        let treeX = 0;
        let validPosition = false;
        while (attempts < 20 && !validPosition) {
          const xOffset = (seed * 13 + attempts * 19) % 100 / 100;
          const minX = mountainX + mountainWidth * 0.15;
          const maxX = mountainX + mountainWidth * 0.85 - treeWidth;
          treeX = minX + (maxX - minX) * xOffset;
          if (!isTreeOverlapping(treeX, treeWidth)) {
            validPosition = true;
          }
          attempts++;
        }
        if (validPosition) {
          placedTrees.push({ x: treeX, width: treeWidth });
          const treeY = maxHeight - treeHeight;
          decorElements.push(jsx(Group, { x: treeX, y: treeY, children: Tree(treeSize) }));
        }
      }
    });
    const cloudCount = Math.max(1, Math.floor(n4 / 1.5));
    for (let i4 = 0; i4 < cloudCount; i4++) {
      const seed = i4 * 11 + n4 * 5 + 1;
      const cloudType = seed % 2 === 0 ? "single" : "double";
      const cloudSize = cloudSizes[cloudType];
      const cloudRange = lastMountainRight - firstMountainLeft - cloudSize.width;
      const xPos = firstMountainLeft + seed * 7 % 100 / 100 * cloudRange;
      const yPos = seed * 13 % 40;
      decorElements.push(jsx(Cloud, { type: cloudType, x: xPos, y: yPos, width: cloudSize.width, height: cloudSize.height }));
    }
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(Group, { children: decorElements }), jsx(Group, { children: labelElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-mountain", {
  component: SequenceMountain,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-pyramid.js
var SequencePyramid = (props) => {
  const { Title: Title2, Item, data, gap = 10, width = 700, pyramidWidth, itemHeight = 60, options } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  if (items3.length === 0) {
    return jsx(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: titleContent });
  }
  const radius = 5;
  const themeColors = getThemeColors(options.themeConfig);
  const iconSize = 30;
  const itemElements = [];
  const pyramidElements = [];
  const backgroundElements = [];
  const iconElements = [];
  const actualPyramidWidth = pyramidWidth !== null && pyramidWidth !== void 0 ? pyramidWidth : width * 0.6;
  const itemAreaWidth = width - actualPyramidWidth;
  const pyramidLayerHeight = itemHeight * 1.2;
  const totalHeight = items3.length * pyramidLayerHeight + (items3.length - 1) * gap;
  items3.forEach((item, index2) => {
    const indexes = [index2];
    const isFirst = index2 === 0;
    const color3 = getPaletteColor2(options, [index2]) || themeColors.colorPrimary;
    const { points, topWidth, bottomWidth } = calculateTriangleSegment(actualPyramidWidth, pyramidLayerHeight, gap, items3.length, index2);
    const rounded = roundPolygon(points, radius);
    const segments = getSegments(rounded, "AMOUNT", 10);
    const pyramidCenterX = actualPyramidWidth / 2;
    const pyramidY = index2 * (pyramidLayerHeight + gap);
    const backgroundYOffset = (pyramidLayerHeight - itemHeight) / 2;
    const backgroundY = pyramidY + backgroundYOffset;
    const rightTopX = pyramidCenterX + topWidth / 2;
    const rightBottomX = pyramidCenterX + bottomWidth / 2;
    const overlapWidth = radius;
    const backgroundX = rightTopX - overlapWidth;
    const backgroundWidth = itemAreaWidth + radius;
    const backgroundHeight = itemHeight;
    const backgroundRightEdge = backgroundX + backgroundWidth;
    const iconX = pyramidCenterX - iconSize / 2;
    const iconY = pyramidY + pyramidLayerHeight / 2 - iconSize / 2 + (isFirst ? 8 : 0);
    const itemX = rightBottomX;
    const itemWidth = backgroundRightEdge - rightBottomX;
    const itemY = backgroundY;
    backgroundElements.push(jsx(Rect, { x: backgroundX, y: backgroundY, width: backgroundWidth, height: backgroundHeight, ry: "10", fill: themeColors.colorPrimaryBg, "data-element-type": "shape" }));
    const pyramidColorId = `${color3}-pyramid-${index2}`;
    pyramidElements.push(jsx(Defs, { children: jsxs("linearGradient", { id: pyramidColorId, x1: "0%", y1: "0%", x2: "0%", y2: "100%", children: [jsx("stop", { offset: "0", "stop-color": color3 }), jsx("stop", { offset: "100%", "stop-color": tinycolor.mix(color3, "#fff", 40).toHexString() })] }) }), jsx(Polygon, { points: segments, fill: `url(#${pyramidColorId})`, y: pyramidY, "data-element-type": "shape" }));
    iconElements.push(jsx(ItemIcon, { indexes, x: iconX, y: iconY, size: iconSize, fill: "#fff" }));
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, width: itemWidth, height: itemHeight, positionV: "middle" }));
  });
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { width, height: totalHeight, children: [jsx(Group, { children: backgroundElements }), jsx(Group, { children: pyramidElements }), jsx(Group, { children: iconElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, {})] })] });
};
function calculateTriangleSegment(width, height, gap, counts, index2) {
  const centerX = width / 2;
  const triangleHeight = counts * height + (counts - 1) * gap;
  const rectTop = index2 * (height + gap);
  const rectBottom = rectTop + height;
  const topWidth = rectTop / triangleHeight * width;
  const bottomWidth = rectBottom / triangleHeight * width;
  let points;
  if (index2 === 0) {
    const p1 = { x: centerX, y: 0 };
    const p22 = { x: centerX + bottomWidth / 2, y: height };
    const p32 = { x: centerX - bottomWidth / 2, y: height };
    points = [p1, p22, p32];
  } else {
    const p1 = { x: centerX + topWidth / 2, y: 0 };
    const p22 = { x: centerX + bottomWidth / 2, y: height };
    const p32 = { x: centerX - bottomWidth / 2, y: height };
    const p42 = { x: centerX - topWidth / 2, y: 0 };
    points = [p1, p22, p32, p42];
  }
  return { points, topWidth, bottomWidth };
}
registerStructure("sequence-pyramid", {
  component: SequencePyramid,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-roadmap-vertical.js
var CONFIG = {
  iconSize: 50,
  roadWidth: 24,
  outerRadius: 60,
  rowWidth: 400,
  spacing: 30,
  colorDefault: "#666666"
};
var moveTo = (x6, y6) => `M ${x6} ${y6}`;
var lineTo = (x6, y6) => `L ${x6} ${y6}`;
var arcTo = (r5, sweep, x6, y6) => `A ${r5} ${r5} 0 0 ${sweep} ${x6} ${y6}`;
var getYPositions = (i4, { roadWidth, innerRadius, outerRadius }) => {
  const y1 = (roadWidth + innerRadius * 2) * i4;
  return {
    y1,
    y2: y1 + roadWidth,
    y3: y1 + roadWidth + innerRadius,
    y4: y1 + roadWidth + innerRadius * 2,
    y5: y1 + outerRadius * 2
  };
};
function renderItemRow({ i: i4, direction, x: x6, y: y6, color: color3, data, itemBounds, item, Item, flipped }) {
  const { iconSize } = CONFIG;
  const isLeft = direction === "left";
  const iconX = isLeft ? x6.x4 - iconSize / 2 : x6.x3 - iconSize / 2;
  const iconY = y6.y3 - iconSize / 2;
  const itemX = isLeft ? x6.x6 + CONFIG.spacing : x6.x1 - CONFIG.spacing - itemBounds.width;
  const itemY = y6.y3 - itemBounds.height / 2;
  const positionH = isLeft ? flipped ? "flipped" : "normal" : flipped ? "normal" : "flipped";
  return {
    icon: jsx(ItemIconCircle, { indexes: [i4], x: iconX, y: iconY, size: iconSize, fill: color3 }),
    label: jsx(Text, { width: 40, x: isLeft ? iconX - 50 : iconX + iconSize + 10, y: iconY + iconSize / 2 - 15, fontSize: 30, fill: color3, alignHorizontal: isLeft ? "right" : "left", children: String(i4 + 1).padStart(2, "0") }),
    item: jsx(Item, { indexes: [i4], data, datum: item, x: itemX, y: itemY, positionH })
  };
}
function buildDecorations({ direction, x: x6, y: y6, color: color3, elements }) {
  const isLeft = direction === "left";
  elements.push(jsx(Triangle, { x: isLeft ? x6.x6 + 10 : x6.x1 - 20, y: y6.y3 - 5, width: 10, height: 8, rotation: isLeft ? 90 : -90, colorPrimary: color3, "data-element-type": "shape" }));
}
var SequenceRoadmapVertical = (props) => {
  const { Title: Title2, Item, data, spacing = CONFIG.spacing, options, flipped = false } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const { roadWidth, outerRadius, rowWidth, colorDefault } = CONFIG;
  const halfRoadWidth = roadWidth / 2;
  const innerRadius = outerRadius - roadWidth;
  const totalWidth = (itemBounds.width + spacing) * 2 + rowWidth;
  const x1 = itemBounds.width + spacing;
  const x32 = x1 + outerRadius;
  const x42 = x1 + rowWidth - outerRadius;
  const x52 = x42 + innerRadius;
  const x6 = x52 + roadWidth;
  const xMid = x1 + rowWidth / 2;
  const midPath = [];
  const positivePath = [];
  const negativePath = [];
  const itemIcons = [];
  const seriesNumber = [];
  const itemElements = [];
  const decorationElements = [];
  for (let i4 = 0; i4 < items3.length; i4++) {
    const color3 = getPaletteColor2(options, [i4]) || colorDefault;
    const direction = i4 % 2 === 0 ? "right" : "left";
    const isFirst = i4 === 0;
    const isLast = i4 === items3.length - 1;
    const y6 = getYPositions(i4, { roadWidth, innerRadius, outerRadius });
    if (direction === "right") {
      const p1 = isFirst ? [x6, y6.y1] : [x42, y6.y1];
      const p22 = [x32, y6.y1];
      const p32 = [x32, y6.y5];
      const p42 = isFirst ? [x6, y6.y2] : [x42, y6.y2];
      const p52 = [x32, y6.y2];
      midPath.push(isFirst ? moveTo(x6, y6.y1 + halfRoadWidth) : lineTo(x42, y6.y1 + halfRoadWidth), lineTo(x32, y6.y1 + halfRoadWidth), arcTo(outerRadius - halfRoadWidth, 0, x32, y6.y4 + halfRoadWidth));
      positivePath.push(isFirst ? moveTo(...p1) : lineTo(...p1), lineTo(...p22), arcTo(outerRadius, 0, ...p32));
      negativePath.push(lineTo(...p42), lineTo(...p52), arcTo(innerRadius, 1, ...p52));
      if (isLast) {
        const s3 = roadWidth / 2;
        positivePath.push(lineTo(xMid, y6.y5), lineTo(xMid, y6.y5 + s3), lineTo(xMid + roadWidth, y6.y5 - s3), lineTo(xMid, y6.y4 - s3), lineTo(xMid, y6.y4), lineTo(x32, y6.y4));
        midPath.push(lineTo(xMid, y6.y4 + halfRoadWidth));
      }
    } else {
      const p1 = [x32, y6.y2];
      const p22 = [x42, y6.y2];
      const p32 = [x42, y6.y4];
      const p42 = [x32, y6.y1];
      const p52 = [x42, y6.y1];
      midPath.push(lineTo(x42, y6.y1 + halfRoadWidth), arcTo(outerRadius - halfRoadWidth, 1, x42, y6.y4 + halfRoadWidth));
      positivePath.push(lineTo(...p1), lineTo(...p22), arcTo(innerRadius, 1, ...p32));
      negativePath.push(lineTo(...p42), lineTo(...p52), arcTo(outerRadius, 0, ...p52));
      if (isLast) {
        const s3 = roadWidth / 2;
        positivePath.push(lineTo(xMid, y6.y4), lineTo(xMid, y6.y4 - s3), lineTo(xMid - roadWidth, y6.y4 + s3), lineTo(xMid, y6.y5 + s3), lineTo(xMid, y6.y5), lineTo(x42, y6.y5));
        midPath.push(lineTo(xMid, y6.y4 + halfRoadWidth));
      }
    }
    buildDecorations({
      direction,
      x: { x1, x4: x42, x6 },
      y: y6,
      color: color3,
      elements: decorationElements
    });
    const { icon, label, item } = renderItemRow({
      i: i4,
      direction,
      x: { x1, x3: x32, x4: x42, x6 },
      y: y6,
      color: color3,
      data,
      itemBounds,
      item: items3[i4],
      Item,
      flipped
    });
    itemIcons.push(icon);
    seriesNumber.push(label);
    itemElements.push(item);
  }
  const pathArr = [...positivePath, ...negativePath.reverse(), "Z"];
  const roadmapHeight = items3.length * (roadWidth + innerRadius * 2) + roadWidth * 1.5;
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { width: totalWidth, height: itemBounds.height <= outerRadius * 2 ? roadmapHeight : roadmapHeight + itemBounds.height - outerRadius * 2, children: [jsx(Path, { width: rowWidth, height: roadmapHeight, d: pathArr.join(" "), fill: colorDefault, stroke: colorDefault, strokeWidth: "4", strokeLinecap: "round", strokeLinejoin: "round", "data-element-type": "shape" }), jsx(Path, { d: midPath.join(" "), stroke: "white", fill: "none", strokeWidth: "3", strokeDasharray: "8 8", strokeLinecap: "round", strokeLinejoin: "round", "data-element-type": "shape" }), jsxs(Fragment, { children: [itemIcons, seriesNumber, itemElements, decorationElements] })] })] });
};
registerStructure("sequence-roadmap-vertical", {
  component: SequenceRoadmapVertical,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-snake-steps.js
var SequenceSnakeSteps = (props) => {
  const { Title: Title2, Item, data, gap = 40, itemsPerRow = 3, rowGap = 80, options } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const colorPrimary = getColorPrimary(options);
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const btnElements = [];
  const itemElements = [];
  const decorElements = [];
  const arrowWidth = 25;
  const arrowHeight = 25;
  items3.forEach((item, index2) => {
    const rowIndex = Math.floor(index2 / itemsPerRow);
    const colIndex = index2 % itemsPerRow;
    const isReversedRow = rowIndex % 2 === 1;
    const actualColIndex = isReversedRow ? itemsPerRow - 1 - colIndex : colIndex;
    const itemX = actualColIndex * (itemBounds.width + gap);
    const itemY = rowIndex * (itemBounds.height + rowGap);
    const indexes = [index2];
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, positionH: "center" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: itemY + itemBounds.height + 10 }));
    if (index2 === 0) {
      btnElements.push(jsx(BtnAdd, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: itemY - btnBounds.height - 10 }));
    }
    if (index2 < items3.length - 1) {
      const nextRowIndex = Math.floor((index2 + 1) / itemsPerRow);
      const nextColIndex = (index2 + 1) % itemsPerRow;
      const isNextReversedRow = nextRowIndex % 2 === 1;
      const nextActualColIndex = isNextReversedRow ? itemsPerRow - 1 - nextColIndex : nextColIndex;
      const nextItemX = nextActualColIndex * (itemBounds.width + gap);
      const isSameRow = rowIndex === nextRowIndex;
      if (isSameRow) {
        const isRightToLeft = isReversedRow;
        const arrowX = isRightToLeft ? nextItemX + itemBounds.width + (gap - arrowWidth) / 2 : itemX + itemBounds.width + (gap - arrowWidth) / 2;
        const arrowY = itemY + itemBounds.height / 2 - arrowHeight / 2;
        decorElements.push(jsx(SimpleArrow, { x: arrowX, y: arrowY, width: arrowWidth, height: arrowHeight, colorPrimary, rotation: isRightToLeft ? 180 : 0 }));
        btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: arrowX + (arrowWidth - btnBounds.width) / 2, y: itemY - btnBounds.height - 10 }));
      } else {
        const turnArrowX = itemX + itemBounds.width / 2 - arrowWidth / 2;
        const turnArrowY = itemY + itemBounds.height + (rowGap - arrowHeight) / 2;
        decorElements.push(jsx(SimpleArrow, { x: turnArrowX, y: turnArrowY, width: arrowWidth, height: arrowHeight, colorPrimary, rotation: 90 }));
        btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: turnArrowX + (arrowWidth - btnBounds.width) / 2, y: turnArrowY + (arrowHeight - btnBounds.height) / 2 }));
      }
    }
  });
  if (items3.length > 0) {
    const lastIndex = items3.length - 1;
    const lastRowIndex = Math.floor(lastIndex / itemsPerRow);
    const lastColIndex = lastIndex % itemsPerRow;
    const isLastReversedRow = lastRowIndex % 2 === 1;
    const lastActualColIndex = isLastReversedRow ? itemsPerRow - 1 - lastColIndex : lastColIndex;
    const lastItemX = lastActualColIndex * (itemBounds.width + gap);
    const lastItemY = lastRowIndex * (itemBounds.height + rowGap);
    btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: lastItemX + (itemBounds.width - btnBounds.width) / 2, y: lastItemY + itemBounds.height + btnBounds.height + 20 }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(Group, { children: decorElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-snake-steps", {
  component: SequenceSnakeSteps,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-stairs-front.js
var SequenceStairsFront = (props) => {
  const { Title: Title2, Item, data, options, gap = 16, perspectiveFactor = 0.2, width = 720 } = props;
  const { title, desc, items: items3 = [] } = data;
  const TitleComponent = Title2;
  const titleContent = TitleComponent ? jsx(TitleComponent, { title, desc }) : null;
  if (items3.length === 0) {
    const btnAddElement = jsx(BtnAdd, { indexes: [0], x: 0, y: 0 });
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsx(Group, { children: jsx(BtnsGroup, { children: btnAddElement }) })] });
  }
  const colorPrimary = getColorPrimary(options);
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0] || {}, positionH: "center" }));
  const connectorGap = 12;
  const baseConnectorWidth = Math.min(width * 0.1, 100);
  const bottomStepWidth = Math.min(width * 0.45, Math.max(80, width - itemBounds.width - connectorGap - baseConnectorWidth));
  const baseDepth = Math.max(24, bottomStepWidth * perspectiveFactor * 0.35);
  const baseStepHeight = 56;
  const minStepHeight = baseStepHeight * 0.7;
  const heightStep = items3.length > 1 ? (baseStepHeight - minStepHeight) / (items3.length - 1) : 0;
  const topMargin = Math.max(btnBounds.height + baseDepth + 20, baseDepth + 28);
  const centerX = bottomStepWidth / 2;
  const itemX = bottomStepWidth + baseConnectorWidth + connectorGap;
  const stepHeights = items3.map((_2, index2) => baseStepHeight - heightStep * index2);
  const stepDepths = items3.map((_2, index2) => Math.max(baseDepth * (1 - index2 * 0.05), baseDepth * 0.7));
  const stepYs = [];
  const depthFromTop = [];
  const lastIndex = items3.length - 1;
  stepYs[lastIndex] = topMargin;
  depthFromTop[lastIndex] = 0;
  for (let i4 = lastIndex - 1; i4 >= 0; i4 -= 1) {
    depthFromTop[i4] = depthFromTop[i4 + 1] + stepDepths[i4] + gap;
    stepYs[i4] = stepYs[i4 + 1] + stepDepths[i4] + stepHeights[i4 + 1] + gap;
  }
  const totalDepthSpan = depthFromTop[0] || stepDepths[0] || baseDepth;
  const minStepWidth = bottomStepWidth * (0.55 + perspectiveFactor * 0.1);
  const widthShrink = bottomStepWidth - minStepWidth;
  const stepWidths = items3.map((_2, index2) => {
    const ratio = totalDepthSpan === 0 ? 1 : depthFromTop[index2] / totalDepthSpan;
    return minStepWidth + widthShrink * ratio;
  });
  const connectorWidths = stepWidths.map((stepWidth) => {
    const connectorStartX = centerX + stepWidth / 2;
    return Math.max(0, itemX - connectorGap - connectorStartX);
  });
  const stepElements = [];
  const itemElements = [];
  const btnElements = [];
  const connectorElements = [];
  const spineElements = [];
  const spineTop = 0;
  const spineBottom = (stepYs[0] || topMargin) + (stepHeights[0] || baseStepHeight);
  const arrowHeight = spineBottom - spineTop;
  const arrowHeadHeight = 35;
  const topStepWidth = stepWidths[lastIndex] || minStepWidth;
  const arrowTopWidth = topStepWidth * 0.8;
  const arrowNeckWidth = arrowTopWidth * 0.65;
  const arrowBottomWidth = (stepWidths[0] || bottomStepWidth) * 0.9;
  spineElements.push(jsx(Polygon, { points: [
    { x: centerX, y: spineTop },
    { x: centerX + arrowTopWidth / 2, y: spineTop + arrowHeadHeight },
    { x: centerX + arrowNeckWidth / 2, y: spineTop + arrowHeadHeight },
    { x: centerX + arrowBottomWidth / 2, y: spineBottom },
    { x: centerX - arrowBottomWidth / 2, y: spineBottom },
    { x: centerX - arrowNeckWidth / 2, y: spineTop + arrowHeadHeight },
    { x: centerX - arrowTopWidth / 2, y: spineTop + arrowHeadHeight }
  ], fill: "rgba(0,0,0,0.12)", width: arrowBottomWidth, height: arrowHeight, "data-element-type": "shape" }));
  let previousCenterY = stepYs[lastIndex] + stepHeights[lastIndex] / 2;
  items3.forEach((item, index2) => {
    const indexes = [index2];
    const stepWidth = stepWidths[index2];
    const stepDepth = stepDepths[index2];
    const stepX = centerX - stepWidth / 2;
    const stepHeight = stepHeights[index2];
    const stepY = stepYs[index2];
    const topY = stepY - stepDepth;
    const rectCenterY = stepY + stepHeight / 2;
    const stepColor = getPaletteColor2(options, indexes) || colorPrimary;
    stepElements.push(jsx(Rect, { x: stepX, y: stepY, width: stepWidth, height: stepHeight, fill: stepColor, "data-element-type": "shape" }), jsx(Polygon, { points: [
      { x: stepX, y: stepY },
      { x: stepX + stepWidth, y: stepY },
      { x: stepX + stepWidth - stepDepth / 2, y: topY },
      { x: stepX + stepDepth / 2, y: topY }
    ], fill: stepColor, opacity: "0.3", width: stepWidth, height: stepDepth, "data-element-type": "shape" }), jsx(Text, { x: stepX, y: stepY, width: stepWidth, height: stepHeight, fontSize: stepHeight / 2, fontWeight: "bold", alignHorizontal: "center", alignVertical: "middle", fill: "#ffffff", children: String(index2 + 1).padStart(2, "0") }));
    const connectorStartX = stepX + stepWidth;
    const connectorEndY = rectCenterY;
    const connectorWidth = connectorWidths[index2];
    const lineEndX = connectorStartX + connectorWidth;
    connectorElements.push(jsx(Path, { d: `M ${connectorStartX} ${connectorEndY} L ${lineEndX} ${connectorEndY}`, stroke: stepColor, strokeWidth: 2, fill: "none", width: connectorWidth, height: 2, "data-element-type": "shape" }), jsx(Path, { d: `M ${lineEndX} ${connectorEndY} L ${lineEndX} ${connectorEndY}`, stroke: stepColor, strokeWidth: 6, strokeLinecap: "round", width: 1, height: 1, "data-element-type": "shape" }));
    const itemY = rectCenterY - itemBounds.height / 2;
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, positionV: "middle" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: itemX + itemBounds.width + 10, y: itemY + itemBounds.height / 2 - btnBounds.height / 2 }));
    if (index2 === 0) {
      btnElements.push(jsx(BtnAdd, { indexes: [0], x: itemX + (itemBounds.width - btnBounds.width) / 2, y: itemY - btnBounds.height - 12 }));
    } else {
      btnElements.push(jsx(BtnAdd, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: (previousCenterY + rectCenterY) / 2 - btnBounds.height / 2 }));
    }
    previousCenterY = rectCenterY;
  });
  const lastCenterY = previousCenterY;
  const lastItemY = lastCenterY - itemBounds.height / 2;
  btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: itemX + (itemBounds.width - btnBounds.width) / 2, y: lastItemY + itemBounds.height + 12 }));
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(Group, { children: spineElements }), jsx(Group, { children: stepElements }), jsx(Group, { children: connectorElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-stairs-front", {
  component: SequenceStairsFront,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-steps.js
var SequenceSteps = (props) => {
  const { Title: Title2, Item, data, gap = 40, options } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const colorPrimary = getColorPrimary(options);
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const btnElements = [];
  const itemElements = [];
  const decorElements = [];
  const arrowWidth = 25;
  const arrowHeight = 25;
  const topMargin = Math.max(btnBounds.height + 20, 30);
  items3.forEach((item, index2) => {
    const itemX = index2 * (itemBounds.width + gap);
    const indexes = [index2];
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: topMargin, positionH: "center" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: topMargin + itemBounds.height + 10 }));
    if (index2 === 0) {
      btnElements.push(jsx(BtnAdd, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: topMargin - btnBounds.height - 10 }));
    } else {
      btnElements.push(jsx(BtnAdd, { indexes, x: itemX - gap / 2 - btnBounds.width / 2, y: topMargin - btnBounds.height - 10 }));
    }
    if (index2 < items3.length - 1) {
      const arrowX = itemX + itemBounds.width + (gap - arrowWidth) / 2;
      const arrowY = topMargin + itemBounds.height / 2 - arrowHeight / 2;
      decorElements.push(jsx(SimpleArrow, { x: arrowX, y: arrowY, width: arrowWidth, height: arrowHeight, colorPrimary }));
    }
  });
  if (items3.length > 0) {
    const lastItemX = (items3.length - 1) * (itemBounds.width + gap);
    btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: lastItemX + itemBounds.width + (gap - btnBounds.width) / 2, y: topMargin - btnBounds.height - 10 }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(Group, { children: decorElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-steps", {
  component: SequenceSteps,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-timeline.js
var SequenceTimeline = (props) => {
  const { Title: Title2, Item, data, gap = 10, options } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const colorPrimary = getColorPrimary(options);
  const palette2 = getPaletteColors(options);
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "normal" }));
  const btnElements = [];
  const itemElements = [];
  const decorElements = [];
  const stepLabelX = 10;
  const timelineX = stepLabelX + 70 + 10;
  const itemX = timelineX + 30;
  const nodeRadius = 6;
  if (items3.length > 1) {
    const firstNodeY = itemBounds.height / 2 + nodeRadius;
    const lastNodeY = (items3.length - 1) * (itemBounds.height + gap) + itemBounds.height / 2 - nodeRadius;
    const continuousLinePath = `M ${timelineX} ${firstNodeY} L ${timelineX} ${lastNodeY}`;
    const linearGradientId = "gradient-timeline-line";
    const totalHeight = lastNodeY - firstNodeY;
    const gradientStops = items3.map((_2, index2) => {
      const nodeY = index2 * (itemBounds.height + gap) + itemBounds.height / 2;
      const offset = (nodeY - firstNodeY) / totalHeight * 100;
      const color3 = getPaletteColor2(options, [index2]);
      return jsx("stop", { offset: `${offset}%`, stopColor: color3 || colorPrimary });
    });
    decorElements.push(jsxs(Fragment, { children: [jsx(Defs, { children: jsx("linearGradient", { id: linearGradientId, x1: timelineX, y1: firstNodeY, x2: timelineX, y2: lastNodeY, gradientUnits: "userSpaceOnUse", children: gradientStops }) }), jsx(Path, { d: continuousLinePath, stroke: `url(#${linearGradientId})`, strokeWidth: 2, width: 1, height: lastNodeY - firstNodeY })] }));
  }
  items3.forEach((item, index2) => {
    const itemY = index2 * (itemBounds.height + gap);
    const nodeY = itemY + itemBounds.height / 2;
    const indexes = [index2];
    decorElements.push(jsx(Text, { x: stepLabelX, y: nodeY, width: 70, fontSize: 18, fontWeight: "bold", alignHorizontal: "left", alignVertical: "middle", fill: palette2[index2 % palette2.length], children: `STEP ${index2 + 1}` }));
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, positionH: "normal" }));
    decorElements.push(jsx(Ellipse, { x: timelineX - nodeRadius, y: nodeY - nodeRadius, width: nodeRadius * 2, height: nodeRadius * 2, fill: palette2[index2 % palette2.length] }));
    btnElements.push(jsx(BtnRemove, { indexes, x: itemX - btnBounds.width - 10, y: itemY + (itemBounds.height - btnBounds.height) / 2 }));
    if (index2 === 0) {
      btnElements.push(jsx(BtnAdd, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: itemY - btnBounds.height - 10 }));
    } else {
      btnElements.push(jsx(BtnAdd, { indexes, x: itemX + (itemBounds.width - btnBounds.width) / 2, y: itemY - gap / 2 - btnBounds.height / 2 }));
    }
  });
  if (items3.length > 0) {
    const lastItemY = (items3.length - 1) * (itemBounds.height + gap);
    btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: itemX + (itemBounds.width - btnBounds.width) / 2, y: lastItemY + itemBounds.height + 10 }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [titleContent, jsxs(Group, { children: [jsx(ShapesGroup, { children: decorElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-timeline", {
  component: SequenceTimeline,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-zigzag-pucks-3d.js
var PUCK_WIDTH = 120;
var PUCK_HEIGHT = 108;
var ITEM_TO_PUCK_GAP = 30;
var PUCK_TOP_PATH = "M4.49144e-05 34.4898C4.49144e-05 37.8786 0.848973 41.152 2.43571 44.2444C4.23516 47.7642 6.98514 51.0472 10.517 54.0009C21.331 63.047 39.4615 68.9814 59.9991 68.9814C80.5385 68.9814 98.6672 63.047 109.483 54.0009C113.013 51.0472 115.765 47.7642 117.564 44.2444C119.149 41.152 120 37.8786 120 34.4898C120 15.4407 93.1364 0 59.9991 0C26.8635 0 4.49144e-05 15.4407 4.49144e-05 34.4898Z";
var PUCK_MIDDLE_PATH = "M4.49145e-05 34.4898V53.9991C4.49145e-05 57.3879 0.848973 60.6613 2.43571 63.7556C9.75425 78.0545 32.7562 88.4907 59.999 88.4907C87.2438 88.4907 110.246 78.0545 117.564 63.7556C119.149 60.6613 120 57.3879 120 53.9991V34.4898C120 37.8786 119.149 41.152 117.564 44.2444C115.765 47.7642 113.013 51.0472 109.483 54.0009C98.6672 63.047 80.5385 68.9814 59.999 68.9814C39.4615 68.9814 21.3309 63.047 10.5169 54.0009C6.98509 51.0472 4.23516 47.7642 2.43567 44.2444C0.848928 41.152 4.49145e-05 37.8786 4.49145e-05 34.4898Z";
var PUCK_BOTTOM_PATH = "M0 53.9991V73.5102C0 92.5593 26.8634 108 59.999 108C93.1363 108 120 92.5593 120 73.5102V53.9991C120 57.3879 119.149 60.6613 117.564 63.7556C110.246 78.0545 87.2438 88.4907 59.999 88.4907C32.7562 88.4907 9.75425 78.0545 2.43571 63.7556C0.848973 60.6613 0 57.3879 0 53.9991Z";
var DropShadowFilter2 = jsxs("filter", { id: "sequence-zigzag-pucks-3d-shadow-filter", x: "-50%", y: "-50%", width: "200%", height: "200%", filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB", children: [jsx("feOffset", { dx: "-7", dy: "7", in: "SourceAlpha", result: "offset" }), jsx("feGaussianBlur", { stdDeviation: "7.5", in: "offset", result: "blurred" }), jsx("feColorMatrix", { in: "blurred", type: "matrix", values: "0 0 0 0 0 \n              0 0 0 0 0 \n              0 0 0 0 0 \n              0 0 0 0.3 0", result: "shadow" }), jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "shadow" })] });
var SequenceZigzagPucks3d = (props) => {
  const { Title: Title2, Item, data, options, gap = 80 } = props;
  const puckWidth = PUCK_WIDTH;
  const puckHeight = PUCK_HEIGHT;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const colorPrimary = getColorPrimary(options);
  if (items3.length === 0) {
    const btnAddElement = jsx(BtnAdd, { indexes: [0], x: 0, y: 0 });
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [jsx(Defs, { children: DropShadowFilter2 }), titleContent, jsx(Group, { children: jsx(BtnsGroup, { children: btnAddElement }) })] });
  }
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0], positionH: "center" }));
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const btnElements = [];
  const itemElements = [];
  const puckElements = [];
  let minY = Infinity;
  let maxY = -Infinity;
  const itemHeight = itemBounds.height + ITEM_TO_PUCK_GAP + puckHeight;
  items3.forEach((item, index2) => {
    const indexes = [index2];
    const currentColor = getPaletteColor2(options, indexes);
    const isEven = index2 % 2 === 0;
    const puckX = index2 * (puckWidth + gap);
    const puckY = isEven ? 0 : itemBounds.height + ITEM_TO_PUCK_GAP;
    minY = Math.min(minY, puckY);
    const gradientId1 = `puck-gradient-middle-${index2}`;
    const gradientId2 = `puck-gradient-bottom-${index2}`;
    puckElements.push(jsxs(Group, { x: puckX, y: puckY, id: `puck-${index2}`, width: puckWidth, height: puckHeight, filter: "url(#sequence-zigzag-pucks-3d-shadow-filter)", children: [jsxs(Defs, { children: [jsxs("linearGradient", { id: gradientId1, x1: "115", y1: "55.9991", x2: "15.0002", y2: "55.9991", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { offset: "0", stopColor: currentColor || colorPrimary }), jsx("stop", { offset: "1", stopColor: currentColor || colorPrimary, stopOpacity: "0.6" })] }), jsxs("linearGradient", { id: gradientId2, x1: "115", y1: "72.1803", x2: "15.0002", y2: "72.1803", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { offset: "0", stopColor: "#F4F4FB" }), jsx("stop", { offset: "1", stopColor: "#8E8C90" })] })] }), jsxs(ShapesGroup, { width: PUCK_WIDTH, height: PUCK_HEIGHT, children: [jsx(Path, { d: PUCK_TOP_PATH, fill: currentColor || colorPrimary }), jsx(Path, { d: PUCK_MIDDLE_PATH, fill: `url(#${gradientId1})` }), jsx(Path, { d: PUCK_BOTTOM_PATH, fill: `url(#${gradientId2})` }), jsx("rect", { fill: "transparent", y: PUCK_HEIGHT, width: PUCK_WIDTH, height: 20 })] }), jsx("text", { x: 65, y: 40, width: 50, height: 50, fontSize: 40, fontWeight: "bold", fill: "#FFFFFF", textAnchor: "middle", dominantBaseline: "middle", transform: "rotate(-15 65 40) scale(1, 0.8)", children: index2 + 1 })] }));
    const itemX = puckX + (puckWidth - itemBounds.width) / 2;
    const itemY = isEven ? puckY + puckHeight + ITEM_TO_PUCK_GAP : puckY - ITEM_TO_PUCK_GAP - itemBounds.height;
    maxY = Math.max(maxY, itemY + itemBounds.height);
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY, positionH: "center" }));
    btnElements.push(jsx(BtnRemove, { indexes, x: itemX + itemBounds.width - btnBounds.width / 2, y: itemY + itemBounds.height - btnBounds.height / 2 }));
    if (index2 === 0) {
      btnElements.push(jsx(BtnAdd, { indexes: [0], x: puckX + puckWidth / 2 - btnBounds.width / 2 - (gap + puckWidth) / 2, y: puckY + puckHeight / 2 - btnBounds.height / 2 }));
    }
    if (index2 < items3.length - 1) {
      const nextIsEven = (index2 + 1) % 2 === 0;
      const nextPuckY = nextIsEven ? 0 : itemHeight;
      const btnAddX = puckX + puckWidth + gap / 2 - btnBounds.width / 2;
      const btnAddY = (puckY + puckHeight / 2 + nextPuckY + puckHeight / 2) / 2 - btnBounds.height / 2;
      btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: btnAddX, y: btnAddY }));
    } else {
      btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: puckX + puckWidth + gap / 2 - btnBounds.width / 2, y: puckY + puckHeight / 2 - btnBounds.height / 2 }));
    }
  });
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: 30, children: [jsx(Defs, { children: DropShadowFilter2 }), titleContent, jsxs(Group, { x: 0, y: 0, children: [jsx(Group, { children: puckElements }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-zigzag-pucks-3d", {
  component: SequenceZigzagPucks3d,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/designs/structures/sequence-zigzag-steps.js
var DX = 240;
var DY = 130;
var ITEM_TO_PATH_GAP = 105;
var W_PATH_W = 12;
var GLOW_W = 120;
var GLOW_H = 50;
var GLOW_OPACITY = 0.6;
var DECO_PATH_1 = "M132.821 50.6599L87.6795 76.8925C78.0629 82.4807 62.4238 82.4807 52.7445 76.8925L7.30824 50.6599C2.43719 47.8482 0.00459679 44.1562 0.0152907 40.472L3.17695e-05 45.6925C-0.0101404 49.378 2.42245 53.0686 7.29298 55.8803L52.7289 82.1129C62.4094 87.7011 78.0485 87.7011 87.6652 82.1129L132.806 55.8803C137.583 53.1038 139.975 49.4705 139.986 45.832L140 40.6116C139.989 44.2501 137.598 47.8834 132.821 50.6599Z";
var DECO_PATH_2 = "M132.707 30.4224C142.386 36.0119 142.437 45.0704 132.821 50.6599L87.6795 76.8925C78.0629 82.4807 62.4238 82.4807 52.7445 76.8925L7.30825 50.6599C-2.37126 45.0717 -2.42225 36.0132 7.19414 30.4237L52.335 4.19115C61.9517 -1.39705 77.5908 -1.39705 87.2713 4.19115L132.707 30.4224Z";
var DECO_OFFSET_X = 70 + W_PATH_W / 2;
var DECO_OFFSET_Y = 40 + W_PATH_W / 2;
var GlowFilter = jsx("filter", { id: "sequence-zigzag-glow-filter", x: "-50%", y: "-50%", width: "200%", height: "200%", children: jsx("feGaussianBlur", { in: "SourceGraphic", stdDeviation: "15", result: "blur" }) });
var SequenceZigzagSteps = (props) => {
  var _a;
  const { Title: Title2, Item, data, options, dx = DX, dy = DY, iconSize = 30 } = props;
  const { title, desc, items: items3 = [] } = data;
  const titleContent = Title2 ? jsx(Title2, { title, desc }) : null;
  const colorPrimary = getColorPrimary(options);
  if (items3.length === 0) {
    const btnAddElement = jsx(BtnAdd, { indexes: [0], x: 0, y: 0 });
    return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", children: [jsx(Defs, { children: GlowFilter }), titleContent, jsx(Group, { children: jsx(BtnsGroup, { children: btnAddElement }) })] });
  }
  const itemBounds = getElementBounds(jsx(Item, { indexes: [0], data, datum: items3[0] }));
  const btnBounds = getElementBounds(jsx(BtnAdd, { indexes: [0] }));
  const btnElements = [];
  const itemElements = [];
  const pathElements = [];
  const decoElements = [];
  const iconElements = [];
  let currentX = 0;
  let currentY = 0;
  let pathD = "";
  let minPathY = Infinity;
  let maxItemY = -Infinity;
  let minDecoX = Infinity;
  let minDecoY = Infinity;
  const pathPoints = [];
  items3.forEach((item, index2) => {
    const cx = currentX;
    const cy = currentY;
    pathPoints.push({ x: cx, y: cy });
    minPathY = Math.min(minPathY, cy);
    const decoX = cx - DECO_OFFSET_X;
    const decoY = cy - DECO_OFFSET_Y;
    minDecoX = Math.min(minDecoX, decoX);
    minDecoY = Math.min(minDecoY, decoY);
    const isPeak = index2 % 2 === 0;
    if (index2 < items3.length - 1) {
      currentX += dx;
      currentY = isPeak ? currentY + dy : currentY - dy;
    }
  });
  const offsetX = Math.max(0, -minDecoX);
  const offsetY = Math.max(0, -minDecoY);
  currentX = 0;
  currentY = 0;
  items3.forEach((item, index2) => {
    const indexes = [index2];
    const pathPoint = pathPoints[index2];
    const cx = pathPoint.x + offsetX;
    const cy = pathPoint.y + offsetY;
    const currentColor = getPaletteColor2(options, indexes);
    const decoX = Math.max(0, cx - DECO_OFFSET_X);
    const decoY = Math.max(0, cy - DECO_OFFSET_Y);
    const glowX = 10;
    const glowY = GLOW_H + 10;
    const { colorPrimaryBg } = getThemeColors({
      colorPrimary: currentColor
    });
    decoElements.push(jsxs(ShapesGroup, { x: decoX, y: decoY, width: 140, height: 110, children: [jsx(Ellipse, { x: glowX, y: glowY, width: GLOW_W, height: GLOW_H, fill: currentColor || colorPrimary, filter: "url(#sequence-zigzag-glow-filter)", opacity: GLOW_OPACITY }), jsx(Path, { d: DECO_PATH_1, fill: currentColor || colorPrimary }), jsx(Path, { d: DECO_PATH_2, fill: "#fff" }), jsx(Path, { d: DECO_PATH_2, fill: colorPrimaryBg || colorPrimaryBg })] }));
    if (item.icon) {
      const iconX = Math.max(0, cx - iconSize / 2 - W_PATH_W / 2);
      const iconY = Math.max(0, cy - iconSize / 2 - W_PATH_W / 2);
      iconElements.push(jsx(ItemIcon, { x: iconX, y: iconY, size: iconSize, indexes, fill: currentColor }));
    }
    const itemX = cx - itemBounds.width / 2 - W_PATH_W / 2;
    const itemY = Math.max(0, cy + ITEM_TO_PATH_GAP - W_PATH_W / 2);
    maxItemY = Math.max(maxItemY, itemY + itemBounds.height);
    if (index2 === 0) {
      pathD = `M ${cx} ${cy}`;
    } else {
      pathD += ` L ${cx} ${cy}`;
    }
    itemElements.push(jsx(Item, { indexes, datum: item, data, x: itemX, y: itemY }));
    btnElements.push(jsx(BtnRemove, { indexes, x: Math.max(0, itemX + itemBounds.width - btnBounds.width / 2), y: Math.max(0, itemY + itemBounds.height - btnBounds.height / 2) }));
    if (index2 < items3.length - 1) {
      const nextPoint = pathPoints[index2 + 1];
      const nextCx = nextPoint.x + offsetX;
      const nextCy = nextPoint.y + offsetY;
      const btnAddX = Math.max(0, cx + (nextCx - cx) / 2 - btnBounds.width / 2);
      const btnAddY = Math.max(0, cy + (nextCy - cy) / 2 - btnBounds.height / 2);
      btnElements.push(jsx(BtnAdd, { indexes: [index2 + 1], x: btnAddX, y: btnAddY }));
    } else {
      btnElements.push(jsx(BtnAdd, { indexes: [items3.length], x: Math.max(0, itemX + itemBounds.width + dx / 4), y: Math.max(0, itemY + itemBounds.height / 2 - btnBounds.height / 2) }));
    }
  });
  if (pathD) {
    const finalX = (((_a = pathPoints[pathPoints.length - 1]) === null || _a === void 0 ? void 0 : _a.x) || 0) + offsetX;
    pathElements.push(jsx(Path, { d: pathD, stroke: "#f3f2f1", strokeWidth: W_PATH_W, fill: "none", width: finalX, height: maxItemY - Math.min(minPathY + offsetY, 0) }));
  }
  return jsxs(FlexLayout, { id: "infographic-container", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: 30, children: [jsx(Defs, { children: GlowFilter }), titleContent, jsxs(Group, { x: 0, y: 0, children: [jsx(Group, { children: [...pathElements, ...decoElements, ...iconElements] }), jsx(ItemsGroup, { children: itemElements }), jsx(BtnsGroup, { children: btnElements })] })] });
};
registerStructure("sequence-zigzag-steps", {
  component: SequenceZigzagSteps,
  composites: ["title", "item"]
});

// node_modules/@antv/infographic/esm/editor/interactions/base.js
var Interaction = class {
  init(options) {
    Object.assign(this, options);
  }
};

// node_modules/@antv/infographic/esm/editor/utils/click-handler.js
var ClickHandler = class {
  constructor(element, options = {}) {
    var _a;
    this.clickTimer = null;
    this.singleClickCallback = null;
    this.doubleClickCallback = null;
    this.pointerId = null;
    this.startX = 0;
    this.startY = 0;
    this.skipClick = false;
    this.dragged = false;
    this.handlePointerDown = (event) => {
      this.pointerId = event.pointerId;
      this.startX = event.clientX;
      this.startY = event.clientY;
      this.dragged = false;
      this.skipClick = false;
      window.addEventListener("pointermove", this.handlePointerMove, {
        passive: true
      });
      window.addEventListener("pointerup", this.handlePointerUp, {
        passive: true
      });
      window.addEventListener("pointercancel", this.handlePointerUp, {
        passive: true
      });
    };
    this.handlePointerMove = (event) => {
      if (this.pointerId === null || event.pointerId !== this.pointerId)
        return;
      const dx = event.clientX - this.startX;
      const dy = event.clientY - this.startY;
      if (Math.hypot(dx, dy) > this.dragThreshold) {
        this.skipClick = true;
        this.dragged = true;
      }
    };
    this.handlePointerUp = (event) => {
      if (this.pointerId !== null && event.pointerId === this.pointerId) {
        this.pointerId = null;
        window.removeEventListener("pointermove", this.handlePointerMove);
        window.removeEventListener("pointerup", this.handlePointerUp);
        window.removeEventListener("pointercancel", this.handlePointerUp);
        if (!this.dragged)
          this.skipClick = false;
        this.dragged = false;
      }
    };
    this.element = element;
    this.delay = options.delay || 300;
    this.dragThreshold = (_a = options.dragThreshold) !== null && _a !== void 0 ? _a : 4;
    this.init();
  }
  init() {
    this.element.addEventListener("click", this.handleClick.bind(this));
    this.element.addEventListener("dblclick", this.handleDoubleClick.bind(this));
    this.element.addEventListener("pointerdown", this.handlePointerDown);
  }
  handleClick(e8) {
    if (this.skipClick) {
      this.skipClick = false;
      return;
    }
    if (this.clickTimer)
      clearTimeout(this.clickTimer);
    this.clickTimer = window.setTimeout(() => {
      var _a;
      (_a = this.singleClickCallback) === null || _a === void 0 ? void 0 : _a.call(this, e8);
    }, this.delay);
  }
  handleDoubleClick(e8) {
    var _a;
    if (this.skipClick) {
      this.skipClick = false;
      return;
    }
    if (this.clickTimer)
      clearTimeout(this.clickTimer);
    (_a = this.doubleClickCallback) === null || _a === void 0 ? void 0 : _a.call(this, e8);
  }
  onClick(callback) {
    this.singleClickCallback = callback;
    return this;
  }
  onDoubleClick(callback) {
    this.doubleClickCallback = callback;
    return this;
  }
  destroy() {
    if (this.clickTimer)
      clearTimeout(this.clickTimer);
    this.element.removeEventListener("click", this.handleClick);
    this.element.removeEventListener("dblclick", this.handleDoubleClick);
    this.element.removeEventListener("pointerdown", this.handlePointerDown);
    window.removeEventListener("pointermove", this.handlePointerMove);
    window.removeEventListener("pointerup", this.handlePointerUp);
    window.removeEventListener("pointercancel", this.handlePointerUp);
  }
};

// node_modules/@antv/infographic/esm/editor/utils/coordinate.js
function getInverseScreenCTM(svg) {
  var _a;
  return ((_a = svg.getScreenCTM()) === null || _a === void 0 ? void 0 : _a.inverse()) || new DOMMatrix();
}
function clientToViewport(svg, x6, y6) {
  return new DOMPoint(x6, y6).matrixTransform(getInverseScreenCTM(svg));
}
function getElementViewportBounds(svg, element) {
  const bounds = element.getBoundingClientRect();
  const points = [
    { x: bounds.x, y: bounds.y },
    // 
    { x: bounds.x + bounds.width, y: bounds.y },
    // 
    { x: bounds.x, y: bounds.y + bounds.height },
    // 
    { x: bounds.x + bounds.width, y: bounds.y + bounds.height }
    // 
  ];
  const transformedPoints = points.map((point) => {
    return clientToViewport(svg, point.x, point.y);
  });
  const minX = Math.min(...transformedPoints.map((p7) => p7.x));
  const maxX = Math.max(...transformedPoints.map((p7) => p7.x));
  const minY = Math.min(...transformedPoints.map((p7) => p7.y));
  const maxY = Math.max(...transformedPoints.map((p7) => p7.y));
  return new DOMRect(minX, minY, maxX - minX, maxY - minY);
}

// node_modules/@antv/infographic/esm/editor/utils/data.js
function getChildrenDataByIndexes(data, indexes) {
  if (indexes.length === 0)
    return data.data;
  const datum2 = getDatumByIndexes(data, indexes);
  datum2.children || (datum2.children = []);
  return datum2.children;
}
function buildItemPath(indexes, prefix = "data.items") {
  return indexes.reduce((path2, idx, i4) => i4 === 0 ? `${path2}[${idx}]` : `${path2}.children[${idx}]`, prefix);
}

// node_modules/@antv/infographic/esm/editor/utils/element.js
function getIndexesFromElement(element) {
  var _a, _b;
  return ((_b = (_a = getElementEntity(element)) === null || _a === void 0 ? void 0 : _a.dataset.indexes) === null || _b === void 0 ? void 0 : _b.split(",").map(Number)) || [];
}
function getElementEntity(element) {
  if (isIconElement(element))
    return getIconEntity(element);
  return element;
}

// node_modules/@antv/infographic/esm/editor/utils/event.js
function getEventTarget(element) {
  if (!element)
    return null;
  const preprocess = [getRoughEventTarget];
  let target = element;
  for (const fn5 of preprocess) {
    const result = fn5(target);
    if (result) {
      target = result;
      break;
    }
  }
  return getSelectableTarget(target);
}
function getSelectableTarget(element) {
  if (!element)
    return null;
  const recognizers = [getTextEventTarget, getIconEventTarget];
  for (const fn5 of recognizers) {
    const result = fn5(element);
    if (result) {
      return result;
    }
  }
  if (isEditArea(element)) {
    return element;
  }
  if (isEditableText(element) || isIconElement(element)) {
    return element;
  }
  return null;
}
var getRoughEventTarget = (element) => {
  var _a;
  const is2 = (ele) => {
    if (!ele)
      return false;
    return isRoughElement(ele) || isRoughVolume(ele);
  };
  if (is2(element)) {
    return element.parentElement;
  }
  if (is2(element.parentElement)) {
    return (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement;
  }
  return null;
};
var getTextEventTarget = (element) => {
  if (isTextEntity(element) && isForeignObjectElement(element.parentElement)) {
    return element.parentElement;
  }
  return null;
};
var getIconEventTarget = (element) => {
  const parent = element.parentElement;
  if (isItemIconGroup(parent)) {
    return parent;
  }
  if (isItemIcon(element)) {
    return element;
  }
  return null;
};

// node_modules/@antv/infographic/esm/editor/utils/extension.js
var Extension = class {
  constructor() {
    this.extensions = /* @__PURE__ */ new Map();
  }
  register(name, extension, options) {
    if (!(options === null || options === void 0 ? void 0 : options.override) && this.extensions.has(name)) {
      throw new Error(`Extension "${name}" already registered`);
    }
    this.extensions.set(name, extension);
  }
  get(name) {
    return this.extensions.get(name);
  }
  has(name) {
    return this.extensions.has(name);
  }
  getAll() {
    return this.extensions;
  }
  forEach(callback) {
    this.extensions.forEach((extension, name) => {
      callback(extension, name);
    });
  }
  [Symbol.iterator]() {
    return this.extensions.entries();
  }
  unregister(name) {
    return this.extensions.delete(name);
  }
  destroy() {
    this.extensions.forEach((extension) => {
      if (extension && typeof extension.dispose === "function") {
        extension.dispose();
      }
    });
    this.extensions.clear();
  }
};

// node_modules/@antv/infographic/esm/editor/utils/hotkey.js
var isEditableTarget = (target) => {
  if (!target)
    return false;
  if (!(target instanceof HTMLElement))
    return false;
  if (target.isContentEditable)
    return true;
  const tagName = target.tagName.toLowerCase();
  return tagName === "input" || tagName === "textarea" || tagName === "select";
};
var normalizeCombo = (combo) => {
  const parts = combo.toLowerCase().split("+").map((p7) => p7.trim()).filter(Boolean);
  const comboObj = { key: "" };
  parts.forEach((part) => {
    if (part === "shift")
      comboObj.shift = true;
    else if (part === "alt" || part === "option")
      comboObj.alt = true;
    else if (part === "ctrl" || part === "control")
      comboObj.ctrl = true;
    else if (part === "meta" || part === "cmd" || part === "command")
      comboObj.meta = true;
    else if (part === "mod")
      comboObj.mod = true;
    else
      comboObj.key = part;
  });
  if (!comboObj.key) {
    throw new Error(`Invalid hotkey combo: "${combo}"`);
  }
  return comboObj;
};
var matchCombo = (event, combo) => {
  var _a;
  const key = event.key.toLowerCase();
  if (key !== combo.key)
    return false;
  const wantsMod = (_a = combo.mod) !== null && _a !== void 0 ? _a : false;
  const hasMeta = event.metaKey;
  const hasCtrl = event.ctrlKey;
  const hasMod = hasMeta || hasCtrl;
  const matchesStrict = (expected, actual) => expected === void 0 ? !actual : expected === actual;
  if (wantsMod && !hasMod)
    return false;
  if (wantsMod) {
    if (!matchesStrict(combo.shift, event.shiftKey))
      return false;
    if (!matchesStrict(combo.alt, event.altKey))
      return false;
    if (combo.meta !== void 0 && !matchesStrict(combo.meta, hasMeta))
      return false;
    if (combo.ctrl !== void 0 && !matchesStrict(combo.ctrl, hasCtrl))
      return false;
    return true;
  }
  if (!matchesStrict(combo.meta, hasMeta))
    return false;
  if (!matchesStrict(combo.ctrl, hasCtrl))
    return false;
  if (!matchesStrict(combo.shift, event.shiftKey))
    return false;
  if (!matchesStrict(combo.alt, event.altKey))
    return false;
  return true;
};
var Hotkey = class {
  constructor(options = {}) {
    this.bindings = [];
    this.handleKeydown = (event) => {
      if (!(event instanceof KeyboardEvent))
        return;
      if (event.defaultPrevented)
        return;
      if (isEditableTarget(event.target))
        return;
      if (this.filter && !this.filter(event))
        return;
      for (const binding of this.bindings) {
        if (binding.combos.some((combo) => matchCombo(event, combo))) {
          binding.handler(event);
          break;
        }
      }
    };
    const { target = document, filter: filter2 } = options;
    this.target = target;
    this.filter = filter2;
    this.target.addEventListener("keydown", this.handleKeydown);
  }
  bind(combo, handler) {
    const combos = Array.isArray(combo) ? combo : [combo];
    const binding = {
      combos: combos.map((c4) => normalizeCombo(c4)),
      handler
    };
    this.bindings.push(binding);
    return () => this.unbind(binding);
  }
  destroy() {
    this.target.removeEventListener("keydown", this.handleKeydown);
    this.bindings = [];
  }
  unbind(binding) {
    this.bindings = this.bindings.filter((item) => item !== binding);
  }
};

// node_modules/@antv/infographic/esm/editor/interactions/brush-select.js
var __awaiter8 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BrushSelect = class extends Interaction {
  constructor() {
    super(...arguments);
    this.name = "brush-select";
    this.shiftKey = false;
    this.dragging = false;
    this.dragThreshold = 4;
    this.handleStart = (event) => {
      if (!this.interaction.isActive())
        return;
      if (event.button !== 0)
        return;
      if (this.isTextSelectionTarget(event.target))
        return;
      if (this.hasElementAtStart(event.target))
        return;
      this.interaction.executeExclusiveInteraction(this, () => __awaiter8(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
          this.completeInteraction = resolve;
          const svg = this.editor.getDocument();
          this.startPoint = clientToViewport(svg, event.clientX, event.clientY);
          this.pointerId = event.pointerId;
          this.shiftKey = event.shiftKey;
          this.dragging = false;
          window.addEventListener("pointermove", this.handleMove);
          window.addEventListener("pointerup", this.handleEnd);
        });
      }));
    };
    this.handleMove = (event) => {
      if (event.pointerId !== this.pointerId || !this.startPoint)
        return;
      const svg = this.editor.getDocument();
      const current = clientToViewport(svg, event.clientX, event.clientY);
      const dx = current.x - this.startPoint.x;
      const dy = current.y - this.startPoint.y;
      if (!this.dragging) {
        if (Math.hypot(dx, dy) < this.dragThreshold)
          return;
        this.dragging = true;
        this.ensureBrush();
        this.updateBrush(this.startPoint, current);
      }
      event.preventDefault();
      event.stopPropagation();
      this.updateBrush(this.startPoint, current);
    };
    this.handleEnd = (event) => {
      var _a, _b;
      if (event.pointerId !== this.pointerId || !this.startPoint)
        return;
      window.removeEventListener("pointermove", this.handleMove);
      window.removeEventListener("pointerup", this.handleEnd);
      let rect = null;
      if (this.dragging) {
        event.preventDefault();
        event.stopPropagation();
        const svg = this.editor.getDocument();
        const endPoint = clientToViewport(svg, event.clientX, event.clientY);
        rect = this.updateBrush(this.startPoint, endPoint);
        this.clearBrush();
      }
      this.pointerId = void 0;
      this.startPoint = void 0;
      this.dragging = false;
      const withShift = this.shiftKey;
      this.shiftKey = false;
      if (!rect) {
        (_a = this.completeInteraction) === null || _a === void 0 ? void 0 : _a.call(this);
        this.completeInteraction = void 0;
        return;
      }
      const selection2 = this.collectSelection(rect);
      (_b = this.completeInteraction) === null || _b === void 0 ? void 0 : _b.call(this);
      this.completeInteraction = void 0;
      if (selection2.length === 0) {
        if (!withShift)
          this.interaction.clearSelection();
        return;
      }
      const mode = withShift ? "add" : "replace";
      this.interaction.select(selection2, mode);
    };
  }
  init(options) {
    super.init(options);
    this.editor.getDocument().addEventListener("pointerdown", this.handleStart);
  }
  destroy() {
    this.clearBrush();
    this.editor.getDocument().removeEventListener("pointerdown", this.handleStart);
    window.removeEventListener("pointermove", this.handleMove);
    window.removeEventListener("pointerup", this.handleEnd);
  }
  ensureBrush() {
    if (this.brush)
      return this.brush;
    this.brush = this.interaction.appendTransientElement(createElement("rect", {
      fill: "rgba(51, 132, 245, 0.08)",
      stroke: "#3384F5",
      "stroke-dasharray": "4 2",
      "stroke-width": 1,
      "pointer-events": "none"
    }));
    return this.brush;
  }
  updateBrush(start2, current) {
    if (!this.brush)
      return null;
    const x6 = Math.min(start2.x, current.x);
    const y6 = Math.min(start2.y, current.y);
    const width = Math.abs(start2.x - current.x);
    const height = Math.abs(start2.y - current.y);
    setAttributes(this.brush, { x: x6, y: y6, width, height });
    return { x: x6, y: y6, width, height };
  }
  clearBrush() {
    var _a;
    (_a = this.brush) === null || _a === void 0 ? void 0 : _a.remove();
    this.brush = void 0;
  }
  collectSelection(rect) {
    const svg = this.editor.getDocument();
    const candidates = Array.from(svg.querySelectorAll("[data-element-type]"));
    const intersects = (a3, b2) => {
      const ax2 = a3.x + a3.width;
      const ay2 = a3.y + a3.height;
      const bx2 = b2.x + b2.width;
      const by2 = b2.y + b2.height;
      return !(ax2 < b2.x || bx2 < a3.x || ay2 < b2.y || by2 < a3.y);
    };
    const collected = /* @__PURE__ */ new Set();
    return candidates.reduce((selection2, node) => {
      const element = getSelectableTarget(node);
      if (!element || collected.has(element))
        return selection2;
      const bounds = getElementViewportBounds(svg, element);
      const targetRect = {
        x: bounds.x,
        y: bounds.y,
        width: bounds.width,
        height: bounds.height
      };
      if (intersects(rect, targetRect)) {
        selection2.push(element);
        collected.add(element);
      }
      return selection2;
    }, []);
  }
  hasElementAtStart(target) {
    var _a;
    if (!(target instanceof Element))
      return false;
    if (getEventTarget(target))
      return true;
    return Boolean((_a = target.closest) === null || _a === void 0 ? void 0 : _a.call(target, "[data-element-type]"));
  }
  isTextSelectionTarget(target) {
    if (!(target instanceof HTMLElement))
      return false;
    if (target.isContentEditable)
      return true;
    const tag = target.tagName.toLowerCase();
    return tag === "input" || tag === "textarea";
  }
};

// node_modules/@antv/infographic/esm/editor/interactions/click-select.js
var __awaiter9 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ClickSelect = class extends Interaction {
  constructor() {
    super(...arguments);
    this.name = "click-select";
    this.shiftKey = false;
    this.onShiftKeyDown = (event) => {
      if (event.key === "Shift") {
        this.shiftKey = true;
      }
    };
    this.onShiftKeyUp = (event) => {
      if (event.key === "Shift") {
        this.shiftKey = false;
      }
    };
    this.onEscKeyDown = (event) => {
      if (event.key === "Escape") {
        this.interaction.clearSelection();
      }
    };
  }
  init(options) {
    super.init(options);
    const { editor, interaction } = this;
    this.clickHandler = new ClickHandler(editor.getDocument(), { delay: 0 });
    const handleSelect = (event) => {
      if (!interaction.isActive())
        return;
      interaction.executeExclusiveInteraction(this, () => __awaiter9(this, void 0, void 0, function* () {
        const target = getEventTarget(event.target);
        if (isEditingText(target))
          return;
        if (this.shiftKey) {
          if (target) {
            if (interaction.isSelected(target)) {
              interaction.select([target], "remove");
            } else {
              interaction.select([target], "add");
            }
          }
        } else {
          if (target)
            interaction.select([target], "replace");
          else
            interaction.clearSelection();
        }
      }));
    };
    this.clickHandler.onClick(handleSelect);
    document.addEventListener("keydown", this.onShiftKeyDown);
    document.addEventListener("keyup", this.onShiftKeyUp);
    document.addEventListener("keydown", this.onEscKeyDown);
  }
  destroy() {
    var _a;
    (_a = this.clickHandler) === null || _a === void 0 ? void 0 : _a.destroy();
    document.removeEventListener("keydown", this.onShiftKeyDown);
    document.removeEventListener("keyup", this.onShiftKeyUp);
    document.removeEventListener("keydown", this.onEscKeyDown);
  }
};

// node_modules/@antv/infographic/esm/editor/commands/Batch.js
var __awaiter10 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BatchCommand = class {
  constructor(commands) {
    this.commands = commands;
  }
  apply(state) {
    return __awaiter10(this, void 0, void 0, function* () {
      for (const command of this.commands) {
        yield command.apply(state);
      }
    });
  }
  undo(state) {
    return __awaiter10(this, void 0, void 0, function* () {
      for (let i4 = this.commands.length - 1; i4 >= 0; i4--) {
        yield this.commands[i4].undo(state);
      }
    });
  }
  serialize() {
    return {
      type: "batch",
      commands: this.commands.map((cmd) => cmd.serialize())
    };
  }
};

// node_modules/@antv/infographic/esm/editor/commands/UpdateElement.js
var __awaiter11 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UpdateElementCommand = class {
  constructor(element, modified, original) {
    this.element = element;
    this.modified = modified;
    const computedOriginal = getOriginalProps(element, modified);
    this.original = mergeOriginalProps(computedOriginal, original);
  }
  apply(state) {
    return __awaiter11(this, void 0, void 0, function* () {
      updateElement(this.element, this.modified);
      state.updateElement(this.element, this.modified);
    });
  }
  undo(state) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (this.original) {
        updateElement(this.element, this.original);
        state.updateElement(this.element, this.original);
      }
    });
  }
  serialize() {
    return {
      type: "update-element",
      elementId: this.element.id,
      modified: this.modified,
      original: this.original
    };
  }
};
function updateElement(element, props) {
  if (isEditableText(element)) {
    updateTextElement(element, props);
  } else if (isIconElement(element)) {
    updateIconElement(element, void 0, props.attributes);
  } else if (props.attributes) {
    setAttributes(element, props.attributes);
  }
}
function getOriginalProps(element, modified) {
  const modifiedAttrKeys = Object.keys(modified.attributes || {});
  const originalAttributes = getAttributes(element, modifiedAttrKeys, false);
  const assignModifiedAttributes = (attrs) => {
    if (!attrs)
      return;
    modifiedAttrKeys.forEach((key) => {
      if (key in attrs)
        originalAttributes[key] = attrs[key];
    });
  };
  const original = Object.assign(Object.assign({}, modified), { attributes: originalAttributes });
  if (isEditableText(element)) {
    const { attributes } = getTextElementProps(element);
    assignModifiedAttributes(attributes);
  } else if (isIconElement(element)) {
    const entity = getIconEntity(element);
    if (!entity)
      return;
    assignModifiedAttributes(getIconAttrs(element));
  }
  return original;
}
function mergeOriginalProps(computed, provided) {
  if (!computed)
    return provided;
  if (!provided)
    return computed;
  const mergedAttributes = Object.assign(Object.assign({}, computed.attributes || {}), provided.attributes || {});
  return Object.assign(Object.assign(Object.assign({}, computed), provided), { attributes: Object.keys(mergedAttributes).length ? mergedAttributes : void 0 });
}

// node_modules/@antv/infographic/esm/editor/commands/UpdateOptions.js
var __awaiter12 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UpdateOptionsCommand = class {
  constructor(options, original) {
    this.options = options;
    this.original = original;
  }
  apply(state) {
    return __awaiter12(this, void 0, void 0, function* () {
      const prev = state.getOptions();
      if (!this.original) {
        this.original = prev;
      }
      state.updateOptions(Object.assign(Object.assign({}, prev), this.options));
    });
  }
  undo(state) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (this.original) {
        state.updateOptions(this.original);
      }
    });
  }
  serialize() {
    return {
      type: "update-options",
      options: this.options,
      original: this.original
    };
  }
};

// node_modules/@antv/infographic/esm/editor/commands/UpdateText.js
var __awaiter13 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UpdateTextCommand = class {
  constructor(element, newText, originalText) {
    this.element = element;
    this.originalText = originalText !== null && originalText !== void 0 ? originalText : getTextContent(element);
    this.modifiedText = newText;
  }
  apply(state) {
    return __awaiter13(this, void 0, void 0, function* () {
      if (this.originalText === this.modifiedText)
        return;
      setTextContent(this.element, this.modifiedText);
      updateItemText(state, this.element, this.modifiedText);
    });
  }
  undo(state) {
    return __awaiter13(this, void 0, void 0, function* () {
      if (this.originalText === this.modifiedText)
        return;
      setTextContent(this.element, this.originalText);
      updateItemText(state, this.element, this.originalText);
    });
  }
  serialize() {
    return {
      type: "update-text",
      elementId: this.element.id,
      original: this.originalText,
      modified: this.modifiedText
    };
  }
};
function updateItemText(state, element, text) {
  const role = getElementRole(element);
  if (role.startsWith("item-")) {
    const key = role.replace("item-", "");
    const indexes = getIndexesFromElement(element);
    state.updateItemDatum(indexes, { [key]: text });
  } else {
    state.updateData(role, text);
  }
}

// node_modules/@antv/infographic/esm/editor/interactions/dblclick-edit-text.js
var __awaiter14 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DblClickEditText = class extends Interaction {
  constructor() {
    super(...arguments);
    this.name = "dblclick-edit-text";
  }
  init(options) {
    super.init(options);
    const { editor, commander, interaction } = options;
    this.clickHandler = new ClickHandler(editor.getDocument()).onDoubleClick((event) => {
      if (!interaction.isActive())
        return;
      interaction.executeExclusiveInteraction(this, () => __awaiter14(this, void 0, void 0, function* () {
        const target = getEventTarget(event.target);
        if (!target)
          return;
        if (isEditableText(target)) {
          interaction.select([target], "replace");
          const originalText = getTextContent(target);
          const text = yield new Promise((resolve) => {
            const stopListen = this.listenSelectionChange(target);
            editText(target, {
              cursorPosition: {
                clientX: event.clientX,
                clientY: event.clientY
              },
              onBlur: resolve,
              onCancel: resolve
            });
            this.detachSelectionListener = stopListen;
          });
          commander.execute(new UpdateTextCommand(target, text, originalText));
        }
      }));
    });
  }
  destroy() {
    var _a, _b;
    (_a = this.clickHandler) === null || _a === void 0 ? void 0 : _a.destroy();
    (_b = this.detachSelectionListener) === null || _b === void 0 ? void 0 : _b.call(this);
  }
  listenSelectionChange(target) {
    const handler = ({ next }) => {
      var _a;
      if (!next.includes(target)) {
        (_a = this.detachSelectionListener) === null || _a === void 0 ? void 0 : _a.call(this);
        this.detachSelectionListener = void 0;
        const entity = getTextEntity(target);
        if (entity)
          entity.blur();
      }
    };
    this.emitter.on("selection:change", handler);
    return () => this.emitter.off("selection:change", handler);
  }
};
var EDITOR_STYLE_ID = "infographic-inline-text-editor-style";
var EDITOR_BASE_CLASS = "infographic-inline-text-editor";
function editText(text, options) {
  const entity = getTextEntity(text);
  if (!entity)
    return;
  ensureEditorStyles();
  new InlineTextEditor(entity, options).start();
}
var InlineTextEditor = class {
  constructor(entity, options) {
    this.entity = entity;
    this.options = options;
    this.handlePaste = (event) => {
      if (!event.clipboardData)
        return;
      event.preventDefault();
      this.insertPlainText(event.clipboardData.getData("text/plain"));
    };
    this.handleKeydown = (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        this.insertPlainText("\n");
      }
    };
    this.handleInput = () => {
      var _a, _b;
      this.normalizeSpanContent();
      (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.onInput) === null || _b === void 0 ? void 0 : _b.call(_a, this.getText());
    };
    this.handleBlur = () => {
      var _a, _b;
      this.entity.removeAttribute("contenteditable");
      this.entity.classList.remove(EDITOR_BASE_CLASS);
      this.normalizeSpanContent();
      (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, this.getText());
      this.detachListeners();
    };
  }
  start() {
    this.entity.setAttribute("contenteditable", "true");
    this.entity.classList.add(EDITOR_BASE_CLASS);
    this.entity.focus();
    this.placeCaretAtClickPosition();
    this.attachListeners();
  }
  attachListeners() {
    this.entity.addEventListener("paste", this.handlePaste);
    this.entity.addEventListener("keydown", this.handleKeydown);
    this.entity.addEventListener("input", this.handleInput);
    this.entity.addEventListener("blur", this.handleBlur, { once: true });
  }
  detachListeners() {
    this.entity.removeEventListener("paste", this.handlePaste);
    this.entity.removeEventListener("keydown", this.handleKeydown);
    this.entity.removeEventListener("input", this.handleInput);
  }
  insertPlainText(text) {
    var _a, _b;
    const selection2 = window.getSelection();
    if (!selection2)
      return;
    if (!selection2.rangeCount) {
      this.placeCaretAtEnd();
    }
    const range = selection2.rangeCount ? selection2.getRangeAt(0) : document.createRange();
    range.deleteContents();
    const textNode = document.createTextNode(text);
    range.insertNode(textNode);
    range.setStartAfter(textNode);
    range.setEndAfter(textNode);
    selection2.removeAllRanges();
    selection2.addRange(range);
    this.normalizeSpanContent();
    (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.onInput) === null || _b === void 0 ? void 0 : _b.call(_a, this.getText());
  }
  normalizeSpanContent() {
    var _a;
    if (this.entity.childNodes.length === 1 && ((_a = this.entity.firstChild) === null || _a === void 0 ? void 0 : _a.nodeType) === Node.TEXT_NODE) {
      return;
    }
    const plainText = this.getText();
    this.entity.textContent = plainText;
  }
  placeCaretAtClickPosition() {
    const selection2 = window.getSelection();
    if (!selection2)
      return;
    const rangeFromPoint = this.getRangeFromPoint();
    if (rangeFromPoint) {
      selection2.removeAllRanges();
      selection2.addRange(rangeFromPoint);
      return;
    }
    this.placeCaretAtEnd();
  }
  getRangeFromPoint() {
    var _a, _b;
    const { cursorPosition } = this.options || {};
    if (!cursorPosition)
      return null;
    const { clientX, clientY } = cursorPosition;
    const doc = document;
    const rangeFromPoint = (_b = (_a = doc.caretRangeFromPoint) === null || _a === void 0 ? void 0 : _a.call(doc, clientX, clientY)) !== null && _b !== void 0 ? _b : (() => {
      var _a2;
      const caretPosition = (_a2 = doc.caretPositionFromPoint) === null || _a2 === void 0 ? void 0 : _a2.call(doc, clientX, clientY);
      if (!caretPosition)
        return null;
      const caretRange = document.createRange();
      caretRange.setStart(caretPosition.offsetNode, caretPosition.offset);
      caretRange.collapse(true);
      return caretRange;
    })();
    if (!rangeFromPoint)
      return null;
    if (!this.entity.contains(rangeFromPoint.startContainer))
      return null;
    return rangeFromPoint;
  }
  placeCaretAtEnd() {
    const selection2 = window.getSelection();
    if (!selection2)
      return;
    const range = document.createRange();
    range.selectNodeContents(this.entity);
    range.collapse(false);
    selection2.removeAllRanges();
    selection2.addRange(range);
  }
  getText() {
    return this.entity.textContent || "";
  }
};
function ensureEditorStyles() {
  injectStyleOnce(EDITOR_STYLE_ID, `
.${EDITOR_BASE_CLASS} {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  background-color: transparent;
  outline: none;
  cursor: text;
}
.${EDITOR_BASE_CLASS}::selection {
  background-color: #b3d4fc;
}
`);
}

// node_modules/@antv/infographic/esm/editor/interactions/drag-element.js
var __awaiter15 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DragElement = class extends Interaction {
  constructor() {
    super(...arguments);
    this.name = "drag-element";
    this.selectionForDrag = [];
    this.willReplaceSelection = false;
    this.exclusiveStarted = false;
    this.dragItems = [];
    this.dragging = false;
    this.dragThreshold = 4;
    this.handleStart = (event) => {
      if (!this.interaction.isActive())
        return;
      if (event.pointerType === "mouse" && event.button !== 0)
        return;
      const target = getEventTarget(event.target);
      if (!target)
        return;
      if (isEditingText(target))
        return;
      const svg = this.editor.getDocument();
      this.pointerId = event.pointerId;
      this.startPoint = clientToViewport(svg, event.clientX, event.clientY);
      this.dragging = false;
      this.startTarget = target;
      const isSelected = this.interaction.isSelected(target);
      this.selectionForDrag = isSelected ? this.interaction.getSelection() : [target];
      this.willReplaceSelection = !isSelected;
      this.exclusiveStarted = false;
      this.startBounds = this.getSelectionBounds(this.selectionForDrag);
      this.guideCandidates = this.collectGuideCandidates(this.selectionForDrag);
      window.addEventListener("pointermove", this.handleMove);
      window.addEventListener("pointerup", this.handleEnd);
      window.addEventListener("pointercancel", this.handleEnd);
    };
    this.handleMove = (event) => {
      if (event.pointerId !== this.pointerId || !this.startPoint)
        return;
      const svg = this.editor.getDocument();
      const current = clientToViewport(svg, event.clientX, event.clientY);
      const dx = current.x - this.startPoint.x;
      const dy = current.y - this.startPoint.y;
      if (!this.dragging) {
        if (Math.hypot(dx, dy) < this.dragThreshold)
          return;
        if (!this.startDrag()) {
          this.reset();
          return;
        }
        this.dragging = true;
      }
      const altKey = event.altKey;
      const snap = !altKey ? this.getSnappedDelta(dx, dy) : { dx, dy };
      event.preventDefault();
      event.stopPropagation();
      this.updateGuides(snap);
      this.applyTranslation(snap.dx, snap.dy);
      this.emitGeometryChange();
    };
    this.handleEnd = (event) => {
      if (event.pointerId !== this.pointerId || !this.startPoint)
        return;
      this.detachPointerListeners();
      const svg = this.editor.getDocument();
      const endPoint = clientToViewport(svg, event.clientX, event.clientY);
      const dx = endPoint.x - this.startPoint.x;
      const dy = endPoint.y - this.startPoint.y;
      const moved = this.dragging || Math.hypot(dx, dy) >= this.dragThreshold;
      if (moved && this.dragItems.length && this.exclusiveStarted) {
        event.preventDefault();
        event.stopPropagation();
        const snap = event.altKey ? { dx, dy } : this.getSnappedDelta(dx, dy);
        this.updateGuides(snap);
        this.applyTranslation(snap.dx, snap.dy);
        this.commitTranslation(snap.dx, snap.dy);
        this.emitGeometryChange();
      }
      this.reset();
    };
  }
  init(options) {
    super.init(options);
    this.editor.getDocument().addEventListener("pointerdown", this.handleStart);
  }
  destroy() {
    this.detachPointerListeners();
    this.editor.getDocument().removeEventListener("pointerdown", this.handleStart);
  }
  startDrag() {
    if (this.exclusiveStarted)
      return true;
    if (!this.startTarget)
      return false;
    if (this.willReplaceSelection) {
      this.interaction.select([this.startTarget], "replace");
    }
    this.dragItems = this.selectionForDrag.filter((element) => isEditableText(element)).map((element) => this.createDragItem(element)).filter(Boolean);
    if (this.dragItems.length === 0)
      return false;
    let started = false;
    this.interaction.executeExclusiveInteraction(this, () => __awaiter15(this, void 0, void 0, function* () {
      return new Promise((resolve) => {
        this.completeInteraction = resolve;
        started = true;
      });
    }));
    this.exclusiveStarted = started;
    return started;
  }
  applyTranslation(dx, dy) {
    this.dragItems.forEach((item) => {
      if (item.mode === "attr") {
        const x6 = item.startX + dx;
        const y6 = item.startY + dy;
        const attrs = { x: x6, y: y6 };
        if (item.hasDataX)
          attrs["data-x"] = x6;
        if (item.hasDataY)
          attrs["data-y"] = y6;
        setAttributes(item.element, attrs);
      } else {
        const transform2 = this.composeTransform(item.startX + dx, item.startY + dy, item.restTransform);
        setAttributes(item.element, { transform: transform2 });
      }
    });
  }
  commitTranslation(dx, dy) {
    if (Math.abs(dx) < 1e-6 && Math.abs(dy) < 1e-6)
      return;
    const commands = this.dragItems.map((item) => {
      if (item.mode === "attr") {
        const x6 = item.startX + dx;
        const y6 = item.startY + dy;
        const modifiedAttrs = { x: x6, y: y6 };
        const originalAttrs = {};
        if (item.hasX) {
          originalAttrs.x = item.startX;
        } else {
          originalAttrs.x = null;
        }
        if (item.hasY) {
          originalAttrs.y = item.startY;
        } else {
          originalAttrs.y = null;
        }
        if (item.hasDataX) {
          modifiedAttrs["data-x"] = x6;
          originalAttrs["data-x"] = item.startX;
        }
        if (item.hasDataY) {
          modifiedAttrs["data-y"] = y6;
          originalAttrs["data-y"] = item.startY;
        }
        return new UpdateElementCommand(item.element, { attributes: modifiedAttrs }, { attributes: originalAttrs });
      }
      const transform2 = this.composeTransform(item.startX + dx, item.startY + dy, item.restTransform);
      const originalTransform = item.originalTransform !== void 0 ? item.originalTransform : null;
      return new UpdateElementCommand(item.element, { attributes: { transform: transform2 } }, { attributes: { transform: originalTransform } });
    });
    if (commands.length) {
      this.commander.executeBatch(commands);
    }
  }
  createDragItem(element) {
    const transformInfo = this.getTransformInfo(element);
    if (transformInfo) {
      return {
        element,
        mode: "transform",
        startX: transformInfo.x,
        startY: transformInfo.y,
        hasX: false,
        hasY: false,
        hasDataX: false,
        hasDataY: false,
        restTransform: transformInfo.rest,
        originalTransform: transformInfo.original
      };
    }
    const { x: x6, y: y6, hasX, hasY, hasDataX, hasDataY } = this.getAttrInfo(element);
    return {
      element,
      mode: "attr",
      startX: x6,
      startY: y6,
      hasX,
      hasY,
      hasDataX,
      hasDataY
    };
  }
  getAttrInfo(element) {
    const svg = this.editor.getDocument();
    const { x: bx, y: by } = getElementViewportBounds(svg, element);
    const attrs = getAttributes(element, ["x", "y", "data-x", "data-y"], false);
    const hasX = attrs.x !== null && attrs.x !== void 0;
    const hasY = attrs.y !== null && attrs.y !== void 0;
    const hasDataX = attrs["data-x"] !== null && attrs["data-x"] !== void 0;
    const hasDataY = attrs["data-y"] !== null && attrs["data-y"] !== void 0;
    const parseNumber2 = (value, fallback) => {
      const num3 = value !== null && value !== void 0 ? Number(value) : NaN;
      return Number.isFinite(num3) ? num3 : fallback;
    };
    const xFromAttr = parseNumber2(attrs.x, NaN);
    const yFromAttr = parseNumber2(attrs.y, NaN);
    const xFromData = parseNumber2(attrs["data-x"], NaN);
    const yFromData = parseNumber2(attrs["data-y"], NaN);
    const x6 = Number.isFinite(xFromAttr) ? xFromAttr : Number.isFinite(xFromData) ? xFromData : bx;
    const y6 = Number.isFinite(yFromAttr) ? yFromAttr : Number.isFinite(yFromData) ? yFromData : by;
    return { x: x6, y: y6, hasX, hasY, hasDataX, hasDataY };
  }
  getTransformInfo(element) {
    const transform2 = element.getAttribute("transform");
    if (transform2 === null)
      return null;
    const match = transform2.match(/translate\(\s*([-\d.]+)(?:[ ,]\s*([-\d.]+))?\s*\)/i);
    if (!match) {
      return { x: 0, y: 0, rest: transform2, original: transform2 };
    }
    const x6 = Number(match[1]) || 0;
    const y6 = match[2] !== void 0 ? Number(match[2]) || 0 : 0;
    const rest = transform2.replace(match[0], "").trim();
    return { x: x6, y: y6, rest, original: transform2 };
  }
  composeTransform(x6, y6, rest) {
    const translate = `translate(${x6}, ${y6})`;
    return rest && rest.length ? `${translate} ${rest}` : translate;
  }
  emitGeometryChange() {
    var _a;
    const target = (_a = this.dragItems[0]) === null || _a === void 0 ? void 0 : _a.element;
    if (!target)
      return;
    const rect = getElementViewportBounds(this.editor.getDocument(), target);
    this.emitter.emit("selection:geometrychange", {
      type: "selection:geometrychange",
      target,
      rect
    });
  }
  detachPointerListeners() {
    window.removeEventListener("pointermove", this.handleMove);
    window.removeEventListener("pointerup", this.handleEnd);
    window.removeEventListener("pointercancel", this.handleEnd);
  }
  reset() {
    var _a;
    this.detachPointerListeners();
    this.clearGuides();
    this.pointerId = void 0;
    this.startPoint = void 0;
    this.dragItems = [];
    this.startTarget = void 0;
    this.selectionForDrag = [];
    this.willReplaceSelection = false;
    this.exclusiveStarted = false;
    this.dragging = false;
    this.startBounds = void 0;
    this.guideCandidates = void 0;
    (_a = this.completeInteraction) === null || _a === void 0 ? void 0 : _a.call(this);
    this.completeInteraction = void 0;
  }
  getSelectionBounds(selection2) {
    if (!selection2.length)
      return void 0;
    const svg = this.editor.getDocument();
    const rects = selection2.map((el) => getElementViewportBounds(svg, el));
    return getCombinedBounds(rects);
  }
  collectGuideCandidates(selection2) {
    const svg = this.editor.getDocument();
    const skip = new Set(selection2);
    const elements = Array.from(svg.querySelectorAll("[data-element-type]")).filter((el) => !skip.has(el));
    const vertical = [];
    const horizontal = [];
    elements.forEach((el) => {
      const { x: x6, y: y6, width, height } = getElementViewportBounds(svg, el);
      vertical.push(x6, x6 + width / 2, x6 + width);
      horizontal.push(y6, y6 + height / 2, y6 + height);
    });
    return { vertical, horizontal };
  }
  getSnappedDelta(dx, dy) {
    if (!this.startBounds || !this.guideCandidates)
      return { dx, dy };
    const moving = {
      x: this.startBounds.x + dx,
      y: this.startBounds.y + dy,
      width: this.startBounds.width,
      height: this.startBounds.height
    };
    const snapX = this.getSnapOffset([moving.x, moving.x + moving.width / 2, moving.x + moving.width], this.guideCandidates.vertical);
    const snapY = this.getSnapOffset([moving.y, moving.y + moving.height / 2, moving.y + moving.height], this.guideCandidates.horizontal);
    return {
      dx: dx + ((snapX === null || snapX === void 0 ? void 0 : snapX.offset) || 0),
      dy: dy + ((snapY === null || snapY === void 0 ? void 0 : snapY.offset) || 0),
      snapX,
      snapY
    };
  }
  getSnapOffset(points, candidates, threshold = 5) {
    let best = null;
    points.forEach((point) => {
      candidates.forEach((c4) => {
        const delta = c4 - point;
        if (Math.abs(delta) <= threshold) {
          if (!best || Math.abs(delta) < Math.abs(best.offset)) {
            best = { offset: delta, at: c4 };
          }
        }
      });
    });
    return best || void 0;
  }
  ensureGuideLine(orientation) {
    const existing = orientation === "vertical" ? this.guideVertical : this.guideHorizontal;
    if (existing)
      return existing;
    const line2 = this.interaction.appendTransientElement(createElement("line", {
      stroke: "#FF7A45",
      "stroke-width": 1,
      "stroke-dasharray": "4 4",
      "pointer-events": "none",
      visibility: "hidden"
    }));
    if (orientation === "vertical")
      this.guideVertical = line2;
    else
      this.guideHorizontal = line2;
    return line2;
  }
  updateGuides(snap) {
    const svg = this.editor.getDocument();
    const { width, height } = svg.viewBox.baseVal;
    if (snap.snapX) {
      const line2 = this.ensureGuideLine("vertical");
      setAttributes(line2, {
        x1: snap.snapX.at,
        y1: 0,
        x2: snap.snapX.at,
        y2: height,
        visibility: "visible"
      });
    } else if (this.guideVertical) {
      this.guideVertical.setAttribute("visibility", "hidden");
    }
    if (snap.snapY) {
      const line2 = this.ensureGuideLine("horizontal");
      setAttributes(line2, {
        x1: 0,
        y1: snap.snapY.at,
        x2: width,
        y2: snap.snapY.at,
        visibility: "visible"
      });
    } else if (this.guideHorizontal) {
      this.guideHorizontal.setAttribute("visibility", "hidden");
    }
  }
  clearGuides() {
    var _a, _b;
    (_a = this.guideVertical) === null || _a === void 0 ? void 0 : _a.remove();
    (_b = this.guideHorizontal) === null || _b === void 0 ? void 0 : _b.remove();
    this.guideVertical = void 0;
    this.guideHorizontal = void 0;
  }
};

// node_modules/@antv/infographic/esm/editor/interactions/hotkey-history.js
var __awaiter16 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HotkeyHistory = class extends Interaction {
  constructor() {
    super(...arguments);
    this.name = "hotkey-history";
    this.handleUndo = (event) => __awaiter16(this, void 0, void 0, function* () {
      event.preventDefault();
      yield this.commander.undo();
    });
    this.handleRedo = (event) => __awaiter16(this, void 0, void 0, function* () {
      event.preventDefault();
      yield this.commander.redo();
    });
  }
  init(options) {
    super.init(options);
    this.hotkey = new Hotkey({
      filter: () => this.interaction.isActive()
    });
    this.hotkey.bind("mod+z", this.handleUndo);
    this.hotkey.bind(["mod+shift+z", "mod+y"], this.handleRedo);
  }
  destroy() {
    var _a;
    (_a = this.hotkey) === null || _a === void 0 ? void 0 : _a.destroy();
  }
};

// node_modules/@antv/infographic/esm/editor/interactions/select-highlight.js
var SelectHighlight = class extends Interaction {
  constructor() {
    super(...arguments);
    this.name = "select-highlight";
    this.highlightMasks = [];
    this.handleSelectionChanged = ({ next }) => {
      this.highlightSelection(next);
    };
    this.handleGeometryChanged = ({ target }) => {
      if (this.interaction.isSelected(target)) {
        this.highlightSelection(this.interaction.getSelection());
      }
    };
    this.handleHistoryChanged = () => {
      this.highlightSelection(this.interaction.getSelection());
    };
  }
  init(options) {
    super.init(options);
    const { emitter } = options;
    emitter.on("selection:change", this.handleSelectionChanged);
    emitter.on("selection:geometrychange", this.handleGeometryChanged);
    emitter.on("history:change", this.handleHistoryChanged);
    this.highlightSelection(this.interaction.getSelection());
  }
  destroy() {
    this.clearMasks();
    const { emitter } = this;
    emitter.off("selection:change", this.handleSelectionChanged);
    emitter.off("selection:geometrychange", this.handleGeometryChanged);
    emitter.off("history:change", this.handleHistoryChanged);
  }
  highlightSelection(selection2) {
    if (selection2.length === 1 && isEditableText(selection2[0])) {
      this.clearMasks();
      return;
    }
    this.drawElementMasks(selection2);
    this.drawCombinedBoundsMask(selection2);
  }
  drawElementMasks(selection2) {
    let index2 = 0;
    for (; index2 < selection2.length; index2++) {
      const { x: x6, y: y6, width, height } = getElementViewportBounds(this.editor.getDocument(), selection2[index2]);
      const attrs = {
        x: x6,
        y: y6,
        width,
        height,
        fill: "none",
        stroke: "#3384F5",
        "stroke-width": 1,
        "pointer-events": "none"
      };
      const mask = this.highlightMasks[index2];
      if (mask) {
        setAttributes(mask, attrs);
      } else {
        this.highlightMasks[index2] = this.interaction.appendTransientElement(createElement("rect", attrs));
      }
    }
    for (; index2 < this.highlightMasks.length; index2++) {
      this.highlightMasks[index2].remove();
    }
    this.highlightMasks = this.highlightMasks.slice(0, selection2.length);
  }
  drawCombinedBoundsMask(selection2) {
    var _a;
    if (selection2.length < 2) {
      (_a = this.combinedBoundsMask) === null || _a === void 0 ? void 0 : _a.remove();
      this.combinedBoundsMask = void 0;
      return;
    }
    const bounds = getCombinedBounds(selection2.map((element) => getElementViewportBounds(this.editor.getDocument(), element)));
    const attrs = Object.assign(Object.assign({}, bounds), { fill: "none", stroke: "#3384F5", "stroke-width": 2, "pointer-events": "none" });
    if (this.combinedBoundsMask) {
      setAttributes(this.combinedBoundsMask, attrs);
    } else {
      this.combinedBoundsMask = this.interaction.appendTransientElement(createElement("rect", attrs));
    }
  }
  clearMasks() {
    var _a;
    this.highlightMasks.forEach((mask) => mask.remove());
    this.highlightMasks = [];
    (_a = this.combinedBoundsMask) === null || _a === void 0 ? void 0 : _a.remove();
    this.combinedBoundsMask = void 0;
  }
};

// node_modules/@antv/infographic/esm/editor/interactions/zoom-wheel.js
var MIN_VIEWBOX_SIZE = 20;
var MAX_VIEWBOX_SIZE = 2e3;
var ZOOM_FACTOR = 1.1;
var ZoomWheel = class extends Interaction {
  constructor() {
    super(...arguments);
    this.name = "zoom-wheel";
    this.wheelListener = (event) => {
      if (!this.shouldZoom(event))
        return;
      event.preventDefault();
      const isZoomIn = event.deltaY < 0;
      const factor2 = isZoomIn ? 1 / ZOOM_FACTOR : ZOOM_FACTOR;
      const svg = this.editor.getDocument();
      const viewBox = getViewBox(svg);
      const { width, height } = viewBox;
      const newWidth = width * factor2;
      const newHeight = height * factor2;
      if (!inRange_default(newWidth, MIN_VIEWBOX_SIZE, MAX_VIEWBOX_SIZE) || !inRange_default(newHeight, MIN_VIEWBOX_SIZE, MAX_VIEWBOX_SIZE))
        return;
      if ((event.ctrlKey || event.metaKey) && event.shiftKey) {
        const command2 = new UpdateOptionsCommand({
          viewBox: void 0
        });
        void this.commander.execute(command2);
        return;
      }
      const pivot = (event.ctrlKey || event.metaKey) && !event.shiftKey ? this.getMousePoint(svg, event) : this.getCenterPoint(viewBox);
      const newViewBox = calculateZoomedViewBox(viewBox, factor2, pivot);
      const command = new UpdateOptionsCommand({
        viewBox: viewBoxToString(newViewBox)
      });
      void this.commander.execute(command);
    };
    this.getMousePoint = (svg, event) => {
      return clientToViewport(svg, event.clientX, event.clientY);
    };
    this.getCenterPoint = (viewBox) => {
      const centerX = viewBox.x + viewBox.width / 2;
      const centerY = viewBox.y + viewBox.height / 2;
      return { x: centerX, y: centerY };
    };
    this.shouldZoom = (event) => {
      if (!this.interaction.isActive())
        return false;
      if (event.deltaY === 0)
        return false;
      const isMouseZoom = event.ctrlKey || event.metaKey;
      const isCenterZoom = event.shiftKey;
      return isMouseZoom || isCenterZoom;
    };
  }
  init(options) {
    super.init(options);
    document.addEventListener("wheel", this.wheelListener, { passive: false });
  }
  destroy() {
    document.removeEventListener("wheel", this.wheelListener);
  }
};

// node_modules/@antv/infographic/esm/editor/plugins/base.js
var Plugin = class {
  init(options) {
    Object.assign(this, options);
  }
};

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/components/button.js
var IconButton = ({ icon, onClick, activate = false }) => {
  ensureIconButtonStyle();
  const button = document.createElement("button");
  button.type = "button";
  button.classList.add(ICON_BUTTON_CLASS);
  if (activate)
    button.setAttribute("data-activate", "true");
  if (onClick)
    button.addEventListener("click", onClick);
  const iconElement = icon();
  button.appendChild(iconElement);
  const setActivate = (next) => {
    if (next)
      button.setAttribute("data-activate", "true");
    else
      button.removeAttribute("data-activate");
  };
  return Object.assign(button, {
    setActivate: setActivate.bind(button),
    activate
  });
};
var ICON_BUTTON_CLASS = "infographic-edit-bar-icon-btn";
var ICON_BUTTON_STYLE_ID = "infographic-edit-bar-icon-btn-style";
function ensureIconButtonStyle() {
  injectStyleOnce(ICON_BUTTON_STYLE_ID, `
.${ICON_BUTTON_CLASS} {
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  font-size: 12px;
  color: #000000d9;
  border: none;
  border-radius: 6px;
  background-color: #fff;
  cursor: pointer;
  transition: color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
}
.${ICON_BUTTON_CLASS}:hover {
  background-color: #f5f5f5;
}
.${ICON_BUTTON_CLASS}:active {
  background-color: #d9d9d9;
}
.${ICON_BUTTON_CLASS}[data-activate="true"] {
  background-color: #d9d9d9;
}
`);
}

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/components/color-picker.js
var COLOR_PICKER_CLASS = "infographic-color-picker";
var COLOR_PICKER_SWATCHES_CLASS = `${COLOR_PICKER_CLASS}__swatches`;
var COLOR_PICKER_SWATCH_CLASS = `${COLOR_PICKER_CLASS}__swatch`;
var COLOR_PICKER_CONTROLS_CLASS = `${COLOR_PICKER_CLASS}__controls`;
var COLOR_PICKER_INPUT_CLASS = `${COLOR_PICKER_CLASS}__input`;
var COLOR_PICKER_FORMAT_CLASS = `${COLOR_PICKER_CLASS}__format`;
var COLOR_PICKER_SWITCH_CLASS = `${COLOR_PICKER_CLASS}__format-switch`;
var COLOR_PICKER_SWITCH_KNOB_CLASS = `${COLOR_PICKER_CLASS}__format-switch-knob`;
var COLOR_PICKER_SWITCH_LABEL_CLASS = `${COLOR_PICKER_CLASS}__format-switch-label`;
var COLOR_PICKER_STYLE_ID = "infographic-color-picker-style";
var DEFAULT_COLOR2 = "#1f1f1f";
var DEFAULT_SWATCHES = [
  "#000000",
  "#1f1f1f",
  "#434343",
  "#595959",
  "#8c8c8c",
  "#bfbfbf",
  "#d9d9d9",
  "#f0f0f0",
  "#ffffff",
  "#1677ff",
  "#2f54eb",
  "#91caff",
  "#13c2c2",
  "#36cfc9",
  "#52c41a",
  "#73d13d",
  "#fadb14",
  "#ffd666",
  "#fa8c16",
  "#fa541c",
  "#f5222d",
  "#ff7875",
  "#eb2f96",
  "#ffadd2",
  "#722ed1",
  "#9254de",
  "rgba(0, 0, 0, 0.65)",
  "rgba(255, 255, 255, 0.85)"
];
function ColorPicker(props) {
  var _a, _b, _c;
  if (typeof document === "undefined") {
    throw new Error("ColorPicker can only be used in the browser.");
  }
  ensureColorPickerStyles();
  const container = document.createElement("div");
  container.classList.add(COLOR_PICKER_CLASS);
  const swatchContainer = document.createElement("div");
  swatchContainer.classList.add(COLOR_PICKER_SWATCHES_CLASS);
  container.appendChild(swatchContainer);
  const controls = document.createElement("div");
  controls.classList.add(COLOR_PICKER_CONTROLS_CLASS);
  container.appendChild(controls);
  const input = document.createElement("input");
  input.type = "text";
  input.spellcheck = false;
  input.classList.add(COLOR_PICKER_INPUT_CLASS);
  controls.appendChild(input);
  const formatToggle = document.createElement("div");
  formatToggle.classList.add(COLOR_PICKER_FORMAT_CLASS);
  controls.appendChild(formatToggle);
  const formatSwitch = document.createElement("button");
  formatSwitch.type = "button";
  formatSwitch.classList.add(COLOR_PICKER_SWITCH_CLASS);
  formatSwitch.appendChild(createSwitchLabel("HEXA"));
  const switchKnob = document.createElement("span");
  switchKnob.classList.add(COLOR_PICKER_SWITCH_KNOB_CLASS);
  formatSwitch.appendChild(switchKnob);
  formatSwitch.appendChild(createSwitchLabel("RGBA"));
  formatToggle.appendChild(formatSwitch);
  let format2 = "hexa";
  let color3 = (_b = (_a = parseColor(props.value)) !== null && _a !== void 0 ? _a : parseColor(DEFAULT_COLOR2)) !== null && _b !== void 0 ? _b : {
    r: 31,
    g: 31,
    b: 31,
    a: 1
  };
  const swatchButtons = [];
  const swatches = ((_c = props.swatches) === null || _c === void 0 ? void 0 : _c.length) ? props.swatches : DEFAULT_SWATCHES;
  swatches.forEach((value) => {
    const parsed = parseColor(value);
    if (!parsed)
      return;
    const button = document.createElement("button");
    button.type = "button";
    button.classList.add(COLOR_PICKER_SWATCH_CLASS);
    button.style.setProperty("--swatch-color", formatColor(parsed, "rgba"));
    button.dataset.colorKey = colorKey(parsed);
    button.addEventListener("click", () => {
      setColor(parsed);
    });
    swatchContainer.appendChild(button);
    swatchButtons.push(button);
  });
  formatSwitch.addEventListener("click", () => setFormat(format2 === "hexa" ? "rgba" : "hexa", true));
  input.addEventListener("change", handleInput);
  input.addEventListener("keydown", (event) => {
    if (event.key === "Enter")
      handleInput();
  });
  syncUI();
  const api = {
    setValue: (value) => {
      const parsed = parseColor(value);
      if (!parsed) {
        input.setAttribute("data-invalid", "true");
        return;
      }
      input.removeAttribute("data-invalid");
      setColor(parsed, false);
    },
    destroy: () => {
      container.remove();
    }
  };
  return Object.assign(container, api);
  function handleInput() {
    const parsed = parseColor(input.value);
    if (!parsed) {
      input.setAttribute("data-invalid", "true");
      return;
    }
    input.removeAttribute("data-invalid");
    setColor(parsed);
  }
  function setFormat(next, emitChange) {
    var _a2;
    if (format2 === next)
      return;
    format2 = next;
    syncUI();
    if (emitChange) {
      (_a2 = props.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, formatColor(color3, format2));
    }
  }
  function setColor(next, emitChange = true) {
    var _a2;
    if (isSameColor(color3, next)) {
      syncUI();
      return;
    }
    color3 = next;
    syncUI();
    if (emitChange) {
      (_a2 = props.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, formatColor(color3, format2));
    }
  }
  function syncUI() {
    input.value = formatColor(color3, format2);
    updateSwatches();
    updateFormatButtons();
  }
  function updateSwatches() {
    const key = colorKey(color3);
    swatchButtons.forEach((btn) => {
      if (btn.dataset.colorKey === key) {
        btn.setAttribute("data-active", "true");
      } else {
        btn.removeAttribute("data-active");
      }
    });
  }
  function updateFormatButtons() {
    if (format2 === "rgba") {
      formatSwitch.setAttribute("data-format", "rgba");
    } else {
      formatSwitch.setAttribute("data-format", "hexa");
    }
  }
}
function parseColor(value) {
  var _a;
  if (!value)
    return void 0;
  const parsed = parse_default(value);
  if (!parsed || typeof parsed.r !== "number")
    return void 0;
  const rgb4 = parsed;
  return {
    r: clampByte(rgb4.r),
    g: clampByte(rgb4.g),
    b: clampByte(rgb4.b),
    a: clamp012((_a = rgb4.alpha) !== null && _a !== void 0 ? _a : 1)
  };
}
function formatColor(color3, format2) {
  if (format2 === "rgba")
    return formatRgba(color3);
  return formatHexa(color3);
}
function formatHexa(color3) {
  const r5 = toHex2(color3.r);
  const g3 = toHex2(color3.g);
  const b2 = toHex2(color3.b);
  const alpha = color3.a < 1 ? toHex2(Math.round(color3.a * 255)) : "";
  return `#${r5}${g3}${b2}${alpha}`;
}
function formatRgba(color3) {
  const alpha = trimAlpha(color3.a);
  return `rgba(${color3.r}, ${color3.g}, ${color3.b}, ${alpha})`;
}
function colorKey(color3) {
  return formatHexa(color3).toLowerCase();
}
function isSameColor(a3, b2) {
  return a3.r === b2.r && a3.g === b2.g && a3.b === b2.b && a3.a === b2.a;
}
function clamp012(value) {
  if (Number.isNaN(value))
    return 0;
  return Math.min(1, Math.max(0, value));
}
function clampByte(value) {
  if (Number.isNaN(value))
    return 0;
  const normalized = value <= 1 ? value * 255 : value;
  return Math.round(Math.min(255, Math.max(0, normalized)));
}
function toHex2(value) {
  return value.toString(16).padStart(2, "0");
}
function trimAlpha(alpha) {
  const rounded = Math.round(clamp012(alpha) * 100) / 100;
  if (rounded === 1)
    return "1";
  if (rounded === 0)
    return "0";
  return rounded.toString();
}
function createSwitchLabel(text) {
  const span = document.createElement("span");
  span.textContent = text;
  span.classList.add(COLOR_PICKER_SWITCH_LABEL_CLASS);
  return span;
}
function ensureColorPickerStyles() {
  injectStyleOnce(COLOR_PICKER_STYLE_ID, `
.${COLOR_PICKER_CLASS} {
  width: 240px;
  padding: 10px;
  box-sizing: border-box;
}
.${COLOR_PICKER_SWATCHES_CLASS} {
  display: grid;
  grid-template-columns: repeat(auto-fit, 26px);
  gap: 6px;
  margin-bottom: 10px;
}
.${COLOR_PICKER_SWATCH_CLASS} {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: 1px solid rgba(0, 0, 0, 0.06);
  background: var(--swatch-color);
  cursor: pointer;
  padding: 0;
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}
.${COLOR_PICKER_SWATCH_CLASS}[data-active="true"] {
  box-shadow: 0 0 0 2px #1677ff;
  transform: translateY(-1px);
}
.${COLOR_PICKER_SWATCH_CLASS}:hover {
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.18);
}
.${COLOR_PICKER_CONTROLS_CLASS} {
  display: flex;
  align-items: center;
  gap: 6px;
}
.${COLOR_PICKER_INPUT_CLASS} {
  flex: 1;
  min-width: 0;
  height: 30px;
  padding: 2px 6px;
  border: 1px solid #d9d9d9;
  border-radius: 6px;
  background: #f5f5f5;
  color: #262626;
  font-size: 12px;
  font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", "Courier New", monospace;
  box-sizing: border-box;
  outline: none;
  transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
}
.${COLOR_PICKER_INPUT_CLASS}:focus {
  border-color: #1677ff;
  background: #ffffff;
  box-shadow: 0 0 0 2px rgba(22, 119, 255, 0.12);
}
.${COLOR_PICKER_INPUT_CLASS}[data-invalid="true"] {
  border-color: #ff4d4f;
  box-shadow: 0 0 0 2px rgba(255, 77, 79, 0.12);
}
.${COLOR_PICKER_FORMAT_CLASS} {
  display: inline-flex;
}
.${COLOR_PICKER_SWITCH_CLASS} {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  align-items: center;
  width: 110px;
  height: 30px;
  padding: 0;
  border: 1px solid #d9d9d9;
  border-radius: 6px;
  background: #f5f5f5;
  cursor: pointer;
  overflow: hidden;
  transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
}
.${COLOR_PICKER_SWITCH_CLASS}:hover {
  background: #ededed;
}
.${COLOR_PICKER_SWITCH_CLASS}:focus-visible {
  outline: none;
  border-color: #1677ff;
  box-shadow: 0 0 0 2px rgba(22, 119, 255, 0.12);
}
.${COLOR_PICKER_SWITCH_KNOB_CLASS} {
  position: absolute;
  inset: 0;
  width: 50%;
  background: #1677ff;
  border-radius: 6px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
  transition: transform 0.2s ease;
}
.${COLOR_PICKER_SWITCH_CLASS}[data-format="rgba"] .${COLOR_PICKER_SWITCH_KNOB_CLASS} {
  transform: translateX(100%);
}
.${COLOR_PICKER_SWITCH_LABEL_CLASS} {
  position: relative;
  z-index: 1;
  text-align: center;
  font-size: 12px;
  color: #434343;
  user-select: none;
}
.${COLOR_PICKER_SWITCH_CLASS}[data-format="hexa"] .${COLOR_PICKER_SWITCH_LABEL_CLASS}:first-child,
.${COLOR_PICKER_SWITCH_CLASS}[data-format="rgba"] .${COLOR_PICKER_SWITCH_LABEL_CLASS}:last-child {
  color: #ffffff;
}
`);
}

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/components/icons.js
var createIcon2 = (children2, { viewBox = "0 0 1024 1024", size = "1.5em" } = {}) => ({ fill: fill2 = "currentColor" } = {}) => {
  const html = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}" width="${size}" height="${size}" fill="${fill2}">
${children2.trim()}
</svg>`;
  return document.createRange().createContextualFragment(html).firstElementChild;
};
var TEXT_ICONS = {
  fontFamily: createIcon2(`<path d="M236.992 938.688H145.088L469.312 128h85.376l324.224 810.688h-91.904l-102.4-256H339.392l-102.4 256z m136.512-341.376h276.992L512 251.072l-138.496 346.24z"></path>`, { size: "1.2em" }),
  fontSize: createIcon2(`<path d="M479.829333 640H202.837333l-85.333333 213.333333H25.6L298.666667 170.666667h85.333333l273.066667 682.666666h-91.904l-85.333334-213.333333z m-34.133333-85.333333L341.333333 293.76 236.970667 554.666667h208.725333zM896 534.826667V512h85.333333v341.333333h-85.333333v-22.826666a170.666667 170.666667 0 1 1 0-295.68zM810.666667 768a85.333333 85.333333 0 1 0 0-170.666667 85.333333 85.333333 0 0 0 0 170.666667z"></path>`, { size: "1.2em" }),
  align: createIcon2(`<path d="M832 96c53.02 0 96 42.98 96 96v640c0 53.02-42.98 96-96 96H192c-53.02 0-96-42.98-96-96V192c0-53.02 42.98-96 96-96z m0 64H192c-17.673 0-32 14.327-32 32v640c0 17.673 14.327 32 32 32h640c17.673 0 32-14.327 32-32V192c0-17.673-14.327-32-32-32zM725.333 672c17.673 0 32 14.327 32 32 0 17.496-14.041 31.713-31.47 31.996l-0.53 0.004H298.667c-17.673 0-32-14.327-32-32 0-17.496 14.041-31.713 31.47-31.996l0.53-0.004h426.666z m0-192c17.673 0 32 14.327 32 32 0 17.496-14.041 31.713-31.47 31.996l-0.53 0.004H298.667c-17.673 0-32-14.327-32-32 0-17.496 14.041-31.713 31.47-31.996l0.53-0.004h426.666z m0-192c17.673 0 32 14.327 32 32 0 17.496-14.041 31.713-31.47 31.996l-0.53 0.004H298.667c-17.673 0-32-14.327-32-32 0-17.496 14.041-31.713 31.47-31.996l0.53-0.004h426.666z"></path>`),
  alignTop: createIcon2(`<path d="M896 859.329c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.995l-0.53 0.005H128c-17.673 0-32-14.327-32-32 0-17.497 14.042-31.713 31.47-31.996l0.53-0.004h768z m0-121.533c17.673 0 32 14.327 32 32 0 17.497-14.042 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.995l0.53-0.005h768zM512.45 91.003L512 91a32.632 32.632 0 0 1 1.653 0.042l0.134 0.008c3.447 0.189 6.75 0.924 9.82 2.12l0.198 0.078a16.118 16.118 0 0 1 0.485 0.197l0.11 0.046a31.82 31.82 0 0 1 8.546 5.315l0.12 0.105a31.066 31.066 0 0 1 1.189 1.095l0.08 0.078 0.235 0.23 0.062 0.063 128 128.055c12.494 12.5 12.49 32.761-0.01 45.255-12.374 12.37-32.356 12.489-44.877 0.362l-0.377-0.372L544 200.28v413.598c0 17.673-14.327 32-32 32-17.496 0-31.713-14.042-31.996-31.471l-0.004-0.53V200.278l-73.368 73.4c-12.369 12.375-32.35 12.503-44.877 0.381l-0.378-0.37c-12.374-12.37-12.502-32.352-0.38-44.878l0.37-0.378 128-128.055 0.181-0.178a31.875 31.875 0 0 1 9.5-6.47l0.105-0.046c0.116-0.051 0.233-0.101 0.35-0.15 0.054-0.024 0.11-0.047 0.165-0.07a28.198 28.198 0 0 1 0.536-0.219l0.157-0.061a31.816 31.816 0 0 1 9.356-2.103l0.113-0.007c0.147-0.01 0.294-0.02 0.442-0.027l0.028-0.001 0.39-0.019 0.144-0.005a23.911 23.911 0 0 1 0.712-0.018c0.3-0.004 0.602-0.004 0.904 0z"></path>`),
  alignRight: createIcon2(`<path d="M896 800.339c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.995l-0.53 0.005H298.667c-17.673 0-32-14.327-32-32 0-17.497 14.041-31.713 31.47-31.996l0.53-0.004H896z m0-213.226c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.996l0.53-0.004h768z m0-213.226c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.996l-0.53 0.004H298.667c-17.673 0-32-14.327-32-32 0-17.496 14.041-31.713 31.47-31.996l0.53-0.004H896z m0-213.226c17.673 0 32 14.327 32 32 0 17.497-14.042 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.995l0.53-0.005h768z"></path>`),
  alignBottom: createIcon2(`<path d="M896 859.329c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.995l-0.53 0.005H128c-17.673 0-32-14.327-32-32 0-17.497 14.042-31.713 31.47-31.996l0.53-0.004h768z m0-121.533c17.673 0 32 14.327 32 32 0 17.497-14.042 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.995l0.53-0.005h768zM490.505 637.584l-0.127-0.117a32.174 32.174 0 0 1-0.633-0.596l-0.098-0.096-0.217-0.213-0.062-0.063-128-128.055c-12.494-12.499-12.49-32.76 0.01-45.254 12.374-12.37 32.356-12.489 44.877-0.362l0.377 0.371L480 536.598V123c0-17.673 14.327-32 32-32 17.496 0 31.713 14.042 31.996 31.47l0.004 0.53v413.597l73.368-73.398c12.494-12.5 32.755-12.503 45.255-0.01 12.374 12.37 12.502 32.352 0.38 44.878l-0.37 0.377-128 128.055c-0.121 0.12-0.238 0.236-0.356 0.35l0.355-0.35a31.922 31.922 0 0 1-9.68 6.649l-0.09 0.039a29.917 29.917 0 0 1-1.241 0.514 31.816 31.816 0 0 1-9.338 2.095l-0.113 0.008c-0.147 0.01-0.294 0.019-0.442 0.027h-0.028c-0.13 0.008-0.26 0.014-0.39 0.02l-0.144 0.005a23.92 23.92 0 0 1-0.796 0.019 33.927 33.927 0 0 1-0.37 0.002h-0.13l-0.236-0.002 0.366 0.002a32.633 32.633 0 0 1-1.153-0.02l-0.129-0.006a31.108 31.108 0 0 1-0.876-0.046l-0.105-0.008a31.811 31.811 0 0 1-8.926-1.931l-0.089-0.034a21.022 21.022 0 0 1-0.362-0.138l-0.098-0.04a22.132 22.132 0 0 1-0.746-0.304l-0.219-0.093-0.209-0.092a31.812 31.812 0 0 1-8.034-5.094l-0.12-0.105-0.173-0.153-0.151-0.136-0.105-0.093z"></path>`),
  alignLeft: createIcon2(`<path d="M725.333 800.339c17.673 0 32 14.327 32 32 0 17.496-14.041 31.713-31.47 31.995l-0.53 0.005H128c-17.673 0-32-14.327-32-32 0-17.497 14.042-31.713 31.47-31.996l0.53-0.004h597.333zM896 587.113c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.996l0.53-0.004h768zM725.333 373.887c17.673 0 32 14.327 32 32 0 17.496-14.041 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.996l0.53-0.004h597.333zM896 160.661c17.673 0 32 14.327 32 32 0 17.497-14.042 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.995l0.53-0.005h768z"></path>`),
  alignCenter: createIcon2(`<path d="M768 800.339c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.995l-0.53 0.005H256c-17.673 0-32-14.327-32-32 0-17.497 14.042-31.713 31.47-31.996l0.53-0.004h512z m128-213.226c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.996l0.53-0.004h768zM768 373.887c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.996l-0.53 0.004H256c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.996l0.53-0.004h512z m128-213.226c17.673 0 32 14.327 32 32 0 17.497-14.042 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.995l0.53-0.005h768z"></path>`),
  alignMiddle: createIcon2(`<path d="M534.246 617.448l0.377 0.371 128 127.952c12.5 12.494 12.503 32.755 0.009 45.255-12.37 12.374-32.352 12.501-44.878 0.38l-0.377-0.372-73.38-73.352V939c0 17.673-14.326 32-32 32-17.496 0-31.712-14.042-31.995-31.47l-0.004-0.53-0.001-221.314-73.374 73.348c-12.374 12.37-32.356 12.49-44.878 0.363l-0.377-0.371c-12.37-12.375-12.49-32.356-0.362-44.878l0.37-0.377 128-127.952c12.372-12.366 32.347-12.49 44.87-0.37zM896 480.508c17.673 0 32 14.327 32 32 0 17.497-14.042 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.995l0.53-0.005h768zM511.998 54c17.496 0 31.713 14.042 31.996 31.47l0.004 0.53-0.001 221.314 73.38-73.349c12.499-12.494 32.76-12.49 45.255 0.009 12.37 12.374 12.49 32.356 0.362 44.878l-0.37 0.377-128 127.951c-12.372 12.366-32.347 12.49-44.87 0.371l-0.377-0.37-128-127.952c-12.5-12.495-12.503-32.756-0.009-45.255 12.37-12.374 32.352-12.502 44.878-0.38l0.377 0.371 73.374 73.346V86c0-17.673 14.328-32 32-32z"></path>`)
};
var ELEMENT_ICONS = {
  align: createIcon2(`<path d="M555.188 715.059c17.673 0 32 14.327 32 32V875c0 17.673-14.327 32-32 32H171c-17.673 0-32-14.327-32-32V747.059c0-17.673 14.327-32 32-32z m-32.001 63.999H203V843h320.187v-63.942zM854 416.529c17.673 0 32 14.327 32 32v127.942c0 17.673-14.327 32-32 32H171c-17.673 0-32-14.327-32-32V448.529c0-17.673 14.327-32 32-32z m-32 64H203v63.941h619v-63.941zM683.25 118c17.673 0 32 14.327 32 32v127.941c0 17.673-14.327 32-32 32H171c-17.673 0-32-14.327-32-32V150c0-17.673 14.327-32 32-32z m-32 64H203v63.941h448.25V182z"></path>`),
  alignTop: createIcon2(`
    <path d="M661.333 272.411c17.673 0 32 14.327 32 32V902c0 17.673-14.327 32-32 32H362.667c-17.673 0-32-14.327-32-32V304.411c0-17.673 14.327-32 32-32z m-32 63.999H394.666V870h234.667V336.41zM896 101.671c17.673 0 32 14.327 32 32 0 17.497-14.042 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.995l0.53-0.005h768z" />`),
  alignRight: createIcon2(`<path d="M891.329 96c17.496 0 31.713 14.042 31.995 31.47l0.005 0.53v768c0 17.673-14.327 32-32 32-17.497 0-31.713-14.042-31.996-31.47l-0.004-0.53V128c0-17.673 14.327-32 32-32z m-170.74 234.667c17.673 0 32 14.327 32 32v298.666c0 17.673-14.327 32-32 32H123c-17.673 0-32-14.327-32-32V362.667c0-17.673 14.327-32 32-32z m-32 63.999H155v234.667h533.589V394.666z" />`),
  alignBottom: createIcon2(`<path d="M896 859.329c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.995l-0.53 0.005H128c-17.673 0-32-14.327-32-32 0-17.497 14.042-31.713 31.47-31.996l0.53-0.004h768zM661.333 91c17.673 0 32 14.327 32 32v597.589c0 17.673-14.327 32-32 32H362.667c-17.673 0-32-14.327-32-32V123c0-17.673 14.327-32 32-32z m-32 64H394.666v533.589h234.667V155z" />`),
  alignLeft: createIcon2(`<path d="M133.671 96c17.497 0 31.713 14.042 31.996 31.47l0.004 0.53v768c0 17.673-14.327 32-32 32-17.496 0-31.713-14.042-31.995-31.47l-0.005-0.53V128c0-17.673 14.327-32 32-32zM902 330.667c17.673 0 32 14.327 32 32v298.666c0 17.673-14.327 32-32 32H304.411c-17.673 0-32-14.327-32-32V362.667c0-17.673 14.327-32 32-32z m-32.001 63.999H336.41v234.667h533.589V394.666z" />`),
  alignH: createIcon2(`<path d="M512.5 96c17.496 0 31.713 14.042 31.996 31.47l0.004 0.53v202.666H875c17.496 0 31.713 14.042 31.996 31.471l0.004 0.53v298.666c0 17.673-14.327 32-32 32H544.5V896c0 17.673-14.327 32-32 32-17.496 0-31.713-14.042-31.996-31.47l-0.004-0.53V693.333H150c-17.496 0-31.713-14.041-31.996-31.47l-0.004-0.53V362.667c0-17.673 14.327-32 32-32l330.5-0.001V128c0-17.673 14.327-32 32-32z m-32 298.666H182v234.667h298.5V394.666z m362.5 0H544.5v234.667H843V394.666z" />`),
  alignV: createIcon2(`<path d="M661.333 118c17.673 0 32 14.327 32 32v330.5H896c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.996l-0.53 0.004H693.333V875c0 17.496-14.041 31.713-31.47 31.996l-0.53 0.004H362.667c-17.673 0-32-14.327-32-32l-0.001-330.5H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.996l0.53-0.004h202.666V150c0-17.496 14.042-31.713 31.471-31.996l0.53-0.004z m-32.001 426.5H394.665l0.001 298.5h234.667l-0.001-298.5z m0.001-362.5H394.666l-0.001 298.5h234.667l0.001-298.5z" />`),
  distributeH: createIcon2(`<path d="M853.333 96c17.497 0 31.713 14.042 31.996 31.47l0.004 0.53v768c0 17.673-14.327 32-32 32-17.496 0-31.713-14.042-31.995-31.47l-0.005-0.53V128c0-17.673 14.327-32 32-32z m-682.666 0c17.496 0 31.713 14.042 31.995 31.47l0.005 0.53v768c0 17.673-14.327 32-32 32-17.497 0-31.713-14.042-31.996-31.47l-0.004-0.53V128c0-17.673 14.327-32 32-32zM640 181.333c17.673 0 32 14.327 32 32v597.334c0 17.673-14.327 32-32 32H384c-17.673 0-32-14.327-32-32V213.333c0-17.673 14.327-32 32-32z m-32 64H416v533.333h192V245.333z" />`),
  distributeV: createIcon2(`<path d="M896 821.333c17.673 0 32 14.327 32 32 0 17.497-14.042 31.713-31.47 31.996l-0.53 0.004H128c-17.673 0-32-14.327-32-32 0-17.496 14.042-31.713 31.47-31.995l0.53-0.005h768zM810.667 352c17.673 0 32 14.327 32 32v256c0 17.673-14.327 32-32 32H213.333c-17.673 0-32-14.327-32-32V384c0-17.673 14.327-32 32-32z m-32 64H245.334v192h533.333V416zM896 138.667c17.673 0 32 14.327 32 32 0 17.496-14.042 31.713-31.47 31.995l-0.53 0.005H128c-17.673 0-32-14.327-32-32 0-17.497 14.042-31.713 31.47-31.996l0.53-0.004h768z" />`)
};

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/components/popover.js
var POPOVER_CLASS = "infographic-edit-popover";
var POPOVER_CONTENT_CLASS = `${POPOVER_CLASS}__content`;
var POPOVER_ARROW_CLASS = `${POPOVER_CLASS}__arrow`;
var POPOVER_STYLE_ID = "infographic-edit-popover-style";
function Popover(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  ensurePopoverStyle();
  const placement = (_a = props.placement) !== null && _a !== void 0 ? _a : "top";
  const closeOnOutsideClick = (_b = props.closeOnOutsideClick) !== null && _b !== void 0 ? _b : true;
  const triggerActions = Array.isArray(props.trigger) ? props.trigger : [props.trigger || "hover"];
  const hoverOpenDelay = (_c = props.mouseEnterDelay) !== null && _c !== void 0 ? _c : 50;
  const hoverCloseDelay = (_d = props.mouseLeaveDelay) !== null && _d !== void 0 ? _d : 150;
  const offset = (_e = props.offset) !== null && _e !== void 0 ? _e : 8;
  const arrowSize = 8;
  const arrowInnerSize = 7;
  const bodyPadding = typeof props.padding === "number" ? `${props.padding}px` : (_f = props.padding) !== null && _f !== void 0 ? _f : "4px";
  const container = document.createElement("div");
  container.classList.add(POPOVER_CLASS);
  const trigger = (_g = props.target) !== null && _g !== void 0 ? _g : document.createElement("div");
  container.appendChild(trigger);
  const getContentContainer = () => {
    const next = typeof props.getContainer === "function" ? props.getContainer() : props.getContainer;
    return next !== null && next !== void 0 ? next : document.body;
  };
  const content = document.createElement("div");
  content.classList.add(POPOVER_CONTENT_CLASS);
  setElementRole(content, COMPONENT_ROLE);
  content.dataset.placement = Array.isArray(placement) ? placement[0] : placement;
  content.setAttribute("data-open", String(Boolean(props.open)));
  content.style.setProperty("--popover-gap", `${offset}px`);
  content.style.setProperty("--popover-arrow-size", `${arrowSize}px`);
  content.style.setProperty("--popover-arrow-inner-size", `${arrowInnerSize}px`);
  const contentContainer = getContentContainer();
  const isPortal = contentContainer !== container;
  const arrow = document.createElement("div");
  arrow.classList.add(POPOVER_ARROW_CLASS);
  content.appendChild(arrow);
  const body = document.createElement("div");
  body.classList.add(`${POPOVER_CONTENT_CLASS}-body`);
  body.style.padding = bodyPadding;
  content.appendChild(body);
  contentContainer.appendChild(content);
  let open = Boolean(props.open);
  let placementPriority = Array.isArray(placement) ? placement : [placement];
  let currentPlacement = (_h = placementPriority[0]) !== null && _h !== void 0 ? _h : "top";
  const updatePosition = () => {
    var _a2;
    const targetRect = trigger.getBoundingClientRect();
    const contentRect = content.getBoundingClientRect();
    const scrollX = window.scrollX || document.documentElement.scrollLeft;
    const scrollY = window.scrollY || document.documentElement.scrollTop;
    const viewportWidth = document.documentElement.clientWidth;
    const viewportHeight = document.documentElement.clientHeight;
    let left = 0;
    let top = 0;
    const calcPosition = (placementValue) => {
      switch (placementValue) {
        case "top":
          return {
            left: scrollX + targetRect.left + targetRect.width / 2 - contentRect.width / 2,
            top: scrollY + targetRect.top - contentRect.height - offset
          };
        case "bottom":
          return {
            left: scrollX + targetRect.left + targetRect.width / 2 - contentRect.width / 2,
            top: scrollY + targetRect.bottom + offset
          };
        case "left":
          return {
            left: scrollX + targetRect.left - contentRect.width - offset,
            top: scrollY + targetRect.top + targetRect.height / 2 - contentRect.height / 2
          };
        case "right":
        default:
          return {
            left: scrollX + targetRect.right + offset,
            top: scrollY + targetRect.top + targetRect.height / 2 - contentRect.height / 2
          };
      }
    };
    const fitsViewport = (nextLeft2, nextTop) => nextLeft2 >= scrollX && nextTop >= scrollY && nextLeft2 + contentRect.width <= scrollX + viewportWidth && nextTop + contentRect.height <= scrollY + viewportHeight;
    let chosenPlacement = (_a2 = placementPriority[0]) !== null && _a2 !== void 0 ? _a2 : "top";
    let position = calcPosition(chosenPlacement);
    for (const candidate of placementPriority) {
      const nextPosition = calcPosition(candidate);
      position = nextPosition;
      if (fitsViewport(nextPosition.left, nextPosition.top)) {
        chosenPlacement = candidate;
        break;
      }
    }
    currentPlacement = chosenPlacement;
    content.dataset.placement = currentPlacement;
    if (!isPortal)
      return;
    ({ left, top } = position);
    content.style.left = `${left}px`;
    content.style.top = `${top}px`;
    content.style.right = "auto";
    content.style.bottom = "auto";
    content.style.transform = "translate(0, 0)";
  };
  if (isPortal) {
    content.style.position = "absolute";
    window.addEventListener("resize", updatePosition);
    window.addEventListener("scroll", updatePosition, true);
  }
  const setContent = (next) => {
    let nextContent = next;
    if (typeof nextContent === "function") {
      nextContent = nextContent();
    }
    body.innerHTML = "";
    if (nextContent instanceof HTMLElement) {
      body.appendChild(nextContent);
    } else {
      body.textContent = nextContent !== null && nextContent !== void 0 ? nextContent : "";
    }
    updatePosition();
  };
  const setPlacement = (next) => {
    var _a2;
    placementPriority = Array.isArray(next) ? next : [next];
    currentPlacement = (_a2 = placementPriority[0]) !== null && _a2 !== void 0 ? _a2 : "top";
    updatePosition();
  };
  const setOpen = (value) => {
    open = value;
    content.setAttribute("data-open", String(open));
    if (open)
      updatePosition();
    if (open && closeOnOutsideClick) {
      document.addEventListener("click", handleOutsideClick, true);
    } else {
      document.removeEventListener("click", handleOutsideClick, true);
    }
  };
  const toggle = () => setOpen(!open);
  const handleOutsideClick = (event) => {
    const targetNode = event.target;
    if (!container.contains(targetNode) && (isPortal ? !content.contains(targetNode) : true)) {
      setOpen(false);
    }
  };
  let openTimer;
  let closeTimer;
  const hasHover = triggerActions.includes("hover");
  const hasClick = triggerActions.includes("click");
  const clearTimers = () => {
    if (openTimer !== void 0) {
      clearTimeout(openTimer);
      openTimer = void 0;
    }
    if (closeTimer !== void 0) {
      clearTimeout(closeTimer);
      closeTimer = void 0;
    }
  };
  const handleMouseEnter = () => {
    if (!hasHover)
      return;
    clearTimers();
    openTimer = window.setTimeout(() => setOpen(true), hoverOpenDelay);
  };
  const handleMouseLeave = () => {
    if (!hasHover)
      return;
    clearTimers();
    closeTimer = window.setTimeout(() => setOpen(false), hoverCloseDelay);
  };
  if (hasClick) {
    trigger.addEventListener("click", toggle);
  }
  if (hasHover) {
    container.addEventListener("mouseenter", handleMouseEnter);
    container.addEventListener("mouseleave", handleMouseLeave);
    content.addEventListener("mouseenter", handleMouseEnter);
    content.addEventListener("mouseleave", handleMouseLeave);
  }
  setContent(props.content);
  setPlacement(placement);
  setOpen(open);
  const api = {
    setOpen,
    toggle,
    setContent,
    setPlacement,
    destroy: () => {
      document.removeEventListener("click", handleOutsideClick, true);
      if (hasClick)
        trigger.removeEventListener("click", toggle);
      if (hasHover) {
        container.removeEventListener("mouseenter", handleMouseEnter);
        container.removeEventListener("mouseleave", handleMouseLeave);
        content.removeEventListener("mouseenter", handleMouseEnter);
        content.removeEventListener("mouseleave", handleMouseLeave);
        clearTimers();
      }
      if (isPortal) {
        window.removeEventListener("resize", updatePosition);
        window.removeEventListener("scroll", updatePosition, true);
        content.remove();
      }
      container.remove();
    }
  };
  return Object.assign(container, api);
}
function ensurePopoverStyle() {
  injectStyleOnce(POPOVER_STYLE_ID, `
.${POPOVER_CLASS} {
  position: relative;
  display: inline-flex;
}
.${POPOVER_CONTENT_CLASS} {
  position: absolute;
  z-index: 1200;
  padding: 0;
  --popover-gap: 8px;
  --popover-arrow-size: 8px;
  --popover-arrow-inner-size: 7px;
  background: #fff;
  border-radius: 8px;
  border: 1px solid rgba(239, 240, 240, 0.9);
  box-shadow: rgba(0, 0, 0, 0.08) 0px 1px 2px -2px, rgba(0, 0, 0, 0.04) 0px 2px 6px, rgba(0, 0, 0, 0.02) 0px 4px 8px 1px;
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transition: opacity 120ms ease, transform 120ms ease, visibility 120ms ease;
}
.${POPOVER_CONTENT_CLASS}-body {
  padding: 4px;
  color: #000000d9;
  font-size: 12px;
  line-height: 1.5;
}
.${POPOVER_CONTENT_CLASS}[data-open="true"] {
  opacity: 1;
  visibility: visible;
  pointer-events: auto;
}
.${POPOVER_ARROW_CLASS} {
  position: absolute;
  width: 0;
  height: 0;
}
.${POPOVER_ARROW_CLASS}::after {
  content: '';
  position: absolute;
  width: 0;
  height: 0;
}
.${POPOVER_CONTENT_CLASS}[data-placement="top"] {
  left: 50%;
  bottom: calc(100% + var(--popover-gap));
  transform: translate(-50%, calc(-1 * var(--popover-gap) / 2));
}
.${POPOVER_CONTENT_CLASS}[data-placement="top"] .${POPOVER_ARROW_CLASS} {
  left: 50%;
  bottom: calc(-1 * var(--popover-arrow-size));
  transform: translateX(-50%);
  border-left: var(--popover-arrow-size) solid transparent;
  border-right: var(--popover-arrow-size) solid transparent;
  border-top: var(--popover-arrow-size) solid rgba(239, 240, 240, 0.9);
}
.${POPOVER_CONTENT_CLASS}[data-placement="top"] .${POPOVER_ARROW_CLASS}::after {
  left: 50%;
  bottom: 1px;
  transform: translateX(-50%);
  border-left: var(--popover-arrow-inner-size) solid transparent;
  border-right: var(--popover-arrow-inner-size) solid transparent;
  border-top: var(--popover-arrow-inner-size) solid #fff;
}
.${POPOVER_CONTENT_CLASS}[data-placement="top"][data-open="true"] {
  transform: translate(-50%, 0);
}
.${POPOVER_CONTENT_CLASS}[data-placement="bottom"] {
  left: 50%;
  top: calc(100% + var(--popover-gap));
  transform: translate(-50%, calc(var(--popover-gap) / 2));
}
.${POPOVER_CONTENT_CLASS}[data-placement="bottom"] .${POPOVER_ARROW_CLASS} {
  left: 50%;
  top: calc(-1 * var(--popover-arrow-size) + 2px);
  transform: translateX(-50%);
  border-left: var(--popover-arrow-size) solid transparent;
  border-right: var(--popover-arrow-size) solid transparent;
  border-bottom: var(--popover-arrow-size) solid rgba(239, 240, 240, 0.9);
}
.${POPOVER_CONTENT_CLASS}[data-placement="bottom"] .${POPOVER_ARROW_CLASS}::after {
  left: 50%;
  top: 1px;
  transform: translateX(-50%);
  border-left: var(--popover-arrow-inner-size) solid transparent;
  border-right: var(--popover-arrow-inner-size) solid transparent;
  border-bottom: var(--popover-arrow-inner-size) solid #fff;
}
.${POPOVER_CONTENT_CLASS}[data-placement="bottom"][data-open="true"] {
  transform: translate(-50%, 0);
}
.${POPOVER_CONTENT_CLASS}[data-placement="left"] {
  right: calc(100% + var(--popover-gap));
  top: 50%;
  transform: translate(calc(-1 * var(--popover-gap) / 2), -50%);
}
.${POPOVER_CONTENT_CLASS}[data-placement="left"] .${POPOVER_ARROW_CLASS} {
  right: calc(-1 * var(--popover-arrow-size) + 1px);
  top: 50%;
  transform: translateY(-50%);
  border-top: var(--popover-arrow-size) solid transparent;
  border-bottom: var(--popover-arrow-size) solid transparent;
  border-left: var(--popover-arrow-size) solid rgba(239, 240, 240, 0.9);
  border-right: 0;
}
.${POPOVER_CONTENT_CLASS}[data-placement="left"] .${POPOVER_ARROW_CLASS}::after {
  right: 1px;
  top: 50%;
  transform: translateY(-50%);
  border-top: var(--popover-arrow-inner-size) solid transparent;
  border-bottom: var(--popover-arrow-inner-size) solid transparent;
  border-left: var(--popover-arrow-inner-size) solid #fff;
  border-right: 0;
}
.${POPOVER_CONTENT_CLASS}[data-placement="left"][data-open="true"] {
  transform: translate(0, -50%);
}
.${POPOVER_CONTENT_CLASS}[data-placement="right"] {
  left: calc(100% + var(--popover-gap));
  top: 50%;
  transform: translate(calc(var(--popover-gap) / 2), -50%);
}
.${POPOVER_CONTENT_CLASS}[data-placement="right"] .${POPOVER_ARROW_CLASS} {
  left: calc(-1 * var(--popover-arrow-size) + 1px);
  top: 50%;
  transform: translateY(-50%);
  border-top: var(--popover-arrow-size) solid transparent;
  border-bottom: var(--popover-arrow-size) solid transparent;
  border-right: var(--popover-arrow-size) solid rgba(239, 240, 240, 0.9);
  border-left: 0;
}
.${POPOVER_CONTENT_CLASS}[data-placement="right"] .${POPOVER_ARROW_CLASS}::after {
  left: 1px;
  top: 50%;
  transform: translateY(-50%);
  border-top: var(--popover-arrow-inner-size) solid transparent;
  border-bottom: var(--popover-arrow-inner-size) solid transparent;
  border-right: var(--popover-arrow-inner-size) solid #fff;
}
.${POPOVER_CONTENT_CLASS}[data-placement="right"][data-open="true"] {
  transform: translate(0, -50%);
}
`);
}

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/components/select.js
var SELECT_CLASS = "infographic-edit-select";
var OPTION_CLASS = `${SELECT_CLASS}__option`;
var DROPDOWN_CLASS = `${SELECT_CLASS}__dropdown`;
var TRIGGER_CLASS = `${SELECT_CLASS}__trigger`;
var LABEL_CLASS = `${SELECT_CLASS}__label`;
var ARROW_CLASS = `${SELECT_CLASS}__arrow`;

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/edit-items/align-elements.js
var GRID_CLASS = "infographic-align-grid";
var GRID_COMPACT_CLASS = `${GRID_CLASS}--compact`;
var GRID_STYLE_ID = "infographic-align-grid-style";
var GRID_STYLES = `
.${GRID_CLASS} {
  display: grid;
  grid-template-columns: repeat(4, 32px);
  grid-auto-rows: 32px;
  gap: 2px;
}
.${GRID_COMPACT_CLASS} {
  grid-template-columns: repeat(3, 32px);
}
`;
var ALIGN_OPTIONS = [
  { icon: ELEMENT_ICONS.alignLeft, action: "LEFT" },
  { icon: ELEMENT_ICONS.alignH, action: "H_CENTER" },
  { icon: ELEMENT_ICONS.alignRight, action: "RIGHT" },
  { icon: ELEMENT_ICONS.distributeH, action: "H_DISTRIBUTE" },
  { icon: ELEMENT_ICONS.alignTop, action: "TOP" },
  { icon: ELEMENT_ICONS.alignV, action: "V_CENTER" },
  { icon: ELEMENT_ICONS.alignBottom, action: "BOTTOM" },
  { icon: ELEMENT_ICONS.distributeV, action: "V_DISTRIBUTE" }
];
var ElementAlign = (selection2, _attrs, commander, options) => {
  var _a;
  injectStyleOnce(GRID_STYLE_ID, GRID_STYLES);
  const enableDistribution = (_a = options === null || options === void 0 ? void 0 : options.enableDistribution) !== null && _a !== void 0 ? _a : true;
  const content = createAlignContent((action) => alignSelection(selection2, action, commander), enableDistribution);
  return Popover({
    target: IconButton({ icon: ELEMENT_ICONS.align }),
    content,
    placement: "top",
    offset: 12
  });
};
function createAlignContent(onSelect, enableDistribution) {
  const content = document.createElement("div");
  content.classList.add(GRID_CLASS);
  if (!enableDistribution)
    content.classList.add(GRID_COMPACT_CLASS);
  const visibleOptions = enableDistribution ? ALIGN_OPTIONS : ALIGN_OPTIONS.filter(({ action }) => action !== "H_DISTRIBUTE" && action !== "V_DISTRIBUTE");
  visibleOptions.forEach(({ icon, action }) => {
    const button = IconButton({
      icon,
      onClick: () => onSelect(action)
    });
    content.appendChild(button);
  });
  return content;
}
function alignSelection(selection2, action, commander) {
  if (!selection2.length)
    return;
  const svg = selection2[0].ownerSVGElement;
  if (!svg)
    return;
  const items3 = selection2.map((element) => createAlignableItem(element, svg)).filter(Boolean);
  if (!items3.length)
    return;
  const movable = items3.filter((item) => item.movable);
  if (!movable.length)
    return;
  const anchors = items3.filter((item) => !item.movable);
  const referenceSource = anchors.length ? anchors : items3;
  const reference = getCombinedBounds(referenceSource.map((item) => item.bounds));
  const commands = [];
  switch (action) {
    case "LEFT": {
      const target = reference.x;
      movable.forEach((item) => {
        const dx = target - item.bounds.x;
        appendCommand(commands, item, dx, 0);
      });
      break;
    }
    case "H_CENTER": {
      const target = reference.x + reference.width / 2;
      movable.forEach((item) => {
        const dx = target - (item.bounds.x + item.bounds.width / 2);
        appendCommand(commands, item, dx, 0);
      });
      break;
    }
    case "RIGHT": {
      const target = reference.x + reference.width;
      movable.forEach((item) => {
        const dx = target - (item.bounds.x + item.bounds.width);
        appendCommand(commands, item, dx, 0);
      });
      break;
    }
    case "TOP": {
      const target = reference.y;
      movable.forEach((item) => {
        const dy = target - item.bounds.y;
        appendCommand(commands, item, 0, dy);
      });
      break;
    }
    case "V_CENTER": {
      const target = reference.y + reference.height / 2;
      movable.forEach((item) => {
        const dy = target - (item.bounds.y + item.bounds.height / 2);
        appendCommand(commands, item, 0, dy);
      });
      break;
    }
    case "BOTTOM": {
      const target = reference.y + reference.height;
      movable.forEach((item) => {
        const dy = target - (item.bounds.y + item.bounds.height);
        appendCommand(commands, item, 0, dy);
      });
      break;
    }
    case "H_DISTRIBUTE": {
      distributeHorizontally(items3, commands);
      break;
    }
    case "V_DISTRIBUTE": {
      distributeVertically(items3, commands);
      break;
    }
  }
  if (commands.length)
    commander.executeBatch(commands);
}
function distributeHorizontally(items3, commands) {
  if (items3.length <= 2)
    return;
  const sorted = [...items3].sort((a3, b2) => a3.bounds.x - b2.bounds.x || a3.bounds.y - b2.bounds.y);
  const anchorIndices = collectAnchorIndices(sorted);
  for (let i4 = 0; i4 < anchorIndices.length - 1; i4++) {
    const startIndex = anchorIndices[i4];
    const endIndex = anchorIndices[i4 + 1];
    const start2 = sorted[startIndex];
    const end = sorted[endIndex];
    const segment = sorted.slice(startIndex + 1, endIndex);
    if (!segment.length)
      continue;
    const space = end.bounds.x - (start2.bounds.x + start2.bounds.width);
    const totalWidth = segment.reduce((sum, item) => sum + item.bounds.width, 0);
    const gap = (space - totalWidth) / (segment.length + 1);
    let cursor = start2.bounds.x + start2.bounds.width + gap;
    segment.forEach((item) => {
      const dx = cursor - item.bounds.x;
      appendCommand(commands, item, dx, 0);
      cursor += item.bounds.width + gap;
    });
  }
}
function distributeVertically(items3, commands) {
  if (items3.length <= 2)
    return;
  const sorted = [...items3].sort((a3, b2) => a3.bounds.y - b2.bounds.y || a3.bounds.x - b2.bounds.x);
  const anchorIndices = collectAnchorIndices(sorted);
  for (let i4 = 0; i4 < anchorIndices.length - 1; i4++) {
    const startIndex = anchorIndices[i4];
    const endIndex = anchorIndices[i4 + 1];
    const start2 = sorted[startIndex];
    const end = sorted[endIndex];
    const segment = sorted.slice(startIndex + 1, endIndex);
    if (!segment.length)
      continue;
    const space = end.bounds.y - (start2.bounds.y + start2.bounds.height);
    const totalHeight = segment.reduce((sum, item) => sum + item.bounds.height, 0);
    const gap = (space - totalHeight) / (segment.length + 1);
    let cursor = start2.bounds.y + start2.bounds.height + gap;
    segment.forEach((item) => {
      const dy = cursor - item.bounds.y;
      appendCommand(commands, item, 0, dy);
      cursor += item.bounds.height + gap;
    });
  }
}
function collectAnchorIndices(items3) {
  const anchors = /* @__PURE__ */ new Set();
  anchors.add(0);
  anchors.add(items3.length - 1);
  items3.forEach((item, index2) => {
    if (!item.movable)
      anchors.add(index2);
  });
  return Array.from(anchors).sort((a3, b2) => a3 - b2);
}
function appendCommand(commands, item, dx, dy) {
  const command = createUpdateCommand(item, dx, dy);
  if (command)
    commands.push(command);
}
function createAlignableItem(element, svg) {
  const bounds = getElementViewportBounds(svg, element);
  const movable = !isIconElement(element);
  const transformInfo = getTransformInfo(element);
  if (transformInfo) {
    return {
      element,
      bounds,
      mode: "transform",
      startX: transformInfo.x,
      startY: transformInfo.y,
      hasX: false,
      hasY: false,
      hasDataX: false,
      hasDataY: false,
      restTransform: transformInfo.rest,
      originalTransform: transformInfo.original,
      movable
    };
  }
  const { x: x6, y: y6, hasX, hasY, hasDataX, hasDataY } = getAttrInfo(element, bounds);
  return {
    element,
    bounds,
    mode: "attr",
    startX: x6,
    startY: y6,
    hasX,
    hasY,
    hasDataX,
    hasDataY,
    movable
  };
}
function createUpdateCommand(item, dx, dy) {
  if (!item.movable)
    return null;
  if (Math.abs(dx) < 1e-6 && Math.abs(dy) < 1e-6)
    return null;
  if (item.mode === "attr") {
    const x6 = item.startX + dx;
    const y6 = item.startY + dy;
    const modifiedAttrs = { x: x6, y: y6 };
    const originalAttrs = {};
    originalAttrs.x = item.hasX ? item.startX : null;
    originalAttrs.y = item.hasY ? item.startY : null;
    if (item.hasDataX) {
      modifiedAttrs["data-x"] = x6;
      originalAttrs["data-x"] = item.startX;
    }
    if (item.hasDataY) {
      modifiedAttrs["data-y"] = y6;
      originalAttrs["data-y"] = item.startY;
    }
    return new UpdateElementCommand(item.element, { attributes: modifiedAttrs }, { attributes: originalAttrs });
  }
  const transform2 = composeTransform(item.startX + dx, item.startY + dy, item.restTransform);
  const originalTransform = item.originalTransform !== void 0 ? item.originalTransform : null;
  return new UpdateElementCommand(item.element, { attributes: { transform: transform2 } }, { attributes: { transform: originalTransform } });
}
function getAttrInfo(element, bounds) {
  const attrs = getAttributes(element, ["x", "y", "data-x", "data-y"], false);
  const hasX = attrs.x !== null && attrs.x !== void 0;
  const hasY = attrs.y !== null && attrs.y !== void 0;
  const hasDataX = attrs["data-x"] !== null && attrs["data-x"] !== void 0;
  const hasDataY = attrs["data-y"] !== null && attrs["data-y"] !== void 0;
  const parseNumber2 = (value, fallback) => {
    const num3 = value !== null && value !== void 0 ? Number(value) : NaN;
    return Number.isFinite(num3) ? num3 : fallback;
  };
  const xFromAttr = parseNumber2(attrs.x, NaN);
  const yFromAttr = parseNumber2(attrs.y, NaN);
  const xFromData = parseNumber2(attrs["data-x"], NaN);
  const yFromData = parseNumber2(attrs["data-y"], NaN);
  const x6 = Number.isFinite(xFromAttr) ? xFromAttr : Number.isFinite(xFromData) ? xFromData : bounds.x;
  const y6 = Number.isFinite(yFromAttr) ? yFromAttr : Number.isFinite(yFromData) ? yFromData : bounds.y;
  return { x: x6, y: y6, hasX, hasY, hasDataX, hasDataY };
}
function getTransformInfo(element) {
  var _a;
  const transform2 = element.getAttribute("transform");
  if (transform2 === null)
    return null;
  const match = transform2.match(/translate\(\s*([-\d.]+)(?:[ ,]\s*([-\d.]+))?\s*\)/i);
  if (!match) {
    const before2 = transform2.trim();
    return {
      x: 0,
      y: 0,
      rest: { before: before2, after: "" },
      original: transform2
    };
  }
  const x6 = Number(match[1]) || 0;
  const y6 = match[2] !== void 0 ? Number(match[2]) || 0 : 0;
  const start2 = (_a = match.index) !== null && _a !== void 0 ? _a : 0;
  const before = transform2.slice(0, start2).trim();
  const after = transform2.slice(start2 + match[0].length).trim();
  const rest = { before, after };
  return { x: x6, y: y6, rest, original: transform2 };
}
function composeTransform(x6, y6, rest) {
  const translate = `translate(${x6}, ${y6})`;
  const parts = [rest === null || rest === void 0 ? void 0 : rest.before, translate, rest === null || rest === void 0 ? void 0 : rest.after].filter((part) => part && part.length);
  return parts.join(" ");
}

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/edit-items/font-align.js
var GRID_CLASS2 = "infographic-font-align-grid";
var GRID_STYLE_ID2 = "infographic-font-align-grid-style";
var HORIZONTAL_ALIGN_OPTIONS = [
  { icon: TEXT_ICONS.alignLeft, align: "LEFT" },
  { icon: TEXT_ICONS.alignCenter, align: "CENTER" },
  { icon: TEXT_ICONS.alignRight, align: "RIGHT" }
];
var VERTICAL_ALIGN_OPTIONS = [
  { icon: TEXT_ICONS.alignTop, align: "TOP" },
  { icon: TEXT_ICONS.alignMiddle, align: "MIDDLE" },
  { icon: TEXT_ICONS.alignBottom, align: "BOTTOM" }
];
var GRID_STYLES2 = `
.${GRID_CLASS2} {
  display: grid;
  grid-template-columns: repeat(3, 32px);
  grid-auto-rows: 32px;
  gap: 2px;
}
`;
var FontAlign = (selection2, attrs, commander) => {
  injectStyleOnce(GRID_STYLE_ID2, GRID_STYLES2);
  const state = {
    horizontal: attrs["data-horizontal-align"],
    vertical: attrs["data-vertical-align"]
  };
  const button = IconButton({ icon: TEXT_ICONS.align });
  const content = createAlignContent2(state, (align) => {
    const attributes = {};
    if (align.horizontal)
      attributes["data-horizontal-align"] = align.horizontal;
    if (align.vertical)
      attributes["data-vertical-align"] = align.vertical;
    if (!Object.keys(attributes).length)
      return;
    commander.executeBatch(selection2.map((text) => new UpdateElementCommand(text, {
      attributes
    })));
  });
  return Popover({
    target: button,
    content,
    placement: "top",
    offset: 12
  });
};
function createAlignContent2(state, onAlignChange) {
  const content = document.createElement("div");
  content.classList.add(GRID_CLASS2);
  const buttons = {};
  const updateAllButtons = () => {
    Object.entries(buttons).forEach(([align, button]) => {
      const isActive = align === state.horizontal || align === state.vertical;
      button.setActivate(isActive);
    });
  };
  const createButtons = (options, stateKey) => {
    options.forEach(({ icon, align }) => {
      const button = IconButton({
        icon,
        onClick: () => {
          if (state[stateKey] === align)
            return;
          Object.assign(state, { [stateKey]: align });
          updateAllButtons();
          onAlignChange(Object.assign({}, state));
        },
        activate: align === state[stateKey]
      });
      buttons[align] = button;
      content.appendChild(button);
    });
  };
  createButtons(HORIZONTAL_ALIGN_OPTIONS, "horizontal");
  createButtons(VERTICAL_ALIGN_OPTIONS, "vertical");
  return content;
}

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/edit-items/font-color.js
var FONT_COLOR_BUTTON_CLASS = "infographic-font-color-btn";
var FONT_COLOR_STYLE_ID = "infographic-font-color-style";
var DEFAULT_COLOR3 = "#1f1f1f";
var FontColor = (selection2, attrs, commander) => {
  ensureFontColorStyles();
  const color3 = normalizeColor(attrs.fill);
  const isMixed = attrs.fill === void 0 && selection2.length > 1;
  const button = document.createElement("button");
  button.type = "button";
  button.classList.add(FONT_COLOR_BUTTON_CLASS);
  setButtonColor(button, color3 !== null && color3 !== void 0 ? color3 : DEFAULT_COLOR3, isMixed);
  const picker = ColorPicker({
    value: color3 !== null && color3 !== void 0 ? color3 : DEFAULT_COLOR3,
    onChange: (nextColor) => {
      setButtonColor(button, nextColor, false);
      commander.executeBatch(selection2.map((text) => new UpdateElementCommand(text, {
        attributes: { fill: nextColor }
      })));
    }
  });
  return Popover({
    target: button,
    content: picker,
    placement: ["top", "bottom"],
    offset: 12,
    trigger: "hover",
    closeOnOutsideClick: true,
    open: false,
    padding: 0
  });
};
function normalizeColor(fill2) {
  if (!fill2)
    return void 0;
  return hasColor(fill2) ? fill2 : void 0;
}
function setButtonColor(button, color3, mixed) {
  button.style.setProperty("--infographic-font-color", color3);
  if (mixed)
    button.setAttribute("data-mixed", "true");
  else
    button.removeAttribute("data-mixed");
}
function ensureFontColorStyles() {
  injectStyleOnce(FONT_COLOR_STYLE_ID, `
.${FONT_COLOR_BUTTON_CLASS} {
  position: relative;
  width: 32px;
  height: 32px;
  padding: 0;
  border: none;
  background: #fff;
  cursor: pointer;
  transition: box-shadow 0.2s ease, border-color 0.2s ease;
}
.${FONT_COLOR_BUTTON_CLASS}::after {
  content: '';
  position: absolute;
  inset: 6px;
  border-radius: 50%;
  background: var(--infographic-font-color, ${DEFAULT_COLOR3});
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
}
.${FONT_COLOR_BUTTON_CLASS}[data-mixed="true"]::after {
  background: repeating-linear-gradient(
    45deg,
    #d9d9d9 0,
    #d9d9d9 6px,
    #f5f5f5 6px,
    #f5f5f5 12px
  );
}
`);
}

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/edit-items/font-family.js
var FONT_LIST_CLASS = "infographic-font-family-list";
var FONT_OPTION_CLASS = `${FONT_LIST_CLASS}__option`;
var FONT_LIST_STYLE_ID = "infographic-font-family-list-style";
var DEFAULT_FONT_LABEL = "\u9ED8\u8BA4";
var FontFamily = (selection2, attrs, commander) => {
  ensureFontFamilyListStyle();
  const fonts = getFonts();
  const current = normalizeFontFamily(attrs["font-family"]);
  const options = fonts.map((font) => ({
    label: font.name || font.fontFamily,
    value: font.fontFamily
  }));
  if (!options.some((option) => normalizeFontFamily(option.value) === current)) {
    options.unshift({
      label: DEFAULT_FONT_LABEL,
      value: current
    });
  }
  let selected = current;
  const content = createFontList(options, selected, (value) => {
    if (selected === value)
      return;
    selected = value;
    commander.executeBatch(selection2.map((text) => new UpdateElementCommand(text, {
      attributes: { "font-family": decodeFontFamily(value) }
    })));
  });
  const button = IconButton({ icon: TEXT_ICONS.fontFamily });
  const popover = Popover({
    target: button,
    content,
    placement: ["top", "bottom"],
    offset: 12,
    trigger: "hover",
    closeOnOutsideClick: true,
    open: false,
    padding: 0
  });
  return popover;
};
function createFontList(options, selected, onChange) {
  const content = document.createElement("div");
  content.classList.add(FONT_LIST_CLASS);
  const buttons = {};
  const updateAllButtons = (active) => {
    Object.entries(buttons).forEach(([value, button]) => {
      if (value === active)
        button.setAttribute("data-activate", "true");
      else
        button.removeAttribute("data-activate");
    });
  };
  options.forEach(({ label, value }) => {
    const button = document.createElement("button");
    button.type = "button";
    button.classList.add(FONT_OPTION_CLASS);
    button.textContent = label;
    button.style.fontFamily = value;
    if (value === selected)
      button.setAttribute("data-activate", "true");
    button.addEventListener("click", () => {
      if (selected === value)
        return;
      selected = value;
      updateAllButtons(selected);
      onChange(value);
    });
    buttons[value] = button;
    content.appendChild(button);
  });
  return content;
}
function normalizeFontFamily(font) {
  if (!font)
    return "";
  if (Array.isArray(font))
    return encodeFontFamily(font.join(", "));
  return encodeFontFamily(String(font));
}
function ensureFontFamilyListStyle() {
  injectStyleOnce(FONT_LIST_STYLE_ID, `
.${FONT_LIST_CLASS} {
  display: flex;
  flex-direction: column;
  gap: 2px;
  padding: 4px;
  min-width: 180px;
  max-height: 220px;
  overflow-y: auto;
}
.${FONT_OPTION_CLASS} {
  width: 100%;
  text-align: left;
  padding: 6px 10px;
  border: none;
  border-radius: 6px;
  background: #fff;
  cursor: pointer;
  font-size: 12px;
  color: #000000d9;
  transition: background-color 0.2s ease, color 0.2s ease;
}
.${FONT_OPTION_CLASS}:hover {
  background: #f5f5f5;
}
.${FONT_OPTION_CLASS}[data-activate="true"] {
  background: #e6f4ff;
  color: #0958d9;
}
`);
}

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/edit-items/font-size.js
var FONT_SIZE_CLASS = "infographic-font-size-grid";
var FONT_SIZE_STYLE_ID = "infographic-font-size-grid-style";
var FONT_SIZE_OPTIONS = [
  { label: "XS", value: 12 },
  { label: "S", value: 14 },
  { label: "M", value: 16 },
  { label: "L", value: 20 },
  { label: "XL", value: 24 }
];
var FONT_SIZE_STYLES = `
.${FONT_SIZE_CLASS} {
  display: grid;
  grid-template-columns: repeat(5, 32px);
  grid-auto-rows: 32px;
  gap: 2px;
}
`;
var FontSize = (selection2, attrs, commander) => {
  injectStyleOnce(FONT_SIZE_STYLE_ID, FONT_SIZE_STYLES);
  const button = IconButton({ icon: TEXT_ICONS.fontSize });
  const currentSize = normalizeFontSize2(attrs["font-size"]);
  const content = createFontSizeContent(currentSize, (size) => {
    commander.executeBatch(selection2.map((text) => new UpdateElementCommand(text, {
      attributes: { "font-size": size }
    })));
  });
  return Popover({
    target: button,
    content,
    placement: "top",
    offset: 12
  });
};
function createFontSizeContent(defaultSize, onSizeChange) {
  const content = document.createElement("div");
  content.classList.add(FONT_SIZE_CLASS);
  let selected = defaultSize;
  const buttons = {};
  const updateAllButtons = () => {
    Object.entries(buttons).forEach(([value, button]) => {
      const isActive = Number(value) === selected;
      button.setActivate(isActive);
    });
  };
  FONT_SIZE_OPTIONS.forEach(({ label, value }) => {
    const button = IconButton({
      icon: createLabelIcon(label),
      onClick: () => {
        if (selected === value)
          return;
        selected = value;
        updateAllButtons();
        onSizeChange(value);
      },
      activate: value === selected
    });
    buttons[String(value)] = button;
    content.appendChild(button);
  });
  return content;
}
function createLabelIcon(label) {
  return () => {
    const size = "1.2em";
    const span = document.createElement("span");
    span.textContent = label;
    span.style.display = "inline-flex";
    span.style.alignItems = "center";
    span.style.justifyContent = "center";
    span.style.width = size;
    span.style.height = size;
    span.style.fontSize = "12px";
    return span;
  };
}
function normalizeFontSize2(size) {
  const DEFAULT_SIZE = 12;
  if (typeof size === "number")
    return size;
  if (typeof size === "string") {
    const num3 = parseFloat(size);
    return Number.isFinite(num3) ? num3 : DEFAULT_SIZE;
  }
  return DEFAULT_SIZE;
}

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/edit-items/icon-color.js
var ICON_COLOR_BUTTON_CLASS = "infographic-icon-color-btn";
var ICON_COLOR_STYLE_ID = "infographic-icon-color-style";
var DEFAULT_COLOR4 = "#1f1f1f";
var IconColor = (selection2, attrs, commander) => {
  ensureIconColorStyles();
  const color3 = normalizeColor2(attrs.fill);
  const isMixed = attrs.fill === void 0 && selection2.length > 1;
  const button = document.createElement("button");
  button.type = "button";
  button.classList.add(ICON_COLOR_BUTTON_CLASS);
  setButtonColor2(button, color3 !== null && color3 !== void 0 ? color3 : DEFAULT_COLOR4, isMixed);
  const picker = ColorPicker({
    value: color3 !== null && color3 !== void 0 ? color3 : DEFAULT_COLOR4,
    onChange: (nextColor) => {
      setButtonColor2(button, nextColor, false);
      commander.executeBatch(selection2.map((icon) => new UpdateElementCommand(icon, {
        attributes: { fill: nextColor }
      })));
    }
  });
  return Popover({
    target: button,
    content: picker,
    placement: ["top", "bottom"],
    offset: 12,
    trigger: "hover",
    closeOnOutsideClick: true,
    open: false,
    padding: 0
  });
};
function normalizeColor2(fill2) {
  if (!fill2)
    return void 0;
  return hasColor(fill2) ? fill2 : void 0;
}
function setButtonColor2(button, color3, mixed) {
  button.style.setProperty("--infographic-icon-color", color3);
  if (mixed)
    button.setAttribute("data-mixed", "true");
  else
    button.removeAttribute("data-mixed");
}
function ensureIconColorStyles() {
  injectStyleOnce(ICON_COLOR_STYLE_ID, `
.${ICON_COLOR_BUTTON_CLASS} {
  position: relative;
  width: 32px;
  height: 32px;
  padding: 0;
  border: none;
  background: #fff;
  cursor: pointer;
  transition: box-shadow 0.2s ease, border-color 0.2s ease;
}
.${ICON_COLOR_BUTTON_CLASS}::after {
  content: '';
  position: absolute;
  inset: 6px;
  border-radius: 50%;
  background: var(--infographic-icon-color, ${DEFAULT_COLOR4});
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
}
.${ICON_COLOR_BUTTON_CLASS}[data-mixed="true"]::after {
  background: repeating-linear-gradient(
    45deg,
    #d9d9d9 0,
    #d9d9d9 6px,
    #f5f5f5 6px,
    #f5f5f5 12px
  );
}
`);
}

// node_modules/@antv/infographic/esm/editor/plugins/edit-bar/edit-bar.js
var EditBar = class extends Plugin {
  constructor(options) {
    super();
    this.options = options;
    this.name = "edit-bar";
    this.selection = [];
    this.handleSelectionChanged = ({ next }) => {
      this.selection = next;
      if (next.length === 0) {
        if (this.container)
          hideContainer(this.container);
        return;
      }
      const container = this.getOrCreateEditBar();
      const items3 = this.getEditItems(next);
      if (items3.length === 0) {
        hideContainer(container);
        return;
      }
      setContainerItems(container, items3);
      this.placeEditBar(container, next);
      showContainer(container);
    };
    this.handleGeometryChanged = ({ target }) => {
      if (!this.selection.includes(target) || !this.container)
        return;
      this.placeEditBar(this.container, this.selection);
      showContainer(this.container);
    };
    this.handleHistoryChanged = () => {
      if (!this.container || this.selection.length === 0)
        return;
      this.placeEditBar(this.container, this.selection);
      showContainer(this.container);
    };
  }
  init(options) {
    super.init(options);
    const { emitter } = options;
    emitter.on("selection:change", this.handleSelectionChanged);
    emitter.on("selection:geometrychange", this.handleGeometryChanged);
    emitter.on("history:change", this.handleHistoryChanged);
  }
  destroy() {
    var _a;
    const { emitter } = this;
    emitter.off("selection:change", this.handleSelectionChanged);
    emitter.off("selection:geometrychange", this.handleGeometryChanged);
    emitter.off("history:change", this.handleHistoryChanged);
    (_a = this.container) === null || _a === void 0 ? void 0 : _a.remove();
  }
  getEditItems(selection2) {
    let hasText = false;
    let hasIcon = false;
    let hasGeometry = false;
    for (const item of selection2) {
      if (isEditableText(item))
        hasText = true;
      else if (isIconElement(item))
        hasIcon = true;
      else if (isGeometryElement(item))
        hasGeometry = true;
      if (hasText && hasIcon && hasGeometry)
        break;
    }
    if (hasText && !hasIcon && !hasGeometry) {
      if (selection2.length === 1) {
        return this.getTextEditItems(selection2[0]);
      } else {
        return this.getTextCollectionEditItems(selection2);
      }
    }
    if (!hasText && hasIcon && !hasGeometry) {
      if (selection2.length === 1) {
        return this.getIconEditItems(selection2);
      } else {
        return this.getIconCollectionEditItems(selection2);
      }
    }
    if (!hasText && !hasIcon && hasGeometry) {
      if (selection2.length === 1) {
        return this.getGeometryEditItems(selection2);
      } else {
        return this.getGeometryCollectionEditItems(selection2);
      }
    }
    return this.getElementCollectionEditItems(selection2);
  }
  getOrCreateEditBar() {
    if (this.container)
      return this.container;
    const { style, className } = this.options || {};
    const container = document.createElement("div");
    Object.assign(container.style, Object.assign({ visibility: "hidden", position: "absolute", left: "0", top: "0", display: "flex", flexFlow: "row", justifyContent: "center", alignItems: "center", height: "40px", minWidth: "40px", minHeight: "40px", borderRadius: "8px", padding: "0 4px", backgroundColor: "#fff", border: "1px solid rgba(239, 240, 240, 0.9)", zIndex: "9999", boxShadow: "rgba(0, 0, 0, 0.08) 0px 1px 2px -2px, rgba(0, 0, 0, 0.04) 0px 2px 6px, rgba(0, 0, 0, 0.02) 0px 4px 8px 1px" }, style));
    if (className) {
      container.classList.add(className);
    }
    setElementRole(container, COMPONENT_ROLE);
    this.container = container;
    const { getContainer } = this.options || {};
    const resolvedContainer = typeof getContainer === "function" ? getContainer() : getContainer;
    const containerParent = resolvedContainer !== null && resolvedContainer !== void 0 ? resolvedContainer : document.body;
    containerParent === null || containerParent === void 0 ? void 0 : containerParent.appendChild(container);
    return container;
  }
  getTextEditItems(text) {
    const { attributes = {} } = getTextElementProps(text);
    return [FontColor, FontSize, FontAlign, FontFamily].map((item) => item([text], attributes, this.commander));
  }
  getTextCollectionEditItems(selection2) {
    const attrs = getCommonAttrs(selection2.map((text) => getTextElementProps(text).attributes || {}));
    const items3 = [FontColor, FontSize, FontAlign, FontFamily].map((item) => item(selection2, attrs, this.commander));
    const commonItems = this.getElementCollectionEditItems(selection2);
    return [...items3, ...commonItems];
  }
  getIconEditItems(selection2) {
    const attrs = getIconAttrs(selection2[0]);
    return [IconColor].map((item) => item(selection2, attrs, this.commander));
  }
  getIconCollectionEditItems(selection2) {
    const attrs = getCommonAttrs(selection2.map((icon) => getIconAttrs(icon)));
    return [IconColor].map((item) => item(selection2, attrs, this.commander));
  }
  getGeometryEditItems(_selection) {
    return [];
  }
  getGeometryCollectionEditItems(selection2) {
    const commonItems = this.getElementCollectionEditItems(selection2);
    return [...commonItems];
  }
  getElementCollectionEditItems(selection2) {
    if (selection2.length <= 1)
      return [];
    return [
      ElementAlign(selection2, {}, this.commander, {
        enableDistribution: selection2.length > 2
      })
    ];
  }
  placeEditBar(container, selection2) {
    var _a;
    if (selection2.length === 0)
      return;
    const combinedBounds = getCombinedBounds(selection2.map((element) => element.getBoundingClientRect()));
    const offsetParent = (_a = container.offsetParent) !== null && _a !== void 0 ? _a : document.documentElement;
    const viewportHeight = document.documentElement.clientHeight;
    const viewportWidth = document.documentElement.clientWidth;
    const containerRect = container.getBoundingClientRect();
    const offset = 8;
    const anchorTop = {
      x: combinedBounds.x + combinedBounds.width / 2,
      y: combinedBounds.y
    };
    const anchorBottom = {
      x: anchorTop.x,
      y: combinedBounds.y + combinedBounds.height
    };
    const clamp2 = (value, min3, max3) => Math.min(Math.max(value, min3), max3);
    const spaceAbove = anchorTop.y - offset;
    const spaceBelow = viewportHeight - anchorBottom.y - offset;
    const shouldPlaceAbove = spaceAbove >= containerRect.height || spaceAbove >= spaceBelow;
    if (offsetParent === document.body || offsetParent === document.documentElement) {
      const scrollX = window.scrollX || document.documentElement.scrollLeft;
      const scrollY = window.scrollY || document.documentElement.scrollTop;
      let left2 = scrollX + anchorTop.x - containerRect.width / 2;
      left2 = clamp2(left2, scrollX, scrollX + Math.max(viewportWidth - containerRect.width, 0));
      let top2 = shouldPlaceAbove ? scrollY + anchorTop.y - containerRect.height - offset : scrollY + anchorBottom.y + offset;
      top2 = clamp2(top2, scrollY, scrollY + Math.max(viewportHeight - containerRect.height, 0));
      container.style.left = `${left2}px`;
      container.style.top = `${top2}px`;
      return;
    }
    const parentRect = offsetParent.getBoundingClientRect();
    let left = anchorTop.x - parentRect.left - containerRect.width / 2;
    left = clamp2(left, 0, Math.max(parentRect.width - containerRect.width, 0));
    let top = shouldPlaceAbove ? anchorTop.y - parentRect.top - containerRect.height - offset : anchorBottom.y - parentRect.top + offset;
    top = clamp2(top, 0, Math.max(parentRect.height - containerRect.height, 0));
    container.style.left = `${left}px`;
    container.style.top = `${top}px`;
  }
};
function showContainer(container) {
  container.style.visibility = "visible";
}
function hideContainer(container) {
  container.style.visibility = "hidden";
}
function setContainerItems(container, items3) {
  container.innerHTML = "";
  items3.forEach((node) => {
    container.appendChild(node);
  });
}

// node_modules/@antv/infographic/esm/editor/plugins/resize-element.js
var ResizeElement = class extends Plugin {
  constructor() {
    super(...arguments);
    this.name = "resize-element";
    this.target = null;
    this.handles = [];
    this.activeHandle = null;
    this.activePointerId = null;
    this.handleSelectionChange = ({ next }) => {
      const only = next.length === 1 ? next[0] : null;
      if (only && isEditableText(only)) {
        this.target = only;
        this.updateHandles();
      } else {
        this.target = null;
        this.hideHandles();
        this.cancelDrag();
      }
    };
    this.handleDeactivate = () => {
      this.target = null;
      this.hideHandles();
      this.cancelDrag();
    };
    this.handleGeometryChange = ({ target }) => {
      if (!this.target || target !== this.target)
        return;
      const rect = this.getViewportRect(this.target);
      this.lastViewportRect = rect;
      this.updateHandles(rect);
    };
    this.handleHistoryChange = () => {
      if (!this.target)
        return;
      const rect = this.getViewportRect(this.target);
      this.lastViewportRect = rect;
      this.updateHandles(rect);
    };
    this.handlePointerMove = (event) => {
      if (!this.target || !this.startPointer || !this.startRect || !this.activeHandle || this.activePointerId !== null && event.pointerId !== this.activePointerId) {
        return;
      }
      const point = this.clientToElement(this.target, event.clientX, event.clientY);
      const dx = point.x - this.startPointer.x;
      const dy = point.y - this.startPointer.y;
      const next = this.clampRect(this.applyDelta(this.startRect, dx, dy, this.activeHandle), this.activeHandle);
      this.lastRect = next;
      this.applyRect(this.target, next);
      this.lastViewportRect = this.getViewportRect(this.target);
      this.updateHandles(this.lastViewportRect);
      this.emitSelectionGeometryChange();
    };
    this.handlePointerUp = (event) => {
      if (this.activePointerId !== null && event.pointerId !== this.activePointerId) {
        return;
      }
      const finalRect = this.lastRect;
      const original = this.startAttrs;
      const changed = finalRect && this.startRect && this.hasRectChanged(this.startRect, finalRect);
      this.cancelDrag();
      if (changed && this.target && finalRect && original) {
        this.commander.execute(new UpdateElementCommand(this.target, { attributes: finalRect }, { attributes: original }));
        this.lastViewportRect = this.getViewportRect(this.target);
        this.updateHandles(this.lastViewportRect);
        this.emitSelectionGeometryChange();
      } else if (this.target) {
        const viewportRect = this.lastViewportRect || this.getViewportRect(this.target);
        this.updateHandles(viewportRect);
      }
    };
  }
  init(options) {
    super.init(options);
    const { emitter } = options;
    emitter.on("selection:change", this.handleSelectionChange);
    emitter.on("selection:geometrychange", this.handleGeometryChange);
    emitter.on("history:change", this.handleHistoryChange);
    emitter.on("deactivated", this.handleDeactivate);
  }
  destroy() {
    this.cancelDrag();
    this.removeContainer();
    const { emitter } = this;
    emitter.off("selection:change", this.handleSelectionChange);
    emitter.off("selection:geometrychange", this.handleGeometryChange);
    emitter.off("history:change", this.handleHistoryChange);
    emitter.off("deactivated", this.handleDeactivate);
  }
  ensureContainer() {
    if (this.container)
      return this.container;
    const container = createElement("g", {
      "pointer-events": "none"
    });
    this.overlay = createElement("rect", {
      fill: "rgba(51, 132, 245, 0.06)",
      stroke: "none",
      "pointer-events": "none"
    });
    const outline = createElement("rect", {
      fill: "none",
      stroke: "#3384F5",
      "stroke-width": 1,
      "stroke-dasharray": "4 2",
      "pointer-events": "none"
    });
    container.appendChild(this.overlay);
    container.appendChild(outline);
    this.outline = outline;
    const handlePositions = ResizeElement.HANDLE_POSITIONS;
    const cursors = {
      "top-left": "nwse-resize",
      top: "ns-resize",
      "top-right": "nesw-resize",
      right: "ew-resize",
      "bottom-right": "nwse-resize",
      bottom: "ns-resize",
      "bottom-left": "nesw-resize",
      left: "ew-resize"
    };
    handlePositions.forEach((pos, index2) => {
      const isEdge = pos === "top" || pos === "right" || pos === "bottom" || pos === "left";
      const handle = isEdge ? createElement("line", {
        stroke: "transparent",
        "stroke-width": ResizeElement.LINE_STROKE_WIDTH
      }) : createElement("circle", {
        r: ResizeElement.HANDLE_SIZE / 2,
        fill: "#3384F5",
        stroke: "#fff",
        "stroke-width": 1.5
      });
      handle.style.cursor = cursors[pos];
      handle.style.pointerEvents = "all";
      handle.addEventListener("pointerdown", (event) => this.handlePointerDown(event, pos));
      handle.addEventListener("click", (event) => {
        event.stopPropagation();
        event.preventDefault();
      });
      container.appendChild(handle);
      this.handles[index2] = handle;
    });
    this.editor.getDocument().appendChild(container);
    this.container = container;
    return container;
  }
  updateHandles(rect) {
    if (!this.target) {
      this.hideHandles();
      return;
    }
    const bounds = rect || this.getViewportRect(this.target) || this.lastViewportRect || null;
    if (!bounds) {
      this.hideHandles();
      return;
    }
    this.lastViewportRect = bounds;
    const container = this.ensureContainer();
    container.style.display = "block";
    this.outline.style.display = "block";
    setAttributes(this.outline, bounds);
    if (this.overlay) {
      this.overlay.style.display = "block";
      setAttributes(this.overlay, bounds);
    }
    const points = this.getHandlePoints(bounds);
    this.handles.forEach((handle, index2) => {
      const [x6, y6] = points[index2];
      if (handle.tagName === "circle") {
        setAttributes(handle, { cx: x6, cy: y6 });
      } else {
        const pos = ResizeElement.HANDLE_POSITIONS[index2];
        const line2 = this.getHandleLine(bounds, pos);
        setAttributes(handle, line2);
      }
      handle.style.display = "block";
    });
  }
  hideHandles() {
    if (this.container)
      this.container.style.display = "none";
    if (this.outline)
      this.outline.style.display = "none";
    if (this.overlay)
      this.overlay.style.display = "none";
    this.handles.forEach((handle) => handle.style.display = "none");
  }
  removeContainer() {
    var _a;
    (_a = this.container) === null || _a === void 0 ? void 0 : _a.remove();
    this.container = void 0;
    this.outline = void 0;
    this.overlay = void 0;
    this.handles = [];
  }
  handlePointerDown(event, handle) {
    if (!this.target)
      return;
    if (event.button !== 0 && event.pointerType === "mouse")
      return;
    event.stopPropagation();
    event.preventDefault();
    const point = this.clientToElement(this.target, event.clientX, event.clientY);
    this.activeHandle = handle;
    this.activePointerId = event.pointerId;
    this.startPointer = point;
    const currentRect = this.getCurrentAttributes(this.target);
    this.startRect = currentRect;
    this.startAttrs = Object.assign({}, currentRect);
    this.lastRect = currentRect;
    this.lastViewportRect = this.getViewportRect(this.target);
    window.addEventListener("pointermove", this.handlePointerMove);
    window.addEventListener("pointerup", this.handlePointerUp);
    window.addEventListener("pointercancel", this.handlePointerUp);
  }
  cancelDrag() {
    this.activeHandle = null;
    this.activePointerId = null;
    this.startPointer = void 0;
    this.startRect = void 0;
    this.startAttrs = void 0;
    this.lastRect = void 0;
    this.lastViewportRect = void 0;
    window.removeEventListener("pointermove", this.handlePointerMove);
    window.removeEventListener("pointerup", this.handlePointerUp);
    window.removeEventListener("pointercancel", this.handlePointerUp);
  }
  applyRect(target, rect) {
    setAttributes(target, {
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    });
  }
  getViewportRect(element) {
    const { x: x6, y: y6, width, height } = getElementViewportBounds(this.editor.getDocument(), element);
    return { x: x6, y: y6, width, height };
  }
  clientToElement(element, x6, y6) {
    var _a, _b;
    const matrix = ((_a = element.getScreenCTM()) === null || _a === void 0 ? void 0 : _a.inverse()) || ((_b = this.editor.getDocument().getScreenCTM()) === null || _b === void 0 ? void 0 : _b.inverse()) || new DOMMatrix();
    return new DOMPoint(x6, y6).matrixTransform(matrix);
  }
  getCurrentAttributes(element) {
    const attrs = getAttributes(element, ["x", "y", "width", "height"], false);
    const fallback = this.getViewportRect(element);
    const getNumber = (value, backup) => {
      const numeric = value !== null ? Number(value) : NaN;
      return Number.isFinite(numeric) ? numeric : backup;
    };
    return {
      x: getNumber(attrs.x, fallback.x),
      y: getNumber(attrs.y, fallback.y),
      width: getNumber(attrs.width, fallback.width),
      height: getNumber(attrs.height, fallback.height)
    };
  }
  getHandlePoints(rect) {
    const { x: x6, y: y6, width, height } = rect;
    const cx = x6 + width / 2;
    const cy = y6 + height / 2;
    return [
      [x6, y6],
      // top-left
      [cx, y6],
      // top
      [x6 + width, y6],
      // top-right
      [x6 + width, cy],
      // right
      [x6 + width, y6 + height],
      // bottom-right
      [cx, y6 + height],
      // bottom
      [x6, y6 + height],
      // bottom-left
      [x6, cy]
      // left
    ];
  }
  applyDelta(rect, dx, dy, handle) {
    let { x: x6, y: y6, width, height } = rect;
    switch (handle) {
      case "top-left":
        x6 += dx;
        y6 += dy;
        width -= dx;
        height -= dy;
        break;
      case "top":
        y6 += dy;
        height -= dy;
        break;
      case "top-right":
        y6 += dy;
        width += dx;
        height -= dy;
        break;
      case "right":
        width += dx;
        break;
      case "bottom-right":
        width += dx;
        height += dy;
        break;
      case "bottom":
        height += dy;
        break;
      case "bottom-left":
        x6 += dx;
        width -= dx;
        height += dy;
        break;
      case "left":
        x6 += dx;
        width -= dx;
        break;
    }
    return { x: x6, y: y6, width, height };
  }
  clampRect(rect, handle) {
    let { x: x6, y: y6, width, height } = rect;
    if (width < ResizeElement.MIN_SIZE) {
      const diff = ResizeElement.MIN_SIZE - width;
      if (handle === "top-left" || handle === "bottom-left" || handle === "left")
        x6 -= diff;
      width = ResizeElement.MIN_SIZE;
    }
    if (height < ResizeElement.MIN_SIZE) {
      const diff = ResizeElement.MIN_SIZE - height;
      if (handle === "top-left" || handle === "top-right" || handle === "top")
        y6 -= diff;
      height = ResizeElement.MIN_SIZE;
    }
    return { x: x6, y: y6, width, height };
  }
  hasRectChanged(a3, b2) {
    return Math.abs(a3.x - b2.x) > 0.5 || Math.abs(a3.y - b2.y) > 0.5 || Math.abs(a3.width - b2.width) > 0.5 || Math.abs(a3.height - b2.height) > 0.5;
  }
  emitSelectionGeometryChange() {
    if (this.target && this.lastViewportRect) {
      this.emitter.emit("selection:geometrychange", {
        type: "selection:geometrychange",
        target: this.target,
        rect: this.lastViewportRect
      });
    }
  }
  getHandleLine(rect, pos) {
    const { x: x6, y: y6, width, height } = rect;
    switch (pos) {
      case "top":
        return { x1: x6, y1: y6, x2: x6 + width, y2: y6 };
      case "right":
        return { x1: x6 + width, y1: y6, x2: x6 + width, y2: y6 + height };
      case "bottom":
        return { x1: x6, y1: y6 + height, x2: x6 + width, y2: y6 + height };
      case "left":
      default:
        return { x1: x6, y1: y6, x2: x6, y2: y6 + height };
    }
  }
};
ResizeElement.HANDLE_SIZE = 10;
ResizeElement.LINE_STROKE_WIDTH = 8;
ResizeElement.MIN_SIZE = 1;
ResizeElement.HANDLE_POSITIONS = [
  "top-left",
  "top",
  "top-right",
  "right",
  "bottom-right",
  "bottom",
  "bottom-left",
  "left"
];

// node_modules/postcss/lib/postcss.mjs
var import_postcss = __toESM(require_postcss(), 1);
var postcss_default = import_postcss.default;
var stringify = import_postcss.default.stringify;
var fromJSON = import_postcss.default.fromJSON;
var plugin = import_postcss.default.plugin;
var parse2 = import_postcss.default.parse;
var list2 = import_postcss.default.list;
var document2 = import_postcss.default.document;
var comment = import_postcss.default.comment;
var atRule = import_postcss.default.atRule;
var rule = import_postcss.default.rule;
var decl = import_postcss.default.decl;
var root3 = import_postcss.default.root;
var CssSyntaxError = import_postcss.default.CssSyntaxError;
var Declaration = import_postcss.default.Declaration;
var Container = import_postcss.default.Container;
var Processor = import_postcss.default.Processor;
var Document = import_postcss.default.Document;
var Comment = import_postcss.default.Comment;
var Warning = import_postcss.default.Warning;
var AtRule = import_postcss.default.AtRule;
var Result = import_postcss.default.Result;
var Input = import_postcss.default.Input;
var Rule = import_postcss.default.Rule;
var Root = import_postcss.default.Root;
var Node3 = import_postcss.default.Node;

// node_modules/@antv/infographic/esm/exporter/font.js
var __awaiter17 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function embedFonts(svg_1) {
  return __awaiter17(this, arguments, void 0, function* (svg, embedResources = true) {
    const usedFonts = collectUsedFonts(svg);
    if (usedFonts.size === 0)
      return;
    const parsedFontsFaces = [];
    yield Promise.all(Array.from(usedFonts).map((fontFamily) => __awaiter17(this, void 0, void 0, function* () {
      const loadedFonts = getActualLoadedFontFace(fontFamily);
      if (!loadedFonts.length)
        return;
      const cssFontFaces = yield parseFontFamily(fontFamily);
      if (!cssFontFaces.length)
        return;
      const processed = yield Promise.all(cssFontFaces.map((rawFace) => __awaiter17(this, void 0, void 0, function* () {
        const fontFace = normalizeFontFace(rawFace);
        const unicodeRange = fontFace["unicode-range"].replace(/\s/g, "");
        const subset = loadedFonts.find((font) => font.unicodeRange && font.unicodeRange.replace(/\s/g, "") === unicodeRange);
        if (!subset)
          return null;
        const baseURL = getWoff2BaseURL(fontFace["font-family"], normalizeFontWeightName(fontFace["font-weight"]));
        if (!baseURL)
          return null;
        const urlMatch = fontFace.src.match(/url\(["']?(.*?\.woff2)[^"']*["']?\)/);
        if (!(urlMatch === null || urlMatch === void 0 ? void 0 : urlMatch[1]))
          return null;
        const woff2URL = join(baseURL, urlMatch[1]);
        if (embedResources) {
          const woff2DataUrl = yield loadWoff2(woff2URL);
          fontFace.src = `url(${woff2DataUrl}) format('woff2')`;
        } else {
          fontFace.src = `url(${woff2URL}) format('woff2')`;
        }
        return fontFace;
      })));
      parsedFontsFaces.push(...processed.filter(Boolean) || []);
    })));
    if (parsedFontsFaces.length > 0) {
      insertFontStyle(svg, parsedFontsFaces);
    }
  });
}
function collectUsedFonts(svg) {
  const usedFonts = /* @__PURE__ */ new Set();
  const addFamilies = (fontFamilyString) => {
    if (!fontFamilyString)
      return;
    splitFontFamily(fontFamilyString).forEach((family) => {
      const decodedFontFamily = decodeFontFamily(family);
      if (decodedFontFamily)
        usedFonts.add(decodedFontFamily);
    });
  };
  addFamilies(svg.getAttribute("font-family"));
  const textElements = svg.querySelectorAll("foreignObject span");
  for (const span of textElements) {
    addFamilies(span.style.fontFamily);
  }
  return usedFonts;
}
function parseFontFamily(fontFamily) {
  return __awaiter17(this, void 0, void 0, function* () {
    const urls = getFontURLs(fontFamily);
    const fontFaces = [];
    yield Promise.allSettled(urls.map((url) => __awaiter17(this, void 0, void 0, function* () {
      const cssText = yield fetchWithCache(url).then((res) => res.text()).catch(() => {
        console.error(`Failed to fetch font CSS: ${url}`);
        return null;
      });
      if (!cssText)
        return;
      try {
        const root4 = postcss_default.parse(cssText);
        root4.walkAtRules("font-face", (rule2) => {
          const fontFace = {};
          rule2.walkDecls((decl2) => {
            fontFace[decl2.prop] = decl2.value;
          });
          fontFaces.push(fontFace);
        });
      } catch (error) {
        console.error(`Failed to parse CSS: ${url}`, error);
      }
    })));
    return fontFaces;
  });
}
function getActualLoadedFontFace(fontFamily) {
  const fonts = [];
  const families = splitFontFamily(fontFamily).map((family) => decodeFontFamily(family));
  document.fonts.forEach((font) => {
    if (families.includes(decodeFontFamily(font.family)) && font.status === "loaded") {
      fonts.push(font);
    }
  });
  return fonts;
}
function normalizeFontFace(face) {
  var _a, _b, _c, _d, _e, _f;
  return {
    "font-family": (_a = face["font-family"]) !== null && _a !== void 0 ? _a : "",
    src: (_b = face.src) !== null && _b !== void 0 ? _b : "",
    "font-style": (_c = face["font-style"]) !== null && _c !== void 0 ? _c : "normal",
    "font-display": (_d = face["font-display"]) !== null && _d !== void 0 ? _d : "swap",
    "font-weight": (_e = face["font-weight"]) !== null && _e !== void 0 ? _e : "400",
    "unicode-range": (_f = face["unicode-range"]) !== null && _f !== void 0 ? _f : "U+0-FFFF"
  };
}
function insertFontStyle(svg, fontFaces) {
  const unique = [];
  const seen = /* @__PURE__ */ new Set();
  for (const f5 of fontFaces) {
    const key = [
      f5["font-family"],
      f5["font-weight"],
      f5["font-style"],
      f5["unicode-range"],
      f5.src
    ].join("|");
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(f5);
    }
  }
  if (unique.length === 0)
    return;
  const style = createElement("style", { type: "text/css" });
  style.innerHTML = unique.map((f5) => `
@font-face {
  font-family: ${f5["font-family"]};
  src: ${f5.src};
  font-style: ${f5["font-style"]};
  font-weight: ${f5["font-weight"]};
  font-display: ${f5["font-display"]};
  unicode-range: ${f5["unicode-range"]};
}
`.trim()).join("\n");
  const defs = svg.querySelector("defs");
  if (defs && defs.parentNode) {
    defs.parentNode.insertBefore(style, defs.nextSibling);
  } else {
    svg.insertBefore(style, svg.firstChild);
  }
}
function loadWoff2(url) {
  return __awaiter17(this, void 0, void 0, function* () {
    const response = yield fetchWithCache(url);
    if (!response.ok) {
      throw new Error(`Failed to load font: ${url}`);
    }
    const blob = yield response.blob();
    const dataUrl = yield new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        resolve(reader.result);
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    return dataUrl;
  });
}

// node_modules/@antv/infographic/esm/exporter/svg.js
var __awaiter18 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function exportToSVGString(svg_1) {
  return __awaiter18(this, arguments, void 0, function* (svg, options = {}) {
    const node = yield exportToSVG(svg, options);
    const str = new XMLSerializer().serializeToString(node);
    return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(str);
  });
}
function exportToSVG(svg_1) {
  return __awaiter18(this, arguments, void 0, function* (svg, options = {}) {
    const { embedResources = true, removeIds = false } = options;
    const clonedSVG = svg.cloneNode(true);
    const { width, height } = getViewBox(svg);
    setAttributes(clonedSVG, { width, height });
    if (removeIds) {
      inlineUseElements(clonedSVG);
      inlineDefsReferences(clonedSVG);
    } else {
      yield embedIcons(clonedSVG);
    }
    yield embedFonts(clonedSVG, embedResources);
    cleanSVG(clonedSVG);
    return clonedSVG;
  });
}
function embedIcons(svg) {
  return __awaiter18(this, void 0, void 0, function* () {
    const icons = svg.querySelectorAll("use");
    const defs = getDefs(svg);
    icons.forEach((icon) => {
      const href = icon.getAttribute("href");
      if (!href)
        return;
      const existsSymbol = svg.querySelector(href);
      if (!existsSymbol) {
        const symbolElement = document.querySelector(href);
        if (symbolElement)
          defs.appendChild(symbolElement.cloneNode(true));
      }
    });
  });
}
var iconRole = "icon-defs";
function getDefs(svg) {
  const defs = getElementByRole(svg, iconRole);
  if (defs)
    return defs;
  const _defs = createElement("defs");
  setElementRole(_defs, iconRole);
  svg.prepend(_defs);
  return _defs;
}
function inlineUseElements(svg) {
  const uses = Array.from(svg.querySelectorAll("use"));
  if (!uses.length)
    return;
  uses.forEach((use) => {
    const href = getUseHref(use);
    if (!href || !href.startsWith("#"))
      return;
    const target = resolveUseTarget(svg, href);
    if (!target || target === use)
      return;
    const replacement = createInlineElement(use, target);
    if (!replacement)
      return;
    use.replaceWith(replacement);
  });
}
function getUseHref(use) {
  var _a;
  return (_a = use.getAttribute("href")) !== null && _a !== void 0 ? _a : use.getAttribute("xlink:href");
}
function resolveUseTarget(svg, href) {
  const localTarget = svg.querySelector(href);
  if (localTarget)
    return localTarget;
  const docTarget = document.querySelector(href);
  return docTarget;
}
function createInlineElement(use, target) {
  const tag = target.tagName.toLowerCase();
  if (tag === "symbol") {
    return materializeSymbol(use, target);
  }
  if (tag === "svg") {
    return materializeSVG(use, target);
  }
  return materializeElement(use, target);
}
function materializeSymbol(use, symbol) {
  const symbolClone = symbol.cloneNode(true);
  const svg = createElement("svg");
  applyAttributes(svg, symbolClone, /* @__PURE__ */ new Set(["id"]));
  applyAttributes(svg, use, /* @__PURE__ */ new Set(["href", "xlink:href"]));
  while (symbolClone.firstChild) {
    svg.appendChild(symbolClone.firstChild);
  }
  return svg;
}
function materializeSVG(use, source) {
  const clone2 = source.cloneNode(true);
  clone2.removeAttribute("id");
  applyAttributes(clone2, use, /* @__PURE__ */ new Set(["href", "xlink:href"]));
  return clone2;
}
function materializeElement(use, source) {
  const clone2 = source.cloneNode(true);
  clone2.removeAttribute("id");
  const wrapper = createElement("g");
  applyAttributes(wrapper, use, /* @__PURE__ */ new Set(["href", "xlink:href", "x", "y", "width", "height", "transform"]));
  const transform2 = buildUseTransform(use);
  if (transform2) {
    wrapper.setAttribute("transform", transform2);
  }
  wrapper.appendChild(clone2);
  return wrapper;
}
function buildUseTransform(use) {
  var _a;
  const x6 = use.getAttribute("x");
  const y6 = use.getAttribute("y");
  const translate = x6 || y6 ? `translate(${x6 !== null && x6 !== void 0 ? x6 : 0} ${y6 !== null && y6 !== void 0 ? y6 : 0})` : "";
  const transform2 = (_a = use.getAttribute("transform")) !== null && _a !== void 0 ? _a : "";
  if (translate && transform2)
    return `${translate} ${transform2}`;
  return translate || transform2 || null;
}
function applyAttributes(target, source, exclude = /* @__PURE__ */ new Set()) {
  Array.from(source.attributes).forEach((attr) => {
    if (exclude.has(attr.name))
      return;
    if (attr.name === "style") {
      mergeStyleAttribute(target, attr.value);
      return;
    }
    if (attr.name === "class") {
      mergeClassAttribute(target, attr.value);
      return;
    }
    target.setAttribute(attr.name, attr.value);
  });
}
function mergeStyleAttribute(target, value) {
  const current = target.getAttribute("style");
  if (!current) {
    target.setAttribute("style", value);
    return;
  }
  const separator = current.trim().endsWith(";") ? "" : ";";
  target.setAttribute("style", `${current}${separator}${value}`);
}
function mergeClassAttribute(target, value) {
  const current = target.getAttribute("class");
  if (!current) {
    target.setAttribute("class", value);
    return;
  }
  target.setAttribute("class", `${current} ${value}`.trim());
}
var urlRefRegex = /url\(\s*['"]?#([^'")\s]+)['"]?\s*\)/g;
function inlineDefsReferences(svg) {
  const referencedIds = collectReferencedIds(svg);
  if (referencedIds.size === 0) {
    removeDefs(svg);
    return;
  }
  const defsDataUrl = createDefsDataUrl(svg, referencedIds);
  if (!defsDataUrl)
    return;
  traverse(svg, (node) => {
    if (node.tagName.toLowerCase() === "defs")
      return false;
    const attrs = Array.from(node.attributes);
    attrs.forEach((attr) => {
      const value = attr.value;
      if (!value.includes("url("))
        return;
      const updated = value.replace(urlRefRegex, (_match, id2) => {
        const encodedId = encodeURIComponent(id2);
        return `url("${defsDataUrl}#${encodedId}")`;
      });
      if (updated !== value)
        node.setAttribute(attr.name, updated);
    });
  });
  removeDefs(svg);
}
function collectReferencedIds(svg) {
  const ids = /* @__PURE__ */ new Set();
  traverse(svg, (node) => {
    if (node.tagName.toLowerCase() === "defs")
      return false;
    collectIdsFromAttributes(node, (id2) => ids.add(id2));
  });
  return ids;
}
function collectIdsFromAttributes(node, addId) {
  for (const attr of Array.from(node.attributes)) {
    const value = attr.value;
    if (value.includes("url(")) {
      for (const match of value.matchAll(urlRefRegex)) {
        if (match[1])
          addId(match[1]);
      }
    }
    if ((attr.name === "href" || attr.name === "xlink:href") && value[0] === "#") {
      addId(value.slice(1));
    }
  }
}
function createDefsDataUrl(svg, ids) {
  if (ids.size === 0)
    return null;
  const collected = collectDefElements(svg, ids);
  if (collected.size === 0)
    return null;
  const defsSvg = createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
  });
  const defs = createElement("defs");
  collected.forEach((node) => {
    defs.appendChild(node.cloneNode(true));
  });
  if (!defs.children.length)
    return null;
  defsSvg.appendChild(defs);
  const serialized = new XMLSerializer().serializeToString(defsSvg);
  return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(serialized);
}
function collectDefElements(svg, ids) {
  const collected = /* @__PURE__ */ new Map();
  const queue = Array.from(ids);
  const queued = new Set(queue);
  const visited = /* @__PURE__ */ new Set();
  const enqueue = (id2) => {
    if (visited.has(id2) || queued.has(id2))
      return;
    queue.push(id2);
    queued.add(id2);
  };
  while (queue.length) {
    const id2 = queue.shift();
    if (visited.has(id2))
      continue;
    visited.add(id2);
    const selector = `#${escapeCssId(id2)}`;
    const target = svg.querySelector(selector);
    if (!target)
      continue;
    collected.set(id2, target);
    traverse(target, (node) => {
      collectIdsFromAttributes(node, enqueue);
    });
  }
  return collected;
}
function escapeCssId(id2) {
  if (globalThis.CSS && typeof globalThis.CSS.escape === "function") {
    return globalThis.CSS.escape(id2);
  }
  return id2.replace(/([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g, "\\$1");
}
function removeDefs(svg) {
  const defsList = Array.from(svg.querySelectorAll("defs"));
  defsList.forEach((defs) => defs.remove());
}
function cleanSVG(svg) {
  removeBtnGroup(svg);
  removeTransientContainer(svg);
  removeUselessAttrs(svg);
  clearDataset(svg);
}
function removeBtnGroup(svg) {
  const btnGroup = getElementByRole(
    svg,
    "btns-group"
    /* ElementTypeEnum.BtnsGroup */
  );
  btnGroup === null || btnGroup === void 0 ? void 0 : btnGroup.remove();
  const btnIconDefs = getElementByRole(svg, "btn-icon-defs");
  btnIconDefs === null || btnIconDefs === void 0 ? void 0 : btnIconDefs.remove();
}
function removeTransientContainer(svg) {
  const transientContainer = svg.querySelector("[data-element-type=transient-container]");
  transientContainer === null || transientContainer === void 0 ? void 0 : transientContainer.remove();
}
function removeUselessAttrs(svg) {
  const groups = svg.querySelectorAll("g");
  groups.forEach((group) => {
    group.removeAttribute("x");
    group.removeAttribute("y");
    group.removeAttribute("width");
    group.removeAttribute("height");
  });
}
function clearDataset(svg) {
  traverse(svg, (node) => {
    for (const key in node.dataset) {
      delete node.dataset[key];
    }
  });
}

// node_modules/@antv/infographic/esm/exporter/png.js
var __awaiter19 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function exportToPNGString(svg_1) {
  return __awaiter19(this, arguments, void 0, function* (svg, options = {}) {
    var _a;
    const { dpr = (_a = globalThis.devicePixelRatio) !== null && _a !== void 0 ? _a : 2 } = options;
    const node = yield exportToSVG(svg);
    const { width, height } = getViewBox(node);
    return new Promise((resolve, reject) => {
      try {
        const canvas = document.createElement("canvas");
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Failed to get canvas context"));
          return;
        }
        ctx.scale(dpr, dpr);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        node.setAttribute("width", String(width));
        node.setAttribute("height", String(height));
        const updatedSvgData = new XMLSerializer().serializeToString(node);
        const svgURL = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(updatedSvgData);
        const img = new Image();
        img.onload = function() {
          ctx.clearRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          const pngURL = canvas.toDataURL("image/png");
          resolve(pngURL);
        };
        img.onerror = function(error) {
          reject(new Error("Image load failed: " + error));
        };
        img.src = svgURL;
      } catch (error) {
        reject(error);
      }
    });
  });
}

// node_modules/eventemitter3/index.mjs
var import_index14 = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index14.default;

// node_modules/@antv/infographic/esm/editor/managers/command.js
var __awaiter20 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CommandManager = class {
  constructor() {
    this.undoStack = [];
    this.redoStack = [];
  }
  init(options) {
    Object.assign(this, options);
  }
  execute(command) {
    return __awaiter20(this, void 0, void 0, function* () {
      yield command.apply(this.state);
      this.undoStack.push(command);
      this.redoStack = [];
      this.emitHistoryChange("execute");
    });
  }
  executeBatch(commands) {
    return __awaiter20(this, void 0, void 0, function* () {
      if (commands.length === 0)
        return;
      const batchCommand = new BatchCommand(commands);
      yield this.execute(batchCommand);
    });
  }
  undo() {
    return __awaiter20(this, void 0, void 0, function* () {
      const command = this.undoStack.pop();
      if (command) {
        yield command.undo(this.state);
        this.redoStack.push(command);
        this.emitHistoryChange("undo");
      }
    });
  }
  redo() {
    return __awaiter20(this, void 0, void 0, function* () {
      const command = this.redoStack.pop();
      if (command) {
        yield command.apply(this.state);
        this.undoStack.push(command);
        this.emitHistoryChange("redo");
      }
    });
  }
  serialize() {
    return this.undoStack.map((cmd) => cmd.serialize());
  }
  clear() {
    this.undoStack = [];
    this.redoStack = [];
  }
  canUndo() {
    return this.undoStack.length > 0;
  }
  canRedo() {
    return this.redoStack.length > 0;
  }
  getHistorySize() {
    return this.undoStack.length;
  }
  destroy() {
    this.clear();
  }
  emitHistoryChange(action) {
    var _a;
    (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit("history:change", {
      type: "history:change",
      action
    });
  }
};

// node_modules/@antv/infographic/esm/editor/managers/interaction.js
var __awaiter21 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var InteractionManager = class {
  constructor() {
    this.extensions = new Extension();
    this.interactions = [];
    this.active = false;
    this.running = null;
    this.concurrentInteractions = /* @__PURE__ */ new Set();
    this.selection = /* @__PURE__ */ new Set();
    this.handleClick = (event) => {
      const doc = this.editor.getDocument();
      const target = event.target;
      if (!target) {
        this.deactivate();
        return;
      }
      if (doc.contains(target) || isInfographicComponent(target))
        this.activate();
      else
        this.deactivate();
    };
  }
  init(options) {
    Object.assign(this, options);
    document.addEventListener("click", this.handleClick);
    this.interactions.forEach((interaction) => {
      this.extensions.register(interaction.name, interaction);
      interaction.init({
        emitter: this.emitter,
        editor: this.editor,
        commander: this.commander,
        state: this.state,
        interaction: this
      });
      this.emitter.emit("interaction:registered", interaction);
    });
  }
  isActive() {
    return this.active;
  }
  select(items3, mode) {
    const previous = this.getSelection();
    const added = [];
    const removed = [];
    if (mode === "replace") {
      const next2 = new Set(items3);
      previous.forEach((id2) => {
        if (!next2.has(id2))
          removed.push(id2);
      });
      items3.forEach((id2) => {
        if (!this.selection.has(id2))
          added.push(id2);
      });
      this.selection = next2;
    } else if (mode === "add") {
      items3.forEach((id2) => {
        if (!this.selection.has(id2)) {
          this.selection.add(id2);
          added.push(id2);
        }
      });
    } else if (mode === "remove") {
      items3.forEach((id2) => {
        if (this.selection.delete(id2)) {
          removed.push(id2);
        }
      });
    } else if (mode === "toggle") {
      items3.forEach((id2) => {
        if (this.selection.has(id2)) {
          this.selection.delete(id2);
          removed.push(id2);
        } else {
          this.selection.add(id2);
          added.push(id2);
        }
      });
    }
    const next = this.getSelection();
    const payload = {
      type: "selection:change",
      previous,
      next,
      added,
      removed,
      mode
    };
    this.emitter.emit("selection:change", payload);
  }
  getSelection() {
    return [...this.selection];
  }
  isSelected(item) {
    return this.selection.has(item);
  }
  clearSelection() {
    const previous = this.getSelection();
    this.selection.clear();
    const payload = {
      type: "selection:change",
      previous,
      next: [],
      added: [],
      removed: previous,
      mode: "replace"
    };
    this.emitter.emit("selection:change", payload);
  }
  activate() {
    this.active = true;
    this.emitter.emit("activated");
  }
  deactivate() {
    this.active = false;
    this.running = null;
    this.clearSelection();
    this.emitter.emit("deactivated");
  }
  /**
   * 
   */
  executeExclusiveInteraction(instance, callback) {
    return __awaiter21(this, void 0, void 0, function* () {
      if (!this.active || this.running)
        return;
      this.running = instance;
      try {
        this.emitter.emit("interaction:started", instance);
        yield callback();
        this.emitter.emit("interaction:ended", instance);
      } catch (error) {
        console.error(`Error occurred during exclusive interaction "${instance.name}":`, error);
        this.emitter.emit("interaction:error", instance, error);
      } finally {
        this.running = null;
      }
    });
  }
  /**
   * 
   */
  executeConcurrentInteraction(instance, callback) {
    return __awaiter21(this, void 0, void 0, function* () {
      if (!this.active)
        return;
      this.concurrentInteractions.add(instance);
      try {
        this.emitter.emit("interaction:started", instance);
        yield callback();
        this.emitter.emit("interaction:ended", instance);
      } catch (error) {
        console.error(`Error occurred during concurrent interaction "${instance.name}":`, error);
        this.emitter.emit("interaction:error", instance, error);
      } finally {
        this.concurrentInteractions.delete(instance);
      }
    });
  }
  getOrCreateTransientContainer() {
    const role = "transient-container";
    const doc = this.editor.getDocument();
    const container = getElementByRole(doc, role);
    if (container && container.isConnected)
      return container;
    const g3 = createElement("g");
    setElementRole(g3, role);
    doc.appendChild(g3);
    return g3;
  }
  appendTransientElement(element) {
    const container = this.getOrCreateTransientContainer();
    container.appendChild(element);
    return element;
  }
  destroy() {
    this.extensions.forEach((interaction) => {
      interaction.destroy();
      this.emitter.emit("interaction:destroyed", interaction);
    });
    this.extensions.destroy();
    this.active = false;
    this.running = null;
    this.clearSelection();
    document.removeEventListener("click", this.handleClick);
    this.getOrCreateTransientContainer().remove();
  }
};

// node_modules/@antv/infographic/esm/editor/managers/plugin.js
var PluginManager = class {
  constructor() {
    this.extensions = new Extension();
  }
  init(options, plugins = []) {
    Object.assign(this, options);
    plugins.forEach((plugin2) => {
      this.registerPlugin(plugin2);
    });
  }
  getPlugin(name) {
    return this.extensions.get(name);
  }
  getPlugins() {
    return this.extensions.getAll();
  }
  registerPlugin(plugin2) {
    this.extensions.register(plugin2.name, plugin2);
    const pluginInitOptions = {
      emitter: this.emitter,
      editor: this.editor,
      commander: this.commander,
      plugin: this,
      state: this.state
    };
    plugin2.init(pluginInitOptions);
    this.emitter.emit("plugin:registered", plugin2);
  }
  unregisterPlugin(name) {
    const plugin2 = this.extensions.get(name);
    if (plugin2) {
      plugin2.destroy();
      this.extensions.unregister(name);
      this.emitter.emit("plugin:unregistered", plugin2);
    }
  }
  destroy() {
    this.extensions.getAll().forEach((plugin2) => {
      this.unregisterPlugin(plugin2.name);
      this.emitter.emit("plugin:destroyed", plugin2);
    });
    this.extensions.destroy();
  }
};

// node_modules/@antv/infographic/esm/editor/managers/state.js
var StateManager = class {
  init(options) {
    Object.assign(this, options);
  }
  addItemDatum(indexes, datum2) {
    const pre = indexes.slice(0, -1);
    const last = indexes[indexes.length - 1];
    const arr = Array.isArray(datum2) ? datum2 : [datum2];
    const list3 = getChildrenDataByIndexes(this.options.data, pre);
    list3.splice(last, 0, ...arr);
    this.emitter.emit("options:data:item:add", { indexes, datum: datum2 });
    this.emitter.emit("options:change", {
      type: "options:change",
      changes: [
        {
          op: "add",
          path: "data.items",
          indexes,
          value: arr
        }
      ]
    });
  }
  updateItemDatum(indexes, datum2) {
    const item = getDatumByIndexes(this.options.data, indexes);
    Object.assign(item, datum2);
    this.emitter.emit("options:data:item:update", { indexes, datum: datum2 });
    this.emitter.emit("options:change", {
      type: "options:change",
      changes: [
        {
          op: "update",
          path: "data.items",
          indexes,
          value: datum2
        }
      ]
    });
  }
  removeItemDatum(indexes, count2 = 1) {
    const pre = indexes.slice(0, -1);
    const last = indexes[indexes.length - 1];
    const list3 = getChildrenDataByIndexes(this.options.data, pre);
    const datum2 = list3.splice(last, count2);
    this.emitter.emit("options:data:item:remove", { indexes, datum: datum2 });
    this.emitter.emit("options:change", {
      type: "options:change",
      changes: [
        {
          op: "remove",
          path: "data.items",
          indexes,
          value: datum2
        }
      ]
    });
  }
  updateData(key, value) {
    this.options.data[key] = value;
    this.emitter.emit("options:data:update", { key, value });
    this.emitter.emit("options:change", {
      type: "options:change",
      changes: [
        {
          op: "update",
          path: `data.${key}`,
          value
        }
      ]
    });
  }
  updateElement(element, props) {
    this.updateBuiltInElement(element, props);
  }
  updateOptions(options) {
    this.options = Object.assign(Object.assign({}, this.options), options);
    if (this.options.viewBox) {
      this.editor.getDocument().setAttribute("viewBox", this.options.viewBox);
    } else {
      this.editor.getDocument().removeAttribute("viewBox");
      if (this.options.padding !== void 0) {
        setSVGPadding(this.editor.getDocument(), parsePadding(this.options.padding));
      }
    }
    this.emitter.emit("options:change", {
      type: "options:change",
      changes: [
        {
          op: "update",
          path: "",
          value: options
        }
      ]
    });
  }
  getOptions() {
    return this.options;
  }
  /**
   * 
   */
  updateBuiltInElement(element, props) {
    var _a, _b;
    const { data } = this.options;
    const { attributes = {} } = props;
    const role = getElementRole(element);
    const isItemElement = isIconElement(element) || "item-label" === role || "item-desc" === role || "item-value" === role || "item-illus" === role;
    const indexes = isItemElement ? getIndexesFromElement(element) : void 0;
    if (isItemElement) {
      const datum2 = getDatumByIndexes(data, indexes);
      const key = role.replace("item-", "");
      datum2.attributes || (datum2.attributes = {});
      (_a = datum2.attributes)[key] || (_a[key] = {});
      Object.assign(datum2.attributes[key], attributes);
    } else if ("title" === role || "desc" === role || "illus" === role) {
      data.attributes || (data.attributes = {});
      (_b = data.attributes)[role] || (_b[role] = {});
      Object.assign(data.attributes[role], attributes);
    }
    this.emitter.emit("options:element:update", { element, props });
    this.emitter.emit("options:change", {
      type: "options:change",
      changes: [
        {
          op: "update",
          role,
          indexes,
          path: isItemElement ? `${buildItemPath(indexes)}.attributes.${role.replace("item-", "")}` : `data.attributes.${role}`,
          value: props
        }
      ]
    });
  }
  destroy() {
  }
};

// node_modules/@antv/infographic/esm/editor/editor.js
var Editor = class {
  constructor(emitter, document3, options) {
    this.emitter = emitter;
    this.document = document3;
    this.options = options;
    if (!document3.isConnected) {
      throw new Error("The provided document is not connected to the DOM.");
    }
    document3.style.userSelect = "none";
    const commander = new CommandManager();
    const state = new StateManager();
    const plugin2 = new PluginManager();
    const interaction = new InteractionManager();
    commander.init({ state, emitter });
    state.init({
      emitter,
      editor: this,
      commander,
      options
    });
    plugin2.init({
      emitter,
      editor: this,
      commander,
      state
    }, options.plugins);
    interaction.init({
      emitter,
      editor: this,
      commander,
      state,
      interactions: options.interactions
    });
    this.commander = commander;
    this.state = state;
    this.plugin = plugin2;
    this.interaction = interaction;
  }
  getDocument() {
    return this.document;
  }
  destroy() {
    this.document.style.userSelect = "";
    this.interaction.destroy();
    this.plugin.destroy();
    this.commander.destroy();
    this.state.destroy();
  }
};

// node_modules/@antv/infographic/esm/options/parser.js
var __rest19 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
function parseOptions(options) {
  const { container = "#container", padding = 0, template, design, theme, themeConfig, data } = options, restOptions = __rest19(options, ["container", "padding", "template", "design", "theme", "themeConfig", "data"]);
  const parsedContainer = typeof container === "string" ? document.querySelector(container) || document.createElement("div") : container;
  const templateOptions = template ? getTemplate(template) : void 0;
  const mergedThemeConfig = merge_default({}, templateOptions === null || templateOptions === void 0 ? void 0 : templateOptions.themeConfig, themeConfig);
  const resolvedThemeConfig = theme || themeConfig || (templateOptions === null || templateOptions === void 0 ? void 0 : templateOptions.themeConfig) ? parseTheme(theme, mergedThemeConfig) : void 0;
  const parsed = {
    container: parsedContainer,
    padding: parsePadding(padding)
  };
  if (templateOptions) {
    const { design: templateDesign } = templateOptions, restTemplateOptions = __rest19(templateOptions, ["design"]);
    Object.assign(parsed, restTemplateOptions);
  }
  Object.assign(parsed, restOptions);
  const parsedData = parseData(data, options.template);
  if (parsedData)
    parsed.data = parsedData;
  if (template)
    parsed.template = template;
  if ((templateOptions === null || templateOptions === void 0 ? void 0 : templateOptions.design) || design) {
    const designOptions = Object.assign(Object.assign({}, resolvedThemeConfig ? Object.assign(Object.assign({}, options), { themeConfig: resolvedThemeConfig }) : options), { data: parsedData || data });
    const parsedDesign = parseDesign(Object.assign(Object.assign({}, templateOptions === null || templateOptions === void 0 ? void 0 : templateOptions.design), design), designOptions);
    if (isNonNullableParsedDesignsOptions(parsedDesign)) {
      parsed.design = parsedDesign;
    }
  }
  if (theme)
    parsed.theme = theme;
  if (resolvedThemeConfig) {
    parsed.themeConfig = resolvedThemeConfig;
  }
  return parsed;
}
function parseData(data, template) {
  if (!data)
    return void 0;
  if (Array.isArray(data.items) && data.items.length)
    return data;
  const { lists, sequences, compares, nodes, values, root: root4 } = data;
  const getPreferredData = () => {
    if (!template)
      return null;
    const DATA_MAP = {
      list: lists,
      sequence: sequences,
      compare: compares,
      relation: nodes,
      chart: values,
      hierarchy: root4 ? [root4] : []
    };
    const prefix = template.split("-")[0];
    const arr = DATA_MAP[prefix];
    return (arr === null || arr === void 0 ? void 0 : arr.length) ? arr : null;
  };
  const getPolyfillData = () => {
    var _a;
    if (lists === null || lists === void 0 ? void 0 : lists.length)
      return lists;
    if (sequences === null || sequences === void 0 ? void 0 : sequences.length)
      return sequences;
    if (compares === null || compares === void 0 ? void 0 : compares.length)
      return compares;
    if (nodes === null || nodes === void 0 ? void 0 : nodes.length)
      return nodes;
    if (values === null || values === void 0 ? void 0 : values.length)
      return values;
    if (root4)
      return [root4];
    if ((_a = data.items) === null || _a === void 0 ? void 0 : _a.length)
      return data.items;
    return [];
  };
  let items3 = getPreferredData() || getPolyfillData();
  if (items3 === sequences && data.order === "desc") {
    items3 = [...items3].reverse();
  }
  return Object.assign(Object.assign({}, data), { items: items3 });
}
function normalizeWithType(obj) {
  if (typeof obj === "string")
    return { type: obj };
  if (!("type" in obj))
    throw new Error("Type is required");
  return obj;
}
function parseDesign(config, options) {
  const { structure, title, item, items: items3 } = config || {};
  const defaultItem = parseDesignItem(item || (items3 === null || items3 === void 0 ? void 0 : items3[0]), options);
  return {
    structure: parseDesignStructure(structure),
    title: parseDesignTitle(title, options),
    item: defaultItem,
    items: !items3 ? [defaultItem] : items3.map((item2) => parseDesignItem(item2, options))
  };
}
function parseDesignStructure(config) {
  if (!config)
    return null;
  const _a = normalizeWithType(config), { type: type2 } = _a, userProps = __rest19(_a, ["type"]);
  const structure = getStructure(type2);
  if (!structure)
    return null;
  const { component } = structure;
  return Object.assign(Object.assign({}, structure), { component: (props) => component(Object.assign(Object.assign({}, props), userProps)) });
}
function parseDesignTitle(config, options) {
  if (!config)
    return { component: null };
  const _a = normalizeWithType(config), { type: type2 } = _a, userProps = __rest19(_a, ["type"]);
  const { themeConfig } = options;
  const background = (themeConfig === null || themeConfig === void 0 ? void 0 : themeConfig.colorBg) || "#fff";
  const themeColors = generateColors(background, background);
  return {
    component: (props) => Title(Object.assign(Object.assign(Object.assign({}, props), { themeColors }), userProps))
  };
}
function parseDesignItem(config, options) {
  if (!config)
    return null;
  const _a = normalizeWithType(config), { type: type2 } = _a, userProps = __rest19(_a, ["type"]);
  const item = getItem(type2);
  if (!item)
    return null;
  const { component, options: itemOptions } = item;
  return Object.assign(Object.assign({}, item), { component: (props) => {
    var _a2;
    const { indexes } = props;
    const { data, themeConfig } = options;
    const background = (themeConfig === null || themeConfig === void 0 ? void 0 : themeConfig.colorBg) || "#fff";
    const { themeColors = generateColors(getPaletteColor(themeConfig === null || themeConfig === void 0 ? void 0 : themeConfig.palette, indexes, (_a2 = data === null || data === void 0 ? void 0 : data.items) === null || _a2 === void 0 ? void 0 : _a2.length) || (themeConfig === null || themeConfig === void 0 ? void 0 : themeConfig.colorPrimary) || "#FF356A", background) } = props, restProps = __rest19(props, ["themeColors"]);
    return component(Object.assign(Object.assign({ themeColors }, restProps), userProps));
  }, options: itemOptions });
}
function parseTheme(theme, themeConfig = {}) {
  var _a;
  const base = theme ? getTheme(theme) || {} : {};
  const parsedThemeConfig = merge_default({}, base, themeConfig);
  parsedThemeConfig.palette = themeConfig.palette || base.palette;
  parsedThemeConfig.stylize = (_a = themeConfig.stylize) !== null && _a !== void 0 ? _a : base.stylize;
  if (!parsedThemeConfig.colorPrimary) {
    parsedThemeConfig.colorPrimary = "#FF356A";
  }
  if (!parsedThemeConfig.palette) {
    parsedThemeConfig.palette = [parsedThemeConfig.colorPrimary];
  }
  return parsedThemeConfig;
}
function generateColors(colorPrimary, background = "#fff") {
  return generateThemeColors({
    colorPrimary,
    isDarkMode: isDarkColor(background),
    colorBg: background
  });
}

// node_modules/@antv/infographic/esm/syntax/parser.js
function isWhitespace(char) {
  return char === " " || char === "	";
}
function getIndentInfo(line2) {
  let indent = 0;
  let index2 = 0;
  while (index2 < line2.length) {
    const char = line2[index2];
    if (char === " ") {
      indent += 1;
      index2 += 1;
      continue;
    }
    if (char === "	") {
      indent += 2;
      index2 += 1;
      continue;
    }
    break;
  }
  return { indent, content: line2.slice(index2) };
}
function stripComments(content) {
  return content.trimEnd();
}
function looksLikeRelationExpression(text) {
  return /[<>=o.x-]{2,}/.test(text);
}
function parseKeyValue(raw) {
  const text = raw.trim();
  if (!text)
    return null;
  const match = text.match(/^([^:\s=]+)\s*[:=]\s*(.*)$/);
  if (match) {
    return { key: match[1], value: match[2].trim() };
  }
  const matchSpace = text.match(/^([^\s]+)\s+(.*)$/);
  if (matchSpace) {
    return { key: matchSpace[1], value: matchSpace[2].trim() };
  }
  return { key: text, value: void 0 };
}
function createObjectNode(line2, value) {
  return { kind: "object", line: line2, value, entries: {} };
}
function createArrayNode(line2) {
  return { kind: "array", line: line2, items: [] };
}
function parseSyntaxToAst(input) {
  const errors = [];
  const root4 = createObjectNode(0);
  const stack = [
    { indent: -1, node: root4, parent: null, key: null }
  ];
  const lines = input.split(/\r?\n/);
  lines.forEach((line2, index2) => {
    const lineNumber = index2 + 1;
    if (!line2.trim())
      return;
    const { indent, content } = getIndentInfo(line2);
    const stripped = stripComments(content);
    if (!stripped.trim())
      return;
    while (stack.length > 1 && indent <= stack[stack.length - 1].indent) {
      stack.pop();
    }
    const parentFrame = stack[stack.length - 1];
    let parentNode = parentFrame.node;
    const trimmed = stripped.trim();
    if (trimmed.startsWith("-") && (trimmed.length === 1 || isWhitespace(trimmed[1]))) {
      if (parentNode.kind !== "array") {
        if (parentNode.kind === "object" && Object.keys(parentNode.entries).length === 0 && parentNode.value === void 0 && parentFrame.parent && parentFrame.key) {
          const arrayNode = createArrayNode(parentNode.line);
          if (parentFrame.parent.kind === "object") {
            parentFrame.parent.entries[parentFrame.key] = arrayNode;
          } else if (parentFrame.parent.kind === "array") {
            const indexInParent = parentFrame.parent.items.indexOf(parentNode);
            if (indexInParent >= 0)
              parentFrame.parent.items[indexInParent] = arrayNode;
          }
          parentFrame.node = arrayNode;
          parentNode = arrayNode;
        } else {
          errors.push({
            path: "",
            line: lineNumber,
            code: "bad_list",
            message: "List item is not under an array container.",
            raw: trimmed
          });
          return;
        }
      }
      const itemContent = trimmed.slice(1).trim();
      const itemNode = createObjectNode(lineNumber, itemContent || void 0);
      parentNode.items.push(itemNode);
      stack.push({
        indent,
        node: itemNode,
        parent: parentNode
      });
      return;
    }
    if (parentFrame.key === "relations" && !trimmed.startsWith("-") && looksLikeRelationExpression(trimmed)) {
      if (parentNode.kind !== "array") {
        if (parentNode.kind === "object" && Object.keys(parentNode.entries).length === 0 && parentNode.value === void 0 && parentFrame.parent && parentFrame.key) {
          const arrayNode = createArrayNode(parentNode.line);
          if (parentFrame.parent.kind === "object") {
            parentFrame.parent.entries[parentFrame.key] = arrayNode;
          } else if (parentFrame.parent.kind === "array") {
            const indexInParent = parentFrame.parent.items.indexOf(parentNode);
            if (indexInParent >= 0)
              parentFrame.parent.items[indexInParent] = arrayNode;
          }
          parentFrame.node = arrayNode;
          parentNode = arrayNode;
        } else {
          errors.push({
            path: "",
            line: lineNumber,
            code: "bad_list",
            message: "List item is not under an array container.",
            raw: trimmed
          });
          return;
        }
      }
      const itemNode = createObjectNode(lineNumber, trimmed);
      parentNode.items.push(itemNode);
      stack.push({
        indent,
        node: itemNode,
        parent: parentNode
      });
      return;
    }
    const parsed = parseKeyValue(trimmed);
    if (!parsed) {
      errors.push({
        path: "",
        line: lineNumber,
        code: "bad_syntax",
        message: "Invalid syntax line.",
        raw: trimmed
      });
      return;
    }
    if (parentNode.kind !== "object") {
      errors.push({
        path: "",
        line: lineNumber,
        code: "bad_syntax",
        message: "Key-value pair is not under an object container.",
        raw: trimmed
      });
      return;
    }
    const node = createObjectNode(lineNumber, parsed.value);
    parentNode.entries[parsed.key] = node;
    stack.push({
      indent,
      node,
      parent: parentNode,
      key: parsed.key
    });
  });
  return { ast: root4, errors };
}
function parseInlineKeyValue(value) {
  return parseKeyValue(value);
}

// node_modules/@antv/infographic/esm/syntax/mapper.js
function createValueNode(value, line2) {
  return { kind: "value", line: line2, value };
}
var HEX_COLOR_PATTERN = /^(#[0-9a-f]{8}|#[0-9a-f]{6}|#[0-9a-f]{4}|#[0-9a-f]{3})/i;
var FUNCTION_COLOR_PATTERN = /^((?:rgb|rgba|hsl|hsla)\([^)]*\))/i;
function parseScalar(value) {
  const trimmed = value.trim();
  if (trimmed === "true")
    return true;
  if (trimmed === "false")
    return false;
  if (/^-?\d+(\.\d+)?$/.test(trimmed))
    return parseFloat(trimmed);
  return trimmed;
}
function readScalar(node) {
  if (node.kind === "value")
    return node.value;
  if (node.kind === "object")
    return node.value;
  return void 0;
}
function addError(errors, node, path2, code, message, raw) {
  errors.push({
    path: path2,
    line: node.line,
    code,
    message,
    raw
  });
}
function splitArrayValue(value, split = "any") {
  let text = value.trim();
  if (text.startsWith("[") && text.endsWith("]")) {
    text = text.slice(1, -1).trim();
  }
  if (!text)
    return [];
  let parts;
  if (split === "comma") {
    parts = text.split(",");
  } else if (split === "space") {
    parts = text.split(/\s+/);
  } else {
    parts = text.split(/[,\s]+/);
  }
  const normalized = [];
  for (const part of parts) {
    const trimmedPart = part.trim();
    if (!trimmedPart)
      continue;
    if (trimmedPart === "#" || trimmedPart === "//")
      break;
    normalized.push(trimmedPart);
  }
  return normalized;
}
function stripColorComments(value) {
  let trimmed = value.trim();
  const hashIndex = trimmed.search(/\s+#(?![0-9a-f])/i);
  if (hashIndex >= 0) {
    trimmed = trimmed.slice(0, hashIndex).trimEnd();
  }
  const slashIndex = trimmed.indexOf("//");
  if (slashIndex >= 0) {
    trimmed = trimmed.slice(0, slashIndex).trimEnd();
  }
  return trimmed;
}
function normalizeExplicitColor(value) {
  const trimmed = stripColorComments(value);
  if (!trimmed)
    return void 0;
  const hexMatch = trimmed.match(HEX_COLOR_PATTERN);
  if (hexMatch && hexMatch[0].length === trimmed.length) {
    return trimmed;
  }
  const funcMatch = trimmed.match(FUNCTION_COLOR_PATTERN);
  if (funcMatch && funcMatch[1].length === trimmed.length) {
    return trimmed;
  }
  if (tinycolor(trimmed).isValid())
    return trimmed;
  return void 0;
}
function mapColor(node, path2, errors, options = {}) {
  const value = readScalar(node);
  if (value === void 0) {
    addError(errors, node, path2, "schema_mismatch", "Expected color value.");
    return void 0;
  }
  const normalized = normalizeExplicitColor(value);
  if (!normalized) {
    if (!options.soft) {
      addError(errors, node, path2, "invalid_value", "Invalid color value.", value);
    }
    return void 0;
  }
  return normalized;
}
function shouldTreatPaletteStringAsArray(trimmed, parts) {
  if (parts.length > 1)
    return true;
  if (trimmed.startsWith("[") && trimmed.endsWith("]"))
    return true;
  return normalizeExplicitColor(trimmed) !== void 0;
}
function mapUnknown(node) {
  if (node.kind === "array") {
    return node.items.map((item) => mapUnknown(item));
  }
  if (node.kind === "value")
    return parseScalar(node.value);
  const hasEntries = Object.keys(node.entries).length > 0;
  if (!hasEntries && node.value !== void 0) {
    return parseScalar(node.value);
  }
  const result = {};
  if (node.value !== void 0) {
    result.value = parseScalar(node.value);
  }
  Object.entries(node.entries).forEach(([key, child]) => {
    result[key] = mapUnknown(child);
  });
  return result;
}
function mapUnion(node, schema, path2, errors) {
  let bestValue = void 0;
  let bestErrors = null;
  for (const variant of schema.variants) {
    const variantErrors = [];
    const value = mapWithSchema(node, variant, path2, variantErrors);
    if (bestErrors === null || variantErrors.length < bestErrors.length) {
      bestErrors = variantErrors;
      bestValue = value;
    }
  }
  if (bestErrors)
    errors.push(...bestErrors);
  return bestValue;
}
function mapWithSchema(node, schema, path2, errors) {
  switch (schema.kind) {
    case "union":
      return mapUnion(node, schema, path2, errors);
    case "string": {
      const value = readScalar(node);
      if (value === void 0) {
        addError(errors, node, path2, "schema_mismatch", "Expected string value.");
        return void 0;
      }
      return value;
    }
    case "number": {
      const value = readScalar(node);
      if (value === void 0) {
        addError(errors, node, path2, "schema_mismatch", "Expected number value.");
        return void 0;
      }
      const trimmed = value.trim();
      const match = trimmed.match(/^(-?\d+(\.\d+)?)(?:\s*(#|\/\/).*)?$/);
      if (!match) {
        addError(errors, node, path2, "invalid_value", "Invalid number value.", value);
        return void 0;
      }
      return parseFloat(match[1]);
    }
    case "boolean": {
      const value = readScalar(node);
      if (value === void 0) {
        addError(errors, node, path2, "schema_mismatch", "Expected boolean value.");
        return void 0;
      }
      if (value !== "true" && value !== "false") {
        addError(errors, node, path2, "invalid_value", "Invalid boolean value.", value);
        return void 0;
      }
      return value === "true";
    }
    case "enum": {
      const value = readScalar(node);
      if (value === void 0) {
        addError(errors, node, path2, "schema_mismatch", "Expected enum value.");
        return void 0;
      }
      if (!schema.values.includes(value)) {
        addError(errors, node, path2, "invalid_value", "Invalid enum value.", value);
        return void 0;
      }
      return value;
    }
    case "array": {
      if (node.kind === "array") {
        return node.items.map((item, index2) => mapWithSchema(item, schema.item, `${path2}[${index2}]`, errors)).filter((value) => value !== void 0);
      }
      if (node.kind === "object" && Object.keys(node.entries).length > 0) {
        addError(errors, node, path2, "schema_mismatch", "Expected array value.");
        return void 0;
      }
      const scalar = readScalar(node);
      if (scalar === void 0) {
        addError(errors, node, path2, "schema_mismatch", "Expected array value.");
        return void 0;
      }
      const trimmed = scalar.trim();
      if (trimmed.startsWith("[") && !trimmed.endsWith("]")) {
        return void 0;
      }
      const parts = splitArrayValue(scalar, schema.split);
      return parts.map((part, index2) => mapWithSchema(createValueNode(part, node.line), schema.item, `${path2}[${index2}]`, errors)).filter((value) => value !== void 0);
    }
    case "palette": {
      if (node.kind === "array") {
        const values = mapWithSchema(node, { kind: "array", item: { kind: "color" }, split: "any" }, path2, errors);
        return Array.isArray(values) && values.length > 0 ? values : void 0;
      }
      if (node.kind === "object" && Object.keys(node.entries).length > 0) {
        addError(errors, node, path2, "schema_mismatch", "Expected palette value.");
        return void 0;
      }
      const scalar = readScalar(node);
      if (scalar === void 0) {
        addError(errors, node, path2, "schema_mismatch", "Expected palette value.");
        return void 0;
      }
      const trimmed = scalar.trim();
      if (trimmed.startsWith("[") && !trimmed.endsWith("]")) {
        return void 0;
      }
      const directColor = normalizeExplicitColor(trimmed);
      if (directColor) {
        return [directColor];
      }
      const parts = splitArrayValue(scalar, "any");
      if (shouldTreatPaletteStringAsArray(trimmed, parts)) {
        const values = parts.map((part, index2) => mapColor(createValueNode(part, node.line), `${path2}[${index2}]`, errors)).filter((value) => value !== void 0);
        return values.length > 0 ? values : void 0;
      }
      return scalar;
    }
    case "color": {
      return mapColor(node, path2, errors, { soft: schema.soft });
    }
    case "object": {
      if (node.kind === "array") {
        addError(errors, node, path2, "schema_mismatch", "Expected object value.");
        return void 0;
      }
      const result = {};
      if (node.kind === "value") {
        if (schema.shorthandKey) {
          result[schema.shorthandKey] = node.value;
          return result;
        }
        const inline = parseInlineKeyValue(node.value);
        if ((inline === null || inline === void 0 ? void 0 : inline.value) !== void 0) {
          if (schema.fields[inline.key]) {
            const value = mapWithSchema(createValueNode(inline.value, node.line), schema.fields[inline.key], `${path2}.${inline.key}`, errors);
            if (value !== void 0)
              result[inline.key] = value;
            return result;
          }
          if (schema.allowUnknown) {
            result[inline.key] = parseScalar(inline.value);
            return result;
          }
          addError(errors, node, `${path2}.${inline.key}`, "unknown_key", "Unknown key in object.", inline.key);
          return result;
        }
        if (schema.allowUnknown) {
          result.value = parseScalar(node.value);
          return result;
        }
        addError(errors, node, path2, "invalid_value", "Expected object value.");
        return void 0;
      }
      if (node.value !== void 0) {
        if (schema.shorthandKey && result[schema.shorthandKey] === void 0) {
          result[schema.shorthandKey] = node.value;
        } else {
          const inline = parseInlineKeyValue(node.value);
          if ((inline === null || inline === void 0 ? void 0 : inline.value) !== void 0) {
            if (schema.fields[inline.key]) {
              const value = mapWithSchema(createValueNode(inline.value, node.line), schema.fields[inline.key], `${path2}.${inline.key}`, errors);
              if (value !== void 0 && result[inline.key] === void 0) {
                result[inline.key] = value;
              }
            } else if (schema.allowUnknown) {
              result[inline.key] = parseScalar(inline.value);
            } else {
              addError(errors, node, `${path2}.${inline.key}`, "unknown_key", "Unknown key in object.", inline.key);
            }
          } else if (schema.allowUnknown) {
            result.value = parseScalar(node.value);
          }
        }
      }
      Object.entries(node.entries).forEach(([key, child]) => {
        const fieldSchema = schema.fields[key];
        if (!fieldSchema) {
          if (schema.allowUnknown) {
            result[key] = mapUnknown(child);
            return;
          }
          addError(errors, child, `${path2}.${key}`, "unknown_key", "Unknown key in object.", key);
          return;
        }
        const value = mapWithSchema(child, fieldSchema, `${path2}.${key}`, errors);
        if (value !== void 0)
          result[key] = value;
      });
      return result;
    }
    default:
      return void 0;
  }
}

// node_modules/@antv/infographic/esm/syntax/schema.js
var string = () => ({ kind: "string" });
var number4 = () => ({ kind: "number" });
var enumOf = (values) => ({ kind: "enum", values });
var color2 = (options = {}) => ({
  kind: "color",
  soft: options.soft
});
var array2 = (item, split = "any") => ({
  kind: "array",
  item,
  split
});
var object = (fields, options = {}) => ({
  kind: "object",
  fields,
  allowUnknown: options.allowUnknown,
  shorthandKey: options.shorthandKey
});
var union = (...variants) => ({
  kind: "union",
  variants
});
var palette = () => ({ kind: "palette" });
var anyObject = () => object({}, { allowUnknown: true });
var nullableColorFields = {
  fill: color2({ soft: true }),
  stroke: color2({ soft: true })
};
var textStyleSchema = object(nullableColorFields, { allowUnknown: true });
var shapeStyleSchema = object(nullableColorFields, { allowUnknown: true });
var itemDatumSchema = object({}, { allowUnknown: true });
itemDatumSchema.fields = {
  id: string(),
  label: string(),
  value: union(number4(), string()),
  desc: string(),
  icon: union(string(), anyObject()),
  illus: union(string(), anyObject()),
  attributes: anyObject(),
  group: string(),
  category: string(),
  children: array2(itemDatumSchema)
};
var RelationSchema = object({
  id: string(),
  from: string(),
  to: string(),
  label: string(),
  direction: enumOf(["forward", "both", "none"]),
  showArrow: enumOf(["true", "false"]),
  arrowType: enumOf(["arrow", "triangle", "diamond"])
}, { allowUnknown: true });
var ThemeSchema = object({
  type: string(),
  colorBg: color2(),
  colorPrimary: color2(),
  palette: palette(),
  title: textStyleSchema,
  desc: textStyleSchema,
  shape: shapeStyleSchema,
  base: object({
    global: object({}, { allowUnknown: true }),
    shape: shapeStyleSchema,
    text: textStyleSchema
  }),
  item: object({
    icon: object({}, { allowUnknown: true }),
    label: textStyleSchema,
    desc: textStyleSchema,
    value: textStyleSchema,
    shape: shapeStyleSchema
  }),
  stylize: object({
    type: enumOf(["rough", "pattern"]),
    roughness: number4(),
    bowing: number4(),
    fillWeight: number4(),
    hachureGap: number4(),
    pattern: string(),
    backgroundColor: color2(),
    foregroundColor: color2(),
    scale: number4()
  }, { shorthandKey: "type" }),
  elements: object({}, { allowUnknown: true })
}, { shorthandKey: "type" });
var designNodeSchema = object({}, { allowUnknown: true, shorthandKey: "type" });
var DesignSchema = object({
  structure: designNodeSchema,
  item: designNodeSchema,
  items: array2(designNodeSchema),
  title: designNodeSchema
});
var DataSchema = object({
  title: string(),
  desc: string(),
  items: array2(itemDatumSchema),
  lists: array2(itemDatumSchema),
  sequences: array2(itemDatumSchema),
  root: itemDatumSchema,
  compares: array2(itemDatumSchema),
  nodes: array2(itemDatumSchema),
  relations: array2(RelationSchema),
  values: array2(itemDatumSchema),
  order: enumOf(["asc", "desc"]),
  illus: anyObject(),
  attributes: anyObject()
});
var TemplateSchema = object({
  type: string()
}, { shorthandKey: "type" });
var RootSchema = object({
  template: TemplateSchema,
  design: DesignSchema,
  data: DataSchema,
  theme: ThemeSchema,
  width: union(number4(), string()),
  height: union(number4(), string())
});

// node_modules/@antv/infographic/esm/syntax/relations.js
var RELATION_TOKEN = /[<>=o.x-]{2,}/;
var ARROW_TOKEN = /[<>=o.x-]{2,}/g;
function normalizeLabel2(text) {
  let label = text.trim();
  if (!label)
    return "";
  const first = label[0];
  const last = label[label.length - 1];
  if (first === '"' && last === '"' || first === "'" && last === "'") {
    label = label.slice(1, -1);
  }
  label = label.replace(/\\(["'])/g, "$1").replace(/(&quot;|&#quot;|#quot;)/g, '"').replace(/(&apos;|&#39;|#apos;)/g, "'");
  return label.trim();
}
function stripEdgeLabelPrefix(text) {
  const trimmed = text.trim().replace(/^[-=.ox]+/, "").trim();
  return normalizeLabel2(trimmed);
}
function skipSpaces(text, index2) {
  let cursor = index2;
  while (cursor < text.length && /\s/.test(text[cursor])) {
    cursor += 1;
  }
  return cursor;
}
function readNode(text, startIndex) {
  let index2 = skipSpaces(text, startIndex);
  if (index2 >= text.length)
    return null;
  const idStart = index2;
  while (index2 < text.length) {
    const char = text[index2];
    if (/\s/.test(char) || char === "[" || char === "(" || char === "@" || char === "|" || char === "<" || char === ">") {
      break;
    }
    if (char === "-" && (text[index2 + 1] === "-" || text[index2 + 1] === ">" || text[index2 + 1] === "<")) {
      break;
    }
    index2 += 1;
  }
  if (index2 === idStart)
    return null;
  const id2 = text.slice(idStart, index2).trim();
  if (!id2)
    return null;
  if (text.startsWith("@{", index2)) {
    const braceEnd = text.indexOf("}", index2 + 2);
    if (braceEnd !== -1) {
      index2 = braceEnd + 1;
    }
  }
  index2 = skipSpaces(text, index2);
  let label;
  if (text[index2] === "[") {
    const end = text.indexOf("]", index2 + 1);
    if (end !== -1) {
      label = normalizeLabel2(text.slice(index2 + 1, end));
      index2 = end + 1;
    }
  } else if (text[index2] === "(") {
    const end = text.indexOf(")", index2 + 1);
    if (end !== -1) {
      let content = text.slice(index2 + 1, end).trim();
      if (content.startsWith("[") && content.endsWith("]")) {
        content = content.slice(1, -1).trim();
      }
      label = normalizeLabel2(content);
      index2 = end + 1;
    }
  }
  return {
    node: { id: id2, label },
    nextIndex: index2
  };
}
function readEdge(text, startIndex) {
  ARROW_TOKEN.lastIndex = startIndex;
  const match = ARROW_TOKEN.exec(text);
  if (!match)
    return null;
  const arrowToken = match[0];
  const arrowStart = match.index;
  const arrowEnd = arrowStart + arrowToken.length;
  const labelPrefix = stripEdgeLabelPrefix(text.slice(startIndex, arrowStart));
  let label = labelPrefix || void 0;
  let directionToken = arrowToken;
  let index2 = arrowEnd;
  index2 = skipSpaces(text, index2);
  if (text[index2] === "|") {
    const pipeEnd = text.indexOf("|", index2 + 1);
    if (pipeEnd !== -1) {
      const pipeLabel = normalizeLabel2(text.slice(index2 + 1, pipeEnd));
      label = pipeLabel || label;
      index2 = pipeEnd + 1;
      const afterLabel = skipSpaces(text, index2);
      ARROW_TOKEN.lastIndex = afterLabel;
      const tail = ARROW_TOKEN.exec(text);
      if (tail && tail.index === afterLabel) {
        directionToken += tail[0];
        index2 = tail.index + tail[0].length;
      } else {
        index2 = afterLabel;
      }
    }
  }
  const hasLeft = directionToken.includes("<");
  const hasRight = directionToken.includes(">");
  const markerMatch = directionToken.match(/[xo]/gi) || [];
  const markerLeft = /^[xo]/i.test(directionToken);
  const markerRight = /[xo]$/i.test(directionToken);
  let direction = "none";
  let reverse = false;
  if (hasLeft && hasRight || hasLeft && markerRight || hasRight && markerLeft || markerLeft && markerRight) {
    direction = "both";
  } else if (hasLeft || hasRight || markerMatch.length > 0) {
    direction = "forward";
    reverse = hasLeft && !hasRight;
  }
  return { label, direction, reverse, nextIndex: index2 };
}
function parseRelationLine(text) {
  const relations = [];
  const nodes = [];
  const nodeMap = /* @__PURE__ */ new Map();
  let index2 = 0;
  const first = readNode(text, index2);
  if (!first)
    return { relations, nodes };
  let current = first.node;
  if (!nodeMap.has(current.id)) {
    nodeMap.set(current.id, current);
    nodes.push(current);
  }
  index2 = first.nextIndex;
  while (index2 < text.length) {
    const edge = readEdge(text, index2);
    if (!edge)
      break;
    index2 = edge.nextIndex;
    const nextNode = readNode(text, index2);
    if (!nextNode)
      break;
    index2 = nextNode.nextIndex;
    let from = current.id;
    let to = nextNode.node.id;
    const direction = edge.direction;
    if (edge.reverse) {
      from = nextNode.node.id;
      to = current.id;
    }
    const relation = {
      from,
      to
    };
    if (edge.label)
      relation.label = edge.label;
    if (direction === "both")
      relation.direction = "both";
    if (direction === "none")
      relation.direction = "none";
    relations.push(relation);
    if (!nodeMap.has(current.id)) {
      nodeMap.set(current.id, current);
      nodes.push(current);
    }
    if (!nodeMap.has(nextNode.node.id)) {
      nodeMap.set(nextNode.node.id, nextNode.node);
      nodes.push(nextNode.node);
    }
    current = nextNode.node;
  }
  return { relations, nodes };
}
function ensureItemLabel(items3, list3, id2, label) {
  if (!id2)
    return;
  const existing = items3.get(id2);
  if (existing) {
    if (!existing.label && label)
      existing.label = label;
    return;
  }
  const item = { id: id2, label: label || id2 };
  items3.set(id2, item);
  list3.push(item);
}
function parseExplicitRelation(node, path2, errors) {
  const value = mapWithSchema(node, RelationSchema, path2, errors);
  if (!value || typeof value !== "object")
    return null;
  if (typeof value.from !== "string" || typeof value.to !== "string") {
    return null;
  }
  return value;
}
function parseRelationsNode(node, errors, path2) {
  const relations = [];
  const items3 = [];
  const itemMap = /* @__PURE__ */ new Map();
  const parseLine = (line2) => {
    if (!RELATION_TOKEN.test(line2))
      return;
    const parsed = parseRelationLine(line2);
    parsed.nodes.forEach((nodeItem) => {
      ensureItemLabel(itemMap, items3, nodeItem.id, nodeItem.label);
    });
    relations.push(...parsed.relations);
  };
  if (node.kind === "array") {
    node.items.forEach((item, index2) => {
      if (item.kind === "object" && item.value && Object.keys(item.entries).length === 0 && RELATION_TOKEN.test(item.value)) {
        parseLine(item.value);
        return;
      }
      const relation = parseExplicitRelation(item, `${path2}[${index2}]`, errors);
      if (relation) {
        relations.push(relation);
      }
    });
  } else if (node.kind === "object" && node.value) {
    parseLine(node.value);
  }
  return { relations, items: items3 };
}

// node_modules/@antv/infographic/esm/syntax/index.js
var __rest20 = function(s3, e8) {
  var t2 = {};
  for (var p7 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p7) && e8.indexOf(p7) < 0)
      t2[p7] = s3[p7];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p7 = Object.getOwnPropertySymbols(s3); i4 < p7.length; i4++) {
      if (e8.indexOf(p7[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p7[i4]))
        t2[p7[i4]] = s3[p7[i4]];
    }
  return t2;
};
function normalizeItems(items3) {
  var _a;
  const seen = /* @__PURE__ */ new Set();
  const normalized = [];
  for (let index2 = items3.length - 1; index2 >= 0; index2 -= 1) {
    const item = items3[index2];
    const id2 = (_a = item.id) !== null && _a !== void 0 ? _a : item.label;
    if (!id2) {
      normalized.push(item);
      continue;
    }
    if (seen.has(id2))
      continue;
    seen.add(id2);
    if (!item.id)
      item.id = id2;
    normalized.push(item);
  }
  return normalized.reverse();
}
function resolveTemplate(node, errors) {
  if (!node)
    return void 0;
  const mapped = mapWithSchema(node, TemplateSchema, "template", errors);
  if (!mapped)
    return void 0;
  if (typeof mapped === "string")
    return mapped;
  if (typeof mapped === "object" && typeof mapped.type === "string") {
    return mapped.type;
  }
  return void 0;
}
function parseSyntax(input) {
  var _a;
  const { ast, errors } = parseSyntaxToAst(input);
  const warnings = [];
  const options = {};
  const mergedEntries = Object.assign({}, ast.entries);
  const infographicNode = ast.entries.infographic;
  let templateFromInfographic;
  if (infographicNode && infographicNode.kind === "object") {
    if (infographicNode.value)
      templateFromInfographic = infographicNode.value;
    Object.entries(infographicNode.entries).forEach(([key, value]) => {
      if (!(key in mergedEntries))
        mergedEntries[key] = value;
    });
  }
  const allowedRootKeys = /* @__PURE__ */ new Set([
    "infographic",
    "template",
    "design",
    "data",
    "theme",
    "width",
    "height"
  ]);
  Object.keys(mergedEntries).forEach((key) => {
    if (!allowedRootKeys.has(key)) {
      errors.push({
        path: key,
        line: mergedEntries[key].line,
        code: "unknown_key",
        message: "Unknown top-level key.",
        raw: key
      });
    }
  });
  const templateNode = mergedEntries.template;
  const templateValue = resolveTemplate(templateNode, errors);
  if (templateValue)
    options.template = templateValue;
  if (!options.template && templateFromInfographic) {
    options.template = templateFromInfographic;
  }
  const designNode = mergedEntries.design;
  if (designNode) {
    const design = mapWithSchema(designNode, DesignSchema, "design", errors);
    if (design)
      options.design = design;
  }
  const dataNode = mergedEntries.data;
  if (dataNode) {
    let relationsNode;
    let dataNodeForMapping = dataNode;
    if (dataNode.kind === "object") {
      const _b = dataNode.entries, { relations } = _b, rest = __rest20(_b, ["relations"]);
      relationsNode = relations;
      dataNodeForMapping = Object.assign(Object.assign({}, dataNode), { entries: rest });
    }
    const data = mapWithSchema(dataNodeForMapping, DataSchema, "data", errors);
    if (data)
      options.data = data;
    if (relationsNode) {
      const parsed = parseRelationsNode(relationsNode, errors, "data.relations");
      if (parsed.relations.length > 0 || parsed.items.length > 0) {
        const current = (_a = options.data) !== null && _a !== void 0 ? _a : {};
        const existingItems = Array.isArray(current.items) ? current.items : [];
        const normalizedItems = normalizeItems(existingItems);
        const itemMap = /* @__PURE__ */ new Map();
        normalizedItems.forEach((item) => {
          if (item.id)
            itemMap.set(item.id, item);
        });
        parsed.items.forEach((item) => {
          const existing = itemMap.get(item.id);
          if (existing) {
            if (!existing.label && item.label)
              existing.label = item.label;
          } else {
            normalizedItems.push(item);
            itemMap.set(item.id, item);
          }
        });
        current.items = normalizedItems;
        current.relations = parsed.relations;
        options.data = current;
      }
    }
  }
  const themeNode = mergedEntries.theme;
  if (themeNode) {
    const theme = mapWithSchema(themeNode, ThemeSchema, "theme", errors);
    if (theme && typeof theme === "object") {
      const _c = theme, { type: type2 } = _c, rest = __rest20(_c, ["type"]);
      if (typeof type2 === "string" && type2)
        options.theme = type2;
      if (Object.keys(rest).length > 0) {
        options.themeConfig = rest;
      }
    }
  }
  const widthNode = mergedEntries.width;
  if (widthNode) {
    const width = mapWithSchema(widthNode, RootSchema.fields.width, "width", errors);
    if (width !== void 0)
      options.width = width;
  }
  const heightNode = mergedEntries.height;
  if (heightNode) {
    const height = mapWithSchema(heightNode, RootSchema.fields.height, "height", errors);
    if (height !== void 0)
      options.height = height;
  }
  return {
    options,
    errors,
    warnings,
    ast
  };
}

// node_modules/@antv/infographic/esm/runtime/options.js
var createDefaultPlugins = () => [new EditBar(), new ResizeElement()];
var createDefaultInteractions = () => [
  new DblClickEditText(),
  new BrushSelect(),
  new ClickSelect(),
  new DragElement(),
  new HotkeyHistory(),
  new ZoomWheel(),
  new SelectHighlight()
];
var DEFAULT_OPTIONS = {
  padding: 20,
  theme: "light",
  themeConfig: {
    palette: "antv"
  },
  get plugins() {
    return createDefaultPlugins();
  },
  get interactions() {
    return createDefaultInteractions();
  }
};

// node_modules/@antv/infographic/esm/runtime/utils.js
function mergeOptions(object2, source) {
  const base = Object.assign(Object.assign({}, object2), source);
  if (object2.design || source.design) {
    base.design = Object.assign(Object.assign({}, object2.design), source.design);
  }
  if (object2.themeConfig || source.themeConfig) {
    base.themeConfig = Object.assign(Object.assign({}, object2.themeConfig), source.themeConfig);
  }
  if (object2.svg || source.svg) {
    base.svg = Object.assign(Object.assign({}, object2.svg), source.svg);
  }
  return base;
}
function cloneOptions(options) {
  const cloned = Object.assign({}, options);
  if (cloned.data)
    cloned.data = cloneDeep_default(cloned.data);
  if (cloned.elements)
    cloned.elements = cloneDeep_default(cloned.elements);
  return cloned;
}
function isCompleteParsedInfographicOptions(options) {
  const { design, data } = options;
  if (!design)
    return false;
  if (!isNonNullableParsedDesignsOptions(design))
    return false;
  if (!data)
    return false;
  if (!Array.isArray(data.items) || data.items.length < 1)
    return false;
  return true;
}

// node_modules/@antv/infographic/esm/runtime/Infographic.js
var __awaiter22 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Infographic = class {
  constructor(options) {
    this.rendered = false;
    this.emitter = new eventemitter3_default();
    this.node = null;
    this.initialOptions = {};
    this.setOptions(options, "replace", true);
  }
  getOptions() {
    return this.options;
  }
  setOptions(options, mode = "replace", isInitial = false) {
    const { options: parsedOptions, errors, warnings } = parseSyntaxOptions(options);
    if (isInitial) {
      this.initialOptions = parsedOptions;
    }
    const base = mode === "replace" ? mergeOptions(cloneOptions(this.initialOptions || {}), parsedOptions) : mergeOptions(this.options || cloneOptions(this.initialOptions || {}), parsedOptions);
    this.options = base;
    this.parsedOptions = parseOptions(mergeOptions(DEFAULT_OPTIONS, this.options));
    if (warnings.length) {
      this.emitter.emit("warning", warnings);
    }
    if (errors.length) {
      this.emitter.emit("error", errors);
    }
  }
  /**
   * Render the infographic into the container
   */
  render(options) {
    if (options) {
      this.setOptions(options, "replace");
    } else if (!this.options && this.initialOptions) {
      this.setOptions(this.initialOptions, "replace");
    }
    this.performRender();
  }
  update(options) {
    this.setOptions(options, "merge");
    this.performRender();
  }
  performRender() {
    var _a;
    const parsedOptions = this.parsedOptions;
    if (!isCompleteParsedInfographicOptions(parsedOptions)) {
      this.emitter.emit("error", new Error("Incomplete options"));
      return;
    }
    const { container } = this.parsedOptions;
    const template = this.compose(parsedOptions);
    const renderer = new Renderer(parsedOptions, template);
    this.node = renderer.render();
    container === null || container === void 0 ? void 0 : container.replaceChildren(this.node);
    (_a = this.editor) === null || _a === void 0 ? void 0 : _a.destroy();
    this.editor = void 0;
    if (this.options.editable) {
      this.editor = new Editor(this.emitter, this.node, parsedOptions);
    }
    this.rendered = true;
    this.emitter.emit("rendered", { node: this.node, options: this.options });
    const currentNode = this.node;
    if (currentNode) {
      void waitForSvgLoads(currentNode).then(() => {
        if (this.node !== currentNode)
          return;
        this.emitter.emit("loaded", {
          node: currentNode,
          options: this.options
        });
      });
    }
    return true;
  }
  /**
   * Compose the SVG template
   */
  compose(parsedOptions) {
    const { design, data } = parsedOptions;
    const { title, item, items: items3, structure } = design;
    const { component: Structure, props: structureProps } = structure;
    const Title2 = title.component;
    const Item = item.component;
    const Items = items3.map((it) => it.component);
    const svg = renderSVG2(jsx(Structure, Object.assign({ data, Title: Title2, Item, Items, options: parsedOptions }, structureProps)));
    const template = parseSVG(svg);
    if (!template) {
      throw new Error("Failed to parse SVG template");
    }
    return template;
  }
  getTypes() {
    const parsedOptions = this.parsedOptions;
    if (!isCompleteParsedInfographicOptions(parsedOptions)) {
      this.emitter.emit("error", new Error("Incomplete options"));
      return;
    }
    const design = parsedOptions.design;
    const structure = design.structure.composites || [];
    const items3 = design.items.map((it) => it.composites || []);
    return getTypes({ structure, items: items3 });
  }
  /**
   * Export the infographic to data URL
   * @param options Export option
   * @returns Data URL string of the exported infographic
   * @description This method need to be called after `render()` and in a browser environment.
   */
  toDataURL(options) {
    return __awaiter22(this, void 0, void 0, function* () {
      if (!this.node) {
        throw new Error("Infographic is not rendered yet.");
      }
      if ((options === null || options === void 0 ? void 0 : options.type) === "svg") {
        return yield exportToSVGString(this.node, options);
      }
      return yield exportToPNGString(this.node, options);
    });
  }
  on(event, listener) {
    this.emitter.on(event, listener);
  }
  off(event, listener) {
    this.emitter.off(event, listener);
  }
  destroy() {
    var _a, _b;
    (_a = this.editor) === null || _a === void 0 ? void 0 : _a.destroy();
    (_b = this.node) === null || _b === void 0 ? void 0 : _b.remove();
    this.node = null;
    this.rendered = false;
    this.emitter.emit("destroyed");
    this.emitter.removeAllListeners();
  }
};
function parseSyntaxOptions(input) {
  if (typeof input === "string") {
    const { options, errors, warnings } = parseSyntax(input);
    return { options, errors, warnings };
  }
  return {
    options: cloneOptions(input),
    errors: [],
    warnings: []
  };
}

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultTheme: "",
  editable: false
};
var InfographicSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin2) {
    super(app, plugin2);
    this.plugin = plugin2;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Infographic Viz").setHeading();
    new import_obsidian.Setting(containerEl).setName("Default theme").setDesc("Choose the default theme for infographics.").addDropdown((dropdown) => {
      dropdown.addOption("", "Auto (use Infographic default)");
      const themes = getThemes();
      themes.forEach((theme) => {
        dropdown.addOption(theme, theme);
      });
      dropdown.setValue(this.plugin.settings.defaultTheme || "");
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultTheme = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Editable mode").setDesc("Enable inline editing of infographics.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.editable);
      toggle.onChange(async (value) => {
        this.plugin.settings.editable = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Export options").setHeading();
    const exportDiv = containerEl.createDiv({ cls: "setting-item-description" });
    const exportP = exportDiv.createEl("p");
    exportP.textContent = "Right-click on any infographic to access export options:";
    const exportUl = exportDiv.createEl("ul", { cls: "infographic-settings-export-list" });
    const exportLi1 = exportUl.createEl("li");
    const exportStrong1 = exportLi1.createEl("strong");
    exportStrong1.textContent = "Copy to clipboard";
    exportLi1.appendText(" - Copy PNG image to clipboard for pasting");
    const exportLi2 = exportUl.createEl("li");
    const exportStrong2 = exportLi2.createEl("strong");
    exportStrong2.textContent = "Export as PNG";
    exportLi2.appendText(" - Download infographic as PNG file");
    const exportLi3 = exportUl.createEl("li");
    const exportStrong3 = exportLi3.createEl("strong");
    exportStrong3.textContent = "Export as SVG";
    exportLi3.appendText(" - Download infographic as SVG vector file");
    new import_obsidian.Setting(containerEl).setName("Usage").setHeading();
    const usageDiv = containerEl.createDiv({ cls: "setting-item-description" });
    const usageP = usageDiv.createEl("p");
    const usageCode = usageP.createEl("code");
    usageCode.textContent = "infographic";
    usageP.prependText("Use ");
    usageP.appendText(" code blocks to create infographics");
    const usagePre = usageDiv.createEl("pre", { cls: "infographic-settings-code-block" });
    const usageCodeBlock = usagePre.createEl("code");
    usageCodeBlock.textContent = "```infographic\ninfographic sequence-zigzag-steps-underline-text\ndata\n  title Process Flow\n  items\n    - label Phase 1\n      desc Initial setup\n    - label Phase 2\n      desc Development\n    - label Phase 3\n      desc Testing\n```";
  }
};

// src/main.ts
var InfographicPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.instances = /* @__PURE__ */ new WeakMap();
  }
  async onload() {
    console.debug("Loading Infographic Viz plugin...");
    await this.loadSettings();
    this.addSettingTab(new InfographicSettingTab(this.app, this));
    this.registerMarkdownCodeBlockProcessor("infographic", (content, el, ctx) => {
      this.renderInfographic(content, el);
    });
    console.debug("Infographic Viz plugin loaded successfully");
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  renderInfographic(content, containerEl) {
    containerEl.empty();
    const wrapper = containerEl.createDiv("infographic-wrapper");
    try {
      const instance = new Infographic({
        container: wrapper,
        ...this.settingsToOptions()
      });
      instance.render(content);
      this.instances.set(wrapper, instance);
      this.registerDomEvent(wrapper, "contextmenu", (event) => {
        event.preventDefault();
        this.showContextMenu(instance, event);
      });
    } catch (error) {
      console.error("Infographic render error:", error);
      wrapper.createDiv({
        cls: "infographic-error",
        text: `\u6E32\u67D3\u5931\u8D25: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  showContextMenu(instance, event) {
    const menu = new import_obsidian2.Menu();
    menu.addItem(
      (item) => item.setTitle("Copy to clipboard (PNG)").setIcon("copy").onClick(async () => {
        await this.copyToClipboard(instance);
      })
    );
    menu.addItem(
      (item) => item.setTitle("Export as PNG").setIcon("image-file").onClick(async () => {
        await this.exportAsPNG(instance);
      })
    );
    menu.addItem(
      (item) => item.setTitle("Export as SVG").setIcon("image-file").onClick(async () => {
        await this.exportAsSVG(instance);
      })
    );
    menu.showAtMouseEvent(event);
  }
  async copyToClipboard(instance) {
    try {
      const dataUrl = await instance.toDataURL();
      const blob = this.dataUrlToBlob(dataUrl);
      await navigator.clipboard.write([
        new ClipboardItem({
          "image/png": blob
        })
      ]);
      new import_obsidian2.Notice("Copied to clipboard as PNG");
    } catch (error) {
      console.error("Copy error:", error);
      new import_obsidian2.Notice("Failed to copy: " + (error instanceof Error ? error.message : String(error)));
    }
  }
  async exportAsPNG(instance) {
    try {
      const dataUrl = await instance.toDataURL();
      const link = document.createElement("a");
      link.href = dataUrl;
      link.download = `infographic-${Date.now()}.png`;
      link.click();
      new import_obsidian2.Notice("Exported as PNG");
    } catch (error) {
      console.error("Export error:", error);
      new import_obsidian2.Notice("Export failed: " + (error instanceof Error ? error.message : String(error)));
    }
  }
  async exportAsSVG(instance) {
    try {
      const dataUrl = await instance.toDataURL({
        type: "svg",
        embedResources: true,
        removeIds: false
      });
      const link = document.createElement("a");
      link.href = dataUrl;
      link.download = `infographic-${Date.now()}.svg`;
      link.click();
      new import_obsidian2.Notice("Exported as SVG");
    } catch (error) {
      console.error("Export error:", error);
      new import_obsidian2.Notice("Export failed: " + (error instanceof Error ? error.message : String(error)));
    }
  }
  //  data URL  Blob
  dataUrlToBlob(dataUrl) {
    const arr = dataUrl.split(",");
    if (arr.length < 2) {
      throw new Error("Invalid data URL");
    }
    const mimeMatch = arr[0].match(/:(.*?);/);
    const mime = (mimeMatch == null ? void 0 : mimeMatch[1]) || "image/png";
    const bstr = atob(arr[1]);
    let n4 = bstr.length;
    const u8arr = new Uint8Array(n4);
    while (n4--) {
      u8arr[n4] = bstr.charCodeAt(n4);
    }
    return new Blob([u8arr], { type: mime });
  }
  //  Infographic 
  settingsToOptions() {
    const options = {};
    if (this.settings.defaultTheme) {
      options.theme = this.settings.defaultTheme;
    }
    if (this.settings.editable) {
      options.editable = true;
    }
    return options;
  }
};
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

comlink/dist/esm/comlink.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
